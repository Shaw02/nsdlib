PUBLIC	??_GMusicFile@@UAEPAXI@Z			; MusicFile::`scalar deleting destructor'
PUBLIC	??1?$map@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@@std@@QAE@XZ ; std::map<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> > >::~map<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> > >
PUBLIC	??1?$map@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@@std@@QAE@XZ ; std::map<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> > >::~map<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> > >
PUBLIC	??1?$map@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@@std@@QAE@XZ ; std::map<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> > >::~map<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> > >
PUBLIC	??1?$map@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@@std@@QAE@XZ ; std::map<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> > >::~map<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> > >
PUBLIC	??1?$map@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@@std@@QAE@XZ ; std::map<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> > >::~map<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> > >
PUBLIC	??1?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAE@XZ ; std::map<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> > >::~map<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> > >
PUBLIC	??1?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAE@XZ ; std::map<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> > >::~map<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> > >
PUBLIC	??1?$map@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@@std@@QAE@XZ ; std::map<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> > >::~map<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> > >
PUBLIC	??_DMusicFile@@QAEXXZ				; MusicFile::`vbase destructor'
PUBLIC	??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::operator<<
PUBLIC	?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z ; std::basic_ostream<char,std::char_traits<char> >::write
PUBLIC	?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADH@Z ; std::basic_istream<char,std::char_traits<char> >::read
PUBLIC	?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ofstream<char,std::char_traits<char> >::close
PUBLIC	?push_back@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEXABQAVMusicItem@@@Z ; std::list<MusicItem *,std::allocator<MusicItem *> >::push_back
PUBLIC	??0?$map@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@@std@@QAE@XZ ; std::map<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> > >::map<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> > >
PUBLIC	??A?$map@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@@std@@QAEAAPAVFDSC@@ABH@Z ; std::map<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> > >::operator[]
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::~_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::end
PUBLIC	?empty@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE_NXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::empty
PUBLIC	?count@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::count
PUBLIC	??0?$map@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@@std@@QAE@XZ ; std::map<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> > >::map<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> > >
PUBLIC	??A?$map@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@@std@@QAEAAPAVFDSM@@ABH@Z ; std::map<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> > >::operator[]
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::~_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::end
PUBLIC	?empty@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE_NXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::empty
PUBLIC	?count@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::count
PUBLIC	??0?$map@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@@std@@QAE@XZ ; std::map<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> > >::map<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> > >
PUBLIC	??A?$map@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@@std@@QAEAAPAVVRC7@@ABH@Z ; std::map<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> > >::operator[]
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::~_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::end
PUBLIC	?empty@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE_NXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::empty
PUBLIC	?count@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::count
PUBLIC	??0?$map@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@@std@@QAE@XZ ; std::map<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> > >::map<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> > >
PUBLIC	??A?$map@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@@std@@QAEAAPAVN163@@ABH@Z ; std::map<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> > >::operator[]
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::~_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::end
PUBLIC	?empty@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE_NXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::empty
PUBLIC	?count@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::count
PUBLIC	??0?$map@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@@std@@QAE@XZ ; std::map<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> > >::map<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> > >
PUBLIC	??A?$map@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@@std@@QAEAAPAVEnvelop@@ABH@Z ; std::map<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> > >::operator[]
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::~_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::end
PUBLIC	?empty@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE_NXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::empty
PUBLIC	?count@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::count
PUBLIC	??0?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAE@XZ ; std::map<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> > >::map<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> > >
PUBLIC	??A?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAEAAPAVBGM@@ABH@Z ; std::map<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> > >::operator[]
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::~_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >
PUBLIC	?count@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::count
PUBLIC	??0?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAE@XZ ; std::map<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> > >::map<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> > >
PUBLIC	??A?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAEAAPAVSE@@ABH@Z ; std::map<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> > >::operator[]
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::~_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >
PUBLIC	?count@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::count
PUBLIC	??0?$map@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@@std@@QAE@XZ ; std::map<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> > >::map<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> > >
PUBLIC	??A?$map@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@@std@@QAEAAPAVSub@@ABH@Z ; std::map<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> > >::operator[]
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::~_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::end
PUBLIC	?empty@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE_NXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::empty
PUBLIC	?count@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::count
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator::iterator
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVEnvelop@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator::operator->
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator::operator++
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::operator!=
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator::iterator
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator::iterator
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator::iterator
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVSub@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator::operator->
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator::operator++
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::operator!=
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator::iterator
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVFDSC@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator::operator->
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator::operator++
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::operator!=
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator::iterator
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVFDSM@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator::operator->
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator::operator++
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::operator!=
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator::iterator
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVVRC7@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator::operator->
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator::operator++
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::operator!=
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator::iterator
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVN163@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator::operator->
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator::operator++
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::operator!=
PUBLIC	?sgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPADH@Z ; std::basic_streambuf<char,std::char_traits<char> >::sgetn
PUBLIC	?end@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<MusicItem *,std::allocator<MusicItem *> >::end
PUBLIC	?_Insert@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEXViterator@12@ABQAVMusicItem@@@Z ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Insert
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Key
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::size
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVFDSC@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::insert
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::lower_bound
PUBLIC	?equal_range@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::equal_range
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Lmost
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Tidy
PUBLIC	??0?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,FDSC *> >::allocator<std::pair<int const ,FDSC *> >
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Key
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::size
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVFDSM@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::insert
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::lower_bound
PUBLIC	?equal_range@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::equal_range
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Lmost
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Tidy
PUBLIC	??0?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,FDSM *> >::allocator<std::pair<int const ,FDSM *> >
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Key
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::size
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVVRC7@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::insert
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::lower_bound
PUBLIC	?equal_range@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::equal_range
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Lmost
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Tidy
PUBLIC	??0?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,VRC7 *> >::allocator<std::pair<int const ,VRC7 *> >
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Key
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::size
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVN163@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::insert
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::lower_bound
PUBLIC	?equal_range@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::equal_range
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Lmost
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Tidy
PUBLIC	??0?$allocator@U?$pair@$$CBHPAVN163@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,N163 *> >::allocator<std::pair<int const ,N163 *> >
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Key
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::size
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVEnvelop@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::insert
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::lower_bound
PUBLIC	?equal_range@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::equal_range
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Lmost
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Tidy
PUBLIC	??0?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,Envelop *> >::allocator<std::pair<int const ,Envelop *> >
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Key
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::end
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVBGM@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::insert
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::lower_bound
PUBLIC	?equal_range@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::equal_range
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Tidy
PUBLIC	??0?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,BGM *> >::allocator<std::pair<int const ,BGM *> >
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Key
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::end
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVSE@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::insert
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::lower_bound
PUBLIC	?equal_range@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::equal_range
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Tidy
PUBLIC	??0?$allocator@U?$pair@$$CBHPAVSE@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,SE *> >::allocator<std::pair<int const ,SE *> >
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Key
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::size
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVSub@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::insert
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::lower_bound
PUBLIC	?equal_range@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::equal_range
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Lmost
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Tidy
PUBLIC	??0?$allocator@U?$pair@$$CBHPAVSub@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,Sub *> >::allocator<std::pair<int const ,Sub *> >
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator::iterator
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVEnvelop@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator::operator*
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator::operator++
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::const_iterator
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::operator==
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::_Mynode
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVBGM@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator::operator*
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::const_iterator
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::operator==
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::_Mynode
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVSE@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator::operator*
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::const_iterator
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::operator==
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::_Mynode
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator::iterator
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVSub@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator::operator*
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator::operator++
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::const_iterator
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::operator==
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Mynode
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator::iterator
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVFDSC@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator::operator*
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator::operator++
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::const_iterator
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::operator==
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::_Mynode
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator::iterator
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVFDSM@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator::operator*
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator::operator++
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::const_iterator
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::operator==
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::_Mynode
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator::iterator
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVVRC7@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator::operator*
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator::operator++
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::const_iterator
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::operator==
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::_Mynode
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator::iterator
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVN163@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator::operator*
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator::operator++
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::const_iterator
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::operator==
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::_Mynode
PUBLIC	??0?$pair@$$CBHPAVSub@@@std@@QAE@ABHABQAVSub@@@Z ; std::pair<int const ,Sub *>::pair<int const ,Sub *>
PUBLIC	??0?$pair@$$CBHPAVEnvelop@@@std@@QAE@ABHABQAVEnvelop@@@Z ; std::pair<int const ,Envelop *>::pair<int const ,Envelop *>
PUBLIC	??0?$pair@$$CBHPAVFDSC@@@std@@QAE@ABHABQAVFDSC@@@Z ; std::pair<int const ,FDSC *>::pair<int const ,FDSC *>
PUBLIC	??0?$pair@$$CBHPAVFDSM@@@std@@QAE@ABHABQAVFDSM@@@Z ; std::pair<int const ,FDSM *>::pair<int const ,FDSM *>
PUBLIC	??0?$pair@$$CBHPAVVRC7@@@std@@QAE@ABHABQAVVRC7@@@Z ; std::pair<int const ,VRC7 *>::pair<int const ,VRC7 *>
PUBLIC	??0?$pair@$$CBHPAVN163@@@std@@QAE@ABHABQAVN163@@@Z ; std::pair<int const ,N163 *>::pair<int const ,N163 *>
PUBLIC	?put@?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@GU?$char_traits@G@std@@@2@V32@AAVios_base@2@GK@Z ; std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short> > >::put
PUBLIC	??0?$pair@$$CBHPAVBGM@@@std@@QAE@ABHABQAVBGM@@@Z ; std::pair<int const ,BGM *>::pair<int const ,BGM *>
PUBLIC	??0?$pair@$$CBHPAVSE@@@std@@QAE@ABHABQAVSE@@@Z	; std::pair<int const ,SE *>::pair<int const ,SE *>
PUBLIC	?_Nextnode@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@PAU342@@Z ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Nextnode
PUBLIC	?_Prevnode@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@PAU342@@Z ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Prevnode
PUBLIC	?_Buynode@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@PAU342@0ABQAVMusicItem@@@Z ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Buynode
PUBLIC	?_Incsize@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@IAEXI@Z ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Incsize
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Isnil
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Left
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Parent
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Right
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVFDSC@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Myval
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVFDSC@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::insert
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::erase
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::lower_bound
PUBLIC	?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::upper_bound
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Init
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVFDSC@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Insert
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Lbound
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Rmost
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Tree_val<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >
PUBLIC	?_Kfn@?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVFDSC@@@2@@Z ; std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0>::_Kfn
PUBLIC	??0?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,FDSC *> >::allocator<std::pair<int const ,FDSC *> >
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node>::deallocate
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node *>::destroy
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Isnil
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Left
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Parent
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Right
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVFDSM@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Myval
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVFDSM@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::insert
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::erase
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::lower_bound
PUBLIC	?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::upper_bound
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Init
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVFDSM@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Insert
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Lbound
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Rmost
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Tree_val<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >
PUBLIC	?_Kfn@?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVFDSM@@@2@@Z ; std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0>::_Kfn
PUBLIC	??0?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,FDSM *> >::allocator<std::pair<int const ,FDSM *> >
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node>::deallocate
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node *>::destroy
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Isnil
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Left
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Parent
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Right
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVVRC7@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Myval
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVVRC7@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::insert
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::erase
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::lower_bound
PUBLIC	?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::upper_bound
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Init
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVVRC7@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Insert
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Lbound
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Rmost
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Tree_val<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >
PUBLIC	?_Kfn@?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVVRC7@@@2@@Z ; std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0>::_Kfn
PUBLIC	??0?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,VRC7 *> >::allocator<std::pair<int const ,VRC7 *> >
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node>::deallocate
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node *>::destroy
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Isnil
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Left
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Parent
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Right
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVN163@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Myval
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVN163@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::insert
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::erase
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::lower_bound
PUBLIC	?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::upper_bound
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Init
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVN163@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Insert
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Lbound
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Rmost
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Tree_val<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >
PUBLIC	?_Kfn@?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVN163@@@2@@Z ; std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0>::_Kfn
PUBLIC	??0?$allocator@U?$pair@$$CBHPAVN163@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,N163 *> >::allocator<std::pair<int const ,N163 *> >
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node>::deallocate
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node *>::destroy
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Isnil
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Left
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Parent
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Right
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVEnvelop@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Myval
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVEnvelop@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::insert
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::erase
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::lower_bound
PUBLIC	?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::upper_bound
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Init
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVEnvelop@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Insert
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Lbound
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Rmost
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Tree_val<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >
PUBLIC	?_Kfn@?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVEnvelop@@@2@@Z ; std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0>::_Kfn
PUBLIC	??0?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,Envelop *> >::allocator<std::pair<int const ,Envelop *> >
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node>::deallocate
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node *>::destroy
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Isnil
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Left
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Parent
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Right
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVBGM@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Myval
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::begin
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::size
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVBGM@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::insert
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::erase
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::lower_bound
PUBLIC	?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::upper_bound
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Init
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVBGM@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Insert
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Lbound
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Rmost
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Tree_val<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >
PUBLIC	?_Kfn@?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVBGM@@@2@@Z ; std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0>::_Kfn
PUBLIC	??0?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,BGM *> >::allocator<std::pair<int const ,BGM *> >
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node>::deallocate
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node *>::destroy
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Isnil
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Left
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Parent
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Right
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVSE@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Myval
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::begin
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::size
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVSE@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::insert
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::erase
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::lower_bound
PUBLIC	?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::upper_bound
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Init
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVSE@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Insert
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Lbound
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Rmost
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Tree_val<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >
PUBLIC	?_Kfn@?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVSE@@@2@@Z ; std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0>::_Kfn
PUBLIC	??0?$allocator@U?$pair@$$CBHPAVSE@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,SE *> >::allocator<std::pair<int const ,SE *> >
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node>::deallocate
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node *>::destroy
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Isnil
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Left
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Parent
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Right
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVSub@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Myval
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVSub@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::insert
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::erase
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::lower_bound
PUBLIC	?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::upper_bound
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Init
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVSub@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Insert
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Lbound
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Rmost
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Tree_val<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >
PUBLIC	?_Kfn@?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVSub@@@2@@Z ; std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0>::_Kfn
PUBLIC	??0?$allocator@U?$pair@$$CBHPAVSub@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,Sub *> >::allocator<std::pair<int const ,Sub *> >
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node>::deallocate
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node *>::destroy
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator::operator--
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::const_iterator
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVEnvelop@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::operator*
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::operator++
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator::iterator
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator::operator++
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator::operator--
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVBGM@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::operator*
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator::iterator
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator::operator++
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator::operator--
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVSE@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::operator*
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator::operator--
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::const_iterator
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVSub@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::operator*
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::operator++
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator::operator--
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::const_iterator
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVFDSC@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::operator*
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::operator++
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator::operator--
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::const_iterator
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVFDSM@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::operator*
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::operator++
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator::operator--
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::const_iterator
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVVRC7@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::operator*
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::operator++
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator::operator--
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::const_iterator
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVN163@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::operator*
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::operator++
PUBLIC	??0iterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z ; std::list<MusicItem *,std::allocator<MusicItem *> >::iterator::iterator
PUBLIC	?_Mynode@const_iterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@3@XZ ; std::list<MusicItem *,std::allocator<MusicItem *> >::const_iterator::_Mynode
PUBLIC	??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@1@0@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator>
PUBLIC	??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@1@0@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator>
PUBLIC	??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@1@0@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator>
PUBLIC	??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@1@0@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator>
PUBLIC	??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@1@0@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator>
PUBLIC	??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@1@0@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator>
PUBLIC	??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@1@0@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator>
PUBLIC	??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@1@0@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator>
PUBLIC	?max_size@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QBEIXZ ; std::list<MusicItem *,std::allocator<MusicItem *> >::max_size
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@I@Z ; std::allocator<std::_List_nod<MusicItem *,std::allocator<MusicItem *> >::_Node>::deallocate
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@I@Z ; std::allocator<std::_List_nod<MusicItem *,std::allocator<MusicItem *> >::_Node>::allocate
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Color
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::max_size
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::clear
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Lrotate
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Root
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Root
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Rrotate
PUBLIC	?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Ubound
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Buynode
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVFDSC@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Buynode
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Color
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::max_size
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::clear
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Lrotate
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Root
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Root
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Rrotate
PUBLIC	?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Ubound
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Buynode
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVFDSM@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Buynode
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Color
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::max_size
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::clear
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Lrotate
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Root
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Root
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Rrotate
PUBLIC	?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Ubound
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Buynode
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVVRC7@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Buynode
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Color
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::max_size
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::clear
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Lrotate
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Root
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Root
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Rrotate
PUBLIC	?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Ubound
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Buynode
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVN163@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Buynode
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Color
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::max_size
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::clear
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Lrotate
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Root
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Root
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Rrotate
PUBLIC	?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Ubound
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Buynode
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVEnvelop@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Buynode
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Color
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::max_size
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::clear
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Lmost
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Lrotate
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Root
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Root
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Rrotate
PUBLIC	?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Ubound
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Buynode
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVBGM@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Buynode
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Color
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::max_size
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::clear
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Lmost
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Lrotate
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Root
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Root
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Rrotate
PUBLIC	?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Ubound
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Buynode
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVSE@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Buynode
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Color
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::max_size
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::clear
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Lrotate
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Root
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Root
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Rrotate
PUBLIC	?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Ubound
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Buynode
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVSub@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Buynode
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::operator--
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::_Inc
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator::operator++
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::const_iterator
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::operator++
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::operator--
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::operator!=
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator::operator++
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::const_iterator
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::operator++
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::operator--
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::operator!=
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::operator--
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Inc
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::operator--
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::_Inc
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::operator--
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::_Inc
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::operator--
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::_Inc
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::operator--
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::_Inc
PUBLIC	??0const_iterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z ; std::list<MusicItem *,std::allocator<MusicItem *> >::const_iterator::const_iterator
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator,bool>
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator,bool>
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator,bool>
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator,bool>
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator,bool>
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator,bool>
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator,bool>
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator,bool>
PUBLIC	??0_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE@PAU012@0ABQAVMusicItem@@@Z ; std::_List_nod<MusicItem *,std::allocator<MusicItem *> >::_Node::_Node
PUBLIC	?max_size@?$allocator@PAVMusicItem@@@std@@QBEIXZ ; std::allocator<MusicItem *>::max_size
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Erase
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Max
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Min
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,FDSC *> >::max_size
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node>::allocate
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node>::destroy
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node *>::construct
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Erase
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Max
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Min
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,FDSM *> >::max_size
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node>::allocate
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node>::destroy
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node *>::construct
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Erase
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Max
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Min
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,VRC7 *> >::max_size
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node>::allocate
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node>::destroy
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node *>::construct
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Erase
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Max
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Min
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHPAVN163@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,N163 *> >::max_size
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node>::allocate
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node>::destroy
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node *>::construct
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Erase
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Max
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Min
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,Envelop *> >::max_size
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node>::allocate
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node>::destroy
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node *>::construct
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Erase
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Max
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Min
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,BGM *> >::max_size
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node>::allocate
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node>::destroy
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node *>::construct
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Erase
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Max
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Min
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHPAVSE@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,SE *> >::max_size
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node>::allocate
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node>::destroy
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node *>::construct
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Erase
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Max
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Min
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHPAVSub@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,Sub *> >::max_size
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node>::allocate
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node>::destroy
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node *>::construct
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::_Dec
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::_Dec
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::_Inc
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::_Dec
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::_Inc
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Dec
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::_Dec
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::_Dec
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::_Dec
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::_Dec
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVFDSC@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node::_Node
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVFDSM@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node::_Node
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVVRC7@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node::_Node
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVN163@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node::_Node
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVEnvelop@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node::_Node
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVBGM@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node::_Node
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVSE@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node::_Node
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVSub@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node::_Node
PUBLIC	??0?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0>::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0>
PUBLIC	??0?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0>::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0>
PUBLIC	??0?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0>::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0>
PUBLIC	??0?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0>::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0>
PUBLIC	??0?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0>::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0>
PUBLIC	??0?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0>::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0>
PUBLIC	??0?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0>::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0>
PUBLIC	??0?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0>::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0>
PUBLIC	??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@0AAI@Z ; std::_Distance<std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator,unsigned int>
PUBLIC	??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@0AAI@Z ; std::_Distance<std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator,unsigned int>
PUBLIC	??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@0AAI@Z ; std::_Distance<std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator,unsigned int>
PUBLIC	??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@0AAI@Z ; std::_Distance<std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator,unsigned int>
PUBLIC	??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@0AAI@Z ; std::_Distance<std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator,unsigned int>
PUBLIC	??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@0AAI@Z ; std::_Distance<std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator,unsigned int>
PUBLIC	??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@0AAI@Z ; std::_Distance<std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator,unsigned int>
PUBLIC	??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@0AAI@Z ; std::_Distance<std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator,unsigned int>
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node *>
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node *>
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node *>
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node *>
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node *>
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node *>
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node *>
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node *>
PUBLIC	??$_Allocate@U_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<MusicItem *,std::allocator<MusicItem *> >::_Node>
PUBLIC	??$?0U?$pair@$$CBHPAVFDSC@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node *><std::pair<int const ,FDSC *> >
PUBLIC	??$?0U?$pair@$$CBHPAVFDSM@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node *><std::pair<int const ,FDSM *> >
PUBLIC	??$?0U?$pair@$$CBHPAVVRC7@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node *><std::pair<int const ,VRC7 *> >
PUBLIC	??$?0U?$pair@$$CBHPAVN163@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node *><std::pair<int const ,N163 *> >
PUBLIC	??$?0U?$pair@$$CBHPAVEnvelop@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node *><std::pair<int const ,Envelop *> >
PUBLIC	??$?0U?$pair@$$CBHPAVBGM@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node *><std::pair<int const ,BGM *> >
PUBLIC	??$?0U?$pair@$$CBHPAVSE@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node *><std::pair<int const ,SE *> >
PUBLIC	??$?0U?$pair@$$CBHPAVSub@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node *><std::pair<int const ,Sub *> >
PUBLIC	??$?0U?$pair@$$CBHPAVFDSC@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node><std::pair<int const ,FDSC *> >
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node>
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node>
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node *>
PUBLIC	??$?0U?$pair@$$CBHPAVFDSM@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node><std::pair<int const ,FDSM *> >
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node>
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node>
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node *>
PUBLIC	??$?0U?$pair@$$CBHPAVVRC7@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node><std::pair<int const ,VRC7 *> >
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node>
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node>
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node *>
PUBLIC	??$?0U?$pair@$$CBHPAVN163@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node><std::pair<int const ,N163 *> >
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node>
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node>
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node *>
PUBLIC	??$?0U?$pair@$$CBHPAVEnvelop@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node><std::pair<int const ,Envelop *> >
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node>
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node>
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node *>
PUBLIC	??$?0U?$pair@$$CBHPAVBGM@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node><std::pair<int const ,BGM *> >
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node>
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node>
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node *>
PUBLIC	??$?0U?$pair@$$CBHPAVSE@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node><std::pair<int const ,SE *> >
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node>
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node>
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node *>
PUBLIC	??$?0U?$pair@$$CBHPAVSub@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node><std::pair<int const ,Sub *> >
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node>
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node>
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node *>
PUBLIC	??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@@Z ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator>
PUBLIC	??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator,unsigned int>
PUBLIC	??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@@Z ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator>
PUBLIC	??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator,unsigned int>
PUBLIC	??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@@Z ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator>
PUBLIC	??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator,unsigned int>
PUBLIC	??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@@Z ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator>
PUBLIC	??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator,unsigned int>
PUBLIC	??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@@Z ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator>
PUBLIC	??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator,unsigned int>
PUBLIC	??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@@Z ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator>
PUBLIC	??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator,unsigned int>
PUBLIC	??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@@Z ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator>
PUBLIC	??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator,unsigned int>
PUBLIC	??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@@Z ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator>
PUBLIC	??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator,unsigned int>
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z ; std::ctype<char>::_Getcat
PUBLIC	??0?$ctype@D@std@@QAE@PBF_NI@Z			; std::ctype<char>::ctype<char>
PUBLIC	??0ctype_base@std@@QAE@I@Z			; std::ctype_base::ctype_base
PUBLIC	??_Gctype_base@std@@UAEPAXI@Z			; std::ctype_base::`scalar deleting destructor'
PUBLIC	??1ctype_base@std@@UAE@XZ			; std::ctype_base::~ctype_base
PUBLIC	??_G?$ctype@D@std@@MAEPAXI@Z			; std::ctype<char>::`scalar deleting destructor'
PUBLIC	??1?$ctype@D@std@@MAE@XZ			; std::ctype<char>::~ctype<char>
PUBLIC	?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z	; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z	; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MBEDDD@Z		; std::ctype<char>::do_narrow
PUBLIC	?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z	; std::ctype<char>::_Init
PUBLIC	?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ	; std::_Locinfo::_Getctype
PUBLIC	?_Tidy@?$ctype@D@std@@IAEXXZ			; std::ctype<char>::_Tidy
PUBLIC	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
PUBLIC	?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::egptr
PUBLIC	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
PUBLIC	?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
PUBLIC	?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
PUBLIC	?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
PUBLIC	?is@?$ctype@D@std@@QBE_NFD@Z			; std::ctype<char>::is
PUBLIC	?to_char_type@?$char_traits@D@std@@SADABH@Z	; std::char_traits<char>::to_char_type
PUBLIC	?chkUse@MusicItem@@QAE_NXZ			; MusicItem::chkUse
EXTRN	??_EMusicFile@@UAEPAXI@Z:NEAR			; MusicFile::`vector deleting destructor'
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:DWORD		; std::ctype<char>::id
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:NEAR		; std::ctype_base::`vector deleting destructor'
EXTRN	??_E?$ctype@D@std@@MAEPAXI@Z:NEAR		; std::ctype<char>::`vector deleting destructor'
EXTRN	__Tolower:NEAR
EXTRN	__Toupper:NEAR
EXTRN	__Getctype:NEAR
EXTRN	_free:NEAR
; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\MusicFile.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
;	COMDAT ??_C@_06CCOBMGDA@?$CDTitle?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CFENMDAG@?$CDtitle?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04PNPMGKHO@?$IL?H?$JG?$LM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09IGHFHPDK@?$CDComposer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09EIEPNJJ@?$CDcomposer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06MHLOKGDH@?$IN?l?$IL?H?$IO?R?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04CEBCLGG@?$IN?l?$IL?H?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@NBFPABFN@?$CDCopyright?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@JOACACIN@?$CDcopyright?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LEKHBDFG@?$IN?l?$IO?R?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08OIGPKLOH@?$JC?$JI?$IN?l?$IM?$KA?$IO?R?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KIKHLFNJ@?$CDOffsetPCM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OHPKLGAJ@?$CDoffsetPCM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05OEEHBABG@?$CDCode?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05CFIGDPBC@?$CDcode?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06EEPGCMOF@?$IDR?$IB?$FL?$IDh?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09MLAHDPMF@?$CDExternal?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09EJPGLNGG@?$CDexternal?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05KKOMOGMN@?$CDBank?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05GLCNMJMJ@?$CDbank?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06PGPFCODL@?$IDo?$ID?$JD?$IDN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FFNPFLJK@?$CDSegmentPCM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@NDEDNEEN@?$CDsegmentPCM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@KFJANFJL@?$CDSegmentSEQ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@CDAMFKEM@?$CDsegmentSEQ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08NBBMBDKH@?$CDSegment?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08CIGKHBPB@?$CDsegment?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FGHFIFIC@?$CDLabel?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FBNJIALE@?$CDlabel?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08JGMGPAEB@?$CDInclude?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08GPLAJCBH@?$CDinclude?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LJOLKEOC@?$JD?G?$IC?$NO?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09MEAIMKNM@?$CDTimebase?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09EGPJEIHP@?$CDtimebase?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@IDBKDPML@?$CDOctaveReverse?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@EOHOEHBD@?$CDoctaveReverse?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09BABJNKIL@?$CDQReverse?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JCOIFICI@?$CDqReverse?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LOKDGHIN@?$CDBGM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LDFIKKPB@?$CDbgm?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06EHIHHNNG@?$IJ?$LJ?$IKy?$JA?$JE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03IPMIALJK@?$CDSE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03CCABGJNI@?$CDse?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08CMFGKBBL@?$IM?x?$IJ?J?$IJ?$LJ?$JA?$JE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@CLJDPPFJ@?$CDreleaseVolume?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@OGPHIHIB@?$CDReleaseVolume?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@DLKNPGKB@?$CDrepeatMode?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@LNDBHJHG@?$CDRepeatMode?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08KBIDLIGH@?$CDTieMode?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08FIPFNKDB@?$CDtieMode?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09PJMHIDNI@?$CDOffsetE?$EA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HLDGABHL@?$CDoffsetE?$EA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HANLBCKN@?$CDOffsetEv?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09PCCKJAAO@?$CDoffsetEv?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09NJONNJDH@?$CDOffsetEm?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09FLBMFLJE@?$CDoffsetEm?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09PCMAIKPE@?$CDOffsetEn?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HADBAIFH@?$CDoffsetEn?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09KLINEFGN@?$CDPriority?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09CJHMMHMO@?$CDpriority?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05NPLBNLG@?$CDQMax?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05KNMJLCII@?$CDQmax?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JMMKNIKF@?$CDRest?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05FNALPHKB@?$CDrest?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MKPJOGCE@?$CDWait?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LDIMJCA@?$CDwait?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04NFBGGAN@VRC7?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04ECAEINBM@N163?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08GOBOGMGA@envelope?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07LBMEHABG@Envelop?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07EILCBCEA@envelop?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@FMGOOFEB@?$IDG?$ID?$JD?$IDx?$ID?$IN?$IB?$FL?$IDv?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OKKLBHBB@?$IDr?$IDu?$ID?$IJ?$IB?$FL?$IDg?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03CPCCDDB@Sub?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03KCMAIMAP@sub?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03NPKEBKFI@BGM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03NCFPNHCE@bgm?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04PHAOIHPI@?$IJ?$LJ?$IKy?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02ODEKANEE@SE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02EOIDGPAG@se?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06KKABNCAM@?$IM?x?$IJ?J?$IJ?$LJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05OFAJKLEL@Patch?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02KPPNMLFJ@FC?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DBHOOGNH@FM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01MJMHLOMK@O?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01FCMHBHNC@V?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01NANMIPIL@N?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01CPLAODJH@S?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01EJNLAFE@P?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05BABAKHMK@?$EADPCM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03HEGPLIOE@?$EAFM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03MIBHKNNO@?$EAMW?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03IENCOPHH@?$EAOP?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BONOMJKG@?$EAN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02PNCKBAGN@?$EAE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1EM@BEGGFCCM@?$AA?$CD?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe0?$LD0?$NO0?s0?I0o0?$AB@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1EE@MOLGAENM@?$AA?$CD?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AAM?$AAo?$AAd?$AAe0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DO@PDNFGBGE@?$AA?$CD?$AAT?$AAi?$AAe?$AAM?$AAo?$AAd?$AAe0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA10n?$HL?DV?r@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1EA@EIGBEKHF@?$AA?$CD?$AAp?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA30n?$HL?D@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DI@LBEELOIE@?$AA?$CD?$AAR?$AAe?$AAs?$AAt0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA30n?$HL?DV?r0gc?$AH?$FL?$JK@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DI@MNKEBKGP@?$AA?$CD?$AAW?$AAa?$AAi?$AAt0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA30n?$HL?DV?r0gc?$AH?$FL?$JK@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CC@JGHEFCII@?$AAD?$AAP?$AAC?$AAM0?V0?m0?C0?$KP0o?$PP?$BB0d0?$HO0g0g0Y0?$AC?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CM@EIOCHGHI@?$AA?$DN?$AA?$DN?$AA?$DN?$AA?$DN?$AA?5?$AA?$FL?$AA?5?$AAD?$AAP?$AAC?$AAM?$AAi?$AAn?$AAf?$AAo?$AA?5?$AA?$FN?$AA?$DN?$AA?$DN?$AA?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DC@HNHPBHDM@?$AAF?$AAD?$AAS?$AAC?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_19CBLNKBPD@?$AAF?$AAD?$AAS?$AAC?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DC@LLPEDCB@?$AAF?$AAD?$AAS?$AAM?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_19MBGCNGMA@?$AAF?$AAD?$AAS?$AAM?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DC@IKBGODDN@?$AAV?$AAR?$AAC?$AA7?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_19FLEMCNOH@?$AAV?$AAR?$AAC?$AA7?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DC@BMHBEBNP@?$AAN?$AA1?$AA6?$AA3?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_19OFNMEAIG@?$AAN?$AA1?$AA6?$AA3?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DK@BHJCAEG@?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0L@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BC@LIMGOFOL@?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DE@FKOKODHI@0?S0?V0?i0?$PM0?H?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DA@BGBJDANG@?$AAS?$AAu?$AAb?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM0?$HO@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_17ILLEHHEJ@?$AAS?$AAu?$AAb?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DA@MIOILPIL@?$AAB?$AAG?$AAM?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM0?$HO@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1FI@OKDKOODI@?$AAB?$AAG?$AAM?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gc?$AH?$FL?$JK0g0M0?$IL?$HL?DV?r0?$JC?$IN?$IF0H@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_17IKEGFPDC@?$AAB?$AAG?$AAM?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CO@BBMENDGM@?$AAS?$AAE?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM0?$HO0W@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1FE@JACJBOFE@?$AAS?$AAE?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gc?$AH?$FL?$JK0g0M0?$IL?$HL?DV?r0?$JC?$IN?$IF0H0f@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_15GIONIMAK@?$AAS?$AAE?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CO@LFJBLHAK@?$AAB?$AAG?$AAM0h?$AAS?$AAE0nep0LT?$AI?$IK?$AI0g?$AA2?$AA5?$AA50?$JC?$IN?$IK0H0?$HO0W@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BM@PLCKFEBA@?$AAB?$AAG?$AAM0?G0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BM@BGKOPALL@?$AAS?$AAE?$AA?50?G0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06EEKMEKPC@?$CJ?5?9?9?9?9?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09BPDCILGE@?9?9?9?9?5BGM?$CI?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08COBGNJFP@?9?9?9?9?5SE?$CI?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1FC@OJNKDJBH@?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CG@JFAJBGGI@?$AA?$CK?$AAN?$AAS?$AAF?$AA?5?$AAb?$AAu?$AAi?$AAl?$AAd?$AA?5?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1IA@DNNIGADP@c?$AH?$FL?$JK0n?$AA?4?$AAb?$AAi?$AAn0?U0?$KB0?$KE0?k0o0?$AB?$CC?$LP?$AAP?$AAC?$AAM0n0?P0?s@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BO@NLLFDPGO@?$AA?$FL?$AAC?$AAO?$AAD?$AAE?$AA?5?$AA?$CG?$AA?5?$AAM?$AAU?$AAS?$AAI?$AAC?$AA?$FN?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BE@GFIKIAF@?$AA?5?$AA?5?$AAB?$AAa?$AAn?$AAk?$AA?5?$AA?$DN?$AA?5?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BA@PDAIGOGG@?$AA?5?$AA?$FL?$AAB?$AAy?$AAt?$AAe?$AA?$FN?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BG@CFCHLKIG@?$AA?5?$AA?$FL?$AAB?$AAy?$AAt?$AAe?$AA?$FN?$AA?5?$AA?1?$AA?5?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BE@GMJJPPAM@?$AA?5?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?5?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DC@EMBJGJOO@0?$LD0?$PM0?I0?$PL0?$LH0?$PM0?$LB0?s0?$LJ0n0?$LF0?$KE0?$LK0L?$IK1?$FL?$LJP$0?$JC?$IN?$IK0H@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1GG@KLHECIMD@c?$AH?$FL?$JK0n?$AA?4?$AAb?$AAi?$AAn0?U0?$KB0?$KE0?k0o0?$AB?$CC?$LP?$AAP?$AAC?$AAM0n0?P0?s@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1O@KFBOMPNC@?$AA?$FL?$AAC?$AAO?$AAD?$AAE?$AA?$FN?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BG@EHOEIOII@?$AA?5?$AA?5?$AAB?$AAa?$AAn?$AAk?$AA?5?$AA?$DN?$AA?5?$AA3?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CM@KKKMFICH@?$AA?5?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?5?$AA1?$AA2?$AA2?$AA8?$AA8?$AA?5?$AA?$FL?$AAB?$AAy?$AAt?$AAe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BA@HAHLGPF@?$AA?$FL?$AAM?$AAU?$AAS?$AAI?$AAC?$AA?$FN?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1O@OBLFHHEM@?$AA?$FL?$AAD?$AAP?$AAC?$AAM?$AA?$FN?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CI@GAIMJLAM@?$CC?$LP?$AAP?$AAC?$AAM0n0?$LF0?$KE0?$LK0L?$IK1?$FL?$LJP$0?$JC?$IN?$IK0H0?$HO0W0_0?$AC?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CG@LIOGKFKL@0?P0?s0?$KPep0nT?$AI?$IK?$AI0L?$AA2?$AA5?$AA50?$JC?$IN?$IK0H0?$HO0W0_0?$AC?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0NF@IGNECHBF@?$DL?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@HLHGGEDN@?7?4export?7?7?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BK@KGHBAMLI@?$AA?$FL?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?$FN?$AA?5?$AA?3?$AA?5?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BK@BNOPLHAN@?$AA?$FL?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AA?$FN?$AA?5?$AA?3?$AA?5?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??_GMusicFile@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_DMusicFile@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEXABQAVMusicItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$map@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@@std@@QAEAAPAVFDSC@@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?count@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$map@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@@std@@QAEAAPAVFDSM@@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?count@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$map@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@@std@@QAEAAPAVVRC7@@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?count@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$map@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@@std@@QAEAAPAVN163@@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?count@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$map@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@@std@@QAEAAPAVEnvelop@@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?count@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAEAAPAVBGM@@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?count@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAEAAPAVSE@@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?count@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$map@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@@std@@QAEAAPAVSub@@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?count@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVEnvelop@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVSub@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVFDSC@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVFDSM@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVVRC7@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVN163@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEXViterator@12@ABQAVMusicItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVFDSC@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVFDSM@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVVRC7@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVN163@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVN163@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVEnvelop@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVBGM@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVSE@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVSE@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVSub@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVSub@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVEnvelop@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVBGM@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVSE@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVSub@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVFDSC@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVFDSM@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVVRC7@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVN163@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBHPAVSub@@@std@@QAE@ABHABQAVSub@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBHPAVEnvelop@@@std@@QAE@ABHABQAVEnvelop@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBHPAVFDSC@@@std@@QAE@ABHABQAVFDSC@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBHPAVFDSM@@@std@@QAE@ABHABQAVFDSM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBHPAVVRC7@@@std@@QAE@ABHABQAVVRC7@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBHPAVN163@@@std@@QAE@ABHABQAVN163@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put@?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@GU?$char_traits@G@std@@@2@V32@AAVios_base@2@GK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBHPAVBGM@@@std@@QAE@ABHABQAVBGM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBHPAVSE@@@std@@QAE@ABHABQAVSE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@PAU342@0ABQAVMusicItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Incsize@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVFDSC@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVFDSC@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVFDSC@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVFDSC@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVFDSM@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVFDSM@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVFDSM@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVFDSM@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVVRC7@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVVRC7@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVVRC7@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVVRC7@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVN163@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVN163@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVN163@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVN163@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVN163@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVEnvelop@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVEnvelop@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVEnvelop@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVEnvelop@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVBGM@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVBGM@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVBGM@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVBGM@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVSE@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVSE@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVSE@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVSE@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVSE@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVSub@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVSub@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVSub@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVSub@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVSub@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVEnvelop@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVBGM@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVSE@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVSub@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVFDSC@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVFDSM@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVVRC7@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVN163@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVFDSC@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVFDSM@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVVRC7@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVN163@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVEnvelop@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVBGM@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVSE@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVSub@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE@PAU012@0ABQAVMusicItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVMusicItem@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHPAVN163@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHPAVSE@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHPAVSub@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVFDSC@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVFDSM@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVVRC7@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVN163@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVEnvelop@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVBGM@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVSE@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVSub@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E1
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVFDSC@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVFDSM@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVVRC7@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVN163@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVEnvelop@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVBGM@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVSE@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVSub@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVFDSC@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVFDSM@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVVRC7@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVN163@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVEnvelop@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVBGM@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVSE@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVSub@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E3
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E5
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E7
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E9
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ctype@D@std@@QAE@PBF_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is@?$ctype@D@std@@QBE_NFD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?chkUse@MusicItem@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Command@?1???0MusicFile@@QAE@PAVMMLfile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBG@Z@4QBUCommand_Info@@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MusicFile@@6BFileOutput@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7MusicFile@@6BMusicItem@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_8MusicFile@@7B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06CCOBMGDA@?$CDTitle?$AA@			; `string'
PUBLIC	??_C@_06CFENMDAG@?$CDtitle?$AA@			; `string'
PUBLIC	??_C@_04PNPMGKHO@?$IL?H?$JG?$LM?$AA@		; `string'
PUBLIC	??_C@_09IGHFHPDK@?$CDComposer?$AA@		; `string'
PUBLIC	??_C@_09EIEPNJJ@?$CDcomposer?$AA@		; `string'
PUBLIC	??_C@_06MHLOKGDH@?$IN?l?$IL?H?$IO?R?$AA@	; `string'
PUBLIC	??_C@_04CEBCLGG@?$IN?l?$IL?H?$AA@		; `string'
PUBLIC	??_C@_0L@NBFPABFN@?$CDCopyright?$AA@		; `string'
PUBLIC	??_C@_0L@JOACACIN@?$CDcopyright?$AA@		; `string'
PUBLIC	??_C@_04LEKHBDFG@?$IN?l?$IO?R?$AA@		; `string'
PUBLIC	??_C@_08OIGPKLOH@?$JC?$JI?$IN?l?$IM?$KA?$IO?R?$AA@ ; `string'
PUBLIC	??_C@_0L@KIKHLFNJ@?$CDOffsetPCM?$AA@		; `string'
PUBLIC	??_C@_0L@OHPKLGAJ@?$CDoffsetPCM?$AA@		; `string'
PUBLIC	??_C@_05OEEHBABG@?$CDCode?$AA@			; `string'
PUBLIC	??_C@_05CFIGDPBC@?$CDcode?$AA@			; `string'
PUBLIC	??_C@_06EEPGCMOF@?$IDR?$IB?$FL?$IDh?$AA@	; `string'
PUBLIC	??_C@_09MLAHDPMF@?$CDExternal?$AA@		; `string'
PUBLIC	??_C@_09EJPGLNGG@?$CDexternal?$AA@		; `string'
PUBLIC	??_C@_05KKOMOGMN@?$CDBank?$AA@			; `string'
PUBLIC	??_C@_05GLCNMJMJ@?$CDbank?$AA@			; `string'
PUBLIC	??_C@_06PGPFCODL@?$IDo?$ID?$JD?$IDN?$AA@	; `string'
PUBLIC	??_C@_0M@FFNPFLJK@?$CDSegmentPCM?$AA@		; `string'
PUBLIC	??_C@_0M@NDEDNEEN@?$CDsegmentPCM?$AA@		; `string'
PUBLIC	??_C@_0M@KFJANFJL@?$CDSegmentSEQ?$AA@		; `string'
PUBLIC	??_C@_0M@CDAMFKEM@?$CDsegmentSEQ?$AA@		; `string'
PUBLIC	??_C@_08NBBMBDKH@?$CDSegment?$AA@		; `string'
PUBLIC	??_C@_08CIGKHBPB@?$CDsegment?$AA@		; `string'
PUBLIC	??_C@_06FGHFIFIC@?$CDLabel?$AA@			; `string'
PUBLIC	??_C@_06FBNJIALE@?$CDlabel?$AA@			; `string'
PUBLIC	??_C@_08JGMGPAEB@?$CDInclude?$AA@		; `string'
PUBLIC	??_C@_08GPLAJCBH@?$CDinclude?$AA@		; `string'
PUBLIC	??_C@_04LJOLKEOC@?$JD?G?$IC?$NO?$AA@		; `string'
PUBLIC	??_C@_09MEAIMKNM@?$CDTimebase?$AA@		; `string'
PUBLIC	??_C@_09EGPJEIHP@?$CDtimebase?$AA@		; `string'
PUBLIC	??_C@_0P@IDBKDPML@?$CDOctaveReverse?$AA@	; `string'
PUBLIC	??_C@_0P@EOHOEHBD@?$CDoctaveReverse?$AA@	; `string'
PUBLIC	??_C@_09BABJNKIL@?$CDQReverse?$AA@		; `string'
PUBLIC	??_C@_09JCOIFICI@?$CDqReverse?$AA@		; `string'
PUBLIC	??_C@_04LOKDGHIN@?$CDBGM?$AA@			; `string'
PUBLIC	??_C@_04LDFIKKPB@?$CDbgm?$AA@			; `string'
PUBLIC	??_C@_06EHIHHNNG@?$IJ?$LJ?$IKy?$JA?$JE?$AA@	; `string'
PUBLIC	??_C@_03IPMIALJK@?$CDSE?$AA@			; `string'
PUBLIC	??_C@_03CCABGJNI@?$CDse?$AA@			; `string'
PUBLIC	??_C@_08CMFGKBBL@?$IM?x?$IJ?J?$IJ?$LJ?$JA?$JE?$AA@ ; `string'
PUBLIC	??_C@_0P@CLJDPPFJ@?$CDreleaseVolume?$AA@	; `string'
PUBLIC	??_C@_0P@OGPHIHIB@?$CDReleaseVolume?$AA@	; `string'
PUBLIC	??_C@_0M@DLKNPGKB@?$CDrepeatMode?$AA@		; `string'
PUBLIC	??_C@_0M@LNDBHJHG@?$CDRepeatMode?$AA@		; `string'
PUBLIC	??_C@_08KBIDLIGH@?$CDTieMode?$AA@		; `string'
PUBLIC	??_C@_08FIPFNKDB@?$CDtieMode?$AA@		; `string'
PUBLIC	??_C@_09PJMHIDNI@?$CDOffsetE?$EA?$AA@		; `string'
PUBLIC	??_C@_09HLDGABHL@?$CDoffsetE?$EA?$AA@		; `string'
PUBLIC	??_C@_09HANLBCKN@?$CDOffsetEv?$AA@		; `string'
PUBLIC	??_C@_09PCCKJAAO@?$CDoffsetEv?$AA@		; `string'
PUBLIC	??_C@_09NJONNJDH@?$CDOffsetEm?$AA@		; `string'
PUBLIC	??_C@_09FLBMFLJE@?$CDoffsetEm?$AA@		; `string'
PUBLIC	??_C@_09PCMAIKPE@?$CDOffsetEn?$AA@		; `string'
PUBLIC	??_C@_09HADBAIFH@?$CDoffsetEn?$AA@		; `string'
PUBLIC	??_C@_09KLINEFGN@?$CDPriority?$AA@		; `string'
PUBLIC	??_C@_09CJHMMHMO@?$CDpriority?$AA@		; `string'
PUBLIC	??_C@_05NPLBNLG@?$CDQMax?$AA@			; `string'
PUBLIC	??_C@_05KNMJLCII@?$CDQmax?$AA@			; `string'
PUBLIC	??_C@_05JMMKNIKF@?$CDRest?$AA@			; `string'
PUBLIC	??_C@_05FNALPHKB@?$CDrest?$AA@			; `string'
PUBLIC	??_C@_05MKPJOGCE@?$CDWait?$AA@			; `string'
PUBLIC	??_C@_05LDIMJCA@?$CDwait?$AA@			; `string'
PUBLIC	??_C@_04NFBGGAN@VRC7?$AA@			; `string'
PUBLIC	??_C@_04ECAEINBM@N163?$AA@			; `string'
PUBLIC	??_C@_08GOBOGMGA@envelope?$AA@			; `string'
PUBLIC	??_C@_07LBMEHABG@Envelop?$AA@			; `string'
PUBLIC	??_C@_07EILCBCEA@envelop?$AA@			; `string'
PUBLIC	??_C@_0N@FMGOOFEB@?$IDG?$ID?$JD?$IDx?$ID?$IN?$IB?$FL?$IDv?$AA@ ; `string'
PUBLIC	??_C@_0L@OKKLBHBB@?$IDr?$IDu?$ID?$IJ?$IB?$FL?$IDg?$AA@ ; `string'
PUBLIC	??_C@_03CPCCDDB@Sub?$AA@			; `string'
PUBLIC	??_C@_03KCMAIMAP@sub?$AA@			; `string'
PUBLIC	??_C@_03NPKEBKFI@BGM?$AA@			; `string'
PUBLIC	??_C@_03NCFPNHCE@bgm?$AA@			; `string'
PUBLIC	??_C@_04PHAOIHPI@?$IJ?$LJ?$IKy?$AA@		; `string'
PUBLIC	??_C@_02ODEKANEE@SE?$AA@			; `string'
PUBLIC	??_C@_02EOIDGPAG@se?$AA@			; `string'
PUBLIC	??_C@_06KKABNCAM@?$IM?x?$IJ?J?$IJ?$LJ?$AA@	; `string'
PUBLIC	??_C@_05OFAJKLEL@Patch?$AA@			; `string'
PUBLIC	??_C@_02KPPNMLFJ@FC?$AA@			; `string'
PUBLIC	??_C@_02DBHOOGNH@FM?$AA@			; `string'
PUBLIC	??_C@_01MJMHLOMK@O?$AA@				; `string'
PUBLIC	??_C@_01FCMHBHNC@V?$AA@				; `string'
PUBLIC	??_C@_01NANMIPIL@N?$AA@				; `string'
PUBLIC	??_C@_01CPLAODJH@S?$AA@				; `string'
PUBLIC	??_C@_01EJNLAFE@P?$AA@				; `string'
PUBLIC	??_C@_05BABAKHMK@?$EADPCM?$AA@			; `string'
PUBLIC	??_C@_03HEGPLIOE@?$EAFM?$AA@			; `string'
PUBLIC	??_C@_03MIBHKNNO@?$EAMW?$AA@			; `string'
PUBLIC	??_C@_03IENCOPHH@?$EAOP?$AA@			; `string'
PUBLIC	??_C@_02BONOMJKG@?$EAN?$AA@			; `string'
PUBLIC	??_C@_02PNCKBAGN@?$EAE?$AA@			; `string'
PUBLIC	??_C@_1EM@BEGGFCCM@?$AA?$CD?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe0?$LD0?$NO0?s0?I0o0?$AB@ ; `string'
PUBLIC	??_C@_1EE@MOLGAENM@?$AA?$CD?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AAM?$AAo?$AAd?$AAe0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA2@ ; `string'
PUBLIC	??_C@_1DO@PDNFGBGE@?$AA?$CD?$AAT?$AAi?$AAe?$AAM?$AAo?$AAd?$AAe0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA10n?$HL?DV?r@ ; `string'
PUBLIC	??_C@_1EA@EIGBEKHF@?$AA?$CD?$AAp?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA30n?$HL?D@ ; `string'
PUBLIC	??_C@_1DI@LBEELOIE@?$AA?$CD?$AAR?$AAe?$AAs?$AAt0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA30n?$HL?DV?r0gc?$AH?$FL?$JK@ ; `string'
PUBLIC	??_C@_1DI@MNKEBKGP@?$AA?$CD?$AAW?$AAa?$AAi?$AAt0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA30n?$HL?DV?r0gc?$AH?$FL?$JK@ ; `string'
PUBLIC	??_C@_1CC@JGHEFCII@?$AAD?$AAP?$AAC?$AAM0?V0?m0?C0?$KP0o?$PP?$BB0d0?$HO0g0g0Y0?$AC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CM@EIOCHGHI@?$AA?$DN?$AA?$DN?$AA?$DN?$AA?$DN?$AA?5?$AA?$FL?$AA?5?$AAD?$AAP?$AAC?$AAM?$AAi?$AAn?$AAf?$AAo?$AA?5?$AA?$FN?$AA?$DN?$AA?$DN?$AA?$DN@ ; `string'
PUBLIC	??_C@_1DC@HNHPBHDM@?$AAF?$AAD?$AAS?$AAC?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM@ ; `string'
PUBLIC	??_C@_19CBLNKBPD@?$AAF?$AAD?$AAS?$AAC?$AA?$AA@	; `string'
PUBLIC	??_C@_1DC@LLPEDCB@?$AAF?$AAD?$AAS?$AAM?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM@ ; `string'
PUBLIC	??_C@_19MBGCNGMA@?$AAF?$AAD?$AAS?$AAM?$AA?$AA@	; `string'
PUBLIC	??_C@_1DC@IKBGODDN@?$AAV?$AAR?$AAC?$AA7?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM@ ; `string'
PUBLIC	??_C@_19FLEMCNOH@?$AAV?$AAR?$AAC?$AA7?$AA?$AA@	; `string'
PUBLIC	??_C@_1DC@BMHBEBNP@?$AAN?$AA1?$AA6?$AA3?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM@ ; `string'
PUBLIC	??_C@_19OFNMEAIG@?$AAN?$AA1?$AA6?$AA3?$AA?$AA@	; `string'
PUBLIC	??_C@_1DK@BHJCAEG@?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0L@ ; `string'
PUBLIC	??_C@_1BC@LIMGOFOL@?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@FKOKODHI@0?S0?V0?i0?$PM0?H?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U@ ; `string'
PUBLIC	??_C@_1DA@BGBJDANG@?$AAS?$AAu?$AAb?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM0?$HO@ ; `string'
PUBLIC	??_C@_17ILLEHHEJ@?$AAS?$AAu?$AAb?$AA?$AA@	; `string'
PUBLIC	??_C@_1DA@MIOILPIL@?$AAB?$AAG?$AAM?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM0?$HO@ ; `string'
PUBLIC	??_C@_1FI@OKDKOODI@?$AAB?$AAG?$AAM?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gc?$AH?$FL?$JK0g0M0?$IL?$HL?DV?r0?$JC?$IN?$IF0H@ ; `string'
PUBLIC	??_C@_17IKEGFPDC@?$AAB?$AAG?$AAM?$AA?$AA@	; `string'
PUBLIC	??_C@_1CO@BBMENDGM@?$AAS?$AAE?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM0?$HO0W@ ; `string'
PUBLIC	??_C@_1FE@JACJBOFE@?$AAS?$AAE?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gc?$AH?$FL?$JK0g0M0?$IL?$HL?DV?r0?$JC?$IN?$IF0H0f@ ; `string'
PUBLIC	??_C@_15GIONIMAK@?$AAS?$AAE?$AA?$AA@		; `string'
PUBLIC	??_C@_1CO@LFJBLHAK@?$AAB?$AAG?$AAM0h?$AAS?$AAE0nep0LT?$AI?$IK?$AI0g?$AA2?$AA5?$AA50?$JC?$IN?$IK0H0?$HO0W@ ; `string'
PUBLIC	??_C@_1BM@PLCKFEBA@?$AAB?$AAG?$AAM0?G0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BM@BGKOPALL@?$AAS?$AAE?$AA?50?G0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@ ; `string'
PUBLIC	??_C@_06EEKMEKPC@?$CJ?5?9?9?9?9?$AA@		; `string'
PUBLIC	??_C@_09BPDCILGE@?9?9?9?9?5BGM?$CI?$AA@		; `string'
PUBLIC	??_C@_08COBGNJFP@?9?9?9?9?5SE?$CI?$AA@		; `string'
PUBLIC	??_C@_1FC@OJNKDJBH@?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9@ ; `string'
PUBLIC	??_C@_1CG@JFAJBGGI@?$AA?$CK?$AAN?$AAS?$AAF?$AA?5?$AAb?$AAu?$AAi?$AAl?$AAd?$AA?5?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1IA@DNNIGADP@c?$AH?$FL?$JK0n?$AA?4?$AAb?$AAi?$AAn0?U0?$KB0?$KE0?k0o0?$AB?$CC?$LP?$AAP?$AAC?$AAM0n0?P0?s@ ; `string'
PUBLIC	??_C@_1BO@NLLFDPGO@?$AA?$FL?$AAC?$AAO?$AAD?$AAE?$AA?5?$AA?$CG?$AA?5?$AAM?$AAU?$AAS?$AAI?$AAC?$AA?$FN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@GFIKIAF@?$AA?5?$AA?5?$AAB?$AAa?$AAn?$AAk?$AA?5?$AA?$DN?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BA@PDAIGOGG@?$AA?5?$AA?$FL?$AAB?$AAy?$AAt?$AAe?$AA?$FN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@CFCHLKIG@?$AA?5?$AA?$FL?$AAB?$AAy?$AAt?$AAe?$AA?$FN?$AA?5?$AA?1?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@GMJJPPAM@?$AA?5?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DC@EMBJGJOO@0?$LD0?$PM0?I0?$PL0?$LH0?$PM0?$LB0?s0?$LJ0n0?$LF0?$KE0?$LK0L?$IK1?$FL?$LJP$0?$JC?$IN?$IK0H@ ; `string'
PUBLIC	??_C@_1GG@KLHECIMD@c?$AH?$FL?$JK0n?$AA?4?$AAb?$AAi?$AAn0?U0?$KB0?$KE0?k0o0?$AB?$CC?$LP?$AAP?$AAC?$AAM0n0?P0?s@ ; `string'
PUBLIC	??_C@_1O@KFBOMPNC@?$AA?$FL?$AAC?$AAO?$AAD?$AAE?$AA?$FN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@EHOEIOII@?$AA?5?$AA?5?$AAB?$AAa?$AAn?$AAk?$AA?5?$AA?$DN?$AA?5?$AA3?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CM@KKKMFICH@?$AA?5?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?5?$AA1?$AA2?$AA2?$AA8?$AA8?$AA?5?$AA?$FL?$AAB?$AAy?$AAt?$AAe@ ; `string'
PUBLIC	??_C@_1BA@HAHLGPF@?$AA?$FL?$AAM?$AAU?$AAS?$AAI?$AAC?$AA?$FN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@OBLFHHEM@?$AA?$FL?$AAD?$AAP?$AAC?$AAM?$AA?$FN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@GAIMJLAM@?$CC?$LP?$AAP?$AAC?$AAM0n0?$LF0?$KE0?$LK0L?$IK1?$FL?$LJP$0?$JC?$IN?$IK0H0?$HO0W0_0?$AC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@LIOGKFKL@0?P0?s0?$KPep0nT?$AI?$IK?$AI0L?$AA2?$AA5?$AA50?$JC?$IN?$IK0H0?$HO0W0_0?$AC?$AA?$AA@ ; `string'
PUBLIC	??_C@_0NF@IGNECHBF@?$DL?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ ; `string'
PUBLIC	??_C@_0L@HLHGGEDN@?7?4export?7?7?$AA@		; `string'
PUBLIC	??_C@_1BK@KGHBAMLI@?$AA?$FL?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?$FN?$AA?5?$AA?3?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BK@BNOPLHAN@?$AA?$FL?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AA?$FN?$AA?5?$AA?3?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??_7MusicFile@@6BFileOutput@@@			; MusicFile::`vftable'
PUBLIC	??_7MusicFile@@6BMusicItem@@@			; MusicFile::`vftable'
PUBLIC	??_8MusicFile@@7B@				; MusicFile::`vbtable'
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ??_C@_06CCOBMGDA@?$CDTitle?$AA@
CONST	SEGMENT
??_C@_06CCOBMGDA@?$CDTitle?$AA@ DB '#Title', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06CFENMDAG@?$CDtitle?$AA@
CONST	SEGMENT
??_C@_06CFENMDAG@?$CDtitle?$AA@ DB '#title', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04PNPMGKHO@?$IL?H?$JG?$LM?$AA@
CONST	SEGMENT
??_C@_04PNPMGKHO@?$IL?H?$JG?$LM?$AA@ DB 08bH, 0c8H, 096H, 0bcH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IGHFHPDK@?$CDComposer?$AA@
CONST	SEGMENT
??_C@_09IGHFHPDK@?$CDComposer?$AA@ DB '#Composer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EIEPNJJ@?$CDcomposer?$AA@
CONST	SEGMENT
??_C@_09EIEPNJJ@?$CDcomposer?$AA@ DB '#composer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MHLOKGDH@?$IN?l?$IL?H?$IO?R?$AA@
CONST	SEGMENT
??_C@_06MHLOKGDH@?$IN?l?$IL?H?$IO?R?$AA@ DB 08dH, 0ecH, 08bH, 0c8H, 08eH, 0d2H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04CEBCLGG@?$IN?l?$IL?H?$AA@
CONST	SEGMENT
??_C@_04CEBCLGG@?$IN?l?$IL?H?$AA@ DB 08dH, 0ecH, 08bH, 0c8H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NBFPABFN@?$CDCopyright?$AA@
CONST	SEGMENT
??_C@_0L@NBFPABFN@?$CDCopyright?$AA@ DB '#Copyright', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JOACACIN@?$CDcopyright?$AA@
CONST	SEGMENT
??_C@_0L@JOACACIN@?$CDcopyright?$AA@ DB '#copyright', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04LEKHBDFG@?$IN?l?$IO?R?$AA@
CONST	SEGMENT
??_C@_04LEKHBDFG@?$IN?l?$IO?R?$AA@ DB 08dH, 0ecH, 08eH, 0d2H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OIGPKLOH@?$JC?$JI?$IN?l?$IM?$KA?$IO?R?$AA@
CONST	SEGMENT
??_C@_08OIGPKLOH@?$JC?$JI?$IN?l?$IM?$KA?$IO?R?$AA@ DB 092H, 098H, 08dH, 0ecH
	DB	08cH, 0a0H, 08eH, 0d2H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KIKHLFNJ@?$CDOffsetPCM?$AA@
CONST	SEGMENT
??_C@_0L@KIKHLFNJ@?$CDOffsetPCM?$AA@ DB '#OffsetPCM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OHPKLGAJ@?$CDoffsetPCM?$AA@
CONST	SEGMENT
??_C@_0L@OHPKLGAJ@?$CDoffsetPCM?$AA@ DB '#offsetPCM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05OEEHBABG@?$CDCode?$AA@
CONST	SEGMENT
??_C@_05OEEHBABG@?$CDCode?$AA@ DB '#Code', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CFIGDPBC@?$CDcode?$AA@
CONST	SEGMENT
??_C@_05CFIGDPBC@?$CDcode?$AA@ DB '#code', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EEPGCMOF@?$IDR?$IB?$FL?$IDh?$AA@
CONST	SEGMENT
??_C@_06EEPGCMOF@?$IDR?$IB?$FL?$IDh?$AA@ DB 083H, 'R', 081H, '[', 083H, 'h'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_09MLAHDPMF@?$CDExternal?$AA@
CONST	SEGMENT
??_C@_09MLAHDPMF@?$CDExternal?$AA@ DB '#External', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EJPGLNGG@?$CDexternal?$AA@
CONST	SEGMENT
??_C@_09EJPGLNGG@?$CDexternal?$AA@ DB '#external', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05KKOMOGMN@?$CDBank?$AA@
CONST	SEGMENT
??_C@_05KKOMOGMN@?$CDBank?$AA@ DB '#Bank', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GLCNMJMJ@?$CDbank?$AA@
CONST	SEGMENT
??_C@_05GLCNMJMJ@?$CDbank?$AA@ DB '#bank', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PGPFCODL@?$IDo?$ID?$JD?$IDN?$AA@
CONST	SEGMENT
??_C@_06PGPFCODL@?$IDo?$ID?$JD?$IDN?$AA@ DB 083H, 'o', 083H, 093H, 083H, 'N'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FFNPFLJK@?$CDSegmentPCM?$AA@
CONST	SEGMENT
??_C@_0M@FFNPFLJK@?$CDSegmentPCM?$AA@ DB '#SegmentPCM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NDEDNEEN@?$CDsegmentPCM?$AA@
CONST	SEGMENT
??_C@_0M@NDEDNEEN@?$CDsegmentPCM?$AA@ DB '#segmentPCM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KFJANFJL@?$CDSegmentSEQ?$AA@
CONST	SEGMENT
??_C@_0M@KFJANFJL@?$CDSegmentSEQ?$AA@ DB '#SegmentSEQ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CDAMFKEM@?$CDsegmentSEQ?$AA@
CONST	SEGMENT
??_C@_0M@CDAMFKEM@?$CDsegmentSEQ?$AA@ DB '#segmentSEQ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NBBMBDKH@?$CDSegment?$AA@
CONST	SEGMENT
??_C@_08NBBMBDKH@?$CDSegment?$AA@ DB '#Segment', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CIGKHBPB@?$CDsegment?$AA@
CONST	SEGMENT
??_C@_08CIGKHBPB@?$CDsegment?$AA@ DB '#segment', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FGHFIFIC@?$CDLabel?$AA@
CONST	SEGMENT
??_C@_06FGHFIFIC@?$CDLabel?$AA@ DB '#Label', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FBNJIALE@?$CDlabel?$AA@
CONST	SEGMENT
??_C@_06FBNJIALE@?$CDlabel?$AA@ DB '#label', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JGMGPAEB@?$CDInclude?$AA@
CONST	SEGMENT
??_C@_08JGMGPAEB@?$CDInclude?$AA@ DB '#Include', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GPLAJCBH@?$CDinclude?$AA@
CONST	SEGMENT
??_C@_08GPLAJCBH@?$CDinclude?$AA@ DB '#include', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04LJOLKEOC@?$JD?G?$IC?$NO?$AA@
CONST	SEGMENT
??_C@_04LJOLKEOC@?$JD?G?$IC?$NO?$AA@ DB 093H, 0c7H, 082H, 0deH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MEAIMKNM@?$CDTimebase?$AA@
CONST	SEGMENT
??_C@_09MEAIMKNM@?$CDTimebase?$AA@ DB '#Timebase', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EGPJEIHP@?$CDtimebase?$AA@
CONST	SEGMENT
??_C@_09EGPJEIHP@?$CDtimebase?$AA@ DB '#timebase', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IDBKDPML@?$CDOctaveReverse?$AA@
CONST	SEGMENT
??_C@_0P@IDBKDPML@?$CDOctaveReverse?$AA@ DB '#OctaveReverse', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EOHOEHBD@?$CDoctaveReverse?$AA@
CONST	SEGMENT
??_C@_0P@EOHOEHBD@?$CDoctaveReverse?$AA@ DB '#octaveReverse', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BABJNKIL@?$CDQReverse?$AA@
CONST	SEGMENT
??_C@_09BABJNKIL@?$CDQReverse?$AA@ DB '#QReverse', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCOIFICI@?$CDqReverse?$AA@
CONST	SEGMENT
??_C@_09JCOIFICI@?$CDqReverse?$AA@ DB '#qReverse', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOKDGHIN@?$CDBGM?$AA@
CONST	SEGMENT
??_C@_04LOKDGHIN@?$CDBGM?$AA@ DB '#BGM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LDFIKKPB@?$CDbgm?$AA@
CONST	SEGMENT
??_C@_04LDFIKKPB@?$CDbgm?$AA@ DB '#bgm', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EHIHHNNG@?$IJ?$LJ?$IKy?$JA?$JE?$AA@
CONST	SEGMENT
??_C@_06EHIHHNNG@?$IJ?$LJ?$IKy?$JA?$JE?$AA@ DB 089H, 0b9H, 08aH, 'y', 090H
	DB	094H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_03IPMIALJK@?$CDSE?$AA@
CONST	SEGMENT
??_C@_03IPMIALJK@?$CDSE?$AA@ DB '#SE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CCABGJNI@?$CDse?$AA@
CONST	SEGMENT
??_C@_03CCABGJNI@?$CDse?$AA@ DB '#se', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CMFGKBBL@?$IM?x?$IJ?J?$IJ?$LJ?$JA?$JE?$AA@
CONST	SEGMENT
??_C@_08CMFGKBBL@?$IM?x?$IJ?J?$IJ?$LJ?$JA?$JE?$AA@ DB 08cH, 0f8H, 089H, 0caH
	DB	089H, 0b9H, 090H, 094H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CLJDPPFJ@?$CDreleaseVolume?$AA@
CONST	SEGMENT
??_C@_0P@CLJDPPFJ@?$CDreleaseVolume?$AA@ DB '#releaseVolume', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OGPHIHIB@?$CDReleaseVolume?$AA@
CONST	SEGMENT
??_C@_0P@OGPHIHIB@?$CDReleaseVolume?$AA@ DB '#ReleaseVolume', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DLKNPGKB@?$CDrepeatMode?$AA@
CONST	SEGMENT
??_C@_0M@DLKNPGKB@?$CDrepeatMode?$AA@ DB '#repeatMode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LNDBHJHG@?$CDRepeatMode?$AA@
CONST	SEGMENT
??_C@_0M@LNDBHJHG@?$CDRepeatMode?$AA@ DB '#RepeatMode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KBIDLIGH@?$CDTieMode?$AA@
CONST	SEGMENT
??_C@_08KBIDLIGH@?$CDTieMode?$AA@ DB '#TieMode', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FIPFNKDB@?$CDtieMode?$AA@
CONST	SEGMENT
??_C@_08FIPFNKDB@?$CDtieMode?$AA@ DB '#tieMode', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PJMHIDNI@?$CDOffsetE?$EA?$AA@
CONST	SEGMENT
??_C@_09PJMHIDNI@?$CDOffsetE?$EA?$AA@ DB '#OffsetE@', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HLDGABHL@?$CDoffsetE?$EA?$AA@
CONST	SEGMENT
??_C@_09HLDGABHL@?$CDoffsetE?$EA?$AA@ DB '#offsetE@', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HANLBCKN@?$CDOffsetEv?$AA@
CONST	SEGMENT
??_C@_09HANLBCKN@?$CDOffsetEv?$AA@ DB '#OffsetEv', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PCCKJAAO@?$CDoffsetEv?$AA@
CONST	SEGMENT
??_C@_09PCCKJAAO@?$CDoffsetEv?$AA@ DB '#offsetEv', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NJONNJDH@?$CDOffsetEm?$AA@
CONST	SEGMENT
??_C@_09NJONNJDH@?$CDOffsetEm?$AA@ DB '#OffsetEm', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09FLBMFLJE@?$CDoffsetEm?$AA@
CONST	SEGMENT
??_C@_09FLBMFLJE@?$CDoffsetEm?$AA@ DB '#offsetEm', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PCMAIKPE@?$CDOffsetEn?$AA@
CONST	SEGMENT
??_C@_09PCMAIKPE@?$CDOffsetEn?$AA@ DB '#OffsetEn', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HADBAIFH@?$CDoffsetEn?$AA@
CONST	SEGMENT
??_C@_09HADBAIFH@?$CDoffsetEn?$AA@ DB '#offsetEn', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09KLINEFGN@?$CDPriority?$AA@
CONST	SEGMENT
??_C@_09KLINEFGN@?$CDPriority?$AA@ DB '#Priority', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09CJHMMHMO@?$CDpriority?$AA@
CONST	SEGMENT
??_C@_09CJHMMHMO@?$CDpriority?$AA@ DB '#priority', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05NPLBNLG@?$CDQMax?$AA@
CONST	SEGMENT
??_C@_05NPLBNLG@?$CDQMax?$AA@ DB '#QMax', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KNMJLCII@?$CDQmax?$AA@
CONST	SEGMENT
??_C@_05KNMJLCII@?$CDQmax?$AA@ DB '#Qmax', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JMMKNIKF@?$CDRest?$AA@
CONST	SEGMENT
??_C@_05JMMKNIKF@?$CDRest?$AA@ DB '#Rest', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FNALPHKB@?$CDrest?$AA@
CONST	SEGMENT
??_C@_05FNALPHKB@?$CDrest?$AA@ DB '#rest', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MKPJOGCE@?$CDWait?$AA@
CONST	SEGMENT
??_C@_05MKPJOGCE@?$CDWait?$AA@ DB '#Wait', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LDIMJCA@?$CDwait?$AA@
CONST	SEGMENT
??_C@_05LDIMJCA@?$CDwait?$AA@ DB '#wait', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NFBGGAN@VRC7?$AA@
CONST	SEGMENT
??_C@_04NFBGGAN@VRC7?$AA@ DB 'VRC7', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04ECAEINBM@N163?$AA@
CONST	SEGMENT
??_C@_04ECAEINBM@N163?$AA@ DB 'N163', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GOBOGMGA@envelope?$AA@
CONST	SEGMENT
??_C@_08GOBOGMGA@envelope?$AA@ DB 'envelope', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LBMEHABG@Envelop?$AA@
CONST	SEGMENT
??_C@_07LBMEHABG@Envelop?$AA@ DB 'Envelop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EILCBCEA@envelop?$AA@
CONST	SEGMENT
??_C@_07EILCBCEA@envelop?$AA@ DB 'envelop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FMGOOFEB@?$IDG?$ID?$JD?$IDx?$ID?$IN?$IB?$FL?$IDv?$AA@
CONST	SEGMENT
??_C@_0N@FMGOOFEB@?$IDG?$ID?$JD?$IDx?$ID?$IN?$IB?$FL?$IDv?$AA@ DB 083H, 'G'
	DB	083H, 093H, 083H, 'x', 083H, 08dH, 081H, '[', 083H, 'v', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OKKLBHBB@?$IDr?$IDu?$ID?$IJ?$IB?$FL?$IDg?$AA@
CONST	SEGMENT
??_C@_0L@OKKLBHBB@?$IDr?$IDu?$ID?$IJ?$IB?$FL?$IDg?$AA@ DB 083H, 'r', 083H
	DB	'u', 083H, 089H, 081H, '[', 083H, 'g', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03CPCCDDB@Sub?$AA@
CONST	SEGMENT
??_C@_03CPCCDDB@Sub?$AA@ DB 'Sub', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KCMAIMAP@sub?$AA@
CONST	SEGMENT
??_C@_03KCMAIMAP@sub?$AA@ DB 'sub', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NPKEBKFI@BGM?$AA@
CONST	SEGMENT
??_C@_03NPKEBKFI@BGM?$AA@ DB 'BGM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NCFPNHCE@bgm?$AA@
CONST	SEGMENT
??_C@_03NCFPNHCE@bgm?$AA@ DB 'bgm', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PHAOIHPI@?$IJ?$LJ?$IKy?$AA@
CONST	SEGMENT
??_C@_04PHAOIHPI@?$IJ?$LJ?$IKy?$AA@ DB 089H, 0b9H, 08aH, 'y', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02ODEKANEE@SE?$AA@
CONST	SEGMENT
??_C@_02ODEKANEE@SE?$AA@ DB 'SE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EOIDGPAG@se?$AA@
CONST	SEGMENT
??_C@_02EOIDGPAG@se?$AA@ DB 'se', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06KKABNCAM@?$IM?x?$IJ?J?$IJ?$LJ?$AA@
CONST	SEGMENT
??_C@_06KKABNCAM@?$IM?x?$IJ?J?$IJ?$LJ?$AA@ DB 08cH, 0f8H, 089H, 0caH, 089H
	DB	0b9H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_05OFAJKLEL@Patch?$AA@
CONST	SEGMENT
??_C@_05OFAJKLEL@Patch?$AA@ DB 'Patch', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KPPNMLFJ@FC?$AA@
CONST	SEGMENT
??_C@_02KPPNMLFJ@FC?$AA@ DB 'FC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DBHOOGNH@FM?$AA@
CONST	SEGMENT
??_C@_02DBHOOGNH@FM?$AA@ DB 'FM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01MJMHLOMK@O?$AA@
CONST	SEGMENT
??_C@_01MJMHLOMK@O?$AA@ DB 'O', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FCMHBHNC@V?$AA@
CONST	SEGMENT
??_C@_01FCMHBHNC@V?$AA@ DB 'V', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01NANMIPIL@N?$AA@
CONST	SEGMENT
??_C@_01NANMIPIL@N?$AA@ DB 'N', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CPLAODJH@S?$AA@
CONST	SEGMENT
??_C@_01CPLAODJH@S?$AA@ DB 'S', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EJNLAFE@P?$AA@
CONST	SEGMENT
??_C@_01EJNLAFE@P?$AA@ DB 'P', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05BABAKHMK@?$EADPCM?$AA@
CONST	SEGMENT
??_C@_05BABAKHMK@?$EADPCM?$AA@ DB '@DPCM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HEGPLIOE@?$EAFM?$AA@
CONST	SEGMENT
??_C@_03HEGPLIOE@?$EAFM?$AA@ DB '@FM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MIBHKNNO@?$EAMW?$AA@
CONST	SEGMENT
??_C@_03MIBHKNNO@?$EAMW?$AA@ DB '@MW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IENCOPHH@?$EAOP?$AA@
CONST	SEGMENT
??_C@_03IENCOPHH@?$EAOP?$AA@ DB '@OP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02BONOMJKG@?$EAN?$AA@
CONST	SEGMENT
??_C@_02BONOMJKG@?$EAN?$AA@ DB '@N', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02PNCKBAGN@?$EAE?$AA@
CONST	SEGMENT
??_C@_02PNCKBAGN@?$EAE?$AA@ DB '@E', 00H		; `string'
CONST	ENDS
;	COMDAT ?Command@?1???0MusicFile@@QAE@PAVMMLfile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBG@Z@4QBUCommand_Info@@B
CONST	SEGMENT
?Command@?1???0MusicFile@@QAE@PAVMMLfile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBG@Z@4QBUCommand_Info@@B DD FLAT:??_C@_06CCOBMGDA@?$CDTitle?$AA@ ; `MusicFile::MusicFile'::`2'::Command
	DD	00H
	DD	FLAT:??_C@_06CFENMDAG@?$CDtitle?$AA@
	DD	00H
	DD	FLAT:??_C@_04PNPMGKHO@?$IL?H?$JG?$LM?$AA@
	DD	00H
	DD	FLAT:??_C@_09IGHFHPDK@?$CDComposer?$AA@
	DD	01H
	DD	FLAT:??_C@_09EIEPNJJ@?$CDcomposer?$AA@
	DD	01H
	DD	FLAT:??_C@_06MHLOKGDH@?$IN?l?$IL?H?$IO?R?$AA@
	DD	01H
	DD	FLAT:??_C@_04CEBCLGG@?$IN?l?$IL?H?$AA@
	DD	01H
	DD	FLAT:??_C@_0L@NBFPABFN@?$CDCopyright?$AA@
	DD	02H
	DD	FLAT:??_C@_0L@JOACACIN@?$CDcopyright?$AA@
	DD	02H
	DD	FLAT:??_C@_04LEKHBDFG@?$IN?l?$IO?R?$AA@
	DD	02H
	DD	FLAT:??_C@_08OIGPKLOH@?$JC?$JI?$IN?l?$IM?$KA?$IO?R?$AA@
	DD	02H
	DD	FLAT:??_C@_0L@KIKHLFNJ@?$CDOffsetPCM?$AA@
	DD	03H
	DD	FLAT:??_C@_0L@OHPKLGAJ@?$CDoffsetPCM?$AA@
	DD	03H
	DD	FLAT:??_C@_0L@OHPKLGAJ@?$CDoffsetPCM?$AA@
	DD	03H
	DD	FLAT:??_C@_05OEEHBABG@?$CDCode?$AA@
	DD	04H
	DD	FLAT:??_C@_05CFIGDPBC@?$CDcode?$AA@
	DD	04H
	DD	FLAT:??_C@_06EEPGCMOF@?$IDR?$IB?$FL?$IDh?$AA@
	DD	04H
	DD	FLAT:??_C@_09MLAHDPMF@?$CDExternal?$AA@
	DD	05H
	DD	FLAT:??_C@_09EJPGLNGG@?$CDexternal?$AA@
	DD	05H
	DD	FLAT:??_C@_05KKOMOGMN@?$CDBank?$AA@
	DD	06H
	DD	FLAT:??_C@_05GLCNMJMJ@?$CDbank?$AA@
	DD	06H
	DD	FLAT:??_C@_06PGPFCODL@?$IDo?$ID?$JD?$IDN?$AA@
	DD	06H
	DD	FLAT:??_C@_0M@FFNPFLJK@?$CDSegmentPCM?$AA@
	DD	08H
	DD	FLAT:??_C@_0M@NDEDNEEN@?$CDsegmentPCM?$AA@
	DD	08H
	DD	FLAT:??_C@_0M@KFJANFJL@?$CDSegmentSEQ?$AA@
	DD	07H
	DD	FLAT:??_C@_0M@CDAMFKEM@?$CDsegmentSEQ?$AA@
	DD	07H
	DD	FLAT:??_C@_08NBBMBDKH@?$CDSegment?$AA@
	DD	07H
	DD	FLAT:??_C@_08CIGKHBPB@?$CDsegment?$AA@
	DD	07H
	DD	FLAT:??_C@_06FGHFIFIC@?$CDLabel?$AA@
	DD	09H
	DD	FLAT:??_C@_06FBNJIALE@?$CDlabel?$AA@
	DD	09H
	DD	FLAT:??_C@_08JGMGPAEB@?$CDInclude?$AA@
	DD	0bH
	DD	FLAT:??_C@_08GPLAJCBH@?$CDinclude?$AA@
	DD	0bH
	DD	FLAT:??_C@_04LJOLKEOC@?$JD?G?$IC?$NO?$AA@
	DD	0bH
	DD	FLAT:??_C@_09MEAIMKNM@?$CDTimebase?$AA@
	DD	0cH
	DD	FLAT:??_C@_09EGPJEIHP@?$CDtimebase?$AA@
	DD	0cH
	DD	FLAT:??_C@_0P@IDBKDPML@?$CDOctaveReverse?$AA@
	DD	0dH
	DD	FLAT:??_C@_0P@EOHOEHBD@?$CDoctaveReverse?$AA@
	DD	0dH
	DD	FLAT:??_C@_09BABJNKIL@?$CDQReverse?$AA@
	DD	0eH
	DD	FLAT:??_C@_09JCOIFICI@?$CDqReverse?$AA@
	DD	0eH
	DD	FLAT:??_C@_04LOKDGHIN@?$CDBGM?$AA@
	DD	0fH
	DD	FLAT:??_C@_04LDFIKKPB@?$CDbgm?$AA@
	DD	0fH
	DD	FLAT:??_C@_06EHIHHNNG@?$IJ?$LJ?$IKy?$JA?$JE?$AA@
	DD	0fH
	DD	FLAT:??_C@_03IPMIALJK@?$CDSE?$AA@
	DD	010H
	DD	FLAT:??_C@_03CCABGJNI@?$CDse?$AA@
	DD	010H
	DD	FLAT:??_C@_08CMFGKBBL@?$IM?x?$IJ?J?$IJ?$LJ?$JA?$JE?$AA@
	DD	010H
	DD	FLAT:??_C@_0P@CLJDPPFJ@?$CDreleaseVolume?$AA@
	DD	011H
	DD	FLAT:??_C@_0P@OGPHIHIB@?$CDReleaseVolume?$AA@
	DD	011H
	DD	FLAT:??_C@_0M@DLKNPGKB@?$CDrepeatMode?$AA@
	DD	012H
	DD	FLAT:??_C@_0M@LNDBHJHG@?$CDRepeatMode?$AA@
	DD	012H
	DD	FLAT:??_C@_08KBIDLIGH@?$CDTieMode?$AA@
	DD	013H
	DD	FLAT:??_C@_08FIPFNKDB@?$CDtieMode?$AA@
	DD	013H
	DD	FLAT:??_C@_09PJMHIDNI@?$CDOffsetE?$EA?$AA@
	DD	014H
	DD	FLAT:??_C@_09HLDGABHL@?$CDoffsetE?$EA?$AA@
	DD	014H
	DD	FLAT:??_C@_09HANLBCKN@?$CDOffsetEv?$AA@
	DD	015H
	DD	FLAT:??_C@_09PCCKJAAO@?$CDoffsetEv?$AA@
	DD	015H
	DD	FLAT:??_C@_09NJONNJDH@?$CDOffsetEm?$AA@
	DD	017H
	DD	FLAT:??_C@_09FLBMFLJE@?$CDoffsetEm?$AA@
	DD	017H
	DD	FLAT:??_C@_09PCMAIKPE@?$CDOffsetEn?$AA@
	DD	016H
	DD	FLAT:??_C@_09HADBAIFH@?$CDoffsetEn?$AA@
	DD	016H
	DD	FLAT:??_C@_09KLINEFGN@?$CDPriority?$AA@
	DD	0aH
	DD	FLAT:??_C@_09CJHMMHMO@?$CDpriority?$AA@
	DD	0aH
	DD	FLAT:??_C@_05NPLBNLG@?$CDQMax?$AA@
	DD	018H
	DD	FLAT:??_C@_05KNMJLCII@?$CDQmax?$AA@
	DD	018H
	DD	FLAT:??_C@_05JMMKNIKF@?$CDRest?$AA@
	DD	019H
	DD	FLAT:??_C@_05FNALPHKB@?$CDrest?$AA@
	DD	019H
	DD	FLAT:??_C@_05MKPJOGCE@?$CDWait?$AA@
	DD	01aH
	DD	FLAT:??_C@_05LDIMJCA@?$CDwait?$AA@
	DD	01aH
	DD	FLAT:??_C@_04GIKIPLBI@DPCM?$AA@
	DD	01bH
	DD	FLAT:??_C@_04EPLGOGEO@FDSC?$AA@
	DD	01cH
	DD	FLAT:??_C@_04NBDFMLMA@FDSM?$AA@
	DD	01dH
	DD	FLAT:??_C@_04NFBGGAN@VRC7?$AA@
	DD	01eH
	DD	FLAT:??_C@_04ECAEINBM@N163?$AA@
	DD	01fH
	DD	FLAT:??_C@_08OMOPOOMD@Envelope?$AA@
	DD	020H
	DD	FLAT:??_C@_08GOBOGMGA@envelope?$AA@
	DD	020H
	DD	FLAT:??_C@_07LBMEHABG@Envelop?$AA@
	DD	020H
	DD	FLAT:??_C@_07EILCBCEA@envelop?$AA@
	DD	020H
	DD	FLAT:??_C@_0N@FMGOOFEB@?$IDG?$ID?$JD?$IDx?$ID?$IN?$IB?$FL?$IDv?$AA@
	DD	020H
	DD	FLAT:??_C@_0L@OKKLBHBB@?$IDr?$IDu?$ID?$IJ?$IB?$FL?$IDg?$AA@
	DD	021H
	DD	FLAT:??_C@_03CPCCDDB@Sub?$AA@
	DD	023H
	DD	FLAT:??_C@_03KCMAIMAP@sub?$AA@
	DD	023H
	DD	FLAT:??_C@_03NPKEBKFI@BGM?$AA@
	DD	024H
	DD	FLAT:??_C@_03NCFPNHCE@bgm?$AA@
	DD	024H
	DD	FLAT:??_C@_04PHAOIHPI@?$IJ?$LJ?$IKy?$AA@
	DD	024H
	DD	FLAT:??_C@_02ODEKANEE@SE?$AA@
	DD	025H
	DD	FLAT:??_C@_02EOIDGPAG@se?$AA@
	DD	025H
	DD	FLAT:??_C@_06KKABNCAM@?$IM?x?$IJ?J?$IJ?$LJ?$AA@
	DD	025H
	DD	FLAT:??_C@_05OFAJKLEL@Patch?$AA@
	DD	026H
	DD	FLAT:??_C@_01CKDDGHAB@D?$AA@
	DD	01bH
	DD	FLAT:??_C@_02KPPNMLFJ@FC?$AA@
	DD	01cH
	DD	FLAT:??_C@_02DBHOOGNH@FM?$AA@
	DD	01dH
	DD	FLAT:??_C@_01MJMHLOMK@O?$AA@
	DD	01eH
	DD	FLAT:??_C@_01FCMHBHNC@V?$AA@
	DD	01eH
	DD	FLAT:??_C@_01NANMIPIL@N?$AA@
	DD	01fH
	DD	FLAT:??_C@_01DDCIFGEA@E?$AA@
	DD	020H
	DD	FLAT:??_C@_01CPLAODJH@S?$AA@
	DD	023H
	DD	FLAT:??_C@_01EJNLAFE@P?$AA@
	DD	026H
	DD	FLAT:??_C@_01EPMOAMKG@$?$AA@
	DD	022H
	DD	FLAT:??_C@_05BABAKHMK@?$EADPCM?$AA@
	DD	01bH
	DD	FLAT:??_C@_03HEGPLIOE@?$EAFM?$AA@
	DD	01cH
	DD	FLAT:??_C@_03MIBHKNNO@?$EAMW?$AA@
	DD	01dH
	DD	FLAT:??_C@_03IENCOPHH@?$EAOP?$AA@
	DD	01eH
	DD	FLAT:??_C@_02BONOMJKG@?$EAN?$AA@
	DD	01fH
	DD	FLAT:??_C@_02PNCKBAGN@?$EAE?$AA@
	DD	020H
	DD	FLAT:??_C@_02BADABIFP@?$IB?$EA?$AA@
	DD	027H
CONST	ENDS
;	COMDAT ??_C@_1EM@BEGGFCCM@?$AA?$CD?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe0?$LD0?$NO0?s0?I0o0?$AB@
CONST	SEGMENT
??_C@_1EM@BEGGFCCM@?$AA?$CD?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe0?$LD0?$NO0?s0?I0o0?$AB@ DB '#'
	DB	00H, 'R', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 's', 00H
	DB	'e', 00H, 'V', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'e'
	DB	00H, 0b3H, '0', 0deH, '0', 0f3H, '0', 0c9H, '0o0', 01H, '00', 00H
	DB	'^', 0ffH, '1', 00H, '5', 00H, 'n0', 0c4H, '{', 0f2H, 'Vg0', 07H
	DB	'c', 09aH, '[W0f0O0`0U0D0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@MOLGAENM@?$AA?$CD?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AAM?$AAo?$AAd?$AAe0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA2@
CONST	SEGMENT
??_C@_1EE@MOLGAENM@?$AA?$CD?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AAM?$AAo?$AAd?$AAe0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA2@ DB '#'
	DB	00H, 'R', 00H, 'e', 00H, 'p', 00H, 'e', 00H, 'a', 00H, 't', 00H
	DB	'M', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 0b3H, '0', 0deH, '0', 0f3H
	DB	'0', 0c9H, '0o0', 01H, '00', 00H, '^', 0ffH, '2', 00H, 'n0', 0c4H
	DB	'{', 0f2H, 'Vg0', 07H, 'c', 09aH, '[W0f0O0`0U0D0', 02H, '0', 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@PDNFGBGE@?$AA?$CD?$AAT?$AAi?$AAe?$AAM?$AAo?$AAd?$AAe0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA10n?$HL?DV?r@
CONST	SEGMENT
??_C@_1DO@PDNFGBGE@?$AA?$CD?$AAT?$AAi?$AAe?$AAM?$AAo?$AAd?$AAe0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA10n?$HL?DV?r@ DB '#'
	DB	00H, 'T', 00H, 'i', 00H, 'e', 00H, 'M', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, 0b3H, '0', 0deH, '0', 0f3H, '0', 0c9H, '0o0', 01H, '0'
	DB	'0', 00H, '^', 0ffH, '1', 00H, 'n0', 0c4H, '{', 0f2H, 'Vg0', 07H
	DB	'c', 09aH, '[W0f0O0`0U0D0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@EIGBEKHF@?$AA?$CD?$AAp?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA30n?$HL?D@
CONST	SEGMENT
??_C@_1EA@EIGBEKHF@?$AA?$CD?$AAp?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA30n?$HL?D@ DB '#'
	DB	00H, 'p', 00H, 'r', 00H, 'i', 00H, 'o', 00H, 'r', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, 0b3H, '0', 0deH, '0', 0f3H, '0', 0c9H, '0o'
	DB	'0', 01H, '00', 00H, '^', 0ffH, '3', 00H, 'n0', 0c4H, '{', 0f2H
	DB	'Vg0', 07H, 'c', 09aH, '[W0f0O0`0U0D0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@LBEELOIE@?$AA?$CD?$AAR?$AAe?$AAs?$AAt0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA30n?$HL?DV?r0gc?$AH?$FL?$JK@
CONST	SEGMENT
??_C@_1DI@LBEELOIE@?$AA?$CD?$AAR?$AAe?$AAs?$AAt0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA30n?$HL?DV?r0gc?$AH?$FL?$JK@ DB '#'
	DB	00H, 'R', 00H, 'e', 00H, 's', 00H, 't', 00H, 0b3H, '0', 0deH, '0'
	DB	0f3H, '0', 0c9H, '0o0', 01H, '00', 00H, '^', 0ffH, '3', 00H, 'n'
	DB	'0', 0c4H, '{', 0f2H, 'Vg0', 07H, 'c', 09aH, '[W0f0O0`0U0D0', 02H
	DB	'0', 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@MNKEBKGP@?$AA?$CD?$AAW?$AAa?$AAi?$AAt0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA30n?$HL?DV?r0gc?$AH?$FL?$JK@
CONST	SEGMENT
??_C@_1DI@MNKEBKGP@?$AA?$CD?$AAW?$AAa?$AAi?$AAt0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA30n?$HL?DV?r0gc?$AH?$FL?$JK@ DB '#'
	DB	00H, 'W', 00H, 'a', 00H, 'i', 00H, 't', 00H, 0b3H, '0', 0deH, '0'
	DB	0f3H, '0', 0c9H, '0o0', 01H, '00', 00H, '^', 0ffH, '3', 00H, 'n'
	DB	'0', 0c4H, '{', 0f2H, 'Vg0', 07H, 'c', 09aH, '[W0f0O0`0U0D0', 02H
	DB	'0', 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@JGHEFCII@?$AAD?$AAP?$AAC?$AAM0?V0?m0?C0?$KP0o?$PP?$BB0d0?$HO0g0g0Y0?$AC?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@JGHEFCII@?$AAD?$AAP?$AAC?$AAM0?V0?m0?C0?$KP0o?$PP?$BB0d0?$HO0g0g0Y0?$AC?$AA?$AA@ DB 'D'
	DB	00H, 'P', 00H, 'C', 00H, 'M', 00H, 0d6H, '0', 0edH, '0', 0c3H, '0'
	DB	0afH, '0o0', 011H, 0ffH, 'd0~0g0g0Y0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@EIOCHGHI@?$AA?$DN?$AA?$DN?$AA?$DN?$AA?$DN?$AA?5?$AA?$FL?$AA?5?$AAD?$AAP?$AAC?$AAM?$AAi?$AAn?$AAf?$AAo?$AA?5?$AA?$FN?$AA?$DN?$AA?$DN?$AA?$DN@
CONST	SEGMENT
??_C@_1CM@EIOCHGHI@?$AA?$DN?$AA?$DN?$AA?$DN?$AA?$DN?$AA?5?$AA?$FL?$AA?5?$AAD?$AAP?$AAC?$AAM?$AAi?$AAn?$AAf?$AAo?$AA?5?$AA?$FN?$AA?$DN?$AA?$DN?$AA?$DN@ DB '='
	DB	00H, '=', 00H, '=', 00H, '=', 00H, ' ', 00H, '[', 00H, ' ', 00H
	DB	'D', 00H, 'P', 00H, 'C', 00H, 'M', 00H, 'i', 00H, 'n', 00H, 'f'
	DB	00H, 'o', 00H, ' ', 00H, ']', 00H, '=', 00H, '=', 00H, '=', 00H
	DB	'=', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@HNHPBHDM@?$AAF?$AAD?$AAS?$AAC?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM@
CONST	SEGMENT
??_C@_1DC@HNHPBHDM@?$AAF?$AAD?$AAS?$AAC?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM@ DB 'F'
	DB	00H, 'D', 00H, 'S', 00H, 'C', 00H, '(', 00H, ')', 00H, 0d6H, '0'
	DB	0edH, '0', 0c3H, '0', 0afH, '0g0', 0cH, 'TX0ju', 0f7H, 'SL0', 07H
	DB	'c', 09aH, '[U0', 08cH, '0~0W0_0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19CBLNKBPD@?$AAF?$AAD?$AAS?$AAC?$AA?$AA@
CONST	SEGMENT
??_C@_19CBLNKBPD@?$AAF?$AAD?$AAS?$AAC?$AA?$AA@ DB 'F', 00H, 'D', 00H, 'S', 00H
	DB	'C', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@LLPEDCB@?$AAF?$AAD?$AAS?$AAM?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM@
CONST	SEGMENT
??_C@_1DC@LLPEDCB@?$AAF?$AAD?$AAS?$AAM?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM@ DB 'F'
	DB	00H, 'D', 00H, 'S', 00H, 'M', 00H, '(', 00H, ')', 00H, 0d6H, '0'
	DB	0edH, '0', 0c3H, '0', 0afH, '0g0', 0cH, 'TX0ju', 0f7H, 'SL0', 07H
	DB	'c', 09aH, '[U0', 08cH, '0~0W0_0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19MBGCNGMA@?$AAF?$AAD?$AAS?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_19MBGCNGMA@?$AAF?$AAD?$AAS?$AAM?$AA?$AA@ DB 'F', 00H, 'D', 00H, 'S', 00H
	DB	'M', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@IKBGODDN@?$AAV?$AAR?$AAC?$AA7?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM@
CONST	SEGMENT
??_C@_1DC@IKBGODDN@?$AAV?$AAR?$AAC?$AA7?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM@ DB 'V'
	DB	00H, 'R', 00H, 'C', 00H, '7', 00H, '(', 00H, ')', 00H, 0d6H, '0'
	DB	0edH, '0', 0c3H, '0', 0afH, '0g0', 0cH, 'TX0ju', 0f7H, 'SL0', 07H
	DB	'c', 09aH, '[U0', 08cH, '0~0W0_0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19FLEMCNOH@?$AAV?$AAR?$AAC?$AA7?$AA?$AA@
CONST	SEGMENT
??_C@_19FLEMCNOH@?$AAV?$AAR?$AAC?$AA7?$AA?$AA@ DB 'V', 00H, 'R', 00H, 'C', 00H
	DB	'7', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@BMHBEBNP@?$AAN?$AA1?$AA6?$AA3?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM@
CONST	SEGMENT
??_C@_1DC@BMHBEBNP@?$AAN?$AA1?$AA6?$AA3?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM@ DB 'N'
	DB	00H, '1', 00H, '6', 00H, '3', 00H, '(', 00H, ')', 00H, 0d6H, '0'
	DB	0edH, '0', 0c3H, '0', 0afH, '0g0', 0cH, 'TX0ju', 0f7H, 'SL0', 07H
	DB	'c', 09aH, '[U0', 08cH, '0~0W0_0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19OFNMEAIG@?$AAN?$AA1?$AA6?$AA3?$AA?$AA@
CONST	SEGMENT
??_C@_19OFNMEAIG@?$AAN?$AA1?$AA6?$AA3?$AA?$AA@ DB 'N', 00H, '1', 00H, '6', 00H
	DB	'3', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@BHJCAEG@?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0L@
CONST	SEGMENT
??_C@_1DK@BHJCAEG@?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0L@ DB 'E'
	DB	00H, 'n', 00H, 'v', 00H, 'e', 00H, 'l', 00H, 'o', 00H, 'p', 00H
	DB	'e', 00H, '(', 00H, ')', 00H, 0d6H, '0', 0edH, '0', 0c3H, '0', 0afH
	DB	'0g0', 0cH, 'TX0ju', 0f7H, 'SL0', 07H, 'c', 09aH, '[U0', 08cH, '0'
	DB	'~0W0_0', 02H, '0', 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@LIMGOFOL@?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@LIMGOFOL@?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@ DB 'E'
	DB	00H, 'n', 00H, 'v', 00H, 'e', 00H, 'l', 00H, 'o', 00H, 'p', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@FKOKODHI@0?S0?V0?i0?$PM0?H?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U@
CONST	SEGMENT
??_C@_1DE@FKOKODHI@0?S0?V0?i0?$PM0?H?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U@ DB 0d3H
	DB	'0', 0d6H, '0', 0e9H, '0', 0fcH, '0', 0c8H, '0(', 00H, ')', 00H
	DB	0d6H, '0', 0edH, '0', 0c3H, '0', 0afH, '0g0', 0cH, 'TX0ju', 0f7H
	DB	'SL0', 07H, 'c', 09aH, '[U0', 08cH, '0~0W0_0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@BGBJDANG@?$AAS?$AAu?$AAb?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM0?$HO@
CONST	SEGMENT
??_C@_1DA@BGBJDANG@?$AAS?$AAu?$AAb?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM0?$HO@ DB 'S'
	DB	00H, 'u', 00H, 'b', 00H, '(', 00H, ')', 00H, 0d6H, '0', 0edH, '0'
	DB	0c3H, '0', 0afH, '0g0', 0cH, 'TX0ju', 0f7H, 'SL0', 07H, 'c', 09aH
	DB	'[U0', 08cH, '0~0W0_0', 02H, '0', 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_17ILLEHHEJ@?$AAS?$AAu?$AAb?$AA?$AA@
CONST	SEGMENT
??_C@_17ILLEHHEJ@?$AAS?$AAu?$AAb?$AA?$AA@ DB 'S', 00H, 'u', 00H, 'b', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@MIOILPIL@?$AAB?$AAG?$AAM?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM0?$HO@
CONST	SEGMENT
??_C@_1DA@MIOILPIL@?$AAB?$AAG?$AAM?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM0?$HO@ DB 'B'
	DB	00H, 'G', 00H, 'M', 00H, '(', 00H, ')', 00H, 0d6H, '0', 0edH, '0'
	DB	0c3H, '0', 0afH, '0g0', 0cH, 'TX0ju', 0f7H, 'SL0', 07H, 'c', 09aH
	DB	'[U0', 08cH, '0~0W0_0', 02H, '0', 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1FI@OKDKOODI@?$AAB?$AAG?$AAM?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gc?$AH?$FL?$JK0g0M0?$IL?$HL?DV?r0?$JC?$IN?$IF0H@
CONST	SEGMENT
??_C@_1FI@OKDKOODI@?$AAB?$AAG?$AAM?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gc?$AH?$FL?$JK0g0M0?$IL?$HL?DV?r0?$JC?$IN?$IF0H@ DB 'B'
	DB	00H, 'G', 00H, 'M', 00H, '(', 00H, ')', 00H, 0d6H, '0', 0edH, '0'
	DB	0c3H, '0', 0afH, '0g0', 07H, 'c', 09aH, '[g0M0', 08bH, '0', 0c4H
	DB	'{', 0f2H, 'V', 092H, '0', 085H, 08dH, 'H0f0D0~0Y0', 02H, '0', 0aH
	DB	00H, '#', 00H, 'B', 00H, 'G', 00H, 'M', 00H, 'n0pe$P', 092H, '0'
	DB	0baH, 'x', 08dH, 08aH, 'W0f0O0`0U0D0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17IKEGFPDC@?$AAB?$AAG?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_17IKEGFPDC@?$AAB?$AAG?$AAM?$AA?$AA@ DB 'B', 00H, 'G', 00H, 'M', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@BBMENDGM@?$AAS?$AAE?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM0?$HO0W@
CONST	SEGMENT
??_C@_1CO@BBMENDGM@?$AAS?$AAE?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM0?$HO0W@ DB 'S'
	DB	00H, 'E', 00H, '(', 00H, ')', 00H, 0d6H, '0', 0edH, '0', 0c3H, '0'
	DB	0afH, '0g0', 0cH, 'TX0ju', 0f7H, 'SL0', 07H, 'c', 09aH, '[U0', 08cH
	DB	'0~0W0_0', 02H, '0', 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1FE@JACJBOFE@?$AAS?$AAE?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gc?$AH?$FL?$JK0g0M0?$IL?$HL?DV?r0?$JC?$IN?$IF0H0f@
CONST	SEGMENT
??_C@_1FE@JACJBOFE@?$AAS?$AAE?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gc?$AH?$FL?$JK0g0M0?$IL?$HL?DV?r0?$JC?$IN?$IF0H0f@ DB 'S'
	DB	00H, 'E', 00H, '(', 00H, ')', 00H, 0d6H, '0', 0edH, '0', 0c3H, '0'
	DB	0afH, '0g0', 07H, 'c', 09aH, '[g0M0', 08bH, '0', 0c4H, '{', 0f2H
	DB	'V', 092H, '0', 085H, 08dH, 'H0f0D0~0Y0', 02H, '0', 0aH, 00H, '#'
	DB	00H, 'S', 00H, 'E', 00H, 'n0pe$P', 092H, '0', 0baH, 'x', 08dH, 08aH
	DB	'W0f0O0`0U0D0', 02H, '0', 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_15GIONIMAK@?$AAS?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_15GIONIMAK@?$AAS?$AAE?$AA?$AA@ DB 'S', 00H, 'E', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@LFJBLHAK@?$AAB?$AAG?$AAM0h?$AAS?$AAE0nep0LT?$AI?$IK?$AI0g?$AA2?$AA5?$AA50?$JC?$IN?$IK0H0?$HO0W@
CONST	SEGMENT
??_C@_1CO@LFJBLHAK@?$AAB?$AAG?$AAM0h?$AAS?$AAE0nep0LT?$AI?$IK?$AI0g?$AA2?$AA5?$AA50?$JC?$IN?$IK0H0?$HO0W@ DB 'B'
	DB	00H, 'G', 00H, 'M', 00H, 'h0S', 00H, 'E', 00H, 'n0peL0', 08H, 'T'
	DB	08H, 08aH, 'g02', 00H, '5', 00H, '5', 00H, 092H, '0', 08aH, 08dH
	DB	'H0~0W0_0', 02H, '0', 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@PLCKFEBA@?$AAB?$AAG?$AAM0?G0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@PLCKFEBA@?$AAB?$AAG?$AAM0?G0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@ DB 'B'
	DB	00H, 'G', 00H, 'M', 00H, 0c7H, '0', 0fcH, '0', 0bfH, '0L0', 0b3H
	DB	08dH, 08aH, '0~0[0', 093H, '0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@BGKOPALL@?$AAS?$AAE?$AA?50?G0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@BGKOPALL@?$AAS?$AAE?$AA?50?G0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@ DB 'S'
	DB	00H, 'E', 00H, ' ', 00H, 0c7H, '0', 0fcH, '0', 0bfH, '0L0', 0b3H
	DB	08dH, 08aH, '0~0[0', 093H, '0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06EEKMEKPC@?$CJ?5?9?9?9?9?$AA@
CONST	SEGMENT
??_C@_06EEKMEKPC@?$CJ?5?9?9?9?9?$AA@ DB ') ----', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BPDCILGE@?9?9?9?9?5BGM?$CI?$AA@
CONST	SEGMENT
??_C@_09BPDCILGE@?9?9?9?9?5BGM?$CI?$AA@ DB '---- BGM(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08COBGNJFP@?9?9?9?9?5SE?$CI?$AA@
CONST	SEGMENT
??_C@_08COBGNJFP@?9?9?9?9?5SE?$CI?$AA@ DB '---- SE(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FC@OJNKDJBH@?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9@
CONST	SEGMENT
??_C@_1FC@OJNKDJBH@?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9@ DB '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JFAJBGGI@?$AA?$CK?$AAN?$AAS?$AAF?$AA?5?$AAb?$AAu?$AAi?$AAl?$AAd?$AA?5?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@JFAJBGGI@?$AA?$CK?$AAN?$AAS?$AAF?$AA?5?$AAb?$AAu?$AAi?$AAl?$AAd?$AA?5?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$AA@ DB '*'
	DB	00H, 'N', 00H, 'S', 00H, 'F', 00H, ' ', 00H, 'b', 00H, 'u', 00H
	DB	'i', 00H, 'l', 00H, 'd', 00H, ' ', 00H, 'p', 00H, 'r', 00H, 'o'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1IA@DNNIGADP@c?$AH?$FL?$JK0n?$AA?4?$AAb?$AAi?$AAn0?U0?$KB0?$KE0?k0o0?$AB?$CC?$LP?$AAP?$AAC?$AAM0n0?P0?s@
CONST	SEGMENT
??_C@_1IA@DNNIGADP@c?$AH?$FL?$JK0n?$AA?4?$AAb?$AAi?$AAn0?U0?$KB0?$KE0?k0o0?$AB?$CC?$LP?$AAP?$AAC?$AAM0n0?P0?s@ DB 07H
	DB	'c', 09aH, '[n0.', 00H, 'b', 00H, 'i', 00H, 'n', 00H, 0d5H, '0'
	DB	0a1H, '0', 0a4H, '0', 0ebH, '0o0', 01H, '0', 0bfH, '"P', 00H, 'C'
	DB	00H, 'M', 00H, 'n0', 0d0H, '0', 0f3H, '0', 0afH, '0k0', 0feH, '['
	DB	0dcH, '_W0f0D0~0[0', 093H, '0', 02H, '0', 0aH, 00H, 0bfH, '"P', 00H
	DB	'C', 00H, 'M', 00H, 'n0', 0d0H, '0', 0f3H, '0', 0afH, '0k0', 0feH
	DB	'[', 0dcH, '_W0_0.', 00H, 'b', 00H, 'i', 00H, 'n', 00H, 0d5H, '0'
	DB	0a1H, '0', 0a4H, '0', 0ebH, '0', 092H, '0', 07H, 'c', 09aH, '['
	DB	'W0f0O0`0U0D0', 02H, '0', 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@NLLFDPGO@?$AA?$FL?$AAC?$AAO?$AAD?$AAE?$AA?5?$AA?$CG?$AA?5?$AAM?$AAU?$AAS?$AAI?$AAC?$AA?$FN?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@NLLFDPGO@?$AA?$FL?$AAC?$AAO?$AAD?$AAE?$AA?5?$AA?$CG?$AA?5?$AAM?$AAU?$AAS?$AAI?$AAC?$AA?$FN?$AA?$AA@ DB '['
	DB	00H, 'C', 00H, 'O', 00H, 'D', 00H, 'E', 00H, ' ', 00H, '&', 00H
	DB	' ', 00H, 'M', 00H, 'U', 00H, 'S', 00H, 'I', 00H, 'C', 00H, ']'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@GFIKIAF@?$AA?5?$AA?5?$AAB?$AAa?$AAn?$AAk?$AA?5?$AA?$DN?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@GFIKIAF@?$AA?5?$AA?5?$AAB?$AAa?$AAn?$AAk?$AA?5?$AA?$DN?$AA?5?$AA?$AA@ DB ' '
	DB	00H, ' ', 00H, 'B', 00H, 'a', 00H, 'n', 00H, 'k', 00H, ' ', 00H
	DB	'=', 00H, ' ', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@PDAIGOGG@?$AA?5?$AA?$FL?$AAB?$AAy?$AAt?$AAe?$AA?$FN?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@PDAIGOGG@?$AA?5?$AA?$FL?$AAB?$AAy?$AAt?$AAe?$AA?$FN?$AA?$AA@ DB ' '
	DB	00H, '[', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, ']', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@CFCHLKIG@?$AA?5?$AA?$FL?$AAB?$AAy?$AAt?$AAe?$AA?$FN?$AA?5?$AA?1?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@CFCHLKIG@?$AA?5?$AA?$FL?$AAB?$AAy?$AAt?$AAe?$AA?$FN?$AA?5?$AA?1?$AA?5?$AA?$AA@ DB ' '
	DB	00H, '[', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, ']', 00H
	DB	' ', 00H, '/', 00H, ' ', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@GMJJPPAM@?$AA?5?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@GMJJPPAM@?$AA?5?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?5?$AA?$AA@ DB ' '
	DB	00H, ' ', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H
	DB	'=', 00H, ' ', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@EMBJGJOO@0?$LD0?$PM0?I0?$PL0?$LH0?$PM0?$LB0?s0?$LJ0n0?$LF0?$KE0?$LK0L?$IK1?$FL?$LJP$0?$JC?$IN?$IK0H@
CONST	SEGMENT
??_C@_1DC@EMBJGJOO@0?$LD0?$PM0?I0?$PL0?$LH0?$PM0?$LB0?s0?$LJ0n0?$LF0?$KE0?$LK0L?$IK1?$FL?$LJP$0?$JC?$IN?$IK0H@ DB 0b3H
	DB	'0', 0fcH, '0', 0c9H, '0', 0fbH, '0', 0b7H, '0', 0fcH, '0', 0b1H
	DB	'0', 0f3H, '0', 0b9H, '0n0', 0b5H, '0', 0a4H, '0', 0baH, '0L01'
	DB	08aH, 0b9H, '[$P', 092H, '0', 08aH, 08dH, 'H0~0W0_0', 02H, '0', 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1GG@KLHECIMD@c?$AH?$FL?$JK0n?$AA?4?$AAb?$AAi?$AAn0?U0?$KB0?$KE0?k0o0?$AB?$CC?$LP?$AAP?$AAC?$AAM0n0?P0?s@
CONST	SEGMENT
??_C@_1GG@KLHECIMD@c?$AH?$FL?$JK0n?$AA?4?$AAb?$AAi?$AAn0?U0?$KB0?$KE0?k0o0?$AB?$CC?$LP?$AAP?$AAC?$AAM0n0?P0?s@ DB 07H
	DB	'c', 09aH, '[n0.', 00H, 'b', 00H, 'i', 00H, 'n', 00H, 0d5H, '0'
	DB	0a1H, '0', 0a4H, '0', 0ebH, '0o0', 01H, '0', 0bfH, '"P', 00H, 'C'
	DB	00H, 'M', 00H, 'n0', 0d0H, '0', 0f3H, '0', 0afH, '0k0', 0feH, '['
	DB	0dcH, '_W0f0D0~0Y0', 02H, '0', 0aH, 00H, '#', 00H, 'B', 00H, 'a'
	DB	00H, 'n', 00H, 'k', 00H, 0b3H, '0', 0deH, '0', 0f3H, '0', 0c9H
	DB	'0', 092H, '0', 07H, 'c', 09aH, '[W0f0O0`0U0D0', 02H, '0', 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@KFBOMPNC@?$AA?$FL?$AAC?$AAO?$AAD?$AAE?$AA?$FN?$AA?$AA@
CONST	SEGMENT
??_C@_1O@KFBOMPNC@?$AA?$FL?$AAC?$AAO?$AAD?$AAE?$AA?$FN?$AA?$AA@ DB '[', 00H
	DB	'C', 00H, 'O', 00H, 'D', 00H, 'E', 00H, ']', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@EHOEIOII@?$AA?5?$AA?5?$AAB?$AAa?$AAn?$AAk?$AA?5?$AA?$DN?$AA?5?$AA3?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@EHOEIOII@?$AA?5?$AA?5?$AAB?$AAa?$AAn?$AAk?$AA?5?$AA?$DN?$AA?5?$AA3?$AA?$AA@ DB ' '
	DB	00H, ' ', 00H, 'B', 00H, 'a', 00H, 'n', 00H, 'k', 00H, ' ', 00H
	DB	'=', 00H, ' ', 00H, '3', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@KKKMFICH@?$AA?5?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?5?$AA1?$AA2?$AA2?$AA8?$AA8?$AA?5?$AA?$FL?$AAB?$AAy?$AAt?$AAe@
CONST	SEGMENT
??_C@_1CM@KKKMFICH@?$AA?5?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?5?$AA1?$AA2?$AA2?$AA8?$AA8?$AA?5?$AA?$FL?$AAB?$AAy?$AAt?$AAe@ DB ' '
	DB	00H, ' ', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H
	DB	'=', 00H, ' ', 00H, '1', 00H, '2', 00H, '2', 00H, '8', 00H, '8'
	DB	00H, ' ', 00H, '[', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H
	DB	']', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@HAHLGPF@?$AA?$FL?$AAM?$AAU?$AAS?$AAI?$AAC?$AA?$FN?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@HAHLGPF@?$AA?$FL?$AAM?$AAU?$AAS?$AAI?$AAC?$AA?$FN?$AA?$AA@ DB '['
	DB	00H, 'M', 00H, 'U', 00H, 'S', 00H, 'I', 00H, 'C', 00H, ']', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@OBLFHHEM@?$AA?$FL?$AAD?$AAP?$AAC?$AAM?$AA?$FN?$AA?$AA@
CONST	SEGMENT
??_C@_1O@OBLFHHEM@?$AA?$FL?$AAD?$AAP?$AAC?$AAM?$AA?$FN?$AA?$AA@ DB '[', 00H
	DB	'D', 00H, 'P', 00H, 'C', 00H, 'M', 00H, ']', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@GAIMJLAM@?$CC?$LP?$AAP?$AAC?$AAM0n0?$LF0?$KE0?$LK0L?$IK1?$FL?$LJP$0?$JC?$IN?$IK0H0?$HO0W0_0?$AC?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@GAIMJLAM@?$CC?$LP?$AAP?$AAC?$AAM0n0?$LF0?$KE0?$LK0L?$IK1?$FL?$LJP$0?$JC?$IN?$IK0H0?$HO0W0_0?$AC?$AA?$AA@ DB 0bfH
	DB	'"P', 00H, 'C', 00H, 'M', 00H, 'n0', 0b5H, '0', 0a4H, '0', 0baH
	DB	'0L01', 08aH, 0b9H, '[$P', 092H, '0', 08aH, 08dH, 'H0~0W0_0', 02H
	DB	'0', 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@LIOGKFKL@0?P0?s0?$KPep0nT?$AI?$IK?$AI0L?$AA2?$AA5?$AA50?$JC?$IN?$IK0H0?$HO0W0_0?$AC?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@LIOGKFKL@0?P0?s0?$KPep0nT?$AI?$IK?$AI0L?$AA2?$AA5?$AA50?$JC?$IN?$IK0H0?$HO0W0_0?$AC?$AA?$AA@ DB 0d0H
	DB	'0', 0f3H, '0', 0afH, '0pen0', 08H, 'T', 08H, 08aH, 'L02', 00H
	DB	'5', 00H, '5', 00H, 092H, '0', 08aH, 08dH, 'H0~0W0_0', 02H, '0'
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0NF@IGNECHBF@?$DL?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
CONST	SEGMENT
??_C@_0NF@IGNECHBF@?$DL?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ DB ';'
	DB	'============================================================='
	DB	'==', 0aH, ';', 09H, 09H, 'Music file for NES Sound Driver & L'
	DB	'ibrary', 0aH, ';', 09H, 09H, 09H, 'for assembly language (ca6'
	DB	'5.exe)', 0aH, ';============================================='
	DB	'==================', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HLHGGEDN@?7?4export?7?7?$AA@
CONST	SEGMENT
??_C@_0L@HLHGGEDN@?7?4export?7?7?$AA@ DB 09H, '.export', 09H, 09H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@KGHBAMLI@?$AA?$FL?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?$FN?$AA?5?$AA?3?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@KGHBAMLI@?$AA?$FL?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?$FN?$AA?5?$AA?3?$AA?5?$AA?$AA@ DB '['
	DB	00H, ' ', 00H, 'E', 00H, 'R', 00H, 'R', 00H, 'O', 00H, 'R', 00H
	DB	' ', 00H, ']', 00H, ' ', 00H, ':', 00H, ' ', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@BNOPLHAN@?$AA?$FL?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AA?$FN?$AA?5?$AA?3?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@BNOPLHAN@?$AA?$FL?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AA?$FN?$AA?5?$AA?3?$AA?5?$AA?$AA@ DB '['
	DB	00H, 'W', 00H, 'A', 00H, 'R', 00H, 'N', 00H, 'I', 00H, 'N', 00H
	DB	'G', 00H, ']', 00H, ' ', 00H, ':', 00H, ' ', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7MusicFile@@6BMusicItem@@@
CONST	SEGMENT
??_7MusicFile@@6BMusicItem@@@ DD FLAT:?getCode@MusicItem@@UAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; MusicFile::`vftable'
	DD	FLAT:?setCode@MusicItem@@UAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getAsm@MusicItem@@UAEXPAVMusicFile@@@Z
CONST	ENDS
;	COMDAT ??_7MusicFile@@6BFileOutput@@@
CONST	SEGMENT
??_7MusicFile@@6BFileOutput@@@ DD FLAT:??_EMusicFile@@UAEPAXI@Z ; MusicFile::`vftable'
CONST	ENDS
;	COMDAT ??_8MusicFile@@7B@
CONST	SEGMENT
??_8MusicFile@@7B@ DD 00H				; MusicFile::`vbtable'
	DD	01b4H
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_Ectype_base@std@@UAEPAXI@Z ; std::ctype_base::`vftable'
CONST	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_E?$ctype@D@std@@MAEPAXI@Z ; std::ctype<char>::`vftable'
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
; Function compile flags: /Ogsy
; File f:\nes\nsdl\src\nsc\musicitem.h
;	COMDAT ?chkUse@MusicItem@@QAE_NXZ
_TEXT	SEGMENT
?chkUse@MusicItem@@QAE_NXZ PROC NEAR			; MusicItem::chkUse, COMDAT
; _this$ = eax

; 53   : 				bool	chkUse(void){return(f_Optimize);};	//KtO

  00000	8a 40 38	 mov	 al, BYTE PTR [eax+56]
  00003	c3		 ret	 0
?chkUse@MusicItem@@QAE_NXZ ENDP				; MusicItem::chkUse
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC NEAR	; std::char_traits<char>::to_char_type, COMDAT
; __Meta$ = eax

; 380  : 		return ((_Elem)_Meta);

  00000	8a 00		 mov	 al, BYTE PTR [eax]

; 381  : 		}

  00002	c3		 ret	 0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
_TEXT	ENDS
;	COMDAT ?is@?$ctype@D@std@@QBE_NFD@Z
_TEXT	SEGMENT
__Maskval$ = 8						; size = 2
?is@?$ctype@D@std@@QBE_NFD@Z PROC NEAR			; std::ctype<char>::is, COMDAT
; _this$ = ecx
; __Ch$ = eax

; 1145 : 		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);

  00000	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00003	0f b6 c0	 movzx	 eax, al
  00006	0f bf 04 41	 movsx	 eax, WORD PTR [ecx+eax*2]
  0000a	23 44 24 04	 and	 eax, DWORD PTR __Maskval$[esp-4]
  0000e	66 f7 d8	 neg	 ax
  00011	1b c0		 sbb	 eax, eax
  00013	f7 d8		 neg	 eax

; 1146 : 		}

  00015	c2 04 00	 ret	 4
?is@?$ctype@D@std@@QBE_NFD@Z ENDP			; std::ctype<char>::is
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\streambuf
_TEXT	ENDS
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc, COMDAT
; _this$ = ecx

; 219  : 		--*_IGcount;

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	ff 08		 dec	 DWORD PTR [eax]

; 220  : 		return ((*_IGnext)++);

  00005	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00008	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0000d	89 11		 mov	 DWORD PTR [ecx], edx

; 221  : 		}

  0000f	c3		 ret	 0
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::gptr, COMDAT
; _this$ = eax

; 175  : 		return (*_IGnext);

  00000	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 176  : 		}

  00005	c3		 ret	 0
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gptr
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::egptr, COMDAT
; _this$ = eax

; 190  : 		return (*_IGnext + *_IGcount);

  00000	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00003	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	03 02		 add	 eax, DWORD PTR [edx]

; 191  : 		}

  0000a	c3		 ret	 0
?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::egptr
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
_TEXT	ENDS
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$ctype@D@std@@IAEXXZ PROC NEAR			; std::ctype<char>::_Tidy, COMDAT
; _this$ = ecx

; 1259 : 		if (0 < _Ctype._Delfl)

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00003	85 c0		 test	 eax, eax
  00005	7e 0a		 jle	 SHORT $L38552

; 1260 : 			free((void *)_Ctype._Table);

  00007	ff 71 10	 push	 DWORD PTR [ecx+16]
  0000a	e8 00 00 00 00	 call	 _free

; 1262 : 			delete[] (void *)_Ctype._Table;

  0000f	59		 pop	 ecx

; 1263 : 		}

  00010	c3		 ret	 0
$L38552:

; 1261 : 		else if (_Ctype._Delfl < 0)

  00011	7d 09		 jge	 SHORT $L5887

; 1262 : 			delete[] (void *)_Ctype._Table;

  00013	ff 71 10	 push	 DWORD PTR [ecx+16]
  00016	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0001b	59		 pop	 ecx
$L5887:

; 1263 : 		}

  0001c	c3		 ret	 0
?_Tidy@?$ctype@D@std@@IAEXXZ ENDP			; std::ctype<char>::_Tidy
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocinfo
_TEXT	ENDS
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT
$T38558 = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ PROC NEAR	; std::_Locinfo::_Getctype, COMDAT
; _this$ = ecx

; 76   : 		{	// return ctype stuff

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 77   : 		return (::_Getctype());

  00007	8d 45 f0	 lea	 eax, DWORD PTR $T38558[ebp]
  0000a	57		 push	 edi
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 __Getctype
  00011	8b f0		 mov	 esi, eax
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00016	8b f8		 mov	 edi, eax
  00018	a5		 movsd
  00019	a5		 movsd
  0001a	a5		 movsd
  0001b	59		 pop	 ecx
  0001c	a5		 movsd
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi

; 78   : 		}

  0001f	c9		 leave
  00020	c2 04 00	 ret	 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ENDP	; std::_Locinfo::_Getctype
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
_TEXT	ENDS
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T38561 = -16						; size = 16
__Lobj$ = 8						; size = 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z PROC NEAR	; std::ctype<char>::_Init, COMDAT
; _this$ = ecx

; 1253 : 		{	// initialize from _Lobj

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 1254 : 		_Ctype = _Lobj._Getctype();

  00008	8d 45 f0	 lea	 eax, DWORD PTR $T38561[ebp]
  0000b	8b f9		 mov	 edi, ecx
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ; std::_Locinfo::_Getctype
  00016	83 c7 08	 add	 edi, 8
  00019	8b f0		 mov	 esi, eax
  0001b	a5		 movsd
  0001c	a5		 movsd
  0001d	a5		 movsd
  0001e	a5		 movsd
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi

; 1255 : 		}

  00021	c9		 leave
  00022	c2 04 00	 ret	 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ENDP		; std::ctype<char>::_Init
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
___formal$ = 12						; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC NEAR		; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 1305 : 		return (_Ch);

  00000	8a 44 24 04	 mov	 al, BYTE PTR __Ch$[esp-4]

; 1306 : 		}

  00004	c2 08 00	 ret	 8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP			; std::ctype<char>::do_narrow
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC NEAR	; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 1311 : 		::memcpy(_Dest, _First, _Last - _First);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 08	 mov	 esi, DWORD PTR __First$[esp]
  00009	8b c8		 mov	 ecx, eax
  0000b	2b ce		 sub	 ecx, esi
  0000d	8b d1		 mov	 edx, ecx
  0000f	57		 push	 edi
  00010	8b 7c 24 18	 mov	 edi, DWORD PTR __Dest$[esp+4]
  00014	c1 e9 02	 shr	 ecx, 2
  00017	f3 a5		 rep movsd
  00019	8b ca		 mov	 ecx, edx
  0001b	83 e1 03	 and	 ecx, 3
  0001e	f3 a4		 rep movsb
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 1312 : 		return (_Last);
; 1313 : 		}

  00022	c2 10 00	 ret	 16			; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP		; std::ctype<char>::do_narrow
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC NEAR		; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 1293 : 		return (_Byte);

  00000	8a 44 24 04	 mov	 al, BYTE PTR __Byte$[esp-4]

; 1294 : 		}

  00004	c2 04 00	 ret	 4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_widen
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC NEAR	; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 1299 : 		::memcpy(_Dest, _First, _Last - _First);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 08	 mov	 esi, DWORD PTR __First$[esp]
  00009	8b c8		 mov	 ecx, eax
  0000b	2b ce		 sub	 ecx, esi
  0000d	8b d1		 mov	 edx, ecx
  0000f	57		 push	 edi
  00010	8b 7c 24 14	 mov	 edi, DWORD PTR __Dest$[esp+4]
  00014	c1 e9 02	 shr	 ecx, 2
  00017	f3 a5		 rep movsd
  00019	8b ca		 mov	 ecx, edx
  0001b	83 e1 03	 and	 ecx, 3
  0001e	f3 a4		 rep movsb
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 1300 : 		return (_Last);
; 1301 : 		}

  00022	c2 0c 00	 ret	 12			; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::do_widen
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC NEAR		; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 1280 : 		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));

  00000	0f b6 44 24 04	 movzx	 eax, BYTE PTR __Ch$[esp-4]
  00005	83 c1 08	 add	 ecx, 8
  00008	51		 push	 ecx
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 __Toupper
  0000f	59		 pop	 ecx
  00010	59		 pop	 ecx

; 1281 : 		}

  00011	c2 04 00	 ret	 4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_toupper
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC NEAR	; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 1285 : 		{	// convert [_First, _Last) in place to upper case

  00000	56		 push	 esi

; 1286 : 		for (; _First != _Last; ++_First)

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __First$[esp]
  00005	3b 74 24 0c	 cmp	 esi, DWORD PTR __Last$[esp]
  00009	74 1a		 je	 SHORT $L5910
  0000b	57		 push	 edi
  0000c	8d 79 08	 lea	 edi, DWORD PTR [ecx+8]
$L5908:

; 1287 : 			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);

  0000f	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00012	57		 push	 edi
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 __Toupper
  00019	88 06		 mov	 BYTE PTR [esi], al
  0001b	46		 inc	 esi
  0001c	3b 74 24 18	 cmp	 esi, DWORD PTR __Last$[esp+12]
  00020	59		 pop	 ecx
  00021	59		 pop	 ecx
  00022	75 eb		 jne	 SHORT $L5908
  00024	5f		 pop	 edi
$L5910:

; 1288 : 		return ((const _Elem *)_First);

  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi

; 1289 : 		}

  00028	c2 08 00	 ret	 8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_toupper
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC NEAR		; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 1267 : 		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));

  00000	0f b6 44 24 04	 movzx	 eax, BYTE PTR __Ch$[esp-4]
  00005	83 c1 08	 add	 ecx, 8
  00008	51		 push	 ecx
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 __Tolower
  0000f	59		 pop	 ecx
  00010	59		 pop	 ecx

; 1268 : 		}

  00011	c2 04 00	 ret	 4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_tolower
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC NEAR	; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 1272 : 		{	// convert [_First, _Last) in place to lower case

  00000	56		 push	 esi

; 1273 : 		for (; _First != _Last; ++_First)

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __First$[esp]
  00005	3b 74 24 0c	 cmp	 esi, DWORD PTR __Last$[esp]
  00009	74 1a		 je	 SHORT $L5898
  0000b	57		 push	 edi
  0000c	8d 79 08	 lea	 edi, DWORD PTR [ecx+8]
$L5896:

; 1274 : 			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);

  0000f	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00012	57		 push	 edi
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 __Tolower
  00019	88 06		 mov	 BYTE PTR [esi], al
  0001b	46		 inc	 esi
  0001c	3b 74 24 18	 cmp	 esi, DWORD PTR __Last$[esp+12]
  00020	59		 pop	 ecx
  00021	59		 pop	 ecx
  00022	75 eb		 jne	 SHORT $L5896
  00024	5f		 pop	 edi
$L5898:

; 1275 : 		return ((const _Elem *)_First);

  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi

; 1276 : 		}

  00028	c2 08 00	 ret	 8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_tolower
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\istream
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = eax

; 78   : 			return (_Ok);

  00000	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 79   : 			}

  00003	c3		 ret	 0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator>, COMDAT
; ___$ReturnUdt$ = eax

; 202  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 203  : 	return (_Cat);
; 204  : 	}

  00000	c3		 ret	 0
??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator>, COMDAT
; ___$ReturnUdt$ = eax

; 202  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 203  : 	return (_Cat);
; 204  : 	}

  00000	c3		 ret	 0
??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator>, COMDAT
; ___$ReturnUdt$ = eax

; 202  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 203  : 	return (_Cat);
; 204  : 	}

  00000	c3		 ret	 0
??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator>, COMDAT
; ___$ReturnUdt$ = eax

; 202  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 203  : 	return (_Cat);
; 204  : 	}

  00000	c3		 ret	 0
??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator>, COMDAT
; ___$ReturnUdt$ = eax

; 202  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 203  : 	return (_Cat);
; 204  : 	}

  00000	c3		 ret	 0
??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator>, COMDAT
; ___$ReturnUdt$ = eax

; 202  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 203  : 	return (_Cat);
; 204  : 	}

  00000	c3		 ret	 0
??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator>, COMDAT
; ___$ReturnUdt$ = eax

; 202  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 203  : 	return (_Cat);
; 204  : 	}

  00000	c3		 ret	 0
??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator>, COMDAT
; ___$ReturnUdt$ = eax

; 202  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 203  : 	return (_Cat);
; 204  : 	}

  00000	c3		 ret	 0
??$_Iter_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node>, COMDAT
; __Count$ = eax

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 03	 shl	 eax, 3
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 35   : 	}

  0000d	c3		 ret	 0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVSub@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBHPAVSub@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node><std::pair<int const ,Sub *> >, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBHPAVSub@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node><std::pair<int const ,Sub *> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node>, COMDAT
; __Count$ = eax

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 03	 shl	 eax, 3
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 35   : 	}

  0000d	c3		 ret	 0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVSE@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBHPAVSE@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node><std::pair<int const ,SE *> >, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBHPAVSE@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node><std::pair<int const ,SE *> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node>, COMDAT
; __Count$ = eax

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 03	 shl	 eax, 3
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 35   : 	}

  0000d	c3		 ret	 0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVBGM@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBHPAVBGM@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node><std::pair<int const ,BGM *> >, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBHPAVBGM@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node><std::pair<int const ,BGM *> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node>, COMDAT
; __Count$ = eax

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 03	 shl	 eax, 3
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 35   : 	}

  0000d	c3		 ret	 0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVEnvelop@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBHPAVEnvelop@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node><std::pair<int const ,Envelop *> >, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBHPAVEnvelop@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node><std::pair<int const ,Envelop *> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node>, COMDAT
; __Count$ = eax

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 03	 shl	 eax, 3
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 35   : 	}

  0000d	c3		 ret	 0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVN163@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBHPAVN163@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node><std::pair<int const ,N163 *> >, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBHPAVN163@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node><std::pair<int const ,N163 *> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node>, COMDAT
; __Count$ = eax

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 03	 shl	 eax, 3
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 35   : 	}

  0000d	c3		 ret	 0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVVRC7@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBHPAVVRC7@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node><std::pair<int const ,VRC7 *> >, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBHPAVVRC7@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node><std::pair<int const ,VRC7 *> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node>, COMDAT
; __Count$ = eax

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 03	 shl	 eax, 3
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 35   : 	}

  0000d	c3		 ret	 0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVFDSM@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBHPAVFDSM@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node><std::pair<int const ,FDSM *> >, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBHPAVFDSM@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node><std::pair<int const ,FDSM *> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node>, COMDAT
; __Count$ = eax

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 03	 shl	 eax, 3
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 35   : 	}

  0000d	c3		 ret	 0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVFDSC@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBHPAVFDSC@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node><std::pair<int const ,FDSC *> >, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBHPAVFDSC@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node><std::pair<int const ,FDSC *> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVSub@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBHPAVSub@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node *><std::pair<int const ,Sub *> >, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBHPAVSub@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node *><std::pair<int const ,Sub *> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVSE@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBHPAVSE@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node *><std::pair<int const ,SE *> >, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBHPAVSE@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node *><std::pair<int const ,SE *> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVBGM@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBHPAVBGM@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node *><std::pair<int const ,BGM *> >, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBHPAVBGM@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node *><std::pair<int const ,BGM *> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVEnvelop@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBHPAVEnvelop@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node *><std::pair<int const ,Envelop *> >, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBHPAVEnvelop@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node *><std::pair<int const ,Envelop *> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVN163@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBHPAVN163@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node *><std::pair<int const ,N163 *> >, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBHPAVN163@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node *><std::pair<int const ,N163 *> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVVRC7@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBHPAVVRC7@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node *><std::pair<int const ,VRC7 *> >, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBHPAVVRC7@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node *><std::pair<int const ,VRC7 *> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVFDSM@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBHPAVFDSM@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node *><std::pair<int const ,FDSM *> >, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBHPAVFDSM@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node *><std::pair<int const ,FDSM *> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBHPAVFDSC@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBHPAVFDSC@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node *><std::pair<int const ,FDSC *> >, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBHPAVFDSC@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node *><std::pair<int const ,FDSC *> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
??$_Allocate@U_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_List_nod<MusicItem *,std::allocator<MusicItem *> >::_Node>, COMDAT
; __Count$ = eax

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 02	 shl	 eax, 2
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 35   : 	}

  0000d	c3		 ret	 0
??$_Allocate@U_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<MusicItem *,std::allocator<MusicItem *> >::_Node>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node *>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node *>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node *>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node *>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node *>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node *>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node *>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node *>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node *>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z PROC NEAR ; std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0>::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0>, COMDAT
; _this$ = eax

; 39   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ENDP ; std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0>::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z PROC NEAR ; std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0>::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0>, COMDAT
; _this$ = eax

; 39   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ENDP ; std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0>::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z PROC NEAR ; std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0>::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0>, COMDAT
; _this$ = eax

; 39   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ENDP ; std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0>::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z PROC NEAR ; std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0>::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0>, COMDAT
; _this$ = eax

; 39   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ENDP ; std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0>::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z PROC NEAR ; std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0>::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0>, COMDAT
; _this$ = eax

; 39   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ENDP ; std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0>::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z PROC NEAR ; std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0>::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0>, COMDAT
; _this$ = eax

; 39   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ENDP ; std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0>::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z PROC NEAR ; std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0>::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0>, COMDAT
; _this$ = eax

; 39   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ENDP ; std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0>::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z PROC NEAR ; std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0>::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0>, COMDAT
; _this$ = eax

; 39   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ENDP ; std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0>::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVSub@@@2@D@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Rarg$ = 12						; size = 4
__Carg$ = 16						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVSub@@@2@D@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node::_Node, COMDAT
; _this$ = eax
; __Larg$ = edx
; __Val$ = ecx

; 40   : 			{	// construct a node with value

  00000	89 10		 mov	 DWORD PTR [eax], edx
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Parg$[esp-4]
  00006	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00009	8b 54 24 08	 mov	 edx, DWORD PTR __Rarg$[esp-4]
  0000d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00015	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00018	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0001b	8a 4c 24 0c	 mov	 cl, BYTE PTR __Carg$[esp-4]
  0001f	88 48 14	 mov	 BYTE PTR [eax+20], cl
  00022	c6 40 15 00	 mov	 BYTE PTR [eax+21], 0

; 41   : 			}

  00026	c2 0c 00	 ret	 12			; 0000000cH
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVSub@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node::_Node
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVSE@@@2@D@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Rarg$ = 12						; size = 4
__Carg$ = 16						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVSE@@@2@D@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node::_Node, COMDAT
; _this$ = eax
; __Larg$ = edx
; __Val$ = ecx

; 40   : 			{	// construct a node with value

  00000	89 10		 mov	 DWORD PTR [eax], edx
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Parg$[esp-4]
  00006	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00009	8b 54 24 08	 mov	 edx, DWORD PTR __Rarg$[esp-4]
  0000d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00015	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00018	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0001b	8a 4c 24 0c	 mov	 cl, BYTE PTR __Carg$[esp-4]
  0001f	88 48 14	 mov	 BYTE PTR [eax+20], cl
  00022	c6 40 15 00	 mov	 BYTE PTR [eax+21], 0

; 41   : 			}

  00026	c2 0c 00	 ret	 12			; 0000000cH
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVSE@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node::_Node
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVBGM@@@2@D@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Rarg$ = 12						; size = 4
__Carg$ = 16						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVBGM@@@2@D@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node::_Node, COMDAT
; _this$ = eax
; __Larg$ = edx
; __Val$ = ecx

; 40   : 			{	// construct a node with value

  00000	89 10		 mov	 DWORD PTR [eax], edx
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Parg$[esp-4]
  00006	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00009	8b 54 24 08	 mov	 edx, DWORD PTR __Rarg$[esp-4]
  0000d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00015	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00018	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0001b	8a 4c 24 0c	 mov	 cl, BYTE PTR __Carg$[esp-4]
  0001f	88 48 14	 mov	 BYTE PTR [eax+20], cl
  00022	c6 40 15 00	 mov	 BYTE PTR [eax+21], 0

; 41   : 			}

  00026	c2 0c 00	 ret	 12			; 0000000cH
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVBGM@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node::_Node
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVEnvelop@@@2@D@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Rarg$ = 12						; size = 4
__Carg$ = 16						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVEnvelop@@@2@D@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node::_Node, COMDAT
; _this$ = eax
; __Larg$ = edx
; __Val$ = ecx

; 40   : 			{	// construct a node with value

  00000	89 10		 mov	 DWORD PTR [eax], edx
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Parg$[esp-4]
  00006	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00009	8b 54 24 08	 mov	 edx, DWORD PTR __Rarg$[esp-4]
  0000d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00015	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00018	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0001b	8a 4c 24 0c	 mov	 cl, BYTE PTR __Carg$[esp-4]
  0001f	88 48 14	 mov	 BYTE PTR [eax+20], cl
  00022	c6 40 15 00	 mov	 BYTE PTR [eax+21], 0

; 41   : 			}

  00026	c2 0c 00	 ret	 12			; 0000000cH
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVEnvelop@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node::_Node
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVN163@@@2@D@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Rarg$ = 12						; size = 4
__Carg$ = 16						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVN163@@@2@D@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node::_Node, COMDAT
; _this$ = eax
; __Larg$ = edx
; __Val$ = ecx

; 40   : 			{	// construct a node with value

  00000	89 10		 mov	 DWORD PTR [eax], edx
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Parg$[esp-4]
  00006	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00009	8b 54 24 08	 mov	 edx, DWORD PTR __Rarg$[esp-4]
  0000d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00015	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00018	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0001b	8a 4c 24 0c	 mov	 cl, BYTE PTR __Carg$[esp-4]
  0001f	88 48 14	 mov	 BYTE PTR [eax+20], cl
  00022	c6 40 15 00	 mov	 BYTE PTR [eax+21], 0

; 41   : 			}

  00026	c2 0c 00	 ret	 12			; 0000000cH
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVN163@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node::_Node
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVVRC7@@@2@D@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Rarg$ = 12						; size = 4
__Carg$ = 16						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVVRC7@@@2@D@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node::_Node, COMDAT
; _this$ = eax
; __Larg$ = edx
; __Val$ = ecx

; 40   : 			{	// construct a node with value

  00000	89 10		 mov	 DWORD PTR [eax], edx
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Parg$[esp-4]
  00006	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00009	8b 54 24 08	 mov	 edx, DWORD PTR __Rarg$[esp-4]
  0000d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00015	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00018	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0001b	8a 4c 24 0c	 mov	 cl, BYTE PTR __Carg$[esp-4]
  0001f	88 48 14	 mov	 BYTE PTR [eax+20], cl
  00022	c6 40 15 00	 mov	 BYTE PTR [eax+21], 0

; 41   : 			}

  00026	c2 0c 00	 ret	 12			; 0000000cH
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVVRC7@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node::_Node
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVFDSM@@@2@D@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Rarg$ = 12						; size = 4
__Carg$ = 16						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVFDSM@@@2@D@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node::_Node, COMDAT
; _this$ = eax
; __Larg$ = edx
; __Val$ = ecx

; 40   : 			{	// construct a node with value

  00000	89 10		 mov	 DWORD PTR [eax], edx
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Parg$[esp-4]
  00006	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00009	8b 54 24 08	 mov	 edx, DWORD PTR __Rarg$[esp-4]
  0000d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00015	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00018	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0001b	8a 4c 24 0c	 mov	 cl, BYTE PTR __Carg$[esp-4]
  0001f	88 48 14	 mov	 BYTE PTR [eax+20], cl
  00022	c6 40 15 00	 mov	 BYTE PTR [eax+21], 0

; 41   : 			}

  00026	c2 0c 00	 ret	 12			; 0000000cH
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVFDSM@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node::_Node
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVFDSC@@@2@D@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Rarg$ = 12						; size = 4
__Carg$ = 16						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVFDSC@@@2@D@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node::_Node, COMDAT
; _this$ = eax
; __Larg$ = edx
; __Val$ = ecx

; 40   : 			{	// construct a node with value

  00000	89 10		 mov	 DWORD PTR [eax], edx
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Parg$[esp-4]
  00006	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00009	8b 54 24 08	 mov	 edx, DWORD PTR __Rarg$[esp-4]
  0000d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00015	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00018	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0001b	8a 4c 24 0c	 mov	 cl, BYTE PTR __Carg$[esp-4]
  0001f	88 48 14	 mov	 BYTE PTR [eax+20], cl
  00022	c6 40 15 00	 mov	 BYTE PTR [eax+21], 0

; 41   : 			}

  00026	c2 0c 00	 ret	 12			; 0000000cH
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVFDSC@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node::_Node
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node>::destroy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node>::allocate, COMDAT
; __Count$ = eax

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 03	 shl	 eax, 3
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 138  : 		}

  0000d	c3		 ret	 0
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node>::allocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHPAVSub@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBHPAVSub@@@std@@@std@@QBEIXZ PROC NEAR ; std::allocator<std::pair<int const ,Sub *> >::max_size, COMDAT

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBHPAVSub@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,Sub *> >::max_size
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >, COMDAT
; _this$ = eax

; 55   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node>::destroy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node>::allocate, COMDAT
; __Count$ = eax

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 03	 shl	 eax, 3
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 138  : 		}

  0000d	c3		 ret	 0
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node>::allocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHPAVSE@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBHPAVSE@@@std@@@std@@QBEIXZ PROC NEAR ; std::allocator<std::pair<int const ,SE *> >::max_size, COMDAT

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBHPAVSE@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,SE *> >::max_size
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >, COMDAT
; _this$ = eax

; 55   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node>::destroy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node>::allocate, COMDAT
; __Count$ = eax

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 03	 shl	 eax, 3
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 138  : 		}

  0000d	c3		 ret	 0
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node>::allocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@std@@QBEIXZ PROC NEAR ; std::allocator<std::pair<int const ,BGM *> >::max_size, COMDAT

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,BGM *> >::max_size
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >, COMDAT
; _this$ = eax

; 55   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node>::destroy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node>::allocate, COMDAT
; __Count$ = eax

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 03	 shl	 eax, 3
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 138  : 		}

  0000d	c3		 ret	 0
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node>::allocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@std@@QBEIXZ PROC NEAR ; std::allocator<std::pair<int const ,Envelop *> >::max_size, COMDAT

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,Envelop *> >::max_size
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >, COMDAT
; _this$ = eax

; 55   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node>::destroy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node>::allocate, COMDAT
; __Count$ = eax

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 03	 shl	 eax, 3
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 138  : 		}

  0000d	c3		 ret	 0
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node>::allocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHPAVN163@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBHPAVN163@@@std@@@std@@QBEIXZ PROC NEAR ; std::allocator<std::pair<int const ,N163 *> >::max_size, COMDAT

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBHPAVN163@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,N163 *> >::max_size
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >, COMDAT
; _this$ = eax

; 55   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node>::destroy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node>::allocate, COMDAT
; __Count$ = eax

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 03	 shl	 eax, 3
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 138  : 		}

  0000d	c3		 ret	 0
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node>::allocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@std@@QBEIXZ PROC NEAR ; std::allocator<std::pair<int const ,VRC7 *> >::max_size, COMDAT

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,VRC7 *> >::max_size
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >, COMDAT
; _this$ = eax

; 55   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node>::destroy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node>::allocate, COMDAT
; __Count$ = eax

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 03	 shl	 eax, 3
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 138  : 		}

  0000d	c3		 ret	 0
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node>::allocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@std@@QBEIXZ PROC NEAR ; std::allocator<std::pair<int const ,FDSM *> >::max_size, COMDAT

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,FDSM *> >::max_size
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >, COMDAT
; _this$ = eax

; 55   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node>::destroy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node>::allocate, COMDAT
; __Count$ = eax

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 03	 shl	 eax, 3
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 138  : 		}

  0000d	c3		 ret	 0
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node>::allocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@std@@QBEIXZ PROC NEAR ; std::allocator<std::pair<int const ,FDSC *> >::max_size, COMDAT

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,FDSC *> >::max_size
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >, COMDAT
; _this$ = eax

; 55   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVMusicItem@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVMusicItem@@@std@@QBEIXZ PROC NEAR ; std::allocator<MusicItem *>::max_size, COMDAT

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAVMusicItem@@@std@@QBEIXZ ENDP	; std::allocator<MusicItem *>::max_size
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??0_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE@PAU012@0ABQAVMusicItem@@@Z
_TEXT	SEGMENT
__Prevarg$ = 8						; size = 4
__Myvalarg$ = 12					; size = 4
??0_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE@PAU012@0ABQAVMusicItem@@@Z PROC NEAR ; std::_List_nod<MusicItem *,std::allocator<MusicItem *> >::_Node::_Node, COMDAT
; _this$ = eax
; __Nextarg$ = ecx

; 34   : 			{	// construct a node with value

  00000	89 08		 mov	 DWORD PTR [eax], ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Prevarg$[esp-4]
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	8b 4c 24 08	 mov	 ecx, DWORD PTR __Myvalarg$[esp-4]
  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 35   : 			}

  00012	c2 08 00	 ret	 8
??0_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE@PAU012@0ABQAVMusicItem@@@Z ENDP ; std::_List_nod<MusicItem *,std::allocator<MusicItem *> >::_Node::_Node
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@1@AB_N@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8a 09		 mov	 cl, BYTE PTR [ecx]
  0000a	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator,bool>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@1@AB_N@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8a 09		 mov	 cl, BYTE PTR [ecx]
  0000a	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator,bool>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@1@AB_N@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8a 09		 mov	 cl, BYTE PTR [ecx]
  0000a	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator,bool>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@1@AB_N@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8a 09		 mov	 cl, BYTE PTR [ecx]
  0000a	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator,bool>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@1@AB_N@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8a 09		 mov	 cl, BYTE PTR [ecx]
  0000a	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator,bool>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@1@AB_N@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8a 09		 mov	 cl, BYTE PTR [ecx]
  0000a	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator,bool>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@1@AB_N@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8a 09		 mov	 cl, BYTE PTR [ecx]
  0000a	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator,bool>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@1@AB_N@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8a 09		 mov	 cl, BYTE PTR [ecx]
  0000a	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator,bool>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z
_TEXT	SEGMENT
??0const_iterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z PROC NEAR ; std::list<MusicItem *,std::allocator<MusicItem *> >::const_iterator::const_iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 156  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 157  : 			}

  00002	c3		 ret	 0
??0const_iterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z ENDP ; std::list<MusicItem *,std::allocator<MusicItem *> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00002	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00002	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::max_size, COMDAT

; 453  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 454  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::max_size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Color, COMDAT
; __Pnode$ = eax

; 132  : 		return ((_Charref)(*_Pnode)._Color);

  00000	83 c0 14	 add	 eax, 20			; 00000014H

; 133  : 		}

  00003	c3		 ret	 0
?_Color@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Color
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::max_size, COMDAT

; 453  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 454  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::max_size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Color, COMDAT
; __Pnode$ = eax

; 132  : 		return ((_Charref)(*_Pnode)._Color);

  00000	83 c0 14	 add	 eax, 20			; 00000014H

; 133  : 		}

  00003	c3		 ret	 0
?_Color@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Color
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::max_size, COMDAT

; 453  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 454  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::max_size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Color, COMDAT
; __Pnode$ = eax

; 132  : 		return ((_Charref)(*_Pnode)._Color);

  00000	83 c0 14	 add	 eax, 20			; 00000014H

; 133  : 		}

  00003	c3		 ret	 0
?_Color@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Color
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::max_size, COMDAT

; 453  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 454  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::max_size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Color, COMDAT
; __Pnode$ = eax

; 132  : 		return ((_Charref)(*_Pnode)._Color);

  00000	83 c0 14	 add	 eax, 20			; 00000014H

; 133  : 		}

  00003	c3		 ret	 0
?_Color@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Color
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::max_size, COMDAT

; 453  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 454  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::max_size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Color, COMDAT
; __Pnode$ = eax

; 132  : 		return ((_Charref)(*_Pnode)._Color);

  00000	83 c0 14	 add	 eax, 20			; 00000014H

; 133  : 		}

  00003	c3		 ret	 0
?_Color@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Color
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::max_size, COMDAT

; 453  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 454  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::max_size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Color, COMDAT
; __Pnode$ = eax

; 132  : 		return ((_Charref)(*_Pnode)._Color);

  00000	83 c0 14	 add	 eax, 20			; 00000014H

; 133  : 		}

  00003	c3		 ret	 0
?_Color@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Color
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::max_size, COMDAT

; 453  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 454  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::max_size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Color, COMDAT
; __Pnode$ = eax

; 132  : 		return ((_Charref)(*_Pnode)._Color);

  00000	83 c0 14	 add	 eax, 20			; 00000014H

; 133  : 		}

  00003	c3		 ret	 0
?_Color@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Color
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::max_size, COMDAT

; 453  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 454  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::max_size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Color, COMDAT
; __Pnode$ = eax

; 132  : 		return ((_Charref)(*_Pnode)._Color);

  00000	83 c0 14	 add	 eax, 20			; 00000014H

; 133  : 		}

  00003	c3		 ret	 0
?_Color@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Color
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@U_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<MusicItem *,std::allocator<MusicItem *> >::_Node>::allocate, COMDAT
; __Count$ = eax

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 02	 shl	 eax, 2
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 138  : 		}

  0000d	c3		 ret	 0
?allocate@?$allocator@U_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<MusicItem *,std::allocator<MusicItem *> >::_Node>::allocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<MusicItem *,std::allocator<MusicItem *> >::_Node>::deallocate, COMDAT

; 132  : 		operator delete(_Ptr);

  00000	ff 74 24 04	 push	 DWORD PTR __Ptr$[esp-4]
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 133  : 		}

  0000a	c2 04 00	 ret	 4
?deallocate@?$allocator@U_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<MusicItem *,std::allocator<MusicItem *> >::_Node>::deallocate
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?max_size@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QBEIXZ PROC NEAR ; std::list<MusicItem *,std::allocator<MusicItem *> >::max_size, COMDAT

; 436  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 437  : 		}

  00005	c3		 ret	 0
?max_size@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QBEIXZ ENDP ; std::list<MusicItem *,std::allocator<MusicItem *> >::max_size
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@1@0@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@1@0@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@1@0@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@1@0@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@1@0@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@1@0@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@1@0@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@1@0@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@1@0@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@1@0@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@1@0@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@1@0@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@1@0@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@1@0@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@1@0@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@1@0@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@3@XZ PROC NEAR ; std::list<MusicItem *,std::allocator<MusicItem *> >::const_iterator::_Mynode, COMDAT
; _this$ = eax

; 207  : 			return (_Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 208  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@3@XZ ENDP ; std::list<MusicItem *,std::allocator<MusicItem *> >::const_iterator::_Mynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z
_TEXT	SEGMENT
??0iterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z PROC NEAR ; std::list<MusicItem *,std::allocator<MusicItem *> >::iterator::iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 235  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 236  : 			}

  00002	c3		 ret	 0
??0iterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z ENDP ; std::list<MusicItem *,std::allocator<MusicItem *> >::iterator::iterator
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00002	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00002	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00002	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00002	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00002	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator::iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00002	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator::iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator::iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00002	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator::iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00002	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node *>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node *>::destroy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node>::deallocate, COMDAT

; 132  : 		operator delete(_Ptr);

  00000	ff 74 24 04	 push	 DWORD PTR __Ptr$[esp-4]
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 133  : 		}

  0000a	c2 04 00	 ret	 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node>::deallocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVSub@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHPAVSub@@@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<std::pair<int const ,Sub *> >::allocator<std::pair<int const ,Sub *> >, COMDAT
; _this$ = eax

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHPAVSub@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,Sub *> >::allocator<std::pair<int const ,Sub *> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVSub@@@2@@Z
_TEXT	SEGMENT
?_Kfn@?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVSub@@@2@@Z PROC NEAR ; std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0>::_Kfn, COMDAT
; __Val$ = eax

; 64   : 		return (_Val.first);
; 65   : 		}

  00000	c3		 ret	 0
?_Kfn@?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVSub@@@2@@Z ENDP ; std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0>::_Kfn
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVSub@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVSub@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Myval, COMDAT
; __Pnode$ = eax

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00003	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVSub@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Myval
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Right@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Right, COMDAT
; __Pnode$ = eax

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	83 c0 08	 add	 eax, 8

; 158  : 		}

  00003	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Right
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Parent, COMDAT
; __Pnode$ = eax

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	83 c0 04	 add	 eax, 4

; 153  : 		}

  00003	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Parent
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Left@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Left, COMDAT
; __Pnode$ = eax

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);
; 148  : 		}

  00000	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Left
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Isnil, COMDAT
; __Pnode$ = eax

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00003	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Isnil
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node *>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node *>::destroy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node>::deallocate, COMDAT

; 132  : 		operator delete(_Ptr);

  00000	ff 74 24 04	 push	 DWORD PTR __Ptr$[esp-4]
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 133  : 		}

  0000a	c2 04 00	 ret	 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node>::deallocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVSE@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHPAVSE@@@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<std::pair<int const ,SE *> >::allocator<std::pair<int const ,SE *> >, COMDAT
; _this$ = eax

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHPAVSE@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,SE *> >::allocator<std::pair<int const ,SE *> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVSE@@@2@@Z
_TEXT	SEGMENT
?_Kfn@?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVSE@@@2@@Z PROC NEAR ; std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0>::_Kfn, COMDAT
; __Val$ = eax

; 64   : 		return (_Val.first);
; 65   : 		}

  00000	c3		 ret	 0
?_Kfn@?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVSE@@@2@@Z ENDP ; std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0>::_Kfn
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::size, COMDAT
; _this$ = eax

; 448  : 		return (_Mysize);

  00000	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 449  : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVSE@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVSE@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Myval, COMDAT
; __Pnode$ = eax

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00003	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVSE@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Myval
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Right@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Right, COMDAT
; __Pnode$ = eax

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	83 c0 08	 add	 eax, 8

; 158  : 		}

  00003	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Right
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Parent, COMDAT
; __Pnode$ = eax

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	83 c0 04	 add	 eax, 4

; 153  : 		}

  00003	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Parent
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Left@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Left, COMDAT
; __Pnode$ = eax

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);
; 148  : 		}

  00000	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Left
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Isnil, COMDAT
; __Pnode$ = eax

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00003	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Isnil
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node *>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node *>::destroy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node>::deallocate, COMDAT

; 132  : 		operator delete(_Ptr);

  00000	ff 74 24 04	 push	 DWORD PTR __Ptr$[esp-4]
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 133  : 		}

  0000a	c2 04 00	 ret	 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node>::deallocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<std::pair<int const ,BGM *> >::allocator<std::pair<int const ,BGM *> >, COMDAT
; _this$ = eax

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,BGM *> >::allocator<std::pair<int const ,BGM *> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVBGM@@@2@@Z
_TEXT	SEGMENT
?_Kfn@?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVBGM@@@2@@Z PROC NEAR ; std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0>::_Kfn, COMDAT
; __Val$ = eax

; 64   : 		return (_Val.first);
; 65   : 		}

  00000	c3		 ret	 0
?_Kfn@?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVBGM@@@2@@Z ENDP ; std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0>::_Kfn
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::size, COMDAT
; _this$ = eax

; 448  : 		return (_Mysize);

  00000	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 449  : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVBGM@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVBGM@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Myval, COMDAT
; __Pnode$ = eax

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00003	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVBGM@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Myval
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Right@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Right, COMDAT
; __Pnode$ = eax

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	83 c0 08	 add	 eax, 8

; 158  : 		}

  00003	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Right
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Parent, COMDAT
; __Pnode$ = eax

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	83 c0 04	 add	 eax, 4

; 153  : 		}

  00003	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Parent
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Left@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Left, COMDAT
; __Pnode$ = eax

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);
; 148  : 		}

  00000	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Left
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Isnil, COMDAT
; __Pnode$ = eax

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00003	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Isnil
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node *>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node *>::destroy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node>::deallocate, COMDAT

; 132  : 		operator delete(_Ptr);

  00000	ff 74 24 04	 push	 DWORD PTR __Ptr$[esp-4]
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 133  : 		}

  0000a	c2 04 00	 ret	 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node>::deallocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<std::pair<int const ,Envelop *> >::allocator<std::pair<int const ,Envelop *> >, COMDAT
; _this$ = eax

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,Envelop *> >::allocator<std::pair<int const ,Envelop *> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVEnvelop@@@2@@Z
_TEXT	SEGMENT
?_Kfn@?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVEnvelop@@@2@@Z PROC NEAR ; std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0>::_Kfn, COMDAT
; __Val$ = eax

; 64   : 		return (_Val.first);
; 65   : 		}

  00000	c3		 ret	 0
?_Kfn@?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVEnvelop@@@2@@Z ENDP ; std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0>::_Kfn
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVEnvelop@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVEnvelop@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Myval, COMDAT
; __Pnode$ = eax

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00003	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVEnvelop@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Myval
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Right@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Right, COMDAT
; __Pnode$ = eax

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	83 c0 08	 add	 eax, 8

; 158  : 		}

  00003	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Right
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Parent, COMDAT
; __Pnode$ = eax

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	83 c0 04	 add	 eax, 4

; 153  : 		}

  00003	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Parent
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Left@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Left, COMDAT
; __Pnode$ = eax

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);
; 148  : 		}

  00000	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Left
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Isnil, COMDAT
; __Pnode$ = eax

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00003	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Isnil
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node *>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node *>::destroy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node>::deallocate, COMDAT

; 132  : 		operator delete(_Ptr);

  00000	ff 74 24 04	 push	 DWORD PTR __Ptr$[esp-4]
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 133  : 		}

  0000a	c2 04 00	 ret	 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node>::deallocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVN163@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHPAVN163@@@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<std::pair<int const ,N163 *> >::allocator<std::pair<int const ,N163 *> >, COMDAT
; _this$ = eax

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHPAVN163@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,N163 *> >::allocator<std::pair<int const ,N163 *> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVN163@@@2@@Z
_TEXT	SEGMENT
?_Kfn@?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVN163@@@2@@Z PROC NEAR ; std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0>::_Kfn, COMDAT
; __Val$ = eax

; 64   : 		return (_Val.first);
; 65   : 		}

  00000	c3		 ret	 0
?_Kfn@?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVN163@@@2@@Z ENDP ; std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0>::_Kfn
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVN163@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVN163@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Myval, COMDAT
; __Pnode$ = eax

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00003	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVN163@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Myval
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Right@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Right, COMDAT
; __Pnode$ = eax

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	83 c0 08	 add	 eax, 8

; 158  : 		}

  00003	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Right
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Parent, COMDAT
; __Pnode$ = eax

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	83 c0 04	 add	 eax, 4

; 153  : 		}

  00003	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Parent
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Left@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Left, COMDAT
; __Pnode$ = eax

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);
; 148  : 		}

  00000	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Left
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Isnil, COMDAT
; __Pnode$ = eax

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00003	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Isnil
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node *>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node *>::destroy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node>::deallocate, COMDAT

; 132  : 		operator delete(_Ptr);

  00000	ff 74 24 04	 push	 DWORD PTR __Ptr$[esp-4]
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 133  : 		}

  0000a	c2 04 00	 ret	 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node>::deallocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<std::pair<int const ,VRC7 *> >::allocator<std::pair<int const ,VRC7 *> >, COMDAT
; _this$ = eax

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,VRC7 *> >::allocator<std::pair<int const ,VRC7 *> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVVRC7@@@2@@Z
_TEXT	SEGMENT
?_Kfn@?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVVRC7@@@2@@Z PROC NEAR ; std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0>::_Kfn, COMDAT
; __Val$ = eax

; 64   : 		return (_Val.first);
; 65   : 		}

  00000	c3		 ret	 0
?_Kfn@?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVVRC7@@@2@@Z ENDP ; std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0>::_Kfn
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVVRC7@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVVRC7@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Myval, COMDAT
; __Pnode$ = eax

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00003	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVVRC7@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Myval
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Right@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Right, COMDAT
; __Pnode$ = eax

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	83 c0 08	 add	 eax, 8

; 158  : 		}

  00003	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Right
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Parent, COMDAT
; __Pnode$ = eax

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	83 c0 04	 add	 eax, 4

; 153  : 		}

  00003	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Parent
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Left@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Left, COMDAT
; __Pnode$ = eax

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);
; 148  : 		}

  00000	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Left
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Isnil, COMDAT
; __Pnode$ = eax

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00003	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Isnil
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node *>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node *>::destroy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node>::deallocate, COMDAT

; 132  : 		operator delete(_Ptr);

  00000	ff 74 24 04	 push	 DWORD PTR __Ptr$[esp-4]
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 133  : 		}

  0000a	c2 04 00	 ret	 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node>::deallocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<std::pair<int const ,FDSM *> >::allocator<std::pair<int const ,FDSM *> >, COMDAT
; _this$ = eax

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,FDSM *> >::allocator<std::pair<int const ,FDSM *> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVFDSM@@@2@@Z
_TEXT	SEGMENT
?_Kfn@?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVFDSM@@@2@@Z PROC NEAR ; std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0>::_Kfn, COMDAT
; __Val$ = eax

; 64   : 		return (_Val.first);
; 65   : 		}

  00000	c3		 ret	 0
?_Kfn@?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVFDSM@@@2@@Z ENDP ; std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0>::_Kfn
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVFDSM@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVFDSM@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Myval, COMDAT
; __Pnode$ = eax

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00003	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVFDSM@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Myval
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Right@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Right, COMDAT
; __Pnode$ = eax

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	83 c0 08	 add	 eax, 8

; 158  : 		}

  00003	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Right
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Parent, COMDAT
; __Pnode$ = eax

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	83 c0 04	 add	 eax, 4

; 153  : 		}

  00003	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Parent
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Left@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Left, COMDAT
; __Pnode$ = eax

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);
; 148  : 		}

  00000	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Left
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Isnil, COMDAT
; __Pnode$ = eax

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00003	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Isnil
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node *>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node *>::destroy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node>::deallocate, COMDAT

; 132  : 		operator delete(_Ptr);

  00000	ff 74 24 04	 push	 DWORD PTR __Ptr$[esp-4]
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 133  : 		}

  0000a	c2 04 00	 ret	 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node>::deallocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<std::pair<int const ,FDSC *> >::allocator<std::pair<int const ,FDSC *> >, COMDAT
; _this$ = eax

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,FDSC *> >::allocator<std::pair<int const ,FDSC *> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVFDSC@@@2@@Z
_TEXT	SEGMENT
?_Kfn@?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVFDSC@@@2@@Z PROC NEAR ; std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0>::_Kfn, COMDAT
; __Val$ = eax

; 64   : 		return (_Val.first);
; 65   : 		}

  00000	c3		 ret	 0
?_Kfn@?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAVFDSC@@@2@@Z ENDP ; std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0>::_Kfn
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVFDSC@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVFDSC@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Myval, COMDAT
; __Pnode$ = eax

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00003	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBHPAVFDSC@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Myval
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Right@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Right, COMDAT
; __Pnode$ = eax

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	83 c0 08	 add	 eax, 8

; 158  : 		}

  00003	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Right
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Parent, COMDAT
; __Pnode$ = eax

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	83 c0 04	 add	 eax, 4

; 153  : 		}

  00003	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Parent
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Left@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Left, COMDAT
; __Pnode$ = eax

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);
; 148  : 		}

  00000	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Left
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Isnil, COMDAT
; __Pnode$ = eax

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00003	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Isnil
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Prevnode@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@PAU342@@Z PROC NEAR ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Prevnode, COMDAT
; __Pnode$ = eax

; 113  : 		return ((_Nodepref)(*_Pnode)._Prev);

  00000	83 c0 04	 add	 eax, 4

; 114  : 		}

  00003	c3		 ret	 0
?_Prevnode@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@PAU342@@Z ENDP ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Prevnode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Nextnode@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@PAU342@@Z PROC NEAR ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Nextnode, COMDAT
; __Pnode$ = eax

; 108  : 		return ((_Nodepref)(*_Pnode)._Next);
; 109  : 		}

  00000	c3		 ret	 0
?_Nextnode@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@PAU342@@Z ENDP ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Nextnode
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBHPAVSE@@@std@@QAE@ABHABQAVSE@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@$$CBHPAVSE@@@std@@QAE@ABHABQAVSE@@@Z PROC NEAR ; std::pair<int const ,SE *>::pair<int const ,SE *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@$$CBHPAVSE@@@std@@QAE@ABHABQAVSE@@@Z ENDP	; std::pair<int const ,SE *>::pair<int const ,SE *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBHPAVBGM@@@std@@QAE@ABHABQAVBGM@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@$$CBHPAVBGM@@@std@@QAE@ABHABQAVBGM@@@Z PROC NEAR ; std::pair<int const ,BGM *>::pair<int const ,BGM *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@$$CBHPAVBGM@@@std@@QAE@ABHABQAVBGM@@@Z ENDP	; std::pair<int const ,BGM *>::pair<int const ,BGM *>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocnum
_TEXT	ENDS
;	COMDAT ?put@?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@GU?$char_traits@G@std@@@2@V32@AAVios_base@2@GK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 4
?put@?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@GU?$char_traits@G@std@@@2@V32@AAVios_base@2@GK@Z PROC NEAR ; std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short> > >::put, COMDAT
; _this$ = ecx

; 842  : 		{	// put formatted unsigned long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 843  : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

  00003	ff 75 1c	 push	 DWORD PTR __Val$[ebp]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  0000b	ff 75 14	 push	 DWORD PTR __Iosbase$[ebp]
  0000e	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00011	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00014	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00017	ff 50 18	 call	 DWORD PTR [eax+24]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 844  : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 18 00	 ret	 24			; 00000018H
?put@?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@GU?$char_traits@G@std@@@2@V32@AAVios_base@2@GK@Z ENDP ; std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short> > >::put
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBHPAVN163@@@std@@QAE@ABHABQAVN163@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@$$CBHPAVN163@@@std@@QAE@ABHABQAVN163@@@Z PROC NEAR ; std::pair<int const ,N163 *>::pair<int const ,N163 *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@$$CBHPAVN163@@@std@@QAE@ABHABQAVN163@@@Z ENDP	; std::pair<int const ,N163 *>::pair<int const ,N163 *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBHPAVVRC7@@@std@@QAE@ABHABQAVVRC7@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@$$CBHPAVVRC7@@@std@@QAE@ABHABQAVVRC7@@@Z PROC NEAR ; std::pair<int const ,VRC7 *>::pair<int const ,VRC7 *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@$$CBHPAVVRC7@@@std@@QAE@ABHABQAVVRC7@@@Z ENDP	; std::pair<int const ,VRC7 *>::pair<int const ,VRC7 *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBHPAVFDSM@@@std@@QAE@ABHABQAVFDSM@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@$$CBHPAVFDSM@@@std@@QAE@ABHABQAVFDSM@@@Z PROC NEAR ; std::pair<int const ,FDSM *>::pair<int const ,FDSM *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@$$CBHPAVFDSM@@@std@@QAE@ABHABQAVFDSM@@@Z ENDP	; std::pair<int const ,FDSM *>::pair<int const ,FDSM *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBHPAVFDSC@@@std@@QAE@ABHABQAVFDSC@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@$$CBHPAVFDSC@@@std@@QAE@ABHABQAVFDSC@@@Z PROC NEAR ; std::pair<int const ,FDSC *>::pair<int const ,FDSC *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@$$CBHPAVFDSC@@@std@@QAE@ABHABQAVFDSC@@@Z ENDP	; std::pair<int const ,FDSC *>::pair<int const ,FDSC *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBHPAVEnvelop@@@std@@QAE@ABHABQAVEnvelop@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@$$CBHPAVEnvelop@@@std@@QAE@ABHABQAVEnvelop@@@Z PROC NEAR ; std::pair<int const ,Envelop *>::pair<int const ,Envelop *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@$$CBHPAVEnvelop@@@std@@QAE@ABHABQAVEnvelop@@@Z ENDP ; std::pair<int const ,Envelop *>::pair<int const ,Envelop *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBHPAVSub@@@std@@QAE@ABHABQAVSub@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@$$CBHPAVSub@@@std@@QAE@ABHABQAVSub@@@Z PROC NEAR ; std::pair<int const ,Sub *>::pair<int const ,Sub *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@$$CBHPAVSub@@@std@@QAE@ABHABQAVSub@@@Z ENDP	; std::pair<int const ,Sub *>::pair<int const ,Sub *>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = eax

; 284  : 			return (_Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 285  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = eax
; __Right$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	2b 01		 sub	 eax, DWORD PTR [ecx]
  00004	f7 d8		 neg	 eax
  00006	1b c0		 sbb	 eax, eax
  00008	40		 inc	 eax

; 242  : 			}

  00009	c3		 ret	 0
??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax

; 193  : 			{	// construct with null node pointer

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 194  : 			}

  00003	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator::iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00002	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator::iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = eax

; 284  : 			return (_Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 285  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = eax
; __Right$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	2b 01		 sub	 eax, DWORD PTR [ecx]
  00004	f7 d8		 neg	 eax
  00006	1b c0		 sbb	 eax, eax
  00008	40		 inc	 eax

; 242  : 			}

  00009	c3		 ret	 0
??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax

; 193  : 			{	// construct with null node pointer

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 194  : 			}

  00003	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator::iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00002	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator::iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = eax

; 284  : 			return (_Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 285  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = eax
; __Right$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	2b 01		 sub	 eax, DWORD PTR [ecx]
  00004	f7 d8		 neg	 eax
  00006	1b c0		 sbb	 eax, eax
  00008	40		 inc	 eax

; 242  : 			}

  00009	c3		 ret	 0
??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax

; 193  : 			{	// construct with null node pointer

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 194  : 			}

  00003	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator::iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00002	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator::iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = eax

; 284  : 			return (_Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 285  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = eax
; __Right$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	2b 01		 sub	 eax, DWORD PTR [ecx]
  00004	f7 d8		 neg	 eax
  00006	1b c0		 sbb	 eax, eax
  00008	40		 inc	 eax

; 242  : 			}

  00009	c3		 ret	 0
??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax

; 193  : 			{	// construct with null node pointer

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 194  : 			}

  00003	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator::iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00002	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator::iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = eax

; 284  : 			return (_Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 285  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = eax
; __Right$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	2b 01		 sub	 eax, DWORD PTR [ecx]
  00004	f7 d8		 neg	 eax
  00006	1b c0		 sbb	 eax, eax
  00008	40		 inc	 eax

; 242  : 			}

  00009	c3		 ret	 0
??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax

; 193  : 			{	// construct with null node pointer

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 194  : 			}

  00003	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator::iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00002	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator::iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = eax

; 284  : 			return (_Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 285  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = eax
; __Right$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	2b 01		 sub	 eax, DWORD PTR [ecx]
  00004	f7 d8		 neg	 eax
  00006	1b c0		 sbb	 eax, eax
  00008	40		 inc	 eax

; 242  : 			}

  00009	c3		 ret	 0
??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax

; 193  : 			{	// construct with null node pointer

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 194  : 			}

  00003	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = eax

; 284  : 			return (_Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 285  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = eax
; __Right$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	2b 01		 sub	 eax, DWORD PTR [ecx]
  00004	f7 d8		 neg	 eax
  00006	1b c0		 sbb	 eax, eax
  00008	40		 inc	 eax

; 242  : 			}

  00009	c3		 ret	 0
??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax

; 193  : 			{	// construct with null node pointer

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 194  : 			}

  00003	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = eax

; 284  : 			return (_Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 285  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = eax
; __Right$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	2b 01		 sub	 eax, DWORD PTR [ecx]
  00004	f7 d8		 neg	 eax
  00006	1b c0		 sbb	 eax, eax
  00008	40		 inc	 eax

; 242  : 			}

  00009	c3		 ret	 0
??8const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax

; 193  : 			{	// construct with null node pointer

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 194  : 			}

  00003	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator::iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00002	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator::iterator
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVSub@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHPAVSub@@@std@@@std@@QAE@XZ PROC NEAR ; std::allocator<std::pair<int const ,Sub *> >::allocator<std::pair<int const ,Sub *> >, COMDAT
; _this$ = eax

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHPAVSub@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<int const ,Sub *> >::allocator<std::pair<int const ,Sub *> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Lmost, COMDAT
; _this$ = eax

; 1005 : 		return (_Left(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1006 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Lmost
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::size, COMDAT
; _this$ = eax

; 448  : 		return (_Mysize);

  00000	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 449  : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Key@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Key, COMDAT
; __Pnode$ = eax

; 142  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 143  : 		}

  00003	c3		 ret	 0
?_Key@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Key
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVSE@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHPAVSE@@@std@@@std@@QAE@XZ PROC NEAR ; std::allocator<std::pair<int const ,SE *> >::allocator<std::pair<int const ,SE *> >, COMDAT
; _this$ = eax

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHPAVSE@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<int const ,SE *> >::allocator<std::pair<int const ,SE *> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00005	c3		 ret	 0
?end@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::end
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Key@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Key, COMDAT
; __Pnode$ = eax

; 142  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 143  : 		}

  00003	c3		 ret	 0
?_Key@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Key
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@std@@QAE@XZ PROC NEAR ; std::allocator<std::pair<int const ,BGM *> >::allocator<std::pair<int const ,BGM *> >, COMDAT
; _this$ = eax

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<int const ,BGM *> >::allocator<std::pair<int const ,BGM *> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00005	c3		 ret	 0
?end@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::end
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Key@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Key, COMDAT
; __Pnode$ = eax

; 142  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 143  : 		}

  00003	c3		 ret	 0
?_Key@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Key
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@std@@QAE@XZ PROC NEAR ; std::allocator<std::pair<int const ,Envelop *> >::allocator<std::pair<int const ,Envelop *> >, COMDAT
; _this$ = eax

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<int const ,Envelop *> >::allocator<std::pair<int const ,Envelop *> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Lmost, COMDAT
; _this$ = eax

; 1005 : 		return (_Left(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1006 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Lmost
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::size, COMDAT
; _this$ = eax

; 448  : 		return (_Mysize);

  00000	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 449  : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Key@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Key, COMDAT
; __Pnode$ = eax

; 142  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 143  : 		}

  00003	c3		 ret	 0
?_Key@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Key
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVN163@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHPAVN163@@@std@@@std@@QAE@XZ PROC NEAR ; std::allocator<std::pair<int const ,N163 *> >::allocator<std::pair<int const ,N163 *> >, COMDAT
; _this$ = eax

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHPAVN163@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<int const ,N163 *> >::allocator<std::pair<int const ,N163 *> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Lmost, COMDAT
; _this$ = eax

; 1005 : 		return (_Left(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1006 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Lmost
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::size, COMDAT
; _this$ = eax

; 448  : 		return (_Mysize);

  00000	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 449  : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Key@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Key, COMDAT
; __Pnode$ = eax

; 142  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 143  : 		}

  00003	c3		 ret	 0
?_Key@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Key
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@std@@QAE@XZ PROC NEAR ; std::allocator<std::pair<int const ,VRC7 *> >::allocator<std::pair<int const ,VRC7 *> >, COMDAT
; _this$ = eax

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<int const ,VRC7 *> >::allocator<std::pair<int const ,VRC7 *> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Lmost, COMDAT
; _this$ = eax

; 1005 : 		return (_Left(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1006 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Lmost
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::size, COMDAT
; _this$ = eax

; 448  : 		return (_Mysize);

  00000	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 449  : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Key@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Key, COMDAT
; __Pnode$ = eax

; 142  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 143  : 		}

  00003	c3		 ret	 0
?_Key@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Key
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@std@@QAE@XZ PROC NEAR ; std::allocator<std::pair<int const ,FDSM *> >::allocator<std::pair<int const ,FDSM *> >, COMDAT
; _this$ = eax

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<int const ,FDSM *> >::allocator<std::pair<int const ,FDSM *> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Lmost, COMDAT
; _this$ = eax

; 1005 : 		return (_Left(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1006 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Lmost
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::size, COMDAT
; _this$ = eax

; 448  : 		return (_Mysize);

  00000	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 449  : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Key@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Key, COMDAT
; __Pnode$ = eax

; 142  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 143  : 		}

  00003	c3		 ret	 0
?_Key@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Key
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@std@@QAE@XZ PROC NEAR ; std::allocator<std::pair<int const ,FDSC *> >::allocator<std::pair<int const ,FDSC *> >, COMDAT
; _this$ = eax

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<int const ,FDSC *> >::allocator<std::pair<int const ,FDSC *> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Lmost, COMDAT
; _this$ = eax

; 1005 : 		return (_Left(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1006 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Lmost
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::size, COMDAT
; _this$ = eax

; 448  : 		return (_Mysize);

  00000	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 449  : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Key@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Key, COMDAT
; __Pnode$ = eax

; 142  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 143  : 		}

  00003	c3		 ret	 0
?_Key@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Key
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?end@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<MusicItem *,std::allocator<MusicItem *> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 387  : 		return (iterator(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	89 08		 mov	 DWORD PTR [eax], ecx

; 388  : 		}

  00005	c3		 ret	 0
?end@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<MusicItem *,std::allocator<MusicItem *> >::end
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\streambuf
_TEXT	ENDS
;	COMDAT ?sgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPADH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?sgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPADH@Z PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::sgetn, COMDAT
; _this$ = ecx

; 113  : 		return (xsgetn(_Ptr, _Count));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	ff 60 18	 jmp	 DWORD PTR [eax+24]
?sgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPADH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sgetn
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 246  : 			return (!(*this == _Right));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	33 c9		 xor	 ecx, ecx
  00004	3b 02		 cmp	 eax, DWORD PTR [edx]
  00006	0f 95 c1	 setne	 cl
  00009	8a c1		 mov	 al, cl

; 247  : 			}

  0000b	c3		 ret	 0
??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator::iterator, COMDAT
; _this$ = eax

; 304  : 		iterator()

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 305  : 			{	// construct with null node pointer
; 306  : 			}

  00003	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator::iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 246  : 			return (!(*this == _Right));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	33 c9		 xor	 ecx, ecx
  00004	3b 02		 cmp	 eax, DWORD PTR [edx]
  00006	0f 95 c1	 setne	 cl
  00009	8a c1		 mov	 al, cl

; 247  : 			}

  0000b	c3		 ret	 0
??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator::iterator, COMDAT
; _this$ = eax

; 304  : 		iterator()

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 305  : 			{	// construct with null node pointer
; 306  : 			}

  00003	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator::iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 246  : 			return (!(*this == _Right));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	33 c9		 xor	 ecx, ecx
  00004	3b 02		 cmp	 eax, DWORD PTR [edx]
  00006	0f 95 c1	 setne	 cl
  00009	8a c1		 mov	 al, cl

; 247  : 			}

  0000b	c3		 ret	 0
??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator::iterator, COMDAT
; _this$ = eax

; 304  : 		iterator()

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 305  : 			{	// construct with null node pointer
; 306  : 			}

  00003	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator::iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 246  : 			return (!(*this == _Right));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	33 c9		 xor	 ecx, ecx
  00004	3b 02		 cmp	 eax, DWORD PTR [edx]
  00006	0f 95 c1	 setne	 cl
  00009	8a c1		 mov	 al, cl

; 247  : 			}

  0000b	c3		 ret	 0
??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator::iterator, COMDAT
; _this$ = eax

; 304  : 		iterator()

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 305  : 			{	// construct with null node pointer
; 306  : 			}

  00003	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator::iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 246  : 			return (!(*this == _Right));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	33 c9		 xor	 ecx, ecx
  00004	3b 02		 cmp	 eax, DWORD PTR [edx]
  00006	0f 95 c1	 setne	 cl
  00009	8a c1		 mov	 al, cl

; 247  : 			}

  0000b	c3		 ret	 0
??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator::iterator, COMDAT
; _this$ = eax

; 304  : 		iterator()

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 305  : 			{	// construct with null node pointer
; 306  : 			}

  00003	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator::iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator::iterator, COMDAT
; _this$ = eax

; 304  : 		iterator()

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 305  : 			{	// construct with null node pointer
; 306  : 			}

  00003	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator::iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator::iterator, COMDAT
; _this$ = eax

; 304  : 		iterator()

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 305  : 			{	// construct with null node pointer
; 306  : 			}

  00003	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator::iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 246  : 			return (!(*this == _Right));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	33 c9		 xor	 ecx, ecx
  00004	3b 02		 cmp	 eax, DWORD PTR [edx]
  00006	0f 95 c1	 setne	 cl
  00009	8a c1		 mov	 al, cl

; 247  : 			}

  0000b	c3		 ret	 0
??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator::iterator, COMDAT
; _this$ = eax

; 304  : 		iterator()

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 305  : 			{	// construct with null node pointer
; 306  : 			}

  00003	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator::iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE_NXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::empty, COMDAT
; _this$ = ecx

; 458  : 		return (size() == 0);

  00000	33 c0		 xor	 eax, eax
  00002	39 41 08	 cmp	 DWORD PTR [ecx+8], eax
  00005	0f 94 c0	 sete	 al

; 459  : 		}

  00008	c3		 ret	 0
?empty@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE_NXZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::empty
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00005	c3		 ret	 0
?end@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::end
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?begin@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 		}

  00007	c3		 ret	 0
?begin@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::begin
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE_NXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::empty, COMDAT
; _this$ = ecx

; 458  : 		return (size() == 0);

  00000	33 c0		 xor	 eax, eax
  00002	39 41 08	 cmp	 DWORD PTR [ecx+8], eax
  00005	0f 94 c0	 sete	 al

; 459  : 		}

  00008	c3		 ret	 0
?empty@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE_NXZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::empty
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00005	c3		 ret	 0
?end@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::end
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?begin@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 		}

  00007	c3		 ret	 0
?begin@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::begin
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE_NXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::empty, COMDAT
; _this$ = ecx

; 458  : 		return (size() == 0);

  00000	33 c0		 xor	 eax, eax
  00002	39 41 08	 cmp	 DWORD PTR [ecx+8], eax
  00005	0f 94 c0	 sete	 al

; 459  : 		}

  00008	c3		 ret	 0
?empty@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE_NXZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::empty
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00005	c3		 ret	 0
?end@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::end
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?begin@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 		}

  00007	c3		 ret	 0
?begin@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::begin
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE_NXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::empty, COMDAT
; _this$ = ecx

; 458  : 		return (size() == 0);

  00000	33 c0		 xor	 eax, eax
  00002	39 41 08	 cmp	 DWORD PTR [ecx+8], eax
  00005	0f 94 c0	 sete	 al

; 459  : 		}

  00008	c3		 ret	 0
?empty@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE_NXZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::empty
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00005	c3		 ret	 0
?end@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::end
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?begin@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 		}

  00007	c3		 ret	 0
?begin@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::begin
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE_NXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::empty, COMDAT
; _this$ = ecx

; 458  : 		return (size() == 0);

  00000	33 c0		 xor	 eax, eax
  00002	39 41 08	 cmp	 DWORD PTR [ecx+8], eax
  00005	0f 94 c0	 sete	 al

; 459  : 		}

  00008	c3		 ret	 0
?empty@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE_NXZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::empty
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00005	c3		 ret	 0
?end@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::end
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?begin@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 		}

  00007	c3		 ret	 0
?begin@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::begin
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE_NXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::empty, COMDAT
; _this$ = ecx

; 458  : 		return (size() == 0);

  00000	33 c0		 xor	 eax, eax
  00002	39 41 08	 cmp	 DWORD PTR [ecx+8], eax
  00005	0f 94 c0	 sete	 al

; 459  : 		}

  00008	c3		 ret	 0
?empty@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE_NXZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::empty
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00005	c3		 ret	 0
?end@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::end
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?begin@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 		}

  00007	c3		 ret	 0
?begin@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::begin
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\streambuf
;	COMDAT ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc, COMDAT
; _this$ = ecx

; 101  : 		return (gptr() != 0 && gptr() < egptr()
; 102  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 20		 je	 SHORT $L46520
  00008	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	8b 12		 mov	 edx, DWORD PTR [edx]
  0000f	03 d0		 add	 edx, eax
  00011	3b c2		 cmp	 eax, edx
  00013	73 13		 jae	 SHORT $L46520
  00015	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00018	ff 08		 dec	 DWORD PTR [eax]
  0001a	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0001d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001f	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00022	89 11		 mov	 DWORD PTR [ecx], edx
  00024	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 103  : 		}

  00027	c3		 ret	 0
$L46520:

; 101  : 		return (gptr() != 0 && gptr() < egptr()
; 102  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

  00028	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002a	ff 60 14	 jmp	 DWORD PTR [eax+20]
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::sgetc, COMDAT
; _this$ = ecx

; 107  : 		return (gptr() != 0 && gptr() < egptr()
; 108  : 			? _Traits::to_int_type(*gptr()) : underflow());

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]
  00005	85 c0		 test	 eax, eax
  00007	74 16		 je	 SHORT $L46544
  00009	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0000c	8b 12		 mov	 edx, DWORD PTR [edx]
  0000e	56		 push	 esi
  0000f	8b 71 30	 mov	 esi, DWORD PTR [ecx+48]
  00012	8b 36		 mov	 esi, DWORD PTR [esi]
  00014	03 f2		 add	 esi, edx
  00016	3b d6		 cmp	 edx, esi
  00018	5e		 pop	 esi
  00019	73 04		 jae	 SHORT $L46544
  0001b	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 109  : 		}

  0001e	c3		 ret	 0
$L46544:

; 107  : 		return (gptr() != 0 && gptr() < egptr()
; 108  : 			? _Traits::to_int_type(*gptr()) : underflow());

  0001f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00021	ff 60 10	 jmp	 DWORD PTR [eax+16]
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
_TEXT	ENDS
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT
??1ctype_base@std@@UAE@XZ PROC NEAR			; std::ctype_base::~ctype_base, COMDAT
; _this$ = ecx

; 907  : 		}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7facet@locale@std@@6B@
  00006	c3		 ret	 0
??1ctype_base@std@@UAE@XZ ENDP				; std::ctype_base::~ctype_base
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC NEAR			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1ctype_base@std@@UAE@XZ ; std::ctype_base::~ctype_base
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 07		 je	 SHORT $L5521
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	59		 pop	 ecx
$L5521:
  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi
  00019	c2 04 00	 ret	 4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT
__Refs$ = 8						; size = 4
??0ctype_base@std@@QAE@I@Z PROC NEAR			; std::ctype_base::ctype_base, COMDAT
; _this$ = ecx

; 902  : 		{	// default constructor

  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Refs$[esp-4]
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7ctype_base@std@@6B@

; 903  : 		}

  0000f	c2 04 00	 ret	 4
??0ctype_base@std@@QAE@I@Z ENDP				; std::ctype_base::ctype_base
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T46599	DD	0ffffffffH
	DD	FLAT:$L46586
$T46597	DD	019930520H
	DD	01H
	DD	FLAT:$T46599
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
xdata$x	ENDS
;	COMDAT ??0?$ctype@D@std@@QAE@PBF_NI@Z
_TEXT	SEGMENT
$T46585 = -132						; size = 116
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Table$ = 8						; size = 4
__Deletetable$ = 12					; size = 1
__Refs$ = 16						; size = 4
??0?$ctype@D@std@@QAE@PBF_NI@Z PROC NEAR		; std::ctype<char>::ctype<char>, COMDAT
; _this$ = ecx

; 1220 : 		{	// construct with specified table and delete flag for table

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$??0?$ctype@D@std@@QAE@PBF_NI@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 78	 sub	 esp, 120		; 00000078H
  0000d	8b 45 10	 mov	 eax, DWORD PTR __Refs$[ebp]
  00010	56		 push	 esi
  00011	8b f1		 mov	 esi, ecx
  00013	57		 push	 edi
  00014	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00017	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0001a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1221 : 		_Init(_Locinfo());

  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01GFHCPBMG@C?$AA@
  00023	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T46585[ebp]
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7?$ctype@D@std@@6B@
  0002f	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00034	50		 push	 eax
  00035	8b ce		 mov	 ecx, esi
  00037	e8 00 00 00 00	 call	 ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ; std::ctype<char>::_Init
  0003c	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T46585[ebp]
  00042	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo

; 1222 : 		if (_Table != 0)

  00047	8b 7d 08	 mov	 edi, DWORD PTR __Table$[ebp]
  0004a	85 ff		 test	 edi, edi
  0004c	74 14		 je	 SHORT $L5868

; 1223 : 			{	// replace existing char to mask table
; 1224 : 			_Tidy();

  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?_Tidy@?$ctype@D@std@@IAEXXZ ; std::ctype<char>::_Tidy

; 1225 : 			_Ctype._Table = _Table;
; 1226 : 			_Ctype._Delfl = _Deletetable ? -1 : 0;

  00055	8a 45 0c	 mov	 al, BYTE PTR __Deletetable$[ebp]
  00058	f6 d8		 neg	 al
  0005a	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0005d	1b c0		 sbb	 eax, eax
  0005f	89 46 14	 mov	 DWORD PTR [esi+20], eax
$L5868:

; 1227 : 			}
; 1228 : 		}

  00062	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00065	5f		 pop	 edi
  00066	8b c6		 mov	 eax, esi
  00068	5e		 pop	 esi
  00069	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00070	c9		 leave
  00071	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L46586:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ctype_base@std@@UAE@XZ ; std::ctype_base::~ctype_base
__ehhandler$??0?$ctype@D@std@@QAE@PBF_NI@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T46597
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0?$ctype@D@std@@QAE@PBF_NI@Z ENDP			; std::ctype<char>::ctype<char>
;	COMDAT xdata$x
xdata$x	SEGMENT
$T46612	DD	0ffffffffH
	DD	FLAT:$L46608
$T46610	DD	019930520H
	DD	01H
	DD	FLAT:$T46612
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
xdata$x	ENDS
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T46605 = 8						; size = 4
__Ppf$ = 8						; size = 4
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z PROC NEAR ; std::ctype<char>::_Getcat, COMDAT

; 1237 : 		{	// construct from specified locale

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 1238 : 		if (_Ppf != 0 && *_Ppf == 0)

  0000c	8b 7d 08	 mov	 edi, DWORD PTR __Ppf$[ebp]
  0000f	33 f6		 xor	 esi, esi
  00011	3b fe		 cmp	 edi, esi
  00013	74 26		 je	 SHORT $L5872
  00015	39 37		 cmp	 DWORD PTR [edi], esi
  00017	75 22		 jne	 SHORT $L5872

; 1239 : 			*_Ppf = _NEW_CRT ctype<_Elem>;

  00019	6a 18		 push	 24			; 00000018H
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00020	59		 pop	 ecx
  00021	8b c8		 mov	 ecx, eax
  00023	89 4d 08	 mov	 DWORD PTR $T46605[ebp], ecx
  00026	3b ce		 cmp	 ecx, esi
  00028	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  0002b	74 0a		 je	 SHORT $L46606
  0002d	56		 push	 esi
  0002e	56		 push	 esi
  0002f	56		 push	 esi
  00030	e8 00 00 00 00	 call	 ??0?$ctype@D@std@@QAE@PBF_NI@Z ; std::ctype<char>::ctype<char>
  00035	eb 02		 jmp	 SHORT $L46607
$L46606:
  00037	33 c0		 xor	 eax, eax
$L46607:
  00039	89 07		 mov	 DWORD PTR [edi], eax
$L5872:

; 1240 : 		return (_X_CTYPE);
; 1241 : 		}

  0003b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003e	6a 02		 push	 2
  00040	58		 pop	 eax
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0004a	c9		 leave
  0004b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L46608:
  00000	ff 75 08	 push	 DWORD PTR $T46605[ebp]
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx
  00009	c3		 ret	 0
__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z:
  0000a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T46610
  0000f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z ENDP	; std::ctype<char>::_Getcat
;	COMDAT xdata$x
xdata$x	SEGMENT
$T46624	DD	0ffffffffH
	DD	FLAT:$L46619
$T46621	DD	019930520H
	DD	01H
	DD	FLAT:$T46624
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T46617 = -32						; size = 12
__Lock$ = -20						; size = 4
__Psave$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC NEAR ; std::use_facet<std::ctype<char> >, COMDAT

; 315  : 	{	// get facet reference from locale

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 14	 sub	 esp, 20			; 00000014H
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 316  : 	_Lockit _Lock(_LOCK_LOCALE);	// the thread lock, make get atomic

  0000f	6a 00		 push	 0
  00011	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00014	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00019	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 	const locale::facet *_Psave =
; 318  : 		_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  0001d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave

; 319  : 
; 320  : 	size_t _Id = _Facet::id;

  00023	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
  00028	89 75 f0	 mov	 DWORD PTR __Psave$[ebp], esi
  0002b	e8 00 00 00 00	 call	 ??Bid@locale@std@@QAEIXZ ; std::locale::id::operator unsigned int

; 321  : 	const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00030	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
  00039	8b f8		 mov	 edi, eax

; 322  : 
; 323  : 	if (_Pf != 0)

  0003b	85 ff		 test	 edi, edi
  0003d	75 49		 jne	 SHORT $L23850

; 324  : 		;	// got facet from locale
; 325  : 	else if (_Psave != 0)

  0003f	85 f6		 test	 esi, esi
  00041	74 04		 je	 SHORT $L23836

; 326  : 		_Pf = _Psave;	// lazy facet already allocated

  00043	8b fe		 mov	 edi, esi

; 327  : 	else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

  00045	eb 41		 jmp	 SHORT $L23850
$L23836:
  00047	8d 45 f0	 lea	 eax, DWORD PTR __Psave$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z ; std::ctype<char>::_Getcat
  00050	83 f8 ff	 cmp	 eax, -1
  00053	59		 pop	 ecx
  00054	75 1b		 jne	 SHORT $L23839

; 328  : 
; 329  :  #if _HAS_EXCEPTIONS
; 330  : 		throw bad_cast();	// lazy disallowed

  00056	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
  0005b	8d 4d e0	 lea	 ecx, DWORD PTR $T46617[ebp]
  0005e	e8 00 00 00 00	 call	 ??0bad_cast@@QAE@PBD@Z	; bad_cast::bad_cast
  00063	68 00 00 00 00	 push	 OFFSET FLAT:__TI2?AVbad_cast@@
  00068	8d 45 e0	 lea	 eax, DWORD PTR $T46617[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 __CxxThrowException@8
$L46625:
$L23839:

; 331  : 
; 332  :  #else /* _HAS_EXCEPTIONS */
; 333  : 		abort();	// lazy disallowed
; 334  :  #endif /* _HAS_EXCEPTIONS */
; 335  : 
; 336  : 	else
; 337  : 		{	// queue up lazy facet for destruction
; 338  : 		_Pf = _Psave;

  00071	8b 7d f0	 mov	 edi, DWORD PTR __Psave$[ebp]

; 339  : 		_Facetptr<_Facet>::_Psave = _Psave;
; 340  : 
; 341  : 		locale::facet *_Pfmod = (_Facet *)_Psave;
; 342  : 		_Pfmod->_Incref();

  00074	8b cf		 mov	 ecx, edi
  00076	89 3d 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, edi ; std::_Facetptr<std::ctype<char> >::_Psave
  0007c	e8 00 00 00 00	 call	 ?_Incref@facet@locale@std@@QAEXXZ ; std::locale::facet::_Incref

; 343  : 		_Pfmod->_Register();

  00081	8b cf		 mov	 ecx, edi
  00083	e8 00 00 00 00	 call	 ?_Register@facet@locale@std@@QAEXXZ ; std::locale::facet::_Register
$L23850:

; 344  : 		}
; 345  : 
; 346  : 	return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00088	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0008c	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$[ebp]
  0008f	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit

; 347  : 	}

  00094	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00097	8b c7		 mov	 eax, edi
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a2	c9		 leave
  000a3	c3		 ret	 0
$L46623:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L46619:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T46621
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = esi
; __Istr$ = eax

; 52   : 			{	// lock the stream buffer, if there

  00000	89 06		 mov	 DWORD PTR [esi], eax

; 53   : 			if (_Myistr.rdbuf() != 0)

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	8b 44 01 28	 mov	 eax, DWORD PTR [ecx+eax+40]
  0000b	85 c0		 test	 eax, eax
  0000d	74 08		 je	 SHORT $L46639

; 54   : 				_Myistr.rdbuf()->_Lock();

  0000f	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00012	e8 00 00 00 00	 call	 ?_Lock@_Mutex@std@@QAEXXZ ; std::_Mutex::_Lock
$L46639:

; 55   : 			}

  00017	8b c6		 mov	 eax, esi
  00019	c3		 ret	 0
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = eax

; 59   : 			if (_Myistr.rdbuf() != 0)

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	8b 44 01 28	 mov	 eax, DWORD PTR [ecx+eax+40]
  0000b	85 c0		 test	 eax, eax
  0000d	74 08		 je	 SHORT $L46653

; 60   : 				_Myistr.rdbuf()->_Unlock();

  0000f	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00012	e9 00 00 00 00	 jmp	 ?_Unlock@_Mutex@std@@QAEXXZ ; std::_Mutex::_Unlock
$L46653:

; 61   : 			}

  00017	c3		 ret	 0
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = eax
  00000	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node *>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $L46663
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
$L46663:

; 43   : 	}

  00008	c3		 ret	 0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node *>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $L46672
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
$L46672:

; 43   : 	}

  00008	c3		 ret	 0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node *>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $L46681
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
$L46681:

; 43   : 	}

  00008	c3		 ret	 0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node *>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $L46690
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
$L46690:

; 43   : 	}

  00008	c3		 ret	 0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node *>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $L46699
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
$L46699:

; 43   : 	}

  00008	c3		 ret	 0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node *>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $L46708
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
$L46708:

; 43   : 	}

  00008	c3		 ret	 0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node *>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $L46717
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
$L46717:

; 43   : 	}

  00008	c3		 ret	 0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node *>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $L46726
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
$L46726:

; 43   : 	}

  00008	c3		 ret	 0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node *>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $L46744
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
$L46744:

; 148  : 		}

  00008	c3		 ret	 0
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node *>::construct
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Min@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Min, COMDAT
; __Pnode$ = eax

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00000	eb 02		 jmp	 SHORT $L46763
$L31797:

; 1043 : 			_Pnode = _Left(_Pnode);

  00002	8b c1		 mov	 eax, ecx
$L46763:

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	74 f6		 je	 SHORT $L31797

; 1044 : 		return (_Pnode);
; 1045 : 		}

  0000c	c3		 ret	 0
?_Min@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Min
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Max@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Max, COMDAT
; __Pnode$ = eax

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00000	eb 02		 jmp	 SHORT $L46779
$L31793:

; 1036 : 			_Pnode = _Right(_Pnode);

  00002	8b c1		 mov	 eax, ecx
$L46779:

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00004	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00007	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000b	74 f5		 je	 SHORT $L31793

; 1037 : 		return (_Pnode);
; 1038 : 		}

  0000d	c3		 ret	 0
?_Max@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Max
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 890  : 		{	// free entire subtree, recursively

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 891  : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR __Rootnode$[esp+8]
  00007	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  0000b	8b d9		 mov	 ebx, ecx
  0000d	8b f7		 mov	 esi, edi
  0000f	75 1b		 jne	 SHORT $L31790
$L31788:

; 892  : 			{	// free subtrees, then node
; 893  : 			_Erase(_Right(_Pnode));

  00011	ff 76 08	 push	 DWORD PTR [esi+8]
  00014	8b cb		 mov	 ecx, ebx
  00016	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Erase

; 894  : 			_Pnode = _Left(_Pnode);

  0001b	8b 36		 mov	 esi, DWORD PTR [esi]

; 895  : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 896  : 			this->_Alnod.deallocate(_Rootnode, 1);

  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00023	80 7e 15 00	 cmp	 BYTE PTR [esi+21], 0
  00027	59		 pop	 ecx
  00028	8b fe		 mov	 edi, esi
  0002a	74 e5		 je	 SHORT $L31788
$L31790:
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx

; 897  : 			}
; 898  : 		}

  0002f	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Erase
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node *>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $L46818
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
$L46818:

; 148  : 		}

  00008	c3		 ret	 0
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node *>::construct
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Min@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Min, COMDAT
; __Pnode$ = eax

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00000	eb 02		 jmp	 SHORT $L46837
$L31751:

; 1043 : 			_Pnode = _Left(_Pnode);

  00002	8b c1		 mov	 eax, ecx
$L46837:

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	74 f6		 je	 SHORT $L31751

; 1044 : 		return (_Pnode);
; 1045 : 		}

  0000c	c3		 ret	 0
?_Min@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Min
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Max@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Max, COMDAT
; __Pnode$ = eax

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00000	eb 02		 jmp	 SHORT $L46853
$L31747:

; 1036 : 			_Pnode = _Right(_Pnode);

  00002	8b c1		 mov	 eax, ecx
$L46853:

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00004	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00007	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000b	74 f5		 je	 SHORT $L31747

; 1037 : 		return (_Pnode);
; 1038 : 		}

  0000d	c3		 ret	 0
?_Max@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Max
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 890  : 		{	// free entire subtree, recursively

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 891  : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR __Rootnode$[esp+8]
  00007	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  0000b	8b d9		 mov	 ebx, ecx
  0000d	8b f7		 mov	 esi, edi
  0000f	75 1b		 jne	 SHORT $L31744
$L31742:

; 892  : 			{	// free subtrees, then node
; 893  : 			_Erase(_Right(_Pnode));

  00011	ff 76 08	 push	 DWORD PTR [esi+8]
  00014	8b cb		 mov	 ecx, ebx
  00016	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Erase

; 894  : 			_Pnode = _Left(_Pnode);

  0001b	8b 36		 mov	 esi, DWORD PTR [esi]

; 895  : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 896  : 			this->_Alnod.deallocate(_Rootnode, 1);

  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00023	80 7e 15 00	 cmp	 BYTE PTR [esi+21], 0
  00027	59		 pop	 ecx
  00028	8b fe		 mov	 edi, esi
  0002a	74 e5		 je	 SHORT $L31742
$L31744:
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx

; 897  : 			}
; 898  : 		}

  0002f	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Erase
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node *>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $L46892
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
$L46892:

; 148  : 		}

  00008	c3		 ret	 0
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node *>::construct
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Min@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Min, COMDAT
; __Pnode$ = eax

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00000	eb 02		 jmp	 SHORT $L46911
$L31705:

; 1043 : 			_Pnode = _Left(_Pnode);

  00002	8b c1		 mov	 eax, ecx
$L46911:

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	74 f6		 je	 SHORT $L31705

; 1044 : 		return (_Pnode);
; 1045 : 		}

  0000c	c3		 ret	 0
?_Min@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Min
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Max@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Max, COMDAT
; __Pnode$ = eax

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00000	eb 02		 jmp	 SHORT $L46927
$L31701:

; 1036 : 			_Pnode = _Right(_Pnode);

  00002	8b c1		 mov	 eax, ecx
$L46927:

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00004	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00007	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000b	74 f5		 je	 SHORT $L31701

; 1037 : 		return (_Pnode);
; 1038 : 		}

  0000d	c3		 ret	 0
?_Max@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Max
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 890  : 		{	// free entire subtree, recursively

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 891  : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR __Rootnode$[esp+8]
  00007	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  0000b	8b d9		 mov	 ebx, ecx
  0000d	8b f7		 mov	 esi, edi
  0000f	75 1b		 jne	 SHORT $L31698
$L31696:

; 892  : 			{	// free subtrees, then node
; 893  : 			_Erase(_Right(_Pnode));

  00011	ff 76 08	 push	 DWORD PTR [esi+8]
  00014	8b cb		 mov	 ecx, ebx
  00016	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Erase

; 894  : 			_Pnode = _Left(_Pnode);

  0001b	8b 36		 mov	 esi, DWORD PTR [esi]

; 895  : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 896  : 			this->_Alnod.deallocate(_Rootnode, 1);

  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00023	80 7e 15 00	 cmp	 BYTE PTR [esi+21], 0
  00027	59		 pop	 ecx
  00028	8b fe		 mov	 edi, esi
  0002a	74 e5		 je	 SHORT $L31696
$L31698:
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx

; 897  : 			}
; 898  : 		}

  0002f	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Erase
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node *>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $L46966
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
$L46966:

; 148  : 		}

  00008	c3		 ret	 0
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node *>::construct
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Min@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Min, COMDAT
; __Pnode$ = eax

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00000	eb 02		 jmp	 SHORT $L46985
$L31659:

; 1043 : 			_Pnode = _Left(_Pnode);

  00002	8b c1		 mov	 eax, ecx
$L46985:

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	74 f6		 je	 SHORT $L31659

; 1044 : 		return (_Pnode);
; 1045 : 		}

  0000c	c3		 ret	 0
?_Min@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Min
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Max@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Max, COMDAT
; __Pnode$ = eax

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00000	eb 02		 jmp	 SHORT $L47001
$L31655:

; 1036 : 			_Pnode = _Right(_Pnode);

  00002	8b c1		 mov	 eax, ecx
$L47001:

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00004	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00007	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000b	74 f5		 je	 SHORT $L31655

; 1037 : 		return (_Pnode);
; 1038 : 		}

  0000d	c3		 ret	 0
?_Max@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Max
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 890  : 		{	// free entire subtree, recursively

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 891  : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR __Rootnode$[esp+8]
  00007	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  0000b	8b d9		 mov	 ebx, ecx
  0000d	8b f7		 mov	 esi, edi
  0000f	75 1b		 jne	 SHORT $L31652
$L31650:

; 892  : 			{	// free subtrees, then node
; 893  : 			_Erase(_Right(_Pnode));

  00011	ff 76 08	 push	 DWORD PTR [esi+8]
  00014	8b cb		 mov	 ecx, ebx
  00016	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Erase

; 894  : 			_Pnode = _Left(_Pnode);

  0001b	8b 36		 mov	 esi, DWORD PTR [esi]

; 895  : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 896  : 			this->_Alnod.deallocate(_Rootnode, 1);

  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00023	80 7e 15 00	 cmp	 BYTE PTR [esi+21], 0
  00027	59		 pop	 ecx
  00028	8b fe		 mov	 edi, esi
  0002a	74 e5		 je	 SHORT $L31650
$L31652:
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx

; 897  : 			}
; 898  : 		}

  0002f	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Erase
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node *>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $L47040
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
$L47040:

; 148  : 		}

  00008	c3		 ret	 0
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node *>::construct
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Min@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Min, COMDAT
; __Pnode$ = eax

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00000	eb 02		 jmp	 SHORT $L47059
$L31613:

; 1043 : 			_Pnode = _Left(_Pnode);

  00002	8b c1		 mov	 eax, ecx
$L47059:

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	74 f6		 je	 SHORT $L31613

; 1044 : 		return (_Pnode);
; 1045 : 		}

  0000c	c3		 ret	 0
?_Min@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Min
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Max@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Max, COMDAT
; __Pnode$ = eax

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00000	eb 02		 jmp	 SHORT $L47075
$L31609:

; 1036 : 			_Pnode = _Right(_Pnode);

  00002	8b c1		 mov	 eax, ecx
$L47075:

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00004	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00007	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000b	74 f5		 je	 SHORT $L31609

; 1037 : 		return (_Pnode);
; 1038 : 		}

  0000d	c3		 ret	 0
?_Max@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Max
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 890  : 		{	// free entire subtree, recursively

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 891  : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR __Rootnode$[esp+8]
  00007	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  0000b	8b d9		 mov	 ebx, ecx
  0000d	8b f7		 mov	 esi, edi
  0000f	75 1b		 jne	 SHORT $L31606
$L31604:

; 892  : 			{	// free subtrees, then node
; 893  : 			_Erase(_Right(_Pnode));

  00011	ff 76 08	 push	 DWORD PTR [esi+8]
  00014	8b cb		 mov	 ecx, ebx
  00016	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Erase

; 894  : 			_Pnode = _Left(_Pnode);

  0001b	8b 36		 mov	 esi, DWORD PTR [esi]

; 895  : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 896  : 			this->_Alnod.deallocate(_Rootnode, 1);

  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00023	80 7e 15 00	 cmp	 BYTE PTR [esi+21], 0
  00027	59		 pop	 ecx
  00028	8b fe		 mov	 edi, esi
  0002a	74 e5		 je	 SHORT $L31604
$L31606:
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx

; 897  : 			}
; 898  : 		}

  0002f	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Erase
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node *>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $L47113
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
$L47113:

; 148  : 		}

  00008	c3		 ret	 0
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node *>::construct
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Min@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Min, COMDAT
; __Pnode$ = eax

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00000	eb 02		 jmp	 SHORT $L47133
$L31567:

; 1043 : 			_Pnode = _Left(_Pnode);

  00002	8b c1		 mov	 eax, ecx
$L47133:

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	74 f6		 je	 SHORT $L31567

; 1044 : 		return (_Pnode);
; 1045 : 		}

  0000c	c3		 ret	 0
?_Min@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Min
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Max@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Max, COMDAT
; __Pnode$ = eax

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00000	eb 02		 jmp	 SHORT $L47149
$L31563:

; 1036 : 			_Pnode = _Right(_Pnode);

  00002	8b c1		 mov	 eax, ecx
$L47149:

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00004	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00007	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000b	74 f5		 je	 SHORT $L31563

; 1037 : 		return (_Pnode);
; 1038 : 		}

  0000d	c3		 ret	 0
?_Max@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Max
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 890  : 		{	// free entire subtree, recursively

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 891  : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR __Rootnode$[esp+8]
  00007	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  0000b	8b d9		 mov	 ebx, ecx
  0000d	8b f7		 mov	 esi, edi
  0000f	75 1b		 jne	 SHORT $L31560
$L31558:

; 892  : 			{	// free subtrees, then node
; 893  : 			_Erase(_Right(_Pnode));

  00011	ff 76 08	 push	 DWORD PTR [esi+8]
  00014	8b cb		 mov	 ecx, ebx
  00016	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Erase

; 894  : 			_Pnode = _Left(_Pnode);

  0001b	8b 36		 mov	 esi, DWORD PTR [esi]

; 895  : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 896  : 			this->_Alnod.deallocate(_Rootnode, 1);

  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00023	80 7e 15 00	 cmp	 BYTE PTR [esi+21], 0
  00027	59		 pop	 ecx
  00028	8b fe		 mov	 edi, esi
  0002a	74 e5		 je	 SHORT $L31558
$L31560:
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx

; 897  : 			}
; 898  : 		}

  0002f	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Erase
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node *>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $L47188
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
$L47188:

; 148  : 		}

  00008	c3		 ret	 0
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node *>::construct
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Min@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Min, COMDAT
; __Pnode$ = eax

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00000	eb 02		 jmp	 SHORT $L47207
$L31521:

; 1043 : 			_Pnode = _Left(_Pnode);

  00002	8b c1		 mov	 eax, ecx
$L47207:

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	74 f6		 je	 SHORT $L31521

; 1044 : 		return (_Pnode);
; 1045 : 		}

  0000c	c3		 ret	 0
?_Min@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Min
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Max@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Max, COMDAT
; __Pnode$ = eax

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00000	eb 02		 jmp	 SHORT $L47223
$L31517:

; 1036 : 			_Pnode = _Right(_Pnode);

  00002	8b c1		 mov	 eax, ecx
$L47223:

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00004	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00007	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000b	74 f5		 je	 SHORT $L31517

; 1037 : 		return (_Pnode);
; 1038 : 		}

  0000d	c3		 ret	 0
?_Max@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Max
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 890  : 		{	// free entire subtree, recursively

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 891  : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR __Rootnode$[esp+8]
  00007	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  0000b	8b d9		 mov	 ebx, ecx
  0000d	8b f7		 mov	 esi, edi
  0000f	75 1b		 jne	 SHORT $L31514
$L31512:

; 892  : 			{	// free subtrees, then node
; 893  : 			_Erase(_Right(_Pnode));

  00011	ff 76 08	 push	 DWORD PTR [esi+8]
  00014	8b cb		 mov	 ecx, ebx
  00016	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Erase

; 894  : 			_Pnode = _Left(_Pnode);

  0001b	8b 36		 mov	 esi, DWORD PTR [esi]

; 895  : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 896  : 			this->_Alnod.deallocate(_Rootnode, 1);

  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00023	80 7e 15 00	 cmp	 BYTE PTR [esi+21], 0
  00027	59		 pop	 ecx
  00028	8b fe		 mov	 edi, esi
  0002a	74 e5		 je	 SHORT $L31512
$L31514:
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx

; 897  : 			}
; 898  : 		}

  0002f	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Erase
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node *>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $L47261
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
$L47261:

; 148  : 		}

  00008	c3		 ret	 0
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node *>::construct
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Min@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Min, COMDAT
; __Pnode$ = eax

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00000	eb 02		 jmp	 SHORT $L47281
$L31475:

; 1043 : 			_Pnode = _Left(_Pnode);

  00002	8b c1		 mov	 eax, ecx
$L47281:

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	74 f6		 je	 SHORT $L31475

; 1044 : 		return (_Pnode);
; 1045 : 		}

  0000c	c3		 ret	 0
?_Min@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Min
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Max@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Max, COMDAT
; __Pnode$ = eax

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00000	eb 02		 jmp	 SHORT $L47297
$L31471:

; 1036 : 			_Pnode = _Right(_Pnode);

  00002	8b c1		 mov	 eax, ecx
$L47297:

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00004	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00007	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000b	74 f5		 je	 SHORT $L31471

; 1037 : 		return (_Pnode);
; 1038 : 		}

  0000d	c3		 ret	 0
?_Max@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Max
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 890  : 		{	// free entire subtree, recursively

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 891  : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR __Rootnode$[esp+8]
  00007	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  0000b	8b d9		 mov	 ebx, ecx
  0000d	8b f7		 mov	 esi, edi
  0000f	75 1b		 jne	 SHORT $L31468
$L31466:

; 892  : 			{	// free subtrees, then node
; 893  : 			_Erase(_Right(_Pnode));

  00011	ff 76 08	 push	 DWORD PTR [esi+8]
  00014	8b cb		 mov	 ecx, ebx
  00016	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Erase

; 894  : 			_Pnode = _Left(_Pnode);

  0001b	8b 36		 mov	 esi, DWORD PTR [esi]

; 895  : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 896  : 			this->_Alnod.deallocate(_Rootnode, 1);

  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00023	80 7e 15 00	 cmp	 BYTE PTR [esi+21], 0
  00027	59		 pop	 ecx
  00028	8b fe		 mov	 edi, esi
  0002a	74 e5		 je	 SHORT $L31466
$L31468:
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx

; 897  : 			}
; 898  : 		}

  0002f	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Erase
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = edx

; 268  : 			if (_Isnil(_Ptr))

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	53		 push	 ebx
  00003	32 db		 xor	 bl, bl
  00005	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00008	75 2a		 jne	 SHORT $L31188

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	38 59 15	 cmp	 BYTE PTR [ecx+21], bl
  00010	75 18		 jne	 SHORT $L47369

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

  00012	eb 02		 jmp	 SHORT $L47373
$L47356:
  00014	8b c8		 mov	 ecx, eax
$L47373:
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  0001b	74 f7		 je	 SHORT $L47356
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  00020	c3		 ret	 0
$L31191:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  00021	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00023	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00026	75 0a		 jne	 SHORT $L31192

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

  00028	89 02		 mov	 DWORD PTR [edx], eax
$L47369:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00030	74 ef		 je	 SHORT $L31191
$L31192:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

  00032	89 02		 mov	 DWORD PTR [edx], eax
$L31188:
  00034	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  00035	c3		 ret	 0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = edx

; 268  : 			if (_Isnil(_Ptr))

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	53		 push	 ebx
  00003	32 db		 xor	 bl, bl
  00005	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00008	75 2a		 jne	 SHORT $L31176

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	38 59 15	 cmp	 BYTE PTR [ecx+21], bl
  00010	75 18		 jne	 SHORT $L47421

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

  00012	eb 02		 jmp	 SHORT $L47425
$L47408:
  00014	8b c8		 mov	 ecx, eax
$L47425:
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  0001b	74 f7		 je	 SHORT $L47408
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  00020	c3		 ret	 0
$L31179:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  00021	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00023	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00026	75 0a		 jne	 SHORT $L31180

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

  00028	89 02		 mov	 DWORD PTR [edx], eax
$L47421:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00030	74 ef		 je	 SHORT $L31179
$L31180:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

  00032	89 02		 mov	 DWORD PTR [edx], eax
$L31176:
  00034	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  00035	c3		 ret	 0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = edx

; 268  : 			if (_Isnil(_Ptr))

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	53		 push	 ebx
  00003	32 db		 xor	 bl, bl
  00005	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00008	75 2a		 jne	 SHORT $L31164

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	38 59 15	 cmp	 BYTE PTR [ecx+21], bl
  00010	75 18		 jne	 SHORT $L47473

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

  00012	eb 02		 jmp	 SHORT $L47477
$L47460:
  00014	8b c8		 mov	 ecx, eax
$L47477:
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  0001b	74 f7		 je	 SHORT $L47460
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  00020	c3		 ret	 0
$L31167:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  00021	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00023	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00026	75 0a		 jne	 SHORT $L31168

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

  00028	89 02		 mov	 DWORD PTR [edx], eax
$L47473:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00030	74 ef		 je	 SHORT $L31167
$L31168:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

  00032	89 02		 mov	 DWORD PTR [edx], eax
$L31164:
  00034	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  00035	c3		 ret	 0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = edx

; 268  : 			if (_Isnil(_Ptr))

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	53		 push	 ebx
  00003	32 db		 xor	 bl, bl
  00005	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00008	75 2a		 jne	 SHORT $L31152

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	38 59 15	 cmp	 BYTE PTR [ecx+21], bl
  00010	75 18		 jne	 SHORT $L47525

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

  00012	eb 02		 jmp	 SHORT $L47529
$L47512:
  00014	8b c8		 mov	 ecx, eax
$L47529:
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  0001b	74 f7		 je	 SHORT $L47512
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  00020	c3		 ret	 0
$L31155:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  00021	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00023	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00026	75 0a		 jne	 SHORT $L31156

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

  00028	89 02		 mov	 DWORD PTR [edx], eax
$L47525:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00030	74 ef		 je	 SHORT $L31155
$L31156:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

  00032	89 02		 mov	 DWORD PTR [edx], eax
$L31152:
  00034	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  00035	c3		 ret	 0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = edx

; 268  : 			if (_Isnil(_Ptr))

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	53		 push	 ebx
  00003	32 db		 xor	 bl, bl
  00005	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00008	75 2a		 jne	 SHORT $L31140

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	38 59 15	 cmp	 BYTE PTR [ecx+21], bl
  00010	75 18		 jne	 SHORT $L47577

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

  00012	eb 02		 jmp	 SHORT $L47581
$L47557:
  00014	8b c8		 mov	 ecx, eax
$L47581:
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  0001b	74 f7		 je	 SHORT $L47557
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  00020	c3		 ret	 0
$L31143:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  00021	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00023	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00026	75 0a		 jne	 SHORT $L31144

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

  00028	89 02		 mov	 DWORD PTR [edx], eax
$L47577:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00030	74 ef		 je	 SHORT $L31143
$L31144:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

  00032	89 02		 mov	 DWORD PTR [edx], eax
$L31140:
  00034	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  00035	c3		 ret	 0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 246  : 			return (!(*this == _Right));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	33 c9		 xor	 ecx, ecx
  00004	3b 02		 cmp	 eax, DWORD PTR [edx]
  00006	0f 95 c1	 setne	 cl
  00009	8a c1		 mov	 al, cl

; 247  : 			}

  0000b	c3		 ret	 0
??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 246  : 			return (!(*this == _Right));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	33 c9		 xor	 ecx, ecx
  00004	3b 02		 cmp	 eax, DWORD PTR [edx]
  00006	0f 95 c1	 setne	 cl
  00009	8a c1		 mov	 al, cl

; 247  : 			}

  0000b	c3		 ret	 0
??9const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = edx

; 268  : 			if (_Isnil(_Ptr))

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	53		 push	 ebx
  00003	32 db		 xor	 bl, bl
  00005	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00008	75 2a		 jne	 SHORT $L31104

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	38 59 15	 cmp	 BYTE PTR [ecx+21], bl
  00010	75 18		 jne	 SHORT $L47641

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

  00012	eb 02		 jmp	 SHORT $L47645
$L47628:
  00014	8b c8		 mov	 ecx, eax
$L47645:
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  0001b	74 f7		 je	 SHORT $L47628
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  00020	c3		 ret	 0
$L31107:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  00021	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00023	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00026	75 0a		 jne	 SHORT $L31108

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

  00028	89 02		 mov	 DWORD PTR [edx], eax
$L47641:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00030	74 ef		 je	 SHORT $L31107
$L31108:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

  00032	89 02		 mov	 DWORD PTR [edx], eax
$L31104:
  00034	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  00035	c3		 ret	 0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z PROC NEAR ; std::_Tree_ptr<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >, COMDAT
; _this$ = eax

; 77   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_ptr@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVSub@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVSub@@@2@D@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Buynode, COMDAT

; 1130 : 		{	// allocate a node with pointers, value, and color

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1131 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00004	6a 18		 push	 24			; 00000018H
  00006	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000b	8b f0		 mov	 esi, eax

; 1132 : 		_TRY_BEGIN
; 1133 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

  0000d	85 f6		 test	 esi, esi
  0000f	59		 pop	 ecx
  00010	74 14		 je	 SHORT $L47676
  00012	ff 75 18	 push	 DWORD PTR __Carg$[ebp]
  00015	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  00018	ff 75 10	 push	 DWORD PTR __Rarg$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR __Larg$[ebp]
  0001e	ff 75 0c	 push	 DWORD PTR __Parg$[ebp]
  00021	e8 00 00 00 00	 call	 ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVSub@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Node::_Node
$L47676:

; 1134 : 		_CATCH_ALL
; 1135 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1136 : 		_RERAISE;
; 1137 : 		_CATCH_END
; 1138 : 		return (_Wherenode);

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi

; 1139 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 14 00	 ret	 20			; 00000014H
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVSub@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Buynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Buynode, COMDAT

; 1106 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 1107 : 		int _Linkcnt = 0;
; 1108 : 
; 1109 : 		_TRY_BEGIN
; 1110 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

  00007	33 d2		 xor	 edx, edx
  00009	3b c2		 cmp	 eax, edx
  0000b	59		 pop	 ecx
  0000c	74 02		 je	 SHORT $L47735
  0000e	89 10		 mov	 DWORD PTR [eax], edx
$L47735:

; 1111 : 		++_Linkcnt;
; 1112 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

  00010	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00013	3b ca		 cmp	 ecx, edx
  00015	74 02		 je	 SHORT $L47762
  00017	89 11		 mov	 DWORD PTR [ecx], edx
$L47762:

; 1113 : 		++_Linkcnt;
; 1114 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

  00019	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  0001c	3b ca		 cmp	 ecx, edx
  0001e	74 02		 je	 SHORT $L47789
  00020	89 11		 mov	 DWORD PTR [ecx], edx
$L47789:

; 1115 : 		_CATCH_ALL
; 1116 : 		if (1 < _Linkcnt)
; 1117 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1118 : 		if (0 < _Linkcnt)
; 1119 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1120 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1121 : 		_RERAISE;
; 1122 : 		_CATCH_END
; 1123 : 		_Color(_Wherenode) = _Black;

  00022	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 1124 : 		_Isnil(_Wherenode) = false;

  00026	88 50 15	 mov	 BYTE PTR [eax+21], dl

; 1125 : 		return (_Wherenode);
; 1126 : 		}

  00029	c3		 ret	 0
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Buynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Root, COMDAT
; _this$ = eax

; 1064 : 		return (_Parent(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 04	 add	 eax, 4

; 1065 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Root
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Root, COMDAT
; _this$ = eax

; 1059 : 		return (_Parent(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 04	 add	 eax, 4

; 1060 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Root
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Lrotate, COMDAT
; __Wherenode$ = ecx

; 1015 : 		_Nodeptr _Pnode = _Right(_Wherenode);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1016 : 		_Right(_Wherenode) = _Left(_Pnode);

  00003	8b 10		 mov	 edx, DWORD PTR [eax]
  00005	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 1017 : 
; 1018 : 		if (!_Isnil(_Left(_Pnode)))

  00008	8b 10		 mov	 edx, DWORD PTR [eax]
  0000a	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0000e	75 03		 jne	 SHORT $L31044

; 1019 : 			_Parent(_Left(_Pnode)) = _Wherenode;

  00010	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L31044:

; 1020 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1021 : 
; 1022 : 		if (_Wherenode == _Root())

  00019	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  0001d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00020	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00023	75 05		 jne	 SHORT $L31045

; 1023 : 			_Root() = _Pnode;

  00025	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1024 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

  00028	eb 0e		 jmp	 SHORT $L31048
$L31045:
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0002f	75 04		 jne	 SHORT $L31047

; 1025 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  00031	89 02		 mov	 DWORD PTR [edx], eax

; 1026 : 		else

  00033	eb 03		 jmp	 SHORT $L31048
$L31047:

; 1027 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00035	89 42 08	 mov	 DWORD PTR [edx+8], eax
$L31048:

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  00038	89 08		 mov	 DWORD PTR [eax], ecx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  0003a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1031 : 		}

  0003d	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Lrotate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z PROC NEAR ; std::_Tree_ptr<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >, COMDAT
; _this$ = eax

; 77   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_ptr@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVSE@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVSE@@@2@D@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Buynode, COMDAT

; 1130 : 		{	// allocate a node with pointers, value, and color

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1131 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00004	6a 18		 push	 24			; 00000018H
  00006	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000b	8b f0		 mov	 esi, eax

; 1132 : 		_TRY_BEGIN
; 1133 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

  0000d	85 f6		 test	 esi, esi
  0000f	59		 pop	 ecx
  00010	74 14		 je	 SHORT $L47939
  00012	ff 75 18	 push	 DWORD PTR __Carg$[ebp]
  00015	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  00018	ff 75 10	 push	 DWORD PTR __Rarg$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR __Larg$[ebp]
  0001e	ff 75 0c	 push	 DWORD PTR __Parg$[ebp]
  00021	e8 00 00 00 00	 call	 ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVSE@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Node::_Node
$L47939:

; 1134 : 		_CATCH_ALL
; 1135 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1136 : 		_RERAISE;
; 1137 : 		_CATCH_END
; 1138 : 		return (_Wherenode);

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi

; 1139 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 14 00	 ret	 20			; 00000014H
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVSE@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Buynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Buynode, COMDAT

; 1106 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 1107 : 		int _Linkcnt = 0;
; 1108 : 
; 1109 : 		_TRY_BEGIN
; 1110 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

  00007	33 d2		 xor	 edx, edx
  00009	3b c2		 cmp	 eax, edx
  0000b	59		 pop	 ecx
  0000c	74 02		 je	 SHORT $L47998
  0000e	89 10		 mov	 DWORD PTR [eax], edx
$L47998:

; 1111 : 		++_Linkcnt;
; 1112 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

  00010	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00013	3b ca		 cmp	 ecx, edx
  00015	74 02		 je	 SHORT $L48025
  00017	89 11		 mov	 DWORD PTR [ecx], edx
$L48025:

; 1113 : 		++_Linkcnt;
; 1114 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

  00019	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  0001c	3b ca		 cmp	 ecx, edx
  0001e	74 02		 je	 SHORT $L48052
  00020	89 11		 mov	 DWORD PTR [ecx], edx
$L48052:

; 1115 : 		_CATCH_ALL
; 1116 : 		if (1 < _Linkcnt)
; 1117 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1118 : 		if (0 < _Linkcnt)
; 1119 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1120 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1121 : 		_RERAISE;
; 1122 : 		_CATCH_END
; 1123 : 		_Color(_Wherenode) = _Black;

  00022	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 1124 : 		_Isnil(_Wherenode) = false;

  00026	88 50 15	 mov	 BYTE PTR [eax+21], dl

; 1125 : 		return (_Wherenode);
; 1126 : 		}

  00029	c3		 ret	 0
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Buynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Root, COMDAT
; _this$ = eax

; 1064 : 		return (_Parent(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 04	 add	 eax, 4

; 1065 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Root
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Root, COMDAT
; _this$ = eax

; 1059 : 		return (_Parent(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 04	 add	 eax, 4

; 1060 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Root
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Lrotate, COMDAT
; __Wherenode$ = ecx

; 1015 : 		_Nodeptr _Pnode = _Right(_Wherenode);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1016 : 		_Right(_Wherenode) = _Left(_Pnode);

  00003	8b 10		 mov	 edx, DWORD PTR [eax]
  00005	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 1017 : 
; 1018 : 		if (!_Isnil(_Left(_Pnode)))

  00008	8b 10		 mov	 edx, DWORD PTR [eax]
  0000a	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0000e	75 03		 jne	 SHORT $L30934

; 1019 : 			_Parent(_Left(_Pnode)) = _Wherenode;

  00010	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L30934:

; 1020 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1021 : 
; 1022 : 		if (_Wherenode == _Root())

  00019	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  0001d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00020	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00023	75 05		 jne	 SHORT $L30935

; 1023 : 			_Root() = _Pnode;

  00025	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1024 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

  00028	eb 0e		 jmp	 SHORT $L30938
$L30935:
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0002f	75 04		 jne	 SHORT $L30937

; 1025 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  00031	89 02		 mov	 DWORD PTR [edx], eax

; 1026 : 		else

  00033	eb 03		 jmp	 SHORT $L30938
$L30937:

; 1027 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00035	89 42 08	 mov	 DWORD PTR [edx+8], eax
$L30938:

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  00038	89 08		 mov	 DWORD PTR [eax], ecx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  0003a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1031 : 		}

  0003d	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Lrotate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Lmost, COMDAT
; _this$ = eax

; 1005 : 		return (_Left(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1006 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Lmost
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z PROC NEAR ; std::_Tree_ptr<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >, COMDAT
; _this$ = eax

; 77   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_ptr@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVBGM@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVBGM@@@2@D@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Buynode, COMDAT

; 1130 : 		{	// allocate a node with pointers, value, and color

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1131 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00004	6a 18		 push	 24			; 00000018H
  00006	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000b	8b f0		 mov	 esi, eax

; 1132 : 		_TRY_BEGIN
; 1133 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

  0000d	85 f6		 test	 esi, esi
  0000f	59		 pop	 ecx
  00010	74 14		 je	 SHORT $L48209
  00012	ff 75 18	 push	 DWORD PTR __Carg$[ebp]
  00015	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  00018	ff 75 10	 push	 DWORD PTR __Rarg$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR __Larg$[ebp]
  0001e	ff 75 0c	 push	 DWORD PTR __Parg$[ebp]
  00021	e8 00 00 00 00	 call	 ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVBGM@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Node::_Node
$L48209:

; 1134 : 		_CATCH_ALL
; 1135 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1136 : 		_RERAISE;
; 1137 : 		_CATCH_END
; 1138 : 		return (_Wherenode);

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi

; 1139 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 14 00	 ret	 20			; 00000014H
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVBGM@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Buynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Buynode, COMDAT

; 1106 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 1107 : 		int _Linkcnt = 0;
; 1108 : 
; 1109 : 		_TRY_BEGIN
; 1110 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

  00007	33 d2		 xor	 edx, edx
  00009	3b c2		 cmp	 eax, edx
  0000b	59		 pop	 ecx
  0000c	74 02		 je	 SHORT $L48267
  0000e	89 10		 mov	 DWORD PTR [eax], edx
$L48267:

; 1111 : 		++_Linkcnt;
; 1112 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

  00010	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00013	3b ca		 cmp	 ecx, edx
  00015	74 02		 je	 SHORT $L48294
  00017	89 11		 mov	 DWORD PTR [ecx], edx
$L48294:

; 1113 : 		++_Linkcnt;
; 1114 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

  00019	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  0001c	3b ca		 cmp	 ecx, edx
  0001e	74 02		 je	 SHORT $L48321
  00020	89 11		 mov	 DWORD PTR [ecx], edx
$L48321:

; 1115 : 		_CATCH_ALL
; 1116 : 		if (1 < _Linkcnt)
; 1117 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1118 : 		if (0 < _Linkcnt)
; 1119 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1120 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1121 : 		_RERAISE;
; 1122 : 		_CATCH_END
; 1123 : 		_Color(_Wherenode) = _Black;

  00022	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 1124 : 		_Isnil(_Wherenode) = false;

  00026	88 50 15	 mov	 BYTE PTR [eax+21], dl

; 1125 : 		return (_Wherenode);
; 1126 : 		}

  00029	c3		 ret	 0
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Buynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Root, COMDAT
; _this$ = eax

; 1064 : 		return (_Parent(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 04	 add	 eax, 4

; 1065 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Root
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Root, COMDAT
; _this$ = eax

; 1059 : 		return (_Parent(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 04	 add	 eax, 4

; 1060 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Root
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Lrotate, COMDAT
; __Wherenode$ = ecx

; 1015 : 		_Nodeptr _Pnode = _Right(_Wherenode);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1016 : 		_Right(_Wherenode) = _Left(_Pnode);

  00003	8b 10		 mov	 edx, DWORD PTR [eax]
  00005	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 1017 : 
; 1018 : 		if (!_Isnil(_Left(_Pnode)))

  00008	8b 10		 mov	 edx, DWORD PTR [eax]
  0000a	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0000e	75 03		 jne	 SHORT $L30822

; 1019 : 			_Parent(_Left(_Pnode)) = _Wherenode;

  00010	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L30822:

; 1020 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1021 : 
; 1022 : 		if (_Wherenode == _Root())

  00019	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  0001d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00020	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00023	75 05		 jne	 SHORT $L30823

; 1023 : 			_Root() = _Pnode;

  00025	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1024 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

  00028	eb 0e		 jmp	 SHORT $L30826
$L30823:
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0002f	75 04		 jne	 SHORT $L30825

; 1025 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  00031	89 02		 mov	 DWORD PTR [edx], eax

; 1026 : 		else

  00033	eb 03		 jmp	 SHORT $L30826
$L30825:

; 1027 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00035	89 42 08	 mov	 DWORD PTR [edx+8], eax
$L30826:

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  00038	89 08		 mov	 DWORD PTR [eax], ecx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  0003a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1031 : 		}

  0003d	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Lrotate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Lmost, COMDAT
; _this$ = eax

; 1005 : 		return (_Left(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1006 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Lmost
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z PROC NEAR ; std::_Tree_ptr<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >, COMDAT
; _this$ = eax

; 77   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_ptr@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVEnvelop@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVEnvelop@@@2@D@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Buynode, COMDAT

; 1130 : 		{	// allocate a node with pointers, value, and color

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1131 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00004	6a 18		 push	 24			; 00000018H
  00006	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000b	8b f0		 mov	 esi, eax

; 1132 : 		_TRY_BEGIN
; 1133 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

  0000d	85 f6		 test	 esi, esi
  0000f	59		 pop	 ecx
  00010	74 14		 je	 SHORT $L48479
  00012	ff 75 18	 push	 DWORD PTR __Carg$[ebp]
  00015	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  00018	ff 75 10	 push	 DWORD PTR __Rarg$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR __Larg$[ebp]
  0001e	ff 75 0c	 push	 DWORD PTR __Parg$[ebp]
  00021	e8 00 00 00 00	 call	 ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVEnvelop@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Node::_Node
$L48479:

; 1134 : 		_CATCH_ALL
; 1135 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1136 : 		_RERAISE;
; 1137 : 		_CATCH_END
; 1138 : 		return (_Wherenode);

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi

; 1139 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 14 00	 ret	 20			; 00000014H
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVEnvelop@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Buynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Buynode, COMDAT

; 1106 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 1107 : 		int _Linkcnt = 0;
; 1108 : 
; 1109 : 		_TRY_BEGIN
; 1110 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

  00007	33 d2		 xor	 edx, edx
  00009	3b c2		 cmp	 eax, edx
  0000b	59		 pop	 ecx
  0000c	74 02		 je	 SHORT $L48537
  0000e	89 10		 mov	 DWORD PTR [eax], edx
$L48537:

; 1111 : 		++_Linkcnt;
; 1112 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

  00010	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00013	3b ca		 cmp	 ecx, edx
  00015	74 02		 je	 SHORT $L48564
  00017	89 11		 mov	 DWORD PTR [ecx], edx
$L48564:

; 1113 : 		++_Linkcnt;
; 1114 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

  00019	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  0001c	3b ca		 cmp	 ecx, edx
  0001e	74 02		 je	 SHORT $L48591
  00020	89 11		 mov	 DWORD PTR [ecx], edx
$L48591:

; 1115 : 		_CATCH_ALL
; 1116 : 		if (1 < _Linkcnt)
; 1117 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1118 : 		if (0 < _Linkcnt)
; 1119 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1120 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1121 : 		_RERAISE;
; 1122 : 		_CATCH_END
; 1123 : 		_Color(_Wherenode) = _Black;

  00022	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 1124 : 		_Isnil(_Wherenode) = false;

  00026	88 50 15	 mov	 BYTE PTR [eax+21], dl

; 1125 : 		return (_Wherenode);
; 1126 : 		}

  00029	c3		 ret	 0
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Buynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Root, COMDAT
; _this$ = eax

; 1064 : 		return (_Parent(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 04	 add	 eax, 4

; 1065 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Root
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Root, COMDAT
; _this$ = eax

; 1059 : 		return (_Parent(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 04	 add	 eax, 4

; 1060 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Root
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Lrotate, COMDAT
; __Wherenode$ = ecx

; 1015 : 		_Nodeptr _Pnode = _Right(_Wherenode);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1016 : 		_Right(_Wherenode) = _Left(_Pnode);

  00003	8b 10		 mov	 edx, DWORD PTR [eax]
  00005	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 1017 : 
; 1018 : 		if (!_Isnil(_Left(_Pnode)))

  00008	8b 10		 mov	 edx, DWORD PTR [eax]
  0000a	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0000e	75 03		 jne	 SHORT $L30710

; 1019 : 			_Parent(_Left(_Pnode)) = _Wherenode;

  00010	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L30710:

; 1020 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1021 : 
; 1022 : 		if (_Wherenode == _Root())

  00019	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  0001d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00020	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00023	75 05		 jne	 SHORT $L30711

; 1023 : 			_Root() = _Pnode;

  00025	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1024 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

  00028	eb 0e		 jmp	 SHORT $L30714
$L30711:
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0002f	75 04		 jne	 SHORT $L30713

; 1025 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  00031	89 02		 mov	 DWORD PTR [edx], eax

; 1026 : 		else

  00033	eb 03		 jmp	 SHORT $L30714
$L30713:

; 1027 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00035	89 42 08	 mov	 DWORD PTR [edx+8], eax
$L30714:

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  00038	89 08		 mov	 DWORD PTR [eax], ecx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  0003a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1031 : 		}

  0003d	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Lrotate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z PROC NEAR ; std::_Tree_ptr<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >, COMDAT
; _this$ = eax

; 77   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_ptr@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVN163@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVN163@@@2@D@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Buynode, COMDAT

; 1130 : 		{	// allocate a node with pointers, value, and color

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1131 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00004	6a 18		 push	 24			; 00000018H
  00006	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000b	8b f0		 mov	 esi, eax

; 1132 : 		_TRY_BEGIN
; 1133 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

  0000d	85 f6		 test	 esi, esi
  0000f	59		 pop	 ecx
  00010	74 14		 je	 SHORT $L48742
  00012	ff 75 18	 push	 DWORD PTR __Carg$[ebp]
  00015	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  00018	ff 75 10	 push	 DWORD PTR __Rarg$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR __Larg$[ebp]
  0001e	ff 75 0c	 push	 DWORD PTR __Parg$[ebp]
  00021	e8 00 00 00 00	 call	 ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVN163@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Node::_Node
$L48742:

; 1134 : 		_CATCH_ALL
; 1135 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1136 : 		_RERAISE;
; 1137 : 		_CATCH_END
; 1138 : 		return (_Wherenode);

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi

; 1139 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 14 00	 ret	 20			; 00000014H
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVN163@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Buynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Buynode, COMDAT

; 1106 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 1107 : 		int _Linkcnt = 0;
; 1108 : 
; 1109 : 		_TRY_BEGIN
; 1110 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

  00007	33 d2		 xor	 edx, edx
  00009	3b c2		 cmp	 eax, edx
  0000b	59		 pop	 ecx
  0000c	74 02		 je	 SHORT $L48800
  0000e	89 10		 mov	 DWORD PTR [eax], edx
$L48800:

; 1111 : 		++_Linkcnt;
; 1112 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

  00010	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00013	3b ca		 cmp	 ecx, edx
  00015	74 02		 je	 SHORT $L48827
  00017	89 11		 mov	 DWORD PTR [ecx], edx
$L48827:

; 1113 : 		++_Linkcnt;
; 1114 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

  00019	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  0001c	3b ca		 cmp	 ecx, edx
  0001e	74 02		 je	 SHORT $L48854
  00020	89 11		 mov	 DWORD PTR [ecx], edx
$L48854:

; 1115 : 		_CATCH_ALL
; 1116 : 		if (1 < _Linkcnt)
; 1117 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1118 : 		if (0 < _Linkcnt)
; 1119 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1120 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1121 : 		_RERAISE;
; 1122 : 		_CATCH_END
; 1123 : 		_Color(_Wherenode) = _Black;

  00022	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 1124 : 		_Isnil(_Wherenode) = false;

  00026	88 50 15	 mov	 BYTE PTR [eax+21], dl

; 1125 : 		return (_Wherenode);
; 1126 : 		}

  00029	c3		 ret	 0
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Buynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Root, COMDAT
; _this$ = eax

; 1064 : 		return (_Parent(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 04	 add	 eax, 4

; 1065 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Root
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Root, COMDAT
; _this$ = eax

; 1059 : 		return (_Parent(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 04	 add	 eax, 4

; 1060 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Root
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Lrotate, COMDAT
; __Wherenode$ = ecx

; 1015 : 		_Nodeptr _Pnode = _Right(_Wherenode);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1016 : 		_Right(_Wherenode) = _Left(_Pnode);

  00003	8b 10		 mov	 edx, DWORD PTR [eax]
  00005	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 1017 : 
; 1018 : 		if (!_Isnil(_Left(_Pnode)))

  00008	8b 10		 mov	 edx, DWORD PTR [eax]
  0000a	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0000e	75 03		 jne	 SHORT $L30600

; 1019 : 			_Parent(_Left(_Pnode)) = _Wherenode;

  00010	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L30600:

; 1020 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1021 : 
; 1022 : 		if (_Wherenode == _Root())

  00019	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  0001d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00020	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00023	75 05		 jne	 SHORT $L30601

; 1023 : 			_Root() = _Pnode;

  00025	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1024 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

  00028	eb 0e		 jmp	 SHORT $L30604
$L30601:
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0002f	75 04		 jne	 SHORT $L30603

; 1025 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  00031	89 02		 mov	 DWORD PTR [edx], eax

; 1026 : 		else

  00033	eb 03		 jmp	 SHORT $L30604
$L30603:

; 1027 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00035	89 42 08	 mov	 DWORD PTR [edx+8], eax
$L30604:

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  00038	89 08		 mov	 DWORD PTR [eax], ecx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  0003a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1031 : 		}

  0003d	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Lrotate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z PROC NEAR ; std::_Tree_ptr<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >, COMDAT
; _this$ = eax

; 77   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_ptr@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVVRC7@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVVRC7@@@2@D@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Buynode, COMDAT

; 1130 : 		{	// allocate a node with pointers, value, and color

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1131 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00004	6a 18		 push	 24			; 00000018H
  00006	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000b	8b f0		 mov	 esi, eax

; 1132 : 		_TRY_BEGIN
; 1133 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

  0000d	85 f6		 test	 esi, esi
  0000f	59		 pop	 ecx
  00010	74 14		 je	 SHORT $L49005
  00012	ff 75 18	 push	 DWORD PTR __Carg$[ebp]
  00015	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  00018	ff 75 10	 push	 DWORD PTR __Rarg$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR __Larg$[ebp]
  0001e	ff 75 0c	 push	 DWORD PTR __Parg$[ebp]
  00021	e8 00 00 00 00	 call	 ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVVRC7@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Node::_Node
$L49005:

; 1134 : 		_CATCH_ALL
; 1135 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1136 : 		_RERAISE;
; 1137 : 		_CATCH_END
; 1138 : 		return (_Wherenode);

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi

; 1139 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 14 00	 ret	 20			; 00000014H
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVVRC7@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Buynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Buynode, COMDAT

; 1106 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 1107 : 		int _Linkcnt = 0;
; 1108 : 
; 1109 : 		_TRY_BEGIN
; 1110 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

  00007	33 d2		 xor	 edx, edx
  00009	3b c2		 cmp	 eax, edx
  0000b	59		 pop	 ecx
  0000c	74 02		 je	 SHORT $L49064
  0000e	89 10		 mov	 DWORD PTR [eax], edx
$L49064:

; 1111 : 		++_Linkcnt;
; 1112 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

  00010	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00013	3b ca		 cmp	 ecx, edx
  00015	74 02		 je	 SHORT $L49091
  00017	89 11		 mov	 DWORD PTR [ecx], edx
$L49091:

; 1113 : 		++_Linkcnt;
; 1114 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

  00019	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  0001c	3b ca		 cmp	 ecx, edx
  0001e	74 02		 je	 SHORT $L49118
  00020	89 11		 mov	 DWORD PTR [ecx], edx
$L49118:

; 1115 : 		_CATCH_ALL
; 1116 : 		if (1 < _Linkcnt)
; 1117 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1118 : 		if (0 < _Linkcnt)
; 1119 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1120 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1121 : 		_RERAISE;
; 1122 : 		_CATCH_END
; 1123 : 		_Color(_Wherenode) = _Black;

  00022	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 1124 : 		_Isnil(_Wherenode) = false;

  00026	88 50 15	 mov	 BYTE PTR [eax+21], dl

; 1125 : 		return (_Wherenode);
; 1126 : 		}

  00029	c3		 ret	 0
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Buynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Root, COMDAT
; _this$ = eax

; 1064 : 		return (_Parent(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 04	 add	 eax, 4

; 1065 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Root
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Root, COMDAT
; _this$ = eax

; 1059 : 		return (_Parent(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 04	 add	 eax, 4

; 1060 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Root
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Lrotate, COMDAT
; __Wherenode$ = ecx

; 1015 : 		_Nodeptr _Pnode = _Right(_Wherenode);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1016 : 		_Right(_Wherenode) = _Left(_Pnode);

  00003	8b 10		 mov	 edx, DWORD PTR [eax]
  00005	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 1017 : 
; 1018 : 		if (!_Isnil(_Left(_Pnode)))

  00008	8b 10		 mov	 edx, DWORD PTR [eax]
  0000a	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0000e	75 03		 jne	 SHORT $L30490

; 1019 : 			_Parent(_Left(_Pnode)) = _Wherenode;

  00010	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L30490:

; 1020 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1021 : 
; 1022 : 		if (_Wherenode == _Root())

  00019	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  0001d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00020	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00023	75 05		 jne	 SHORT $L30491

; 1023 : 			_Root() = _Pnode;

  00025	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1024 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

  00028	eb 0e		 jmp	 SHORT $L30494
$L30491:
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0002f	75 04		 jne	 SHORT $L30493

; 1025 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  00031	89 02		 mov	 DWORD PTR [edx], eax

; 1026 : 		else

  00033	eb 03		 jmp	 SHORT $L30494
$L30493:

; 1027 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00035	89 42 08	 mov	 DWORD PTR [edx+8], eax
$L30494:

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  00038	89 08		 mov	 DWORD PTR [eax], ecx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  0003a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1031 : 		}

  0003d	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Lrotate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z PROC NEAR ; std::_Tree_ptr<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >, COMDAT
; _this$ = eax

; 77   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_ptr@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVFDSM@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVFDSM@@@2@D@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Buynode, COMDAT

; 1130 : 		{	// allocate a node with pointers, value, and color

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1131 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00004	6a 18		 push	 24			; 00000018H
  00006	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000b	8b f0		 mov	 esi, eax

; 1132 : 		_TRY_BEGIN
; 1133 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

  0000d	85 f6		 test	 esi, esi
  0000f	59		 pop	 ecx
  00010	74 14		 je	 SHORT $L49268
  00012	ff 75 18	 push	 DWORD PTR __Carg$[ebp]
  00015	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  00018	ff 75 10	 push	 DWORD PTR __Rarg$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR __Larg$[ebp]
  0001e	ff 75 0c	 push	 DWORD PTR __Parg$[ebp]
  00021	e8 00 00 00 00	 call	 ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVFDSM@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Node::_Node
$L49268:

; 1134 : 		_CATCH_ALL
; 1135 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1136 : 		_RERAISE;
; 1137 : 		_CATCH_END
; 1138 : 		return (_Wherenode);

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi

; 1139 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 14 00	 ret	 20			; 00000014H
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVFDSM@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Buynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Buynode, COMDAT

; 1106 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 1107 : 		int _Linkcnt = 0;
; 1108 : 
; 1109 : 		_TRY_BEGIN
; 1110 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

  00007	33 d2		 xor	 edx, edx
  00009	3b c2		 cmp	 eax, edx
  0000b	59		 pop	 ecx
  0000c	74 02		 je	 SHORT $L49326
  0000e	89 10		 mov	 DWORD PTR [eax], edx
$L49326:

; 1111 : 		++_Linkcnt;
; 1112 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

  00010	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00013	3b ca		 cmp	 ecx, edx
  00015	74 02		 je	 SHORT $L49353
  00017	89 11		 mov	 DWORD PTR [ecx], edx
$L49353:

; 1113 : 		++_Linkcnt;
; 1114 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

  00019	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  0001c	3b ca		 cmp	 ecx, edx
  0001e	74 02		 je	 SHORT $L49380
  00020	89 11		 mov	 DWORD PTR [ecx], edx
$L49380:

; 1115 : 		_CATCH_ALL
; 1116 : 		if (1 < _Linkcnt)
; 1117 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1118 : 		if (0 < _Linkcnt)
; 1119 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1120 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1121 : 		_RERAISE;
; 1122 : 		_CATCH_END
; 1123 : 		_Color(_Wherenode) = _Black;

  00022	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 1124 : 		_Isnil(_Wherenode) = false;

  00026	88 50 15	 mov	 BYTE PTR [eax+21], dl

; 1125 : 		return (_Wherenode);
; 1126 : 		}

  00029	c3		 ret	 0
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Buynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Root, COMDAT
; _this$ = eax

; 1064 : 		return (_Parent(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 04	 add	 eax, 4

; 1065 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Root
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Root, COMDAT
; _this$ = eax

; 1059 : 		return (_Parent(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 04	 add	 eax, 4

; 1060 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Root
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Lrotate, COMDAT
; __Wherenode$ = ecx

; 1015 : 		_Nodeptr _Pnode = _Right(_Wherenode);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1016 : 		_Right(_Wherenode) = _Left(_Pnode);

  00003	8b 10		 mov	 edx, DWORD PTR [eax]
  00005	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 1017 : 
; 1018 : 		if (!_Isnil(_Left(_Pnode)))

  00008	8b 10		 mov	 edx, DWORD PTR [eax]
  0000a	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0000e	75 03		 jne	 SHORT $L30380

; 1019 : 			_Parent(_Left(_Pnode)) = _Wherenode;

  00010	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L30380:

; 1020 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1021 : 
; 1022 : 		if (_Wherenode == _Root())

  00019	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  0001d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00020	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00023	75 05		 jne	 SHORT $L30381

; 1023 : 			_Root() = _Pnode;

  00025	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1024 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

  00028	eb 0e		 jmp	 SHORT $L30384
$L30381:
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0002f	75 04		 jne	 SHORT $L30383

; 1025 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  00031	89 02		 mov	 DWORD PTR [edx], eax

; 1026 : 		else

  00033	eb 03		 jmp	 SHORT $L30384
$L30383:

; 1027 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00035	89 42 08	 mov	 DWORD PTR [edx+8], eax
$L30384:

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  00038	89 08		 mov	 DWORD PTR [eax], ecx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  0003a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1031 : 		}

  0003d	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Lrotate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z PROC NEAR ; std::_Tree_ptr<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >, COMDAT
; _this$ = eax

; 77   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_ptr@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Tree_ptr<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVFDSC@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVFDSC@@@2@D@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Buynode, COMDAT

; 1130 : 		{	// allocate a node with pointers, value, and color

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1131 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00004	6a 18		 push	 24			; 00000018H
  00006	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000b	8b f0		 mov	 esi, eax

; 1132 : 		_TRY_BEGIN
; 1133 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

  0000d	85 f6		 test	 esi, esi
  0000f	59		 pop	 ecx
  00010	74 14		 je	 SHORT $L49531
  00012	ff 75 18	 push	 DWORD PTR __Carg$[ebp]
  00015	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  00018	ff 75 10	 push	 DWORD PTR __Rarg$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR __Larg$[ebp]
  0001e	ff 75 0c	 push	 DWORD PTR __Parg$[ebp]
  00021	e8 00 00 00 00	 call	 ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHPAVFDSC@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Node::_Node
$L49531:

; 1134 : 		_CATCH_ALL
; 1135 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1136 : 		_RERAISE;
; 1137 : 		_CATCH_END
; 1138 : 		return (_Wherenode);

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi

; 1139 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 14 00	 ret	 20			; 00000014H
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVFDSC@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Buynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Buynode, COMDAT

; 1106 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 1107 : 		int _Linkcnt = 0;
; 1108 : 
; 1109 : 		_TRY_BEGIN
; 1110 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

  00007	33 d2		 xor	 edx, edx
  00009	3b c2		 cmp	 eax, edx
  0000b	59		 pop	 ecx
  0000c	74 02		 je	 SHORT $L49588
  0000e	89 10		 mov	 DWORD PTR [eax], edx
$L49588:

; 1111 : 		++_Linkcnt;
; 1112 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

  00010	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00013	3b ca		 cmp	 ecx, edx
  00015	74 02		 je	 SHORT $L49615
  00017	89 11		 mov	 DWORD PTR [ecx], edx
$L49615:

; 1113 : 		++_Linkcnt;
; 1114 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

  00019	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  0001c	3b ca		 cmp	 ecx, edx
  0001e	74 02		 je	 SHORT $L49642
  00020	89 11		 mov	 DWORD PTR [ecx], edx
$L49642:

; 1115 : 		_CATCH_ALL
; 1116 : 		if (1 < _Linkcnt)
; 1117 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1118 : 		if (0 < _Linkcnt)
; 1119 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1120 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1121 : 		_RERAISE;
; 1122 : 		_CATCH_END
; 1123 : 		_Color(_Wherenode) = _Black;

  00022	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 1124 : 		_Isnil(_Wherenode) = false;

  00026	88 50 15	 mov	 BYTE PTR [eax+21], dl

; 1125 : 		return (_Wherenode);
; 1126 : 		}

  00029	c3		 ret	 0
?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Buynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Root, COMDAT
; _this$ = eax

; 1064 : 		return (_Parent(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 04	 add	 eax, 4

; 1065 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Root
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Root, COMDAT
; _this$ = eax

; 1059 : 		return (_Parent(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 04	 add	 eax, 4

; 1060 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Root
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Lrotate, COMDAT
; __Wherenode$ = ecx

; 1015 : 		_Nodeptr _Pnode = _Right(_Wherenode);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1016 : 		_Right(_Wherenode) = _Left(_Pnode);

  00003	8b 10		 mov	 edx, DWORD PTR [eax]
  00005	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 1017 : 
; 1018 : 		if (!_Isnil(_Left(_Pnode)))

  00008	8b 10		 mov	 edx, DWORD PTR [eax]
  0000a	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0000e	75 03		 jne	 SHORT $L30270

; 1019 : 			_Parent(_Left(_Pnode)) = _Wherenode;

  00010	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L30270:

; 1020 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1021 : 
; 1022 : 		if (_Wherenode == _Root())

  00019	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  0001d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00020	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00023	75 05		 jne	 SHORT $L30271

; 1023 : 			_Root() = _Pnode;

  00025	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1024 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

  00028	eb 0e		 jmp	 SHORT $L30274
$L30271:
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0002f	75 04		 jne	 SHORT $L30273

; 1025 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  00031	89 02		 mov	 DWORD PTR [edx], eax

; 1026 : 		else

  00033	eb 03		 jmp	 SHORT $L30274
$L30273:

; 1027 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00035	89 42 08	 mov	 DWORD PTR [edx+8], eax
$L30274:

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  00038	89 08		 mov	 DWORD PTR [eax], ecx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  0003a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1031 : 		}

  0003d	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Lrotate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::operator++, COMDAT

; 215  : 			_Inc();

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 217  : 			}

  0000d	c2 04 00	 ret	 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVN163@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVN163@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = eax

; 205  : 			return (_Myval(_Ptr));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVN163@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::operator++, COMDAT

; 215  : 			_Inc();

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 217  : 			}

  0000d	c2 04 00	 ret	 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVVRC7@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVVRC7@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = eax

; 205  : 			return (_Myval(_Ptr));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVVRC7@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::operator++, COMDAT

; 215  : 			_Inc();

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 217  : 			}

  0000d	c2 04 00	 ret	 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVFDSM@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVFDSM@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = eax

; 205  : 			return (_Myval(_Ptr));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVFDSM@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::operator++, COMDAT

; 215  : 			_Inc();

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 217  : 			}

  0000d	c2 04 00	 ret	 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVFDSC@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVFDSC@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = eax

; 205  : 			return (_Myval(_Ptr));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVFDSC@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::operator++, COMDAT

; 215  : 			_Inc();

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 217  : 			}

  0000d	c2 04 00	 ret	 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVSub@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVSub@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = eax

; 205  : 			return (_Myval(_Ptr));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVSub@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVSE@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVSE@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = eax

; 205  : 			return (_Myval(_Ptr));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVSE@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVBGM@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVBGM@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = eax

; 205  : 			return (_Myval(_Ptr));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVBGM@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::operator++, COMDAT

; 215  : 			_Inc();

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 217  : 			}

  0000d	c2 04 00	 ret	 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVEnvelop@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVEnvelop@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = eax

; 205  : 			return (_Myval(_Ptr));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBHPAVEnvelop@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z PROC NEAR ; std::_Tree_val<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Tree_val<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >, COMDAT
; _this$ = eax

; 96   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_val@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Tree_val<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Rmost, COMDAT
; _this$ = eax

; 1049 : 		return (_Right(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 08	 add	 eax, 8

; 1050 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Rmost
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Lbound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 988  : 		_Nodeptr _Pnode = _Root();

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	75 16		 jne	 SHORT $L29746
  0000c	8b 12		 mov	 edx, DWORD PTR [edx]
$L29745:

; 992  : 			if (this->comp(_Key(_Pnode), _Keyval))

  0000e	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00011	7d 05		 jge	 SHORT $L29747

; 993  : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00013	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 994  : 			else

  00016	eb 04		 jmp	 SHORT $L29748
$L29747:

; 995  : 				{	// _Pnode not less than _Keyval, remember it
; 996  : 				_Wherenode = _Pnode;

  00018	8b c1		 mov	 eax, ecx

; 997  : 				_Pnode = _Left(_Pnode);	// descend left subtree

  0001a	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L29748:

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  0001c	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00020	74 ec		 je	 SHORT $L29745
$L29746:

; 998  : 				}
; 999  : 
; 1000 : 		return (_Wherenode);	// return best remembered candidate
; 1001 : 		}

  00022	c3		 ret	 0
?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Lbound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Init, COMDAT
; _this$ = esi

; 902  : 		_Myhead = _Buynode();

  00000	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Buynode
  00005	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 903  : 		_Isnil(_Myhead) = true;

  0000a	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1

; 904  : 		_Root() = _Myhead;

  0000e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00010	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 905  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00013	8b 01		 mov	 eax, DWORD PTR [ecx]
  00015	89 00		 mov	 DWORD PTR [eax], eax
  00017	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00019	89 49 08	 mov	 DWORD PTR [ecx+8], ecx

; 906  : 		_Mysize = 0;

  0001c	83 66 08 00	 and	 DWORD PTR [esi+8], 0

; 907  : 		}

  00020	c3		 ret	 0
?_Init@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Init
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::lower_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 815  : 		return (_TREE_CONST_ITERATOR(_Lbound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Lbound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 816  : 		}

  00009	c3		 ret	 0
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::lower_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z PROC NEAR ; std::_Tree_val<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Tree_val<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >, COMDAT
; _this$ = eax

; 96   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_val@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Tree_val<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Rmost, COMDAT
; _this$ = eax

; 1049 : 		return (_Right(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 08	 add	 eax, 8

; 1050 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Rmost
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Lbound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 988  : 		_Nodeptr _Pnode = _Root();

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	75 16		 jne	 SHORT $L29611
  0000c	8b 12		 mov	 edx, DWORD PTR [edx]
$L29610:

; 992  : 			if (this->comp(_Key(_Pnode), _Keyval))

  0000e	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00011	7d 05		 jge	 SHORT $L29612

; 993  : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00013	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 994  : 			else

  00016	eb 04		 jmp	 SHORT $L29613
$L29612:

; 995  : 				{	// _Pnode not less than _Keyval, remember it
; 996  : 				_Wherenode = _Pnode;

  00018	8b c1		 mov	 eax, ecx

; 997  : 				_Pnode = _Left(_Pnode);	// descend left subtree

  0001a	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L29613:

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  0001c	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00020	74 ec		 je	 SHORT $L29610
$L29611:

; 998  : 				}
; 999  : 
; 1000 : 		return (_Wherenode);	// return best remembered candidate
; 1001 : 		}

  00022	c3		 ret	 0
?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Lbound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Init, COMDAT
; _this$ = esi

; 902  : 		_Myhead = _Buynode();

  00000	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Buynode
  00005	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 903  : 		_Isnil(_Myhead) = true;

  0000a	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1

; 904  : 		_Root() = _Myhead;

  0000e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00010	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 905  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00013	8b 01		 mov	 eax, DWORD PTR [ecx]
  00015	89 00		 mov	 DWORD PTR [eax], eax
  00017	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00019	89 49 08	 mov	 DWORD PTR [ecx+8], ecx

; 906  : 		_Mysize = 0;

  0001c	83 66 08 00	 and	 DWORD PTR [esi+8], 0

; 907  : 		}

  00020	c3		 ret	 0
?_Init@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Init
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::lower_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 815  : 		return (_TREE_CONST_ITERATOR(_Lbound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Lbound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 816  : 		}

  00009	c3		 ret	 0
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::lower_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?begin@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 		}

  00007	c3		 ret	 0
?begin@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::begin
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z PROC NEAR ; std::_Tree_val<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Tree_val<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >, COMDAT
; _this$ = eax

; 96   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_val@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Tree_val<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Rmost, COMDAT
; _this$ = eax

; 1049 : 		return (_Right(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 08	 add	 eax, 8

; 1050 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Rmost
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Lbound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 988  : 		_Nodeptr _Pnode = _Root();

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	75 16		 jne	 SHORT $L29470
  0000c	8b 12		 mov	 edx, DWORD PTR [edx]
$L29469:

; 992  : 			if (this->comp(_Key(_Pnode), _Keyval))

  0000e	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00011	7d 05		 jge	 SHORT $L29471

; 993  : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00013	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 994  : 			else

  00016	eb 04		 jmp	 SHORT $L29472
$L29471:

; 995  : 				{	// _Pnode not less than _Keyval, remember it
; 996  : 				_Wherenode = _Pnode;

  00018	8b c1		 mov	 eax, ecx

; 997  : 				_Pnode = _Left(_Pnode);	// descend left subtree

  0001a	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L29472:

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  0001c	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00020	74 ec		 je	 SHORT $L29469
$L29470:

; 998  : 				}
; 999  : 
; 1000 : 		return (_Wherenode);	// return best remembered candidate
; 1001 : 		}

  00022	c3		 ret	 0
?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Lbound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Init, COMDAT
; _this$ = esi

; 902  : 		_Myhead = _Buynode();

  00000	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Buynode
  00005	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 903  : 		_Isnil(_Myhead) = true;

  0000a	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1

; 904  : 		_Root() = _Myhead;

  0000e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00010	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 905  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00013	8b 01		 mov	 eax, DWORD PTR [ecx]
  00015	89 00		 mov	 DWORD PTR [eax], eax
  00017	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00019	89 49 08	 mov	 DWORD PTR [ecx+8], ecx

; 906  : 		_Mysize = 0;

  0001c	83 66 08 00	 and	 DWORD PTR [esi+8], 0

; 907  : 		}

  00020	c3		 ret	 0
?_Init@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Init
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::lower_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 815  : 		return (_TREE_CONST_ITERATOR(_Lbound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Lbound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 816  : 		}

  00009	c3		 ret	 0
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::lower_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?begin@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 		}

  00007	c3		 ret	 0
?begin@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::begin
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z PROC NEAR ; std::_Tree_val<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Tree_val<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >, COMDAT
; _this$ = eax

; 96   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_val@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Tree_val<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Rmost, COMDAT
; _this$ = eax

; 1049 : 		return (_Right(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 08	 add	 eax, 8

; 1050 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Rmost
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Lbound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 988  : 		_Nodeptr _Pnode = _Root();

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	75 16		 jne	 SHORT $L29329
  0000c	8b 12		 mov	 edx, DWORD PTR [edx]
$L29328:

; 992  : 			if (this->comp(_Key(_Pnode), _Keyval))

  0000e	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00011	7d 05		 jge	 SHORT $L29330

; 993  : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00013	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 994  : 			else

  00016	eb 04		 jmp	 SHORT $L29331
$L29330:

; 995  : 				{	// _Pnode not less than _Keyval, remember it
; 996  : 				_Wherenode = _Pnode;

  00018	8b c1		 mov	 eax, ecx

; 997  : 				_Pnode = _Left(_Pnode);	// descend left subtree

  0001a	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L29331:

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  0001c	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00020	74 ec		 je	 SHORT $L29328
$L29329:

; 998  : 				}
; 999  : 
; 1000 : 		return (_Wherenode);	// return best remembered candidate
; 1001 : 		}

  00022	c3		 ret	 0
?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Lbound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Init, COMDAT
; _this$ = esi

; 902  : 		_Myhead = _Buynode();

  00000	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Buynode
  00005	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 903  : 		_Isnil(_Myhead) = true;

  0000a	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1

; 904  : 		_Root() = _Myhead;

  0000e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00010	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 905  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00013	8b 01		 mov	 eax, DWORD PTR [ecx]
  00015	89 00		 mov	 DWORD PTR [eax], eax
  00017	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00019	89 49 08	 mov	 DWORD PTR [ecx+8], ecx

; 906  : 		_Mysize = 0;

  0001c	83 66 08 00	 and	 DWORD PTR [esi+8], 0

; 907  : 		}

  00020	c3		 ret	 0
?_Init@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Init
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::lower_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 815  : 		return (_TREE_CONST_ITERATOR(_Lbound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Lbound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 816  : 		}

  00009	c3		 ret	 0
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::lower_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z PROC NEAR ; std::_Tree_val<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Tree_val<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >, COMDAT
; _this$ = eax

; 96   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_val@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Tree_val<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Rmost, COMDAT
; _this$ = eax

; 1049 : 		return (_Right(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 08	 add	 eax, 8

; 1050 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Rmost
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Lbound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 988  : 		_Nodeptr _Pnode = _Root();

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	75 16		 jne	 SHORT $L29194
  0000c	8b 12		 mov	 edx, DWORD PTR [edx]
$L29193:

; 992  : 			if (this->comp(_Key(_Pnode), _Keyval))

  0000e	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00011	7d 05		 jge	 SHORT $L29195

; 993  : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00013	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 994  : 			else

  00016	eb 04		 jmp	 SHORT $L29196
$L29195:

; 995  : 				{	// _Pnode not less than _Keyval, remember it
; 996  : 				_Wherenode = _Pnode;

  00018	8b c1		 mov	 eax, ecx

; 997  : 				_Pnode = _Left(_Pnode);	// descend left subtree

  0001a	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L29196:

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  0001c	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00020	74 ec		 je	 SHORT $L29193
$L29194:

; 998  : 				}
; 999  : 
; 1000 : 		return (_Wherenode);	// return best remembered candidate
; 1001 : 		}

  00022	c3		 ret	 0
?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Lbound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Init, COMDAT
; _this$ = esi

; 902  : 		_Myhead = _Buynode();

  00000	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Buynode
  00005	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 903  : 		_Isnil(_Myhead) = true;

  0000a	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1

; 904  : 		_Root() = _Myhead;

  0000e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00010	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 905  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00013	8b 01		 mov	 eax, DWORD PTR [ecx]
  00015	89 00		 mov	 DWORD PTR [eax], eax
  00017	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00019	89 49 08	 mov	 DWORD PTR [ecx+8], ecx

; 906  : 		_Mysize = 0;

  0001c	83 66 08 00	 and	 DWORD PTR [esi+8], 0

; 907  : 		}

  00020	c3		 ret	 0
?_Init@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Init
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::lower_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 815  : 		return (_TREE_CONST_ITERATOR(_Lbound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Lbound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 816  : 		}

  00009	c3		 ret	 0
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::lower_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z PROC NEAR ; std::_Tree_val<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Tree_val<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >, COMDAT
; _this$ = eax

; 96   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_val@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Tree_val<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Rmost, COMDAT
; _this$ = eax

; 1049 : 		return (_Right(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 08	 add	 eax, 8

; 1050 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Rmost
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Lbound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 988  : 		_Nodeptr _Pnode = _Root();

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	75 16		 jne	 SHORT $L29059
  0000c	8b 12		 mov	 edx, DWORD PTR [edx]
$L29058:

; 992  : 			if (this->comp(_Key(_Pnode), _Keyval))

  0000e	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00011	7d 05		 jge	 SHORT $L29060

; 993  : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00013	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 994  : 			else

  00016	eb 04		 jmp	 SHORT $L29061
$L29060:

; 995  : 				{	// _Pnode not less than _Keyval, remember it
; 996  : 				_Wherenode = _Pnode;

  00018	8b c1		 mov	 eax, ecx

; 997  : 				_Pnode = _Left(_Pnode);	// descend left subtree

  0001a	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L29061:

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  0001c	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00020	74 ec		 je	 SHORT $L29058
$L29059:

; 998  : 				}
; 999  : 
; 1000 : 		return (_Wherenode);	// return best remembered candidate
; 1001 : 		}

  00022	c3		 ret	 0
?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Lbound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Init, COMDAT
; _this$ = esi

; 902  : 		_Myhead = _Buynode();

  00000	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Buynode
  00005	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 903  : 		_Isnil(_Myhead) = true;

  0000a	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1

; 904  : 		_Root() = _Myhead;

  0000e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00010	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 905  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00013	8b 01		 mov	 eax, DWORD PTR [ecx]
  00015	89 00		 mov	 DWORD PTR [eax], eax
  00017	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00019	89 49 08	 mov	 DWORD PTR [ecx+8], ecx

; 906  : 		_Mysize = 0;

  0001c	83 66 08 00	 and	 DWORD PTR [esi+8], 0

; 907  : 		}

  00020	c3		 ret	 0
?_Init@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Init
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::lower_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 815  : 		return (_TREE_CONST_ITERATOR(_Lbound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Lbound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 816  : 		}

  00009	c3		 ret	 0
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::lower_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z PROC NEAR ; std::_Tree_val<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Tree_val<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >, COMDAT
; _this$ = eax

; 96   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_val@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Tree_val<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Rmost, COMDAT
; _this$ = eax

; 1049 : 		return (_Right(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 08	 add	 eax, 8

; 1050 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Rmost
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Lbound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 988  : 		_Nodeptr _Pnode = _Root();

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	75 16		 jne	 SHORT $L28924
  0000c	8b 12		 mov	 edx, DWORD PTR [edx]
$L28923:

; 992  : 			if (this->comp(_Key(_Pnode), _Keyval))

  0000e	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00011	7d 05		 jge	 SHORT $L28925

; 993  : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00013	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 994  : 			else

  00016	eb 04		 jmp	 SHORT $L28926
$L28925:

; 995  : 				{	// _Pnode not less than _Keyval, remember it
; 996  : 				_Wherenode = _Pnode;

  00018	8b c1		 mov	 eax, ecx

; 997  : 				_Pnode = _Left(_Pnode);	// descend left subtree

  0001a	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L28926:

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  0001c	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00020	74 ec		 je	 SHORT $L28923
$L28924:

; 998  : 				}
; 999  : 
; 1000 : 		return (_Wherenode);	// return best remembered candidate
; 1001 : 		}

  00022	c3		 ret	 0
?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Lbound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Init, COMDAT
; _this$ = esi

; 902  : 		_Myhead = _Buynode();

  00000	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Buynode
  00005	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 903  : 		_Isnil(_Myhead) = true;

  0000a	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1

; 904  : 		_Root() = _Myhead;

  0000e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00010	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 905  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00013	8b 01		 mov	 eax, DWORD PTR [ecx]
  00015	89 00		 mov	 DWORD PTR [eax], eax
  00017	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00019	89 49 08	 mov	 DWORD PTR [ecx+8], ecx

; 906  : 		_Mysize = 0;

  0001c	83 66 08 00	 and	 DWORD PTR [esi+8], 0

; 907  : 		}

  00020	c3		 ret	 0
?_Init@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Init
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::lower_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 815  : 		return (_TREE_CONST_ITERATOR(_Lbound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Lbound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 816  : 		}

  00009	c3		 ret	 0
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::lower_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z PROC NEAR ; std::_Tree_val<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Tree_val<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >, COMDAT
; _this$ = eax

; 96   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_val@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Tree_val<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Rmost, COMDAT
; _this$ = eax

; 1049 : 		return (_Right(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 08	 add	 eax, 8

; 1050 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Rmost
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Lbound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 988  : 		_Nodeptr _Pnode = _Root();

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	75 16		 jne	 SHORT $L28789
  0000c	8b 12		 mov	 edx, DWORD PTR [edx]
$L28788:

; 992  : 			if (this->comp(_Key(_Pnode), _Keyval))

  0000e	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00011	7d 05		 jge	 SHORT $L28790

; 993  : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00013	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 994  : 			else

  00016	eb 04		 jmp	 SHORT $L28791
$L28790:

; 995  : 				{	// _Pnode not less than _Keyval, remember it
; 996  : 				_Wherenode = _Pnode;

  00018	8b c1		 mov	 eax, ecx

; 997  : 				_Pnode = _Left(_Pnode);	// descend left subtree

  0001a	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L28791:

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  0001c	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00020	74 ec		 je	 SHORT $L28788
$L28789:

; 998  : 				}
; 999  : 
; 1000 : 		return (_Wherenode);	// return best remembered candidate
; 1001 : 		}

  00022	c3		 ret	 0
?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Lbound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Init, COMDAT
; _this$ = esi

; 902  : 		_Myhead = _Buynode();

  00000	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Buynode
  00005	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 903  : 		_Isnil(_Myhead) = true;

  0000a	c6 40 15 01	 mov	 BYTE PTR [eax+21], 1

; 904  : 		_Root() = _Myhead;

  0000e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00010	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 905  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00013	8b 01		 mov	 eax, DWORD PTR [ecx]
  00015	89 00		 mov	 DWORD PTR [eax], eax
  00017	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00019	89 49 08	 mov	 DWORD PTR [ecx+8], ecx

; 906  : 		_Mysize = 0;

  0001c	83 66 08 00	 and	 DWORD PTR [esi+8], 0

; 907  : 		}

  00020	c3		 ret	 0
?_Init@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Init
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::lower_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 815  : 		return (_TREE_CONST_ITERATOR(_Lbound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Lbound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 816  : 		}

  00009	c3		 ret	 0
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::lower_bound
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@PAU342@0ABQAVMusicItem@@@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Buynode@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@PAU342@0ABQAVMusicItem@@@Z PROC NEAR ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Buynode, COMDAT

; 918  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

  00000	6a 0c		 push	 12			; 0000000cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 919  : 		_TRY_BEGIN
; 920  : 		new ((void *)_Pnode) _Node(_Next, _Prev, _Val);

  00007	85 c0		 test	 eax, eax
  00009	59		 pop	 ecx
  0000a	74 16		 je	 SHORT $L50894
  0000c	8b 4c 24 04	 mov	 ecx, DWORD PTR __Next$[esp-4]
  00010	89 08		 mov	 DWORD PTR [eax], ecx
  00012	8b 4c 24 08	 mov	 ecx, DWORD PTR __Prev$[esp-4]
  00016	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00019	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0001d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001f	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$L50894:

; 921  : 		_CATCH_ALL
; 922  : 		this->_Alnod.deallocate(_Pnode, 1);
; 923  : 		_RERAISE;
; 924  : 		_CATCH_END
; 925  : 		return (_Pnode);
; 926  : 		}

  00022	c2 0c 00	 ret	 12			; 0000000cH
?_Buynode@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@PAU342@0ABQAVMusicItem@@@Z ENDP ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Buynode
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator::operator++, COMDAT

; 327  : 			++(*(const_iterator *)this);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::_Inc

; 328  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 329  : 			}

  0000d	c2 04 00	 ret	 4
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVN163@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVN163@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator::operator*, COMDAT
; _this$ = eax

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVN163@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator::operator++, COMDAT

; 327  : 			++(*(const_iterator *)this);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::_Inc

; 328  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 329  : 			}

  0000d	c2 04 00	 ret	 4
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVVRC7@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVVRC7@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator::operator*, COMDAT
; _this$ = eax

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVVRC7@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator::operator++, COMDAT

; 327  : 			++(*(const_iterator *)this);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::_Inc

; 328  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 329  : 			}

  0000d	c2 04 00	 ret	 4
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVFDSM@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVFDSM@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator::operator*, COMDAT
; _this$ = eax

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVFDSM@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator::operator++, COMDAT

; 327  : 			++(*(const_iterator *)this);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::_Inc

; 328  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 329  : 			}

  0000d	c2 04 00	 ret	 4
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVFDSC@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVFDSC@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator::operator*, COMDAT
; _this$ = eax

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVFDSC@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator::operator++, COMDAT

; 327  : 			++(*(const_iterator *)this);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Inc

; 328  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 329  : 			}

  0000d	c2 04 00	 ret	 4
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVSub@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVSub@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator::operator*, COMDAT
; _this$ = eax

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVSub@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVSE@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVSE@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator::operator*, COMDAT
; _this$ = eax

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVSE@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVBGM@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVBGM@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator::operator*, COMDAT
; _this$ = eax

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVBGM@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator::operator++, COMDAT

; 327  : 			++(*(const_iterator *)this);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::_Inc

; 328  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 329  : 			}

  0000d	c2 04 00	 ret	 4
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVEnvelop@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVEnvelop@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator::operator*, COMDAT
; _this$ = eax

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBHPAVEnvelop@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::lower_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 810  : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Lbound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 811  : 		}

  00009	c3		 ret	 0
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::lower_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z
_TEXT	SEGMENT
??0?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >, COMDAT
; _this$ = eax

; 361  : 		{	// construct empty tree

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 362  : 		_Init();

  00003	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Init

; 363  : 		}

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi
  0000b	c3		 ret	 0
??0?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVSub@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::lower_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 810  : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Lbound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 811  : 		}

  00009	c3		 ret	 0
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::lower_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z
_TEXT	SEGMENT
??0?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >, COMDAT
; _this$ = eax

; 361  : 		{	// construct empty tree

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 362  : 		_Init();

  00003	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Init

; 363  : 		}

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi
  0000b	c3		 ret	 0
??0?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVSE@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::lower_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 810  : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Lbound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 811  : 		}

  00009	c3		 ret	 0
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::lower_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z
_TEXT	SEGMENT
??0?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >, COMDAT
; _this$ = eax

; 361  : 		{	// construct empty tree

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 362  : 		_Init();

  00003	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Init

; 363  : 		}

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi
  0000b	c3		 ret	 0
??0?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::lower_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 810  : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Lbound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 811  : 		}

  00009	c3		 ret	 0
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::lower_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z
_TEXT	SEGMENT
??0?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >, COMDAT
; _this$ = eax

; 361  : 		{	// construct empty tree

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 362  : 		_Init();

  00003	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Init

; 363  : 		}

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi
  0000b	c3		 ret	 0
??0?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::lower_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 810  : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Lbound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 811  : 		}

  00009	c3		 ret	 0
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::lower_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z
_TEXT	SEGMENT
??0?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >, COMDAT
; _this$ = eax

; 361  : 		{	// construct empty tree

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 362  : 		_Init();

  00003	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Init

; 363  : 		}

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi
  0000b	c3		 ret	 0
??0?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVN163@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::lower_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 810  : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Lbound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 811  : 		}

  00009	c3		 ret	 0
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::lower_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z
_TEXT	SEGMENT
??0?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >, COMDAT
; _this$ = eax

; 361  : 		{	// construct empty tree

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 362  : 		_Init();

  00003	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Init

; 363  : 		}

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi
  0000b	c3		 ret	 0
??0?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::lower_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 810  : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Lbound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 811  : 		}

  00009	c3		 ret	 0
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::lower_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z
_TEXT	SEGMENT
??0?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >, COMDAT
; _this$ = eax

; 361  : 		{	// construct empty tree

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 362  : 		_Init();

  00003	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Init

; 363  : 		}

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi
  0000b	c3		 ret	 0
??0?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::lower_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 810  : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Lbound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 811  : 		}

  00009	c3		 ret	 0
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::lower_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z
_TEXT	SEGMENT
??0?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >, COMDAT
; _this$ = eax

; 361  : 		{	// construct empty tree

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 362  : 		_Init();

  00003	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Init

; 363  : 		}

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi
  0000b	c3		 ret	 0
??0?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator::operator++, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = edi

; 332  : 			{	// postincrement

  00000	56		 push	 esi

; 333  : 			iterator _Tmp = *this;

  00001	8b 32		 mov	 esi, DWORD PTR [edx]

; 334  : 			++*this;

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::_Inc

; 335  : 			return (_Tmp);

  00008	89 37		 mov	 DWORD PTR [edi], esi
  0000a	8b c7		 mov	 eax, edi
  0000c	5e		 pop	 esi

; 336  : 			}

  0000d	c3		 ret	 0
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVN163@@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVN163@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator::operator->, COMDAT
; _this$ = eax

; 322  : 			return (&**this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVN163@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator::operator->
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator::operator++, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = edi

; 332  : 			{	// postincrement

  00000	56		 push	 esi

; 333  : 			iterator _Tmp = *this;

  00001	8b 32		 mov	 esi, DWORD PTR [edx]

; 334  : 			++*this;

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::_Inc

; 335  : 			return (_Tmp);

  00008	89 37		 mov	 DWORD PTR [edi], esi
  0000a	8b c7		 mov	 eax, edi
  0000c	5e		 pop	 esi

; 336  : 			}

  0000d	c3		 ret	 0
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVVRC7@@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVVRC7@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator::operator->, COMDAT
; _this$ = eax

; 322  : 			return (&**this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVVRC7@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator::operator->
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator::operator++, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = edi

; 332  : 			{	// postincrement

  00000	56		 push	 esi

; 333  : 			iterator _Tmp = *this;

  00001	8b 32		 mov	 esi, DWORD PTR [edx]

; 334  : 			++*this;

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::_Inc

; 335  : 			return (_Tmp);

  00008	89 37		 mov	 DWORD PTR [edi], esi
  0000a	8b c7		 mov	 eax, edi
  0000c	5e		 pop	 esi

; 336  : 			}

  0000d	c3		 ret	 0
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVFDSM@@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVFDSM@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator::operator->, COMDAT
; _this$ = eax

; 322  : 			return (&**this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVFDSM@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator::operator->
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator::operator++, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = edi

; 332  : 			{	// postincrement

  00000	56		 push	 esi

; 333  : 			iterator _Tmp = *this;

  00001	8b 32		 mov	 esi, DWORD PTR [edx]

; 334  : 			++*this;

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::_Inc

; 335  : 			return (_Tmp);

  00008	89 37		 mov	 DWORD PTR [edi], esi
  0000a	8b c7		 mov	 eax, edi
  0000c	5e		 pop	 esi

; 336  : 			}

  0000d	c3		 ret	 0
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVFDSC@@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVFDSC@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator::operator->, COMDAT
; _this$ = eax

; 322  : 			return (&**this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVFDSC@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator::operator->
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator::operator++, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = edi

; 332  : 			{	// postincrement

  00000	56		 push	 esi

; 333  : 			iterator _Tmp = *this;

  00001	8b 32		 mov	 esi, DWORD PTR [edx]

; 334  : 			++*this;

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Inc

; 335  : 			return (_Tmp);

  00008	89 37		 mov	 DWORD PTR [edi], esi
  0000a	8b c7		 mov	 eax, edi
  0000c	5e		 pop	 esi

; 336  : 			}

  0000d	c3		 ret	 0
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVSub@@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVSub@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator::operator->, COMDAT
; _this$ = eax

; 322  : 			return (&**this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVSub@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator::operator->
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator::operator++, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = edi

; 332  : 			{	// postincrement

  00000	56		 push	 esi

; 333  : 			iterator _Tmp = *this;

  00001	8b 32		 mov	 esi, DWORD PTR [edx]

; 334  : 			++*this;

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::_Inc

; 335  : 			return (_Tmp);

  00008	89 37		 mov	 DWORD PTR [edi], esi
  0000a	8b c7		 mov	 eax, edi
  0000c	5e		 pop	 esi

; 336  : 			}

  0000d	c3		 ret	 0
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVEnvelop@@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVEnvelop@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator::operator->, COMDAT
; _this$ = eax

; 322  : 			return (&**this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 323  : 			}

  00005	c3		 ret	 0
??Citerator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEPAU?$pair@$$CBHPAVEnvelop@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator::operator->
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\streambuf
;	COMDAT ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::snextc, COMDAT

; 118  : 		return (_Traits::eq_int_type(_Traits::eof(), sbumpc())
; 119  : 			? _Traits::eof() : sgetc());

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
  00009	83 f8 ff	 cmp	 eax, -1
  0000c	75 04		 jne	 SHORT $L56195
  0000e	0b c0		 or	 eax, eax
  00010	eb 09		 jmp	 SHORT $L56196
$L56195:
  00012	8b 4c 24 04	 mov	 ecx, DWORD PTR _this$[esp-4]
  00016	e8 00 00 00 00	 call	 ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
$L56196:

; 120  : 		}

  0001b	c2 04 00	 ret	 4
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::snextc
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
_TEXT	ENDS
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$ctype@D@std@@MAE@XZ PROC NEAR			; std::ctype<char>::~ctype<char>, COMDAT
; _this$ = ecx

; 1247 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7?$ctype@D@std@@6B@

; 1248 : 		_Tidy();

  00009	e8 00 00 00 00	 call	 ?_Tidy@?$ctype@D@std@@IAEXXZ ; std::ctype<char>::_Tidy

; 1249 : 		}

  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7facet@locale@std@@6B@
  00014	5e		 pop	 esi
  00015	c3		 ret	 0
??1?$ctype@D@std@@MAE@XZ ENDP				; std::ctype<char>::~ctype<char>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC NEAR			; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1?$ctype@D@std@@MAE@XZ ; std::ctype<char>::~ctype<char>
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 07		 je	 SHORT $L6031
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	59		 pop	 ecx
$L6031:
  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi
  00019	c2 04 00	 ret	 4
??_G?$ctype@D@std@@MAEPAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xiosbase
xdata$x	SEGMENT
$T56319	DD	0ffffffffH
	DD	FLAT:$L56228
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T56321	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L56227
$T56320	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T56321
$T56313	DD	019930520H
	DD	03H
	DD	FLAT:$T56319
	DD	01H
	DD	FLAT:$T56320
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\istream
xdata$x	ENDS
;	COMDAT ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
$T56224 = 12						; size = 4
__Noskip$ = 12						; size = 1
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::_Ipfx, COMDAT

; 89   : 		{	// test stream state and skip whitespace as needed

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	51		 push	 ecx
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]

; 90   : 		if (ios_base::good())

  00011	8b 07		 mov	 eax, DWORD PTR [edi]
  00013	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00016	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  00019	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0001c	33 db		 xor	 ebx, ebx
  0001e	3b c3		 cmp	 eax, ebx
  00020	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00023	0f 85 cf 00 00
	00		 jne	 $L23589

; 91   : 			{	// state okay, flush tied stream and skip whitespace
; 92   : 			if (_Myios::tie() != 0)

  00029	8b 49 2c	 mov	 ecx, DWORD PTR [ecx+44]
  0002c	3b cb		 cmp	 ecx, ebx
  0002e	74 07		 je	 SHORT $L23576

; 93   : 				_Myios::tie()->flush();

  00030	8b f1		 mov	 esi, ecx
  00032	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$L23576:

; 94   : 
; 95   : 			if (!_Noskip && ios_base::flags() & ios_base::skipws)

  00037	38 5d 0c	 cmp	 BYTE PTR __Noskip$[ebp], bl
  0003a	0f 85 a3 00 00
	00		 jne	 $L23580
  00040	8b 07		 mov	 eax, DWORD PTR [edi]
  00042	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00045	8b 4c 39 10	 mov	 ecx, DWORD PTR [ecx+edi+16]
  00049	f6 c1 01	 test	 cl, 1
  0004c	0f 84 91 00 00
	00		 je	 $L23580

; 96   : 				{	// skip whitespace
; 97   : 				const _Ctype& _Ctype_fac = _USE(ios_base::getloc(), _Ctype);

  00052	8d 4d 0c	 lea	 ecx, DWORD PTR $T56224[ebp]
  00055	51		 push	 ecx
  00056	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00059	03 cf		 add	 ecx, edi
  0005b	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00060	50		 push	 eax
  00061	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx
  00064	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  00069	59		 pop	 ecx
  0006a	8d 4d 0c	 lea	 ecx, DWORD PTR $T56224[ebp]
  0006d	8b f0		 mov	 esi, eax
  0006f	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale

; 98   : 
; 99   : 				_TRY_IO_BEGIN

  00074	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 100  : 				int_type _Meta = _Myios::rdbuf()->sgetc();

  0007b	8b 07		 mov	 eax, DWORD PTR [edi]
  0007d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00080	8b 4c 38 28	 mov	 ecx, DWORD PTR [eax+edi+40]
  00084	e8 00 00 00 00	 call	 ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
$L23582:

; 101  : 
; 102  : 				for (; ; _Meta = _Myios::rdbuf()->snextc())
; 103  : 					if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  00089	83 f8 ff	 cmp	 eax, -1
  0008c	75 16		 jne	 SHORT $L23586

; 104  : 						{	// end of file, quit
; 105  : 						_Myios::setstate(ios_base::eofbit);

  0008e	8b 07		 mov	 eax, DWORD PTR [edi]
  00090	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00093	03 cf		 add	 ecx, edi
  00095	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00098	53		 push	 ebx
  00099	83 c8 01	 or	 eax, 1
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear

; 106  : 						break;

  000a2	eb 3f		 jmp	 SHORT $L23580
$L23586:

; 107  : 						}
; 108  : 					else if (!_Ctype_fac.is(_Ctype::space,
; 109  : 						_Traits::to_char_type(_Meta)))

  000a4	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000a7	0f b6 c0	 movzx	 eax, al
  000aa	f6 04 41 48	 test	 BYTE PTR [ecx+eax*2], 72 ; 00000048H
  000ae	74 33		 je	 SHORT $L23580
  000b0	8b 07		 mov	 eax, DWORD PTR [edi]
  000b2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b5	ff 74 38 28	 push	 DWORD PTR [eax+edi+40]
  000b9	e8 00 00 00 00	 call	 ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
  000be	eb c9		 jmp	 SHORT $L23582
$L56227:

; 110  : 						break;	// not whitespace, quit
; 111  : 				_CATCH_IO_END

  000c0	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c5	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000c8	03 c8		 add	 ecx, eax
  000ca	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000cd	6a 01		 push	 1
  000cf	83 c8 04	 or	 eax, 4
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
  000d8	b8 00 00 00 00	 mov	 eax, $L56315
  000dd	c3		 ret	 0
$L56315:
  000de	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  000e1	33 db		 xor	 ebx, ebx
$L23580:
  000e3	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1

; 112  : 				}
; 113  : 
; 114  : 			if (ios_base::good())

  000e7	8b 07		 mov	 eax, DWORD PTR [edi]
  000e9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ec	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  000ef	39 59 08	 cmp	 DWORD PTR [ecx+8], ebx
  000f2	75 04		 jne	 SHORT $L23589

; 115  : 				return (true);

  000f4	b0 01		 mov	 al, 1
  000f6	eb 0f		 jmp	 SHORT $L23574
$L23589:

; 116  : 			}
; 117  : 		_Myios::setstate(ios_base::failbit);

  000f8	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000fb	53		 push	 ebx
  000fc	83 c8 02	 or	 eax, 2
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear

; 118  : 		return (false);

  00105	32 c0		 xor	 al, al
$L23574:

; 119  : 		}

  00107	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi
  0010c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00113	5b		 pop	 ebx
  00114	c9		 leave
  00115	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L56228:
  00000	8d 4d 0c	 lea	 ecx, DWORD PTR $T56224[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T56313
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
;	COMDAT xdata$x
xdata$x	SEGMENT
$T56330	DD	0ffffffffH
	DD	FLAT:$L56326
$T56328	DD	019930520H
	DD	01H
	DD	FLAT:$T56330
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Istr$ = 12						; size = 4
__Noskip$ = 16						; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 72   : 			{	// construct locking and calling _Ipfx

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Istr$[ebp]
  0000d	56		 push	 esi
  0000e	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base

; 73   : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  00016	ff 75 10	 push	 DWORD PTR __Noskip$[ebp]
  00019	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0001d	ff 36		 push	 DWORD PTR [esi]
  0001f	e8 00 00 00 00	 call	 ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx

; 74   : 			}

  00024	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00027	88 46 04	 mov	 BYTE PTR [esi+4], al
  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00034	c9		 leave
  00035	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L56326:
  00000	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T56328
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z PROC NEAR ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator,unsigned int>, COMDAT
; __Off$ = esi

; 469  : 	{	// add to _Off distance between bidirectional iterators (redundant)

  00000	57		 push	 edi

; 470  : 	for (; _First != _Last; ++_First)

  00001	8b 7c 24 0c	 mov	 edi, DWORD PTR __Last$[esp]
  00005	eb 0b		 jmp	 SHORT $L56348
$L56337:

; 471  : 		++_Off;

  00007	ff 06		 inc	 DWORD PTR [esi]
  00009	8d 54 24 08	 lea	 edx, DWORD PTR __First$[esp]
  0000d	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Inc
$L56348:

; 470  : 	for (; _First != _Last; ++_First)

  00012	39 7c 24 08	 cmp	 DWORD PTR __First$[esp], edi
  00016	75 ef		 jne	 SHORT $L56337
  00018	5f		 pop	 edi

; 472  : 	}

  00019	c3		 ret	 0
??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator,unsigned int>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z PROC NEAR ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator,unsigned int>, COMDAT
; __Off$ = esi

; 469  : 	{	// add to _Off distance between bidirectional iterators (redundant)

  00000	57		 push	 edi

; 470  : 	for (; _First != _Last; ++_First)

  00001	8b 7c 24 0c	 mov	 edi, DWORD PTR __Last$[esp]
  00005	eb 0b		 jmp	 SHORT $L56365
$L56354:

; 471  : 		++_Off;

  00007	ff 06		 inc	 DWORD PTR [esi]
  00009	8d 54 24 08	 lea	 edx, DWORD PTR __First$[esp]
  0000d	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::_Inc
$L56365:

; 470  : 	for (; _First != _Last; ++_First)

  00012	39 7c 24 08	 cmp	 DWORD PTR __First$[esp], edi
  00016	75 ef		 jne	 SHORT $L56354
  00018	5f		 pop	 edi

; 472  : 	}

  00019	c3		 ret	 0
??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator,unsigned int>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z PROC NEAR ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator,unsigned int>, COMDAT
; __Off$ = esi

; 469  : 	{	// add to _Off distance between bidirectional iterators (redundant)

  00000	57		 push	 edi

; 470  : 	for (; _First != _Last; ++_First)

  00001	8b 7c 24 0c	 mov	 edi, DWORD PTR __Last$[esp]
  00005	eb 0b		 jmp	 SHORT $L56382
$L56371:

; 471  : 		++_Off;

  00007	ff 06		 inc	 DWORD PTR [esi]
  00009	8d 54 24 08	 lea	 edx, DWORD PTR __First$[esp]
  0000d	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::_Inc
$L56382:

; 470  : 	for (; _First != _Last; ++_First)

  00012	39 7c 24 08	 cmp	 DWORD PTR __First$[esp], edi
  00016	75 ef		 jne	 SHORT $L56371
  00018	5f		 pop	 edi

; 472  : 	}

  00019	c3		 ret	 0
??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator,unsigned int>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z PROC NEAR ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator,unsigned int>, COMDAT
; __Off$ = esi

; 469  : 	{	// add to _Off distance between bidirectional iterators (redundant)

  00000	57		 push	 edi

; 470  : 	for (; _First != _Last; ++_First)

  00001	8b 7c 24 0c	 mov	 edi, DWORD PTR __Last$[esp]
  00005	eb 0b		 jmp	 SHORT $L56399
$L56388:

; 471  : 		++_Off;

  00007	ff 06		 inc	 DWORD PTR [esi]
  00009	8d 54 24 08	 lea	 edx, DWORD PTR __First$[esp]
  0000d	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::_Inc
$L56399:

; 470  : 	for (; _First != _Last; ++_First)

  00012	39 7c 24 08	 cmp	 DWORD PTR __First$[esp], edi
  00016	75 ef		 jne	 SHORT $L56388
  00018	5f		 pop	 edi

; 472  : 	}

  00019	c3		 ret	 0
??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator,unsigned int>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z PROC NEAR ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator,unsigned int>, COMDAT
; __Off$ = esi

; 469  : 	{	// add to _Off distance between bidirectional iterators (redundant)

  00000	57		 push	 edi

; 470  : 	for (; _First != _Last; ++_First)

  00001	8b 7c 24 0c	 mov	 edi, DWORD PTR __Last$[esp]
  00005	eb 0b		 jmp	 SHORT $L56416
$L56405:

; 471  : 		++_Off;

  00007	ff 06		 inc	 DWORD PTR [esi]
  00009	8d 54 24 08	 lea	 edx, DWORD PTR __First$[esp]
  0000d	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::_Inc
$L56416:

; 470  : 	for (; _First != _Last; ++_First)

  00012	39 7c 24 08	 cmp	 DWORD PTR __First$[esp], edi
  00016	75 ef		 jne	 SHORT $L56405
  00018	5f		 pop	 edi

; 472  : 	}

  00019	c3		 ret	 0
??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator,unsigned int>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z PROC NEAR ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator,unsigned int>, COMDAT
; __Off$ = esi

; 469  : 	{	// add to _Off distance between bidirectional iterators (redundant)

  00000	57		 push	 edi

; 470  : 	for (; _First != _Last; ++_First)

  00001	8b 7c 24 0c	 mov	 edi, DWORD PTR __Last$[esp]
  00005	eb 0b		 jmp	 SHORT $L56433
$L56422:

; 471  : 		++_Off;

  00007	ff 06		 inc	 DWORD PTR [esi]
  00009	8d 54 24 08	 lea	 edx, DWORD PTR __First$[esp]
  0000d	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::_Inc
$L56433:

; 470  : 	for (; _First != _Last; ++_First)

  00012	39 7c 24 08	 cmp	 DWORD PTR __First$[esp], edi
  00016	75 ef		 jne	 SHORT $L56422
  00018	5f		 pop	 edi

; 472  : 	}

  00019	c3		 ret	 0
??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator,unsigned int>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT
$T56437 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@0AAI@Z PROC NEAR ; std::_Distance<std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator,unsigned int>, COMDAT
; __Off$ = esi

; 497  : 	{	// add to _Off distance between iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 498  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

  00004	ff 75 fc	 push	 DWORD PTR $T56437[ebp]
  00007	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator,unsigned int>
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 499  : 	}

  00015	c9		 leave
  00016	c3		 ret	 0
??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@0@0AAI@Z ENDP ; std::_Distance<std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator,unsigned int>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT
$T56444 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@0AAI@Z PROC NEAR ; std::_Distance<std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator,unsigned int>, COMDAT
; __Off$ = esi

; 497  : 	{	// add to _Off distance between iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 498  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

  00004	ff 75 fc	 push	 DWORD PTR $T56444[ebp]
  00007	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator,unsigned int>
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 499  : 	}

  00015	c9		 leave
  00016	c3		 ret	 0
??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@0@0AAI@Z ENDP ; std::_Distance<std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator,unsigned int>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT
$T56451 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@0AAI@Z PROC NEAR ; std::_Distance<std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator,unsigned int>, COMDAT
; __Off$ = esi

; 497  : 	{	// add to _Off distance between iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 498  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

  00004	ff 75 fc	 push	 DWORD PTR $T56451[ebp]
  00007	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator,unsigned int>
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 499  : 	}

  00015	c9		 leave
  00016	c3		 ret	 0
??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@0@0AAI@Z ENDP ; std::_Distance<std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator,unsigned int>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT
$T56458 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@0AAI@Z PROC NEAR ; std::_Distance<std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator,unsigned int>, COMDAT
; __Off$ = esi

; 497  : 	{	// add to _Off distance between iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 498  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

  00004	ff 75 fc	 push	 DWORD PTR $T56458[ebp]
  00007	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator,unsigned int>
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 499  : 	}

  00015	c9		 leave
  00016	c3		 ret	 0
??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@0@0AAI@Z ENDP ; std::_Distance<std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator,unsigned int>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT
$T56465 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@0AAI@Z PROC NEAR ; std::_Distance<std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator,unsigned int>, COMDAT
; __Off$ = esi

; 497  : 	{	// add to _Off distance between iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 498  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

  00004	ff 75 fc	 push	 DWORD PTR $T56465[ebp]
  00007	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator,unsigned int>
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 499  : 	}

  00015	c9		 leave
  00016	c3		 ret	 0
??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@0@0AAI@Z ENDP ; std::_Distance<std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator,unsigned int>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT
$T56472 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@0AAI@Z PROC NEAR ; std::_Distance<std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator,unsigned int>, COMDAT
; __Off$ = esi

; 497  : 	{	// add to _Off distance between iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 498  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

  00004	ff 75 fc	 push	 DWORD PTR $T56472[ebp]
  00007	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator,unsigned int>
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 499  : 	}

  00015	c9		 leave
  00016	c3		 ret	 0
??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@0@0AAI@Z ENDP ; std::_Distance<std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator,unsigned int>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 251  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	53		 push	 ebx
  00003	32 db		 xor	 bl, bl
  00005	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00008	74 05		 je	 SHORT $L31930

; 252  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 253  : 			else if (!_Isnil(_Left(_Ptr)))

  0000d	eb 2c		 jmp	 SHORT $L56533
$L31930:
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	38 5a 15	 cmp	 BYTE PTR [edx+21], bl
  00014	75 18		 jne	 SHORT $L56530

; 254  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

  00016	eb 02		 jmp	 SHORT $L56535
$L56514:
  00018	8b d0		 mov	 edx, eax
$L56535:
  0001a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001d	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00020	74 f6		 je	 SHORT $L56514
  00022	89 11		 mov	 DWORD PTR [ecx], edx
  00024	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  00025	c3		 ret	 0
$L31936:

; 255  : 			else
; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	3b 10		 cmp	 edx, DWORD PTR [eax]
  0002a	75 0a		 jne	 SHORT $L31937

; 260  : 					_Ptr = _Pnode;	// ==> parent while left subtree

  0002c	89 01		 mov	 DWORD PTR [ecx], eax
$L56530:

; 255  : 			else
; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

  0002e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00031	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00034	74 f0		 je	 SHORT $L31936
$L31937:

; 261  : 				if (!_Isnil(_Pnode))

  00036	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00039	75 02		 jne	 SHORT $L31938
$L56533:

; 262  : 					_Ptr = _Pnode;	// ==> parent if not head

  0003b	89 01		 mov	 DWORD PTR [ecx], eax
$L31938:
  0003d	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  0003e	c3		 ret	 0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 251  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	53		 push	 ebx
  00003	32 db		 xor	 bl, bl
  00005	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00008	74 05		 je	 SHORT $L31919

; 252  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 253  : 			else if (!_Isnil(_Left(_Ptr)))

  0000d	eb 2c		 jmp	 SHORT $L56594
$L31919:
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	38 5a 15	 cmp	 BYTE PTR [edx+21], bl
  00014	75 18		 jne	 SHORT $L56591

; 254  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

  00016	eb 02		 jmp	 SHORT $L56596
$L56575:
  00018	8b d0		 mov	 edx, eax
$L56596:
  0001a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001d	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00020	74 f6		 je	 SHORT $L56575
  00022	89 11		 mov	 DWORD PTR [ecx], edx
  00024	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  00025	c3		 ret	 0
$L31925:

; 255  : 			else
; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	3b 10		 cmp	 edx, DWORD PTR [eax]
  0002a	75 0a		 jne	 SHORT $L31926

; 260  : 					_Ptr = _Pnode;	// ==> parent while left subtree

  0002c	89 01		 mov	 DWORD PTR [ecx], eax
$L56591:

; 255  : 			else
; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

  0002e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00031	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00034	74 f0		 je	 SHORT $L31925
$L31926:

; 261  : 				if (!_Isnil(_Pnode))

  00036	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00039	75 02		 jne	 SHORT $L31927
$L56594:

; 262  : 					_Ptr = _Pnode;	// ==> parent if not head

  0003b	89 01		 mov	 DWORD PTR [ecx], eax
$L31927:
  0003d	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  0003e	c3		 ret	 0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 251  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	53		 push	 ebx
  00003	32 db		 xor	 bl, bl
  00005	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00008	74 05		 je	 SHORT $L31908

; 252  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 253  : 			else if (!_Isnil(_Left(_Ptr)))

  0000d	eb 2c		 jmp	 SHORT $L56655
$L31908:
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	38 5a 15	 cmp	 BYTE PTR [edx+21], bl
  00014	75 18		 jne	 SHORT $L56652

; 254  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

  00016	eb 02		 jmp	 SHORT $L56657
$L56636:
  00018	8b d0		 mov	 edx, eax
$L56657:
  0001a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001d	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00020	74 f6		 je	 SHORT $L56636
  00022	89 11		 mov	 DWORD PTR [ecx], edx
  00024	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  00025	c3		 ret	 0
$L31914:

; 255  : 			else
; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	3b 10		 cmp	 edx, DWORD PTR [eax]
  0002a	75 0a		 jne	 SHORT $L31915

; 260  : 					_Ptr = _Pnode;	// ==> parent while left subtree

  0002c	89 01		 mov	 DWORD PTR [ecx], eax
$L56652:

; 255  : 			else
; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

  0002e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00031	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00034	74 f0		 je	 SHORT $L31914
$L31915:

; 261  : 				if (!_Isnil(_Pnode))

  00036	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00039	75 02		 jne	 SHORT $L31916
$L56655:

; 262  : 					_Ptr = _Pnode;	// ==> parent if not head

  0003b	89 01		 mov	 DWORD PTR [ecx], eax
$L31916:
  0003d	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  0003e	c3		 ret	 0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 251  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	53		 push	 ebx
  00003	32 db		 xor	 bl, bl
  00005	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00008	74 05		 je	 SHORT $L31897

; 252  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 253  : 			else if (!_Isnil(_Left(_Ptr)))

  0000d	eb 2c		 jmp	 SHORT $L56716
$L31897:
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	38 5a 15	 cmp	 BYTE PTR [edx+21], bl
  00014	75 18		 jne	 SHORT $L56713

; 254  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

  00016	eb 02		 jmp	 SHORT $L56718
$L56697:
  00018	8b d0		 mov	 edx, eax
$L56718:
  0001a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001d	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00020	74 f6		 je	 SHORT $L56697
  00022	89 11		 mov	 DWORD PTR [ecx], edx
  00024	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  00025	c3		 ret	 0
$L31903:

; 255  : 			else
; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	3b 10		 cmp	 edx, DWORD PTR [eax]
  0002a	75 0a		 jne	 SHORT $L31904

; 260  : 					_Ptr = _Pnode;	// ==> parent while left subtree

  0002c	89 01		 mov	 DWORD PTR [ecx], eax
$L56713:

; 255  : 			else
; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

  0002e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00031	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00034	74 f0		 je	 SHORT $L31903
$L31904:

; 261  : 				if (!_Isnil(_Pnode))

  00036	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00039	75 02		 jne	 SHORT $L31905
$L56716:

; 262  : 					_Ptr = _Pnode;	// ==> parent if not head

  0003b	89 01		 mov	 DWORD PTR [ecx], eax
$L31905:
  0003d	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  0003e	c3		 ret	 0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 251  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	53		 push	 ebx
  00003	32 db		 xor	 bl, bl
  00005	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00008	74 05		 je	 SHORT $L31886

; 252  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 253  : 			else if (!_Isnil(_Left(_Ptr)))

  0000d	eb 2c		 jmp	 SHORT $L56777
$L31886:
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	38 5a 15	 cmp	 BYTE PTR [edx+21], bl
  00014	75 18		 jne	 SHORT $L56774

; 254  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

  00016	eb 02		 jmp	 SHORT $L56779
$L56751:
  00018	8b d0		 mov	 edx, eax
$L56779:
  0001a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001d	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00020	74 f6		 je	 SHORT $L56751
  00022	89 11		 mov	 DWORD PTR [ecx], edx
  00024	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  00025	c3		 ret	 0
$L31892:

; 255  : 			else
; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	3b 10		 cmp	 edx, DWORD PTR [eax]
  0002a	75 0a		 jne	 SHORT $L31893

; 260  : 					_Ptr = _Pnode;	// ==> parent while left subtree

  0002c	89 01		 mov	 DWORD PTR [ecx], eax
$L56774:

; 255  : 			else
; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

  0002e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00031	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00034	74 f0		 je	 SHORT $L31892
$L31893:

; 261  : 				if (!_Isnil(_Pnode))

  00036	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00039	75 02		 jne	 SHORT $L31894
$L56777:

; 262  : 					_Ptr = _Pnode;	// ==> parent if not head

  0003b	89 01		 mov	 DWORD PTR [ecx], eax
$L31894:
  0003d	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  0003e	c3		 ret	 0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = edx

; 268  : 			if (_Isnil(_Ptr))

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	53		 push	 ebx
  00003	32 db		 xor	 bl, bl
  00005	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00008	75 2a		 jne	 SHORT $L31879

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	38 59 15	 cmp	 BYTE PTR [ecx+21], bl
  00010	75 18		 jne	 SHORT $L56827

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

  00012	eb 02		 jmp	 SHORT $L56831
$L56807:
  00014	8b c8		 mov	 ecx, eax
$L56831:
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  0001b	74 f7		 je	 SHORT $L56807
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  00020	c3		 ret	 0
$L31882:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  00021	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00023	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00026	75 0a		 jne	 SHORT $L31883

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

  00028	89 02		 mov	 DWORD PTR [edx], eax
$L56827:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00030	74 ef		 je	 SHORT $L31882
$L31883:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

  00032	89 02		 mov	 DWORD PTR [edx], eax
$L31879:
  00034	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  00035	c3		 ret	 0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 251  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	53		 push	 ebx
  00003	32 db		 xor	 bl, bl
  00005	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00008	74 05		 je	 SHORT $L31865

; 252  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 253  : 			else if (!_Isnil(_Left(_Ptr)))

  0000d	eb 2c		 jmp	 SHORT $L56890
$L31865:
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	38 5a 15	 cmp	 BYTE PTR [edx+21], bl
  00014	75 18		 jne	 SHORT $L56887

; 254  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

  00016	eb 02		 jmp	 SHORT $L56892
$L56864:
  00018	8b d0		 mov	 edx, eax
$L56892:
  0001a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001d	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00020	74 f6		 je	 SHORT $L56864
  00022	89 11		 mov	 DWORD PTR [ecx], edx
  00024	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  00025	c3		 ret	 0
$L31871:

; 255  : 			else
; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	3b 10		 cmp	 edx, DWORD PTR [eax]
  0002a	75 0a		 jne	 SHORT $L31872

; 260  : 					_Ptr = _Pnode;	// ==> parent while left subtree

  0002c	89 01		 mov	 DWORD PTR [ecx], eax
$L56887:

; 255  : 			else
; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

  0002e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00031	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00034	74 f0		 je	 SHORT $L31871
$L31872:

; 261  : 				if (!_Isnil(_Pnode))

  00036	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00039	75 02		 jne	 SHORT $L31873
$L56890:

; 262  : 					_Ptr = _Pnode;	// ==> parent if not head

  0003b	89 01		 mov	 DWORD PTR [ecx], eax
$L31873:
  0003d	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  0003e	c3		 ret	 0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = edx

; 268  : 			if (_Isnil(_Ptr))

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	53		 push	 ebx
  00003	32 db		 xor	 bl, bl
  00005	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00008	75 2a		 jne	 SHORT $L31858

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	38 59 15	 cmp	 BYTE PTR [ecx+21], bl
  00010	75 18		 jne	 SHORT $L56940

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

  00012	eb 02		 jmp	 SHORT $L56944
$L56927:
  00014	8b c8		 mov	 ecx, eax
$L56944:
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  0001b	74 f7		 je	 SHORT $L56927
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  00020	c3		 ret	 0
$L31861:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  00021	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00023	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00026	75 0a		 jne	 SHORT $L31862

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

  00028	89 02		 mov	 DWORD PTR [edx], eax
$L56940:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00030	74 ef		 je	 SHORT $L31861
$L31862:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

  00032	89 02		 mov	 DWORD PTR [edx], eax
$L31858:
  00034	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  00035	c3		 ret	 0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 251  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	53		 push	 ebx
  00003	32 db		 xor	 bl, bl
  00005	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00008	74 05		 je	 SHORT $L31844

; 252  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 253  : 			else if (!_Isnil(_Left(_Ptr)))

  0000d	eb 2c		 jmp	 SHORT $L57003
$L31844:
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	38 5a 15	 cmp	 BYTE PTR [edx+21], bl
  00014	75 18		 jne	 SHORT $L57000

; 254  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

  00016	eb 02		 jmp	 SHORT $L57005
$L56984:
  00018	8b d0		 mov	 edx, eax
$L57005:
  0001a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001d	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00020	74 f6		 je	 SHORT $L56984
  00022	89 11		 mov	 DWORD PTR [ecx], edx
  00024	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  00025	c3		 ret	 0
$L31850:

; 255  : 			else
; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	3b 10		 cmp	 edx, DWORD PTR [eax]
  0002a	75 0a		 jne	 SHORT $L31851

; 260  : 					_Ptr = _Pnode;	// ==> parent while left subtree

  0002c	89 01		 mov	 DWORD PTR [ecx], eax
$L57000:

; 255  : 			else
; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

  0002e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00031	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00034	74 f0		 je	 SHORT $L31850
$L31851:

; 261  : 				if (!_Isnil(_Pnode))

  00036	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00039	75 02		 jne	 SHORT $L31852
$L57003:

; 262  : 					_Ptr = _Pnode;	// ==> parent if not head

  0003b	89 01		 mov	 DWORD PTR [ecx], eax
$L31852:
  0003d	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  0003e	c3		 ret	 0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 251  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	53		 push	 ebx
  00003	32 db		 xor	 bl, bl
  00005	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00008	74 05		 je	 SHORT $L31833

; 252  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 253  : 			else if (!_Isnil(_Left(_Ptr)))

  0000d	eb 2c		 jmp	 SHORT $L57064
$L31833:
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	38 5a 15	 cmp	 BYTE PTR [edx+21], bl
  00014	75 18		 jne	 SHORT $L57061

; 254  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

  00016	eb 02		 jmp	 SHORT $L57066
$L57045:
  00018	8b d0		 mov	 edx, eax
$L57066:
  0001a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001d	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00020	74 f6		 je	 SHORT $L57045
  00022	89 11		 mov	 DWORD PTR [ecx], edx
  00024	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  00025	c3		 ret	 0
$L31839:

; 255  : 			else
; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	3b 10		 cmp	 edx, DWORD PTR [eax]
  0002a	75 0a		 jne	 SHORT $L31840

; 260  : 					_Ptr = _Pnode;	// ==> parent while left subtree

  0002c	89 01		 mov	 DWORD PTR [ecx], eax
$L57061:

; 255  : 			else
; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

  0002e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00031	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00034	74 f0		 je	 SHORT $L31839
$L31840:

; 261  : 				if (!_Isnil(_Pnode))

  00036	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00039	75 02		 jne	 SHORT $L31841
$L57064:

; 262  : 					_Ptr = _Pnode;	// ==> parent if not head

  0003b	89 01		 mov	 DWORD PTR [ecx], eax
$L31841:
  0003d	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  0003e	c3		 ret	 0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::operator--, COMDAT

; 228  : 			_Dec();

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::_Dec

; 229  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 230  : 			}

  0000d	c2 04 00	 ret	 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::operator--, COMDAT

; 228  : 			_Dec();

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::_Dec

; 229  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 230  : 			}

  0000d	c2 04 00	 ret	 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::operator--, COMDAT

; 228  : 			_Dec();

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::_Dec

; 229  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 230  : 			}

  0000d	c2 04 00	 ret	 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::operator--, COMDAT

; 228  : 			_Dec();

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::_Dec

; 229  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 230  : 			}

  0000d	c2 04 00	 ret	 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::operator--, COMDAT

; 228  : 			_Dec();

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Dec

; 229  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 230  : 			}

  0000d	c2 04 00	 ret	 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::operator--, COMDAT

; 228  : 			_Dec();

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::_Dec

; 229  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 230  : 			}

  0000d	c2 04 00	 ret	 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::operator++, COMDAT

; 215  : 			_Inc();

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 217  : 			}

  0000d	c2 04 00	 ret	 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::operator--, COMDAT

; 228  : 			_Dec();

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::_Dec

; 229  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 230  : 			}

  0000d	c2 04 00	 ret	 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::operator++, COMDAT

; 215  : 			_Inc();

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 217  : 			}

  0000d	c2 04 00	 ret	 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::operator--, COMDAT

; 228  : 			_Dec();

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::_Dec

; 229  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 230  : 			}

  0000d	c2 04 00	 ret	 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Ubound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 1089 : 		_Nodeptr _Pnode = _Root();

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1090 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1091 : 
; 1092 : 		while (!_Isnil(_Pnode))

  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	75 16		 jne	 SHORT $L31067
  0000c	8b 12		 mov	 edx, DWORD PTR [edx]
$L31066:

; 1093 : 			if (this->comp(_Keyval, _Key(_Pnode)))

  0000e	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00011	7d 06		 jge	 SHORT $L31068

; 1094 : 				{	// _Pnode greater than _Keyval, remember it
; 1095 : 				_Wherenode = _Pnode;

  00013	8b c1		 mov	 eax, ecx

; 1096 : 				_Pnode = _Left(_Pnode);	// descend left subtree

  00015	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 1097 : 				}
; 1098 : 			else

  00017	eb 03		 jmp	 SHORT $L31069
$L31068:

; 1099 : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
$L31069:

; 1090 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1091 : 
; 1092 : 		while (!_Isnil(_Pnode))

  0001c	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00020	74 ec		 je	 SHORT $L31066
$L31067:

; 1100 : 
; 1101 : 		return (_Wherenode);	// return best remembered candidate
; 1102 : 		}

  00022	c3		 ret	 0
?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Ubound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Rrotate, COMDAT
; __Wherenode$ = ecx

; 1069 : 		_Nodeptr _Pnode = _Left(_Wherenode);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1070 : 		_Left(_Wherenode) = _Right(_Pnode);

  00002	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00005	89 11		 mov	 DWORD PTR [ecx], edx

; 1071 : 
; 1072 : 		if (!_Isnil(_Right(_Pnode)))

  00007	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000a	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0000e	75 03		 jne	 SHORT $L31056

; 1073 : 			_Parent(_Right(_Pnode)) = _Wherenode;

  00010	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L31056:

; 1074 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1075 : 
; 1076 : 		if (_Wherenode == _Root())

  00019	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  0001d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00020	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00023	75 05		 jne	 SHORT $L31057

; 1077 : 			_Root() = _Pnode;

  00025	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1078 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

  00028	eb 0f		 jmp	 SHORT $L31060
$L31057:
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  00030	75 05		 jne	 SHORT $L31059

; 1079 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00032	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1080 : 		else

  00035	eb 02		 jmp	 SHORT $L31060
$L31059:

; 1081 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  00037	89 02		 mov	 DWORD PTR [edx], eax
$L31060:

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  00039	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  0003c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1085 : 		}

  0003f	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Rrotate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::clear, COMDAT
; _this$ = edi

; 780  : 		{	// erase all

  00000	56		 push	 esi

; 781  : 		_Erase(_Root());

  00001	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  00004	8b 06		 mov	 eax, DWORD PTR [esi]
  00006	ff 70 04	 push	 DWORD PTR [eax+4]
  00009	8b cf		 mov	 ecx, edi
  0000b	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Erase

; 782  : 		_Root() = _Myhead, _Mysize = 0;

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 783  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00015	8b 06		 mov	 eax, DWORD PTR [esi]
  00017	83 67 08 00	 and	 DWORD PTR [edi+8], 0
  0001b	89 00		 mov	 DWORD PTR [eax], eax
  0001d	8b 36		 mov	 esi, DWORD PTR [esi]
  0001f	89 76 08	 mov	 DWORD PTR [esi+8], esi
  00022	5e		 pop	 esi

; 784  : 		}

  00023	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::clear
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Ubound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 1089 : 		_Nodeptr _Pnode = _Root();

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1090 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1091 : 
; 1092 : 		while (!_Isnil(_Pnode))

  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	75 16		 jne	 SHORT $L30957
  0000c	8b 12		 mov	 edx, DWORD PTR [edx]
$L30956:

; 1093 : 			if (this->comp(_Keyval, _Key(_Pnode)))

  0000e	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00011	7d 06		 jge	 SHORT $L30958

; 1094 : 				{	// _Pnode greater than _Keyval, remember it
; 1095 : 				_Wherenode = _Pnode;

  00013	8b c1		 mov	 eax, ecx

; 1096 : 				_Pnode = _Left(_Pnode);	// descend left subtree

  00015	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 1097 : 				}
; 1098 : 			else

  00017	eb 03		 jmp	 SHORT $L30959
$L30958:

; 1099 : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
$L30959:

; 1090 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1091 : 
; 1092 : 		while (!_Isnil(_Pnode))

  0001c	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00020	74 ec		 je	 SHORT $L30956
$L30957:

; 1100 : 
; 1101 : 		return (_Wherenode);	// return best remembered candidate
; 1102 : 		}

  00022	c3		 ret	 0
?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Ubound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Rrotate, COMDAT
; __Wherenode$ = ecx

; 1069 : 		_Nodeptr _Pnode = _Left(_Wherenode);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1070 : 		_Left(_Wherenode) = _Right(_Pnode);

  00002	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00005	89 11		 mov	 DWORD PTR [ecx], edx

; 1071 : 
; 1072 : 		if (!_Isnil(_Right(_Pnode)))

  00007	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000a	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0000e	75 03		 jne	 SHORT $L30946

; 1073 : 			_Parent(_Right(_Pnode)) = _Wherenode;

  00010	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L30946:

; 1074 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1075 : 
; 1076 : 		if (_Wherenode == _Root())

  00019	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  0001d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00020	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00023	75 05		 jne	 SHORT $L30947

; 1077 : 			_Root() = _Pnode;

  00025	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1078 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

  00028	eb 0f		 jmp	 SHORT $L30950
$L30947:
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  00030	75 05		 jne	 SHORT $L30949

; 1079 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00032	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1080 : 		else

  00035	eb 02		 jmp	 SHORT $L30950
$L30949:

; 1081 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  00037	89 02		 mov	 DWORD PTR [edx], eax
$L30950:

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  00039	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  0003c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1085 : 		}

  0003f	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Rrotate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::clear, COMDAT
; _this$ = edi

; 780  : 		{	// erase all

  00000	56		 push	 esi

; 781  : 		_Erase(_Root());

  00001	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  00004	8b 06		 mov	 eax, DWORD PTR [esi]
  00006	ff 70 04	 push	 DWORD PTR [eax+4]
  00009	8b cf		 mov	 ecx, edi
  0000b	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Erase

; 782  : 		_Root() = _Myhead, _Mysize = 0;

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 783  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00015	8b 06		 mov	 eax, DWORD PTR [esi]
  00017	83 67 08 00	 and	 DWORD PTR [edi+8], 0
  0001b	89 00		 mov	 DWORD PTR [eax], eax
  0001d	8b 36		 mov	 esi, DWORD PTR [esi]
  0001f	89 76 08	 mov	 DWORD PTR [esi+8], esi
  00022	5e		 pop	 esi

; 784  : 		}

  00023	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::clear
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Ubound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 1089 : 		_Nodeptr _Pnode = _Root();

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1090 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1091 : 
; 1092 : 		while (!_Isnil(_Pnode))

  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	75 16		 jne	 SHORT $L30845
  0000c	8b 12		 mov	 edx, DWORD PTR [edx]
$L30844:

; 1093 : 			if (this->comp(_Keyval, _Key(_Pnode)))

  0000e	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00011	7d 06		 jge	 SHORT $L30846

; 1094 : 				{	// _Pnode greater than _Keyval, remember it
; 1095 : 				_Wherenode = _Pnode;

  00013	8b c1		 mov	 eax, ecx

; 1096 : 				_Pnode = _Left(_Pnode);	// descend left subtree

  00015	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 1097 : 				}
; 1098 : 			else

  00017	eb 03		 jmp	 SHORT $L30847
$L30846:

; 1099 : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
$L30847:

; 1090 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1091 : 
; 1092 : 		while (!_Isnil(_Pnode))

  0001c	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00020	74 ec		 je	 SHORT $L30844
$L30845:

; 1100 : 
; 1101 : 		return (_Wherenode);	// return best remembered candidate
; 1102 : 		}

  00022	c3		 ret	 0
?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Ubound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Rrotate, COMDAT
; __Wherenode$ = ecx

; 1069 : 		_Nodeptr _Pnode = _Left(_Wherenode);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1070 : 		_Left(_Wherenode) = _Right(_Pnode);

  00002	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00005	89 11		 mov	 DWORD PTR [ecx], edx

; 1071 : 
; 1072 : 		if (!_Isnil(_Right(_Pnode)))

  00007	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000a	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0000e	75 03		 jne	 SHORT $L30834

; 1073 : 			_Parent(_Right(_Pnode)) = _Wherenode;

  00010	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L30834:

; 1074 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1075 : 
; 1076 : 		if (_Wherenode == _Root())

  00019	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  0001d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00020	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00023	75 05		 jne	 SHORT $L30835

; 1077 : 			_Root() = _Pnode;

  00025	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1078 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

  00028	eb 0f		 jmp	 SHORT $L30838
$L30835:
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  00030	75 05		 jne	 SHORT $L30837

; 1079 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00032	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1080 : 		else

  00035	eb 02		 jmp	 SHORT $L30838
$L30837:

; 1081 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  00037	89 02		 mov	 DWORD PTR [edx], eax
$L30838:

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  00039	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  0003c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1085 : 		}

  0003f	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Rrotate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::clear, COMDAT
; _this$ = edi

; 780  : 		{	// erase all

  00000	56		 push	 esi

; 781  : 		_Erase(_Root());

  00001	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  00004	8b 06		 mov	 eax, DWORD PTR [esi]
  00006	ff 70 04	 push	 DWORD PTR [eax+4]
  00009	8b cf		 mov	 ecx, edi
  0000b	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Erase

; 782  : 		_Root() = _Myhead, _Mysize = 0;

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 783  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00015	8b 06		 mov	 eax, DWORD PTR [esi]
  00017	83 67 08 00	 and	 DWORD PTR [edi+8], 0
  0001b	89 00		 mov	 DWORD PTR [eax], eax
  0001d	8b 36		 mov	 esi, DWORD PTR [esi]
  0001f	89 76 08	 mov	 DWORD PTR [esi+8], esi
  00022	5e		 pop	 esi

; 784  : 		}

  00023	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::clear
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Ubound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 1089 : 		_Nodeptr _Pnode = _Root();

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1090 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1091 : 
; 1092 : 		while (!_Isnil(_Pnode))

  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	75 16		 jne	 SHORT $L30733
  0000c	8b 12		 mov	 edx, DWORD PTR [edx]
$L30732:

; 1093 : 			if (this->comp(_Keyval, _Key(_Pnode)))

  0000e	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00011	7d 06		 jge	 SHORT $L30734

; 1094 : 				{	// _Pnode greater than _Keyval, remember it
; 1095 : 				_Wherenode = _Pnode;

  00013	8b c1		 mov	 eax, ecx

; 1096 : 				_Pnode = _Left(_Pnode);	// descend left subtree

  00015	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 1097 : 				}
; 1098 : 			else

  00017	eb 03		 jmp	 SHORT $L30735
$L30734:

; 1099 : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
$L30735:

; 1090 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1091 : 
; 1092 : 		while (!_Isnil(_Pnode))

  0001c	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00020	74 ec		 je	 SHORT $L30732
$L30733:

; 1100 : 
; 1101 : 		return (_Wherenode);	// return best remembered candidate
; 1102 : 		}

  00022	c3		 ret	 0
?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Ubound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Rrotate, COMDAT
; __Wherenode$ = ecx

; 1069 : 		_Nodeptr _Pnode = _Left(_Wherenode);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1070 : 		_Left(_Wherenode) = _Right(_Pnode);

  00002	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00005	89 11		 mov	 DWORD PTR [ecx], edx

; 1071 : 
; 1072 : 		if (!_Isnil(_Right(_Pnode)))

  00007	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000a	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0000e	75 03		 jne	 SHORT $L30722

; 1073 : 			_Parent(_Right(_Pnode)) = _Wherenode;

  00010	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L30722:

; 1074 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1075 : 
; 1076 : 		if (_Wherenode == _Root())

  00019	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  0001d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00020	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00023	75 05		 jne	 SHORT $L30723

; 1077 : 			_Root() = _Pnode;

  00025	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1078 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

  00028	eb 0f		 jmp	 SHORT $L30726
$L30723:
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  00030	75 05		 jne	 SHORT $L30725

; 1079 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00032	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1080 : 		else

  00035	eb 02		 jmp	 SHORT $L30726
$L30725:

; 1081 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  00037	89 02		 mov	 DWORD PTR [edx], eax
$L30726:

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  00039	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  0003c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1085 : 		}

  0003f	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Rrotate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::clear, COMDAT
; _this$ = edi

; 780  : 		{	// erase all

  00000	56		 push	 esi

; 781  : 		_Erase(_Root());

  00001	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  00004	8b 06		 mov	 eax, DWORD PTR [esi]
  00006	ff 70 04	 push	 DWORD PTR [eax+4]
  00009	8b cf		 mov	 ecx, edi
  0000b	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Erase

; 782  : 		_Root() = _Myhead, _Mysize = 0;

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 783  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00015	8b 06		 mov	 eax, DWORD PTR [esi]
  00017	83 67 08 00	 and	 DWORD PTR [edi+8], 0
  0001b	89 00		 mov	 DWORD PTR [eax], eax
  0001d	8b 36		 mov	 esi, DWORD PTR [esi]
  0001f	89 76 08	 mov	 DWORD PTR [esi+8], esi
  00022	5e		 pop	 esi

; 784  : 		}

  00023	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::clear
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Ubound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 1089 : 		_Nodeptr _Pnode = _Root();

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1090 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1091 : 
; 1092 : 		while (!_Isnil(_Pnode))

  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	75 16		 jne	 SHORT $L30623
  0000c	8b 12		 mov	 edx, DWORD PTR [edx]
$L30622:

; 1093 : 			if (this->comp(_Keyval, _Key(_Pnode)))

  0000e	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00011	7d 06		 jge	 SHORT $L30624

; 1094 : 				{	// _Pnode greater than _Keyval, remember it
; 1095 : 				_Wherenode = _Pnode;

  00013	8b c1		 mov	 eax, ecx

; 1096 : 				_Pnode = _Left(_Pnode);	// descend left subtree

  00015	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 1097 : 				}
; 1098 : 			else

  00017	eb 03		 jmp	 SHORT $L30625
$L30624:

; 1099 : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
$L30625:

; 1090 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1091 : 
; 1092 : 		while (!_Isnil(_Pnode))

  0001c	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00020	74 ec		 je	 SHORT $L30622
$L30623:

; 1100 : 
; 1101 : 		return (_Wherenode);	// return best remembered candidate
; 1102 : 		}

  00022	c3		 ret	 0
?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Ubound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Rrotate, COMDAT
; __Wherenode$ = ecx

; 1069 : 		_Nodeptr _Pnode = _Left(_Wherenode);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1070 : 		_Left(_Wherenode) = _Right(_Pnode);

  00002	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00005	89 11		 mov	 DWORD PTR [ecx], edx

; 1071 : 
; 1072 : 		if (!_Isnil(_Right(_Pnode)))

  00007	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000a	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0000e	75 03		 jne	 SHORT $L30612

; 1073 : 			_Parent(_Right(_Pnode)) = _Wherenode;

  00010	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L30612:

; 1074 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1075 : 
; 1076 : 		if (_Wherenode == _Root())

  00019	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  0001d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00020	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00023	75 05		 jne	 SHORT $L30613

; 1077 : 			_Root() = _Pnode;

  00025	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1078 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

  00028	eb 0f		 jmp	 SHORT $L30616
$L30613:
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  00030	75 05		 jne	 SHORT $L30615

; 1079 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00032	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1080 : 		else

  00035	eb 02		 jmp	 SHORT $L30616
$L30615:

; 1081 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  00037	89 02		 mov	 DWORD PTR [edx], eax
$L30616:

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  00039	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  0003c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1085 : 		}

  0003f	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Rrotate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::clear, COMDAT
; _this$ = edi

; 780  : 		{	// erase all

  00000	56		 push	 esi

; 781  : 		_Erase(_Root());

  00001	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  00004	8b 06		 mov	 eax, DWORD PTR [esi]
  00006	ff 70 04	 push	 DWORD PTR [eax+4]
  00009	8b cf		 mov	 ecx, edi
  0000b	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Erase

; 782  : 		_Root() = _Myhead, _Mysize = 0;

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 783  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00015	8b 06		 mov	 eax, DWORD PTR [esi]
  00017	83 67 08 00	 and	 DWORD PTR [edi+8], 0
  0001b	89 00		 mov	 DWORD PTR [eax], eax
  0001d	8b 36		 mov	 esi, DWORD PTR [esi]
  0001f	89 76 08	 mov	 DWORD PTR [esi+8], esi
  00022	5e		 pop	 esi

; 784  : 		}

  00023	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::clear
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Ubound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 1089 : 		_Nodeptr _Pnode = _Root();

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1090 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1091 : 
; 1092 : 		while (!_Isnil(_Pnode))

  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	75 16		 jne	 SHORT $L30513
  0000c	8b 12		 mov	 edx, DWORD PTR [edx]
$L30512:

; 1093 : 			if (this->comp(_Keyval, _Key(_Pnode)))

  0000e	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00011	7d 06		 jge	 SHORT $L30514

; 1094 : 				{	// _Pnode greater than _Keyval, remember it
; 1095 : 				_Wherenode = _Pnode;

  00013	8b c1		 mov	 eax, ecx

; 1096 : 				_Pnode = _Left(_Pnode);	// descend left subtree

  00015	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 1097 : 				}
; 1098 : 			else

  00017	eb 03		 jmp	 SHORT $L30515
$L30514:

; 1099 : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
$L30515:

; 1090 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1091 : 
; 1092 : 		while (!_Isnil(_Pnode))

  0001c	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00020	74 ec		 je	 SHORT $L30512
$L30513:

; 1100 : 
; 1101 : 		return (_Wherenode);	// return best remembered candidate
; 1102 : 		}

  00022	c3		 ret	 0
?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Ubound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Rrotate, COMDAT
; __Wherenode$ = ecx

; 1069 : 		_Nodeptr _Pnode = _Left(_Wherenode);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1070 : 		_Left(_Wherenode) = _Right(_Pnode);

  00002	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00005	89 11		 mov	 DWORD PTR [ecx], edx

; 1071 : 
; 1072 : 		if (!_Isnil(_Right(_Pnode)))

  00007	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000a	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0000e	75 03		 jne	 SHORT $L30502

; 1073 : 			_Parent(_Right(_Pnode)) = _Wherenode;

  00010	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L30502:

; 1074 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1075 : 
; 1076 : 		if (_Wherenode == _Root())

  00019	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  0001d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00020	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00023	75 05		 jne	 SHORT $L30503

; 1077 : 			_Root() = _Pnode;

  00025	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1078 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

  00028	eb 0f		 jmp	 SHORT $L30506
$L30503:
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  00030	75 05		 jne	 SHORT $L30505

; 1079 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00032	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1080 : 		else

  00035	eb 02		 jmp	 SHORT $L30506
$L30505:

; 1081 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  00037	89 02		 mov	 DWORD PTR [edx], eax
$L30506:

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  00039	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  0003c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1085 : 		}

  0003f	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Rrotate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::clear, COMDAT
; _this$ = edi

; 780  : 		{	// erase all

  00000	56		 push	 esi

; 781  : 		_Erase(_Root());

  00001	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  00004	8b 06		 mov	 eax, DWORD PTR [esi]
  00006	ff 70 04	 push	 DWORD PTR [eax+4]
  00009	8b cf		 mov	 ecx, edi
  0000b	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Erase

; 782  : 		_Root() = _Myhead, _Mysize = 0;

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 783  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00015	8b 06		 mov	 eax, DWORD PTR [esi]
  00017	83 67 08 00	 and	 DWORD PTR [edi+8], 0
  0001b	89 00		 mov	 DWORD PTR [eax], eax
  0001d	8b 36		 mov	 esi, DWORD PTR [esi]
  0001f	89 76 08	 mov	 DWORD PTR [esi+8], esi
  00022	5e		 pop	 esi

; 784  : 		}

  00023	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::clear
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Ubound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 1089 : 		_Nodeptr _Pnode = _Root();

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1090 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1091 : 
; 1092 : 		while (!_Isnil(_Pnode))

  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	75 16		 jne	 SHORT $L30403
  0000c	8b 12		 mov	 edx, DWORD PTR [edx]
$L30402:

; 1093 : 			if (this->comp(_Keyval, _Key(_Pnode)))

  0000e	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00011	7d 06		 jge	 SHORT $L30404

; 1094 : 				{	// _Pnode greater than _Keyval, remember it
; 1095 : 				_Wherenode = _Pnode;

  00013	8b c1		 mov	 eax, ecx

; 1096 : 				_Pnode = _Left(_Pnode);	// descend left subtree

  00015	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 1097 : 				}
; 1098 : 			else

  00017	eb 03		 jmp	 SHORT $L30405
$L30404:

; 1099 : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
$L30405:

; 1090 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1091 : 
; 1092 : 		while (!_Isnil(_Pnode))

  0001c	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00020	74 ec		 je	 SHORT $L30402
$L30403:

; 1100 : 
; 1101 : 		return (_Wherenode);	// return best remembered candidate
; 1102 : 		}

  00022	c3		 ret	 0
?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Ubound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Rrotate, COMDAT
; __Wherenode$ = ecx

; 1069 : 		_Nodeptr _Pnode = _Left(_Wherenode);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1070 : 		_Left(_Wherenode) = _Right(_Pnode);

  00002	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00005	89 11		 mov	 DWORD PTR [ecx], edx

; 1071 : 
; 1072 : 		if (!_Isnil(_Right(_Pnode)))

  00007	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000a	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0000e	75 03		 jne	 SHORT $L30392

; 1073 : 			_Parent(_Right(_Pnode)) = _Wherenode;

  00010	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L30392:

; 1074 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1075 : 
; 1076 : 		if (_Wherenode == _Root())

  00019	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  0001d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00020	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00023	75 05		 jne	 SHORT $L30393

; 1077 : 			_Root() = _Pnode;

  00025	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1078 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

  00028	eb 0f		 jmp	 SHORT $L30396
$L30393:
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  00030	75 05		 jne	 SHORT $L30395

; 1079 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00032	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1080 : 		else

  00035	eb 02		 jmp	 SHORT $L30396
$L30395:

; 1081 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  00037	89 02		 mov	 DWORD PTR [edx], eax
$L30396:

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  00039	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  0003c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1085 : 		}

  0003f	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Rrotate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::clear, COMDAT
; _this$ = edi

; 780  : 		{	// erase all

  00000	56		 push	 esi

; 781  : 		_Erase(_Root());

  00001	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  00004	8b 06		 mov	 eax, DWORD PTR [esi]
  00006	ff 70 04	 push	 DWORD PTR [eax+4]
  00009	8b cf		 mov	 ecx, edi
  0000b	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Erase

; 782  : 		_Root() = _Myhead, _Mysize = 0;

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 783  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00015	8b 06		 mov	 eax, DWORD PTR [esi]
  00017	83 67 08 00	 and	 DWORD PTR [edi+8], 0
  0001b	89 00		 mov	 DWORD PTR [eax], eax
  0001d	8b 36		 mov	 esi, DWORD PTR [esi]
  0001f	89 76 08	 mov	 DWORD PTR [esi+8], esi
  00022	5e		 pop	 esi

; 784  : 		}

  00023	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::clear
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Ubound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 1089 : 		_Nodeptr _Pnode = _Root();

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1090 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1091 : 
; 1092 : 		while (!_Isnil(_Pnode))

  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	75 16		 jne	 SHORT $L30293
  0000c	8b 12		 mov	 edx, DWORD PTR [edx]
$L30292:

; 1093 : 			if (this->comp(_Keyval, _Key(_Pnode)))

  0000e	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00011	7d 06		 jge	 SHORT $L30294

; 1094 : 				{	// _Pnode greater than _Keyval, remember it
; 1095 : 				_Wherenode = _Pnode;

  00013	8b c1		 mov	 eax, ecx

; 1096 : 				_Pnode = _Left(_Pnode);	// descend left subtree

  00015	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 1097 : 				}
; 1098 : 			else

  00017	eb 03		 jmp	 SHORT $L30295
$L30294:

; 1099 : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
$L30295:

; 1090 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1091 : 
; 1092 : 		while (!_Isnil(_Pnode))

  0001c	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00020	74 ec		 je	 SHORT $L30292
$L30293:

; 1100 : 
; 1101 : 		return (_Wherenode);	// return best remembered candidate
; 1102 : 		}

  00022	c3		 ret	 0
?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Ubound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Rrotate, COMDAT
; __Wherenode$ = ecx

; 1069 : 		_Nodeptr _Pnode = _Left(_Wherenode);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1070 : 		_Left(_Wherenode) = _Right(_Pnode);

  00002	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00005	89 11		 mov	 DWORD PTR [ecx], edx

; 1071 : 
; 1072 : 		if (!_Isnil(_Right(_Pnode)))

  00007	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000a	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0000e	75 03		 jne	 SHORT $L30282

; 1073 : 			_Parent(_Right(_Pnode)) = _Wherenode;

  00010	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L30282:

; 1074 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1075 : 
; 1076 : 		if (_Wherenode == _Root())

  00019	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  0001d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00020	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00023	75 05		 jne	 SHORT $L30283

; 1077 : 			_Root() = _Pnode;

  00025	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1078 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

  00028	eb 0f		 jmp	 SHORT $L30286
$L30283:
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  00030	75 05		 jne	 SHORT $L30285

; 1079 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00032	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1080 : 		else

  00035	eb 02		 jmp	 SHORT $L30286
$L30285:

; 1081 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  00037	89 02		 mov	 DWORD PTR [edx], eax
$L30286:

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  00039	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  0003c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1085 : 		}

  0003f	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Rrotate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::clear, COMDAT
; _this$ = edi

; 780  : 		{	// erase all

  00000	56		 push	 esi

; 781  : 		_Erase(_Root());

  00001	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  00004	8b 06		 mov	 eax, DWORD PTR [esi]
  00006	ff 70 04	 push	 DWORD PTR [eax+4]
  00009	8b cf		 mov	 ecx, edi
  0000b	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Erase

; 782  : 		_Root() = _Myhead, _Mysize = 0;

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 783  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

  00015	8b 06		 mov	 eax, DWORD PTR [esi]
  00017	83 67 08 00	 and	 DWORD PTR [edi+8], 0
  0001b	89 00		 mov	 DWORD PTR [eax], eax
  0001d	8b 36		 mov	 esi, DWORD PTR [esi]
  0001f	89 76 08	 mov	 DWORD PTR [esi+8], esi
  00022	5e		 pop	 esi

; 784  : 		}

  00023	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::clear
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator::operator--, COMDAT

; 340  : 			--(*(const_iterator *)this);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::_Dec

; 341  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 342  : 			}

  0000d	c2 04 00	 ret	 4
??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator::operator--, COMDAT

; 340  : 			--(*(const_iterator *)this);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::_Dec

; 341  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 342  : 			}

  0000d	c2 04 00	 ret	 4
??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator::operator--, COMDAT

; 340  : 			--(*(const_iterator *)this);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::_Dec

; 341  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 342  : 			}

  0000d	c2 04 00	 ret	 4
??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator::operator--, COMDAT

; 340  : 			--(*(const_iterator *)this);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::_Dec

; 341  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 342  : 			}

  0000d	c2 04 00	 ret	 4
??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator::operator--, COMDAT

; 340  : 			--(*(const_iterator *)this);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Dec

; 341  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 342  : 			}

  0000d	c2 04 00	 ret	 4
??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator::operator--, COMDAT

; 340  : 			--(*(const_iterator *)this);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::_Dec

; 341  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 342  : 			}

  0000d	c2 04 00	 ret	 4
??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator::operator++, COMDAT

; 327  : 			++(*(const_iterator *)this);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::_Inc

; 328  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 329  : 			}

  0000d	c2 04 00	 ret	 4
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator::operator--, COMDAT

; 340  : 			--(*(const_iterator *)this);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::_Dec

; 341  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 342  : 			}

  0000d	c2 04 00	 ret	 4
??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator::operator++, COMDAT

; 327  : 			++(*(const_iterator *)this);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::_Inc

; 328  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 329  : 			}

  0000d	c2 04 00	 ret	 4
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator::operator--, COMDAT

; 340  : 			--(*(const_iterator *)this);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::_Dec

; 341  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 342  : 			}

  0000d	c2 04 00	 ret	 4
??Fiterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::upper_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 825  : 		return (_TREE_CONST_ITERATOR(_Ubound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Ubound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 826  : 		}

  00009	c3		 ret	 0
?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::upper_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::upper_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 825  : 		return (_TREE_CONST_ITERATOR(_Ubound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Ubound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 826  : 		}

  00009	c3		 ret	 0
?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::upper_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::upper_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 825  : 		return (_TREE_CONST_ITERATOR(_Ubound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Ubound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 826  : 		}

  00009	c3		 ret	 0
?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::upper_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::upper_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 825  : 		return (_TREE_CONST_ITERATOR(_Ubound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Ubound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 826  : 		}

  00009	c3		 ret	 0
?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::upper_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::upper_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 825  : 		return (_TREE_CONST_ITERATOR(_Ubound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Ubound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 826  : 		}

  00009	c3		 ret	 0
?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::upper_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::upper_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 825  : 		return (_TREE_CONST_ITERATOR(_Ubound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Ubound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 826  : 		}

  00009	c3		 ret	 0
?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::upper_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::upper_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 825  : 		return (_TREE_CONST_ITERATOR(_Ubound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Ubound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 826  : 		}

  00009	c3		 ret	 0
?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::upper_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::upper_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 825  : 		return (_TREE_CONST_ITERATOR(_Ubound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Ubound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 826  : 		}

  00009	c3		 ret	 0
?upper_bound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::upper_bound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Keyval$ = 12						; size = 4
?equal_range@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::equal_range, COMDAT
; ___$ReturnUdt$ = esi

; 835  : 		return (_Paircc(lower_bound(_Keyval), upper_bound(_Keyval)));

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]
  00008	57		 push	 edi
  00009	e8 00 00 00 00	 call	 ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Ubound
  0000e	8b 54 24 0c	 mov	 edx, DWORD PTR __Keyval$[esp]
  00012	8b f8		 mov	 edi, eax
  00014	8b 44 24 08	 mov	 eax, DWORD PTR _this$[esp]
  00018	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Lbound
  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00022	8b c6		 mov	 eax, esi
  00024	5f		 pop	 edi

; 836  : 		}

  00025	c2 08 00	 ret	 8
?equal_range@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::equal_range
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Keyval$ = 12						; size = 4
?equal_range@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::equal_range, COMDAT
; ___$ReturnUdt$ = esi

; 835  : 		return (_Paircc(lower_bound(_Keyval), upper_bound(_Keyval)));

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]
  00008	57		 push	 edi
  00009	e8 00 00 00 00	 call	 ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Ubound
  0000e	8b 54 24 0c	 mov	 edx, DWORD PTR __Keyval$[esp]
  00012	8b f8		 mov	 edi, eax
  00014	8b 44 24 08	 mov	 eax, DWORD PTR _this$[esp]
  00018	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Lbound
  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00022	8b c6		 mov	 eax, esi
  00024	5f		 pop	 edi

; 836  : 		}

  00025	c2 08 00	 ret	 8
?equal_range@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::equal_range
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Keyval$ = 12						; size = 4
?equal_range@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::equal_range, COMDAT
; ___$ReturnUdt$ = esi

; 835  : 		return (_Paircc(lower_bound(_Keyval), upper_bound(_Keyval)));

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]
  00008	57		 push	 edi
  00009	e8 00 00 00 00	 call	 ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Ubound
  0000e	8b 54 24 0c	 mov	 edx, DWORD PTR __Keyval$[esp]
  00012	8b f8		 mov	 edi, eax
  00014	8b 44 24 08	 mov	 eax, DWORD PTR _this$[esp]
  00018	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Lbound
  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00022	8b c6		 mov	 eax, esi
  00024	5f		 pop	 edi

; 836  : 		}

  00025	c2 08 00	 ret	 8
?equal_range@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::equal_range
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Keyval$ = 12						; size = 4
?equal_range@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::equal_range, COMDAT
; ___$ReturnUdt$ = esi

; 835  : 		return (_Paircc(lower_bound(_Keyval), upper_bound(_Keyval)));

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]
  00008	57		 push	 edi
  00009	e8 00 00 00 00	 call	 ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Ubound
  0000e	8b 54 24 0c	 mov	 edx, DWORD PTR __Keyval$[esp]
  00012	8b f8		 mov	 edi, eax
  00014	8b 44 24 08	 mov	 eax, DWORD PTR _this$[esp]
  00018	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Lbound
  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00022	8b c6		 mov	 eax, esi
  00024	5f		 pop	 edi

; 836  : 		}

  00025	c2 08 00	 ret	 8
?equal_range@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::equal_range
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Keyval$ = 12						; size = 4
?equal_range@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::equal_range, COMDAT
; ___$ReturnUdt$ = esi

; 835  : 		return (_Paircc(lower_bound(_Keyval), upper_bound(_Keyval)));

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]
  00008	57		 push	 edi
  00009	e8 00 00 00 00	 call	 ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Ubound
  0000e	8b 54 24 0c	 mov	 edx, DWORD PTR __Keyval$[esp]
  00012	8b f8		 mov	 edi, eax
  00014	8b 44 24 08	 mov	 eax, DWORD PTR _this$[esp]
  00018	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Lbound
  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00022	8b c6		 mov	 eax, esi
  00024	5f		 pop	 edi

; 836  : 		}

  00025	c2 08 00	 ret	 8
?equal_range@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::equal_range
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Keyval$ = 12						; size = 4
?equal_range@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::equal_range, COMDAT
; ___$ReturnUdt$ = esi

; 835  : 		return (_Paircc(lower_bound(_Keyval), upper_bound(_Keyval)));

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]
  00008	57		 push	 edi
  00009	e8 00 00 00 00	 call	 ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Ubound
  0000e	8b 54 24 0c	 mov	 edx, DWORD PTR __Keyval$[esp]
  00012	8b f8		 mov	 edi, eax
  00014	8b 44 24 08	 mov	 eax, DWORD PTR _this$[esp]
  00018	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Lbound
  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00022	8b c6		 mov	 eax, esi
  00024	5f		 pop	 edi

; 836  : 		}

  00025	c2 08 00	 ret	 8
?equal_range@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::equal_range
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Keyval$ = 12						; size = 4
?equal_range@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::equal_range, COMDAT
; ___$ReturnUdt$ = esi

; 835  : 		return (_Paircc(lower_bound(_Keyval), upper_bound(_Keyval)));

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]
  00008	57		 push	 edi
  00009	e8 00 00 00 00	 call	 ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Ubound
  0000e	8b 54 24 0c	 mov	 edx, DWORD PTR __Keyval$[esp]
  00012	8b f8		 mov	 edi, eax
  00014	8b 44 24 08	 mov	 eax, DWORD PTR _this$[esp]
  00018	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Lbound
  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00022	8b c6		 mov	 eax, esi
  00024	5f		 pop	 edi

; 836  : 		}

  00025	c2 08 00	 ret	 8
?equal_range@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::equal_range
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Keyval$ = 12						; size = 4
?equal_range@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::equal_range, COMDAT
; ___$ReturnUdt$ = esi

; 835  : 		return (_Paircc(lower_bound(_Keyval), upper_bound(_Keyval)));

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Keyval$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]
  00008	57		 push	 edi
  00009	e8 00 00 00 00	 call	 ?_Ubound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Ubound
  0000e	8b 54 24 0c	 mov	 edx, DWORD PTR __Keyval$[esp]
  00012	8b f8		 mov	 edi, eax
  00014	8b 44 24 08	 mov	 eax, DWORD PTR _this$[esp]
  00018	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Lbound
  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00022	8b c6		 mov	 eax, esi
  00024	5f		 pop	 edi

; 836  : 		}

  00025	c2 08 00	 ret	 8
?equal_range@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::equal_range
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?count@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z
_TEXT	SEGMENT
__Ans$ = -8						; size = 8
_this$ = 8						; size = 4
$T58608 = 12						; size = 4
__Keyval$ = 12						; size = 4
?count@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::count, COMDAT

; 801  : 		{	// count all elements that match _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 802  : 		_Paircc _Ans = equal_range(_Keyval);

  00007	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  0000a	8d 75 f8	 lea	 esi, DWORD PTR __Ans$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::equal_range

; 803  : 		size_type _Num = 0;
; 804  : 		_Distance(_Ans.first, _Ans.second, _Num);

  00015	8b 45 f8	 mov	 eax, DWORD PTR __Ans$[ebp]
  00018	8b 75 fc	 mov	 esi, DWORD PTR __Ans$[ebp+4]
  0001b	33 ff		 xor	 edi, edi
  0001d	3b c6		 cmp	 eax, esi
  0001f	89 45 0c	 mov	 DWORD PTR $T58608[ebp], eax
  00022	74 0e		 je	 SHORT $L58620
$L58617:
  00024	8d 55 0c	 lea	 edx, DWORD PTR $T58608[ebp]
  00027	47		 inc	 edi
  00028	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Inc
  0002d	39 75 0c	 cmp	 DWORD PTR $T58608[ebp], esi
  00030	75 f2		 jne	 SHORT $L58617
$L58620:

; 805  : 		return (_Num);

  00032	8b c7		 mov	 eax, edi
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi

; 806  : 		}

  00036	c9		 leave
  00037	c2 08 00	 ret	 8
?count@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::count
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?count@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z
_TEXT	SEGMENT
__Ans$ = -8						; size = 8
_this$ = 8						; size = 4
$T58663 = 12						; size = 4
__Keyval$ = 12						; size = 4
?count@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::count, COMDAT

; 801  : 		{	// count all elements that match _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 802  : 		_Paircc _Ans = equal_range(_Keyval);

  00007	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  0000a	8d 75 f8	 lea	 esi, DWORD PTR __Ans$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::equal_range

; 803  : 		size_type _Num = 0;
; 804  : 		_Distance(_Ans.first, _Ans.second, _Num);

  00015	8b 45 f8	 mov	 eax, DWORD PTR __Ans$[ebp]
  00018	8b 75 fc	 mov	 esi, DWORD PTR __Ans$[ebp+4]
  0001b	33 ff		 xor	 edi, edi
  0001d	3b c6		 cmp	 eax, esi
  0001f	89 45 0c	 mov	 DWORD PTR $T58663[ebp], eax
  00022	74 0e		 je	 SHORT $L58672
$L58674:
  00024	8d 55 0c	 lea	 edx, DWORD PTR $T58663[ebp]
  00027	47		 inc	 edi
  00028	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::_Inc
  0002d	39 75 0c	 cmp	 DWORD PTR $T58663[ebp], esi
  00030	75 f2		 jne	 SHORT $L58674
$L58672:

; 805  : 		return (_Num);

  00032	8b c7		 mov	 eax, edi
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi

; 806  : 		}

  00036	c9		 leave
  00037	c2 08 00	 ret	 8
?count@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::count
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?count@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z
_TEXT	SEGMENT
__Ans$ = -8						; size = 8
_this$ = 8						; size = 4
$T58718 = 12						; size = 4
__Keyval$ = 12						; size = 4
?count@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::count, COMDAT

; 801  : 		{	// count all elements that match _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 802  : 		_Paircc _Ans = equal_range(_Keyval);

  00007	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  0000a	8d 75 f8	 lea	 esi, DWORD PTR __Ans$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::equal_range

; 803  : 		size_type _Num = 0;
; 804  : 		_Distance(_Ans.first, _Ans.second, _Num);

  00015	8b 45 f8	 mov	 eax, DWORD PTR __Ans$[ebp]
  00018	8b 75 fc	 mov	 esi, DWORD PTR __Ans$[ebp+4]
  0001b	33 ff		 xor	 edi, edi
  0001d	3b c6		 cmp	 eax, esi
  0001f	89 45 0c	 mov	 DWORD PTR $T58718[ebp], eax
  00022	74 0e		 je	 SHORT $L58727
$L58729:
  00024	8d 55 0c	 lea	 edx, DWORD PTR $T58718[ebp]
  00027	47		 inc	 edi
  00028	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::_Inc
  0002d	39 75 0c	 cmp	 DWORD PTR $T58718[ebp], esi
  00030	75 f2		 jne	 SHORT $L58729
$L58727:

; 805  : 		return (_Num);

  00032	8b c7		 mov	 eax, edi
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi

; 806  : 		}

  00036	c9		 leave
  00037	c2 08 00	 ret	 8
?count@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::count
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?count@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z
_TEXT	SEGMENT
__Ans$ = -8						; size = 8
_this$ = 8						; size = 4
$T58773 = 12						; size = 4
__Keyval$ = 12						; size = 4
?count@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::count, COMDAT

; 801  : 		{	// count all elements that match _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 802  : 		_Paircc _Ans = equal_range(_Keyval);

  00007	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  0000a	8d 75 f8	 lea	 esi, DWORD PTR __Ans$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::equal_range

; 803  : 		size_type _Num = 0;
; 804  : 		_Distance(_Ans.first, _Ans.second, _Num);

  00015	8b 45 f8	 mov	 eax, DWORD PTR __Ans$[ebp]
  00018	8b 75 fc	 mov	 esi, DWORD PTR __Ans$[ebp+4]
  0001b	33 ff		 xor	 edi, edi
  0001d	3b c6		 cmp	 eax, esi
  0001f	89 45 0c	 mov	 DWORD PTR $T58773[ebp], eax
  00022	74 0e		 je	 SHORT $L58782
$L58784:
  00024	8d 55 0c	 lea	 edx, DWORD PTR $T58773[ebp]
  00027	47		 inc	 edi
  00028	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::_Inc
  0002d	39 75 0c	 cmp	 DWORD PTR $T58773[ebp], esi
  00030	75 f2		 jne	 SHORT $L58784
$L58782:

; 805  : 		return (_Num);

  00032	8b c7		 mov	 eax, edi
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi

; 806  : 		}

  00036	c9		 leave
  00037	c2 08 00	 ret	 8
?count@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::count
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?count@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z
_TEXT	SEGMENT
__Ans$ = -8						; size = 8
_this$ = 8						; size = 4
$T58828 = 12						; size = 4
__Keyval$ = 12						; size = 4
?count@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::count, COMDAT

; 801  : 		{	// count all elements that match _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 802  : 		_Paircc _Ans = equal_range(_Keyval);

  00007	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  0000a	8d 75 f8	 lea	 esi, DWORD PTR __Ans$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::equal_range

; 803  : 		size_type _Num = 0;
; 804  : 		_Distance(_Ans.first, _Ans.second, _Num);

  00015	8b 45 f8	 mov	 eax, DWORD PTR __Ans$[ebp]
  00018	8b 75 fc	 mov	 esi, DWORD PTR __Ans$[ebp+4]
  0001b	33 ff		 xor	 edi, edi
  0001d	3b c6		 cmp	 eax, esi
  0001f	89 45 0c	 mov	 DWORD PTR $T58828[ebp], eax
  00022	74 0e		 je	 SHORT $L58837
$L58839:
  00024	8d 55 0c	 lea	 edx, DWORD PTR $T58828[ebp]
  00027	47		 inc	 edi
  00028	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::_Inc
  0002d	39 75 0c	 cmp	 DWORD PTR $T58828[ebp], esi
  00030	75 f2		 jne	 SHORT $L58839
$L58837:

; 805  : 		return (_Num);

  00032	8b c7		 mov	 eax, edi
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi

; 806  : 		}

  00036	c9		 leave
  00037	c2 08 00	 ret	 8
?count@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::count
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?count@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z
_TEXT	SEGMENT
__Ans$ = -8						; size = 8
_this$ = 8						; size = 4
$T58883 = 12						; size = 4
__Keyval$ = 12						; size = 4
?count@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::count, COMDAT

; 801  : 		{	// count all elements that match _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 802  : 		_Paircc _Ans = equal_range(_Keyval);

  00007	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  0000a	8d 75 f8	 lea	 esi, DWORD PTR __Ans$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::equal_range

; 803  : 		size_type _Num = 0;
; 804  : 		_Distance(_Ans.first, _Ans.second, _Num);

  00015	8b 45 f8	 mov	 eax, DWORD PTR __Ans$[ebp]
  00018	8b 75 fc	 mov	 esi, DWORD PTR __Ans$[ebp+4]
  0001b	33 ff		 xor	 edi, edi
  0001d	3b c6		 cmp	 eax, esi
  0001f	89 45 0c	 mov	 DWORD PTR $T58883[ebp], eax
  00022	74 0e		 je	 SHORT $L58893
$L58895:
  00024	8d 55 0c	 lea	 edx, DWORD PTR $T58883[ebp]
  00027	47		 inc	 edi
  00028	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::_Inc
  0002d	39 75 0c	 cmp	 DWORD PTR $T58883[ebp], esi
  00030	75 f2		 jne	 SHORT $L58895
$L58893:

; 805  : 		return (_Num);

  00032	8b c7		 mov	 eax, edi
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi

; 806  : 		}

  00036	c9		 leave
  00037	c2 08 00	 ret	 8
?count@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::count
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\istream
xdata$x	SEGMENT
$T58941	DD	0ffffffffH
	DD	FLAT:$L58910
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T58943	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L58909
$T58942	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T58943
$T58938	DD	019930520H
	DD	03H
	DD	FLAT:$T58941
	DD	01H
	DD	FLAT:$T58942
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
xdata$x	ENDS
;	COMDAT ?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADH@Z
_TEXT	SEGMENT
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
__Str$ = 12						; size = 4
__Count$ = 16						; size = 4
?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADH@Z PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::read, COMDAT

; 649  : 		{	// read up to _Count characters into buffer

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADH@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 10	 sub	 esp, 16			; 00000010H
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00012	57		 push	 edi
  00013	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 650  : 		ios_base::iostate _State = ios_base::goodbit;
; 651  : 		_Chcount = 0;
; 652  : 		const sentry _Ok(*this, true);

  00016	6a 01		 push	 1
  00018	56		 push	 esi
  00019	8d 45 e4	 lea	 eax, DWORD PTR __Ok$[ebp]
  0001c	33 db		 xor	 ebx, ebx
  0001e	50		 push	 eax
  0001f	89 5d ec	 mov	 DWORD PTR __State$[ebp], ebx
  00022	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00025	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
  0002a	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx

; 653  : 
; 654  : 		if (_Ok)

  0002d	38 5d e8	 cmp	 BYTE PTR __Ok$[ebp+4], bl
  00030	74 4c		 je	 SHORT $L26097

; 655  : 			{	// state okay, use facet to extract
; 656  : 			_TRY_IO_BEGIN
; 657  : 			const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);

  00032	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00035	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00039	8b 06		 mov	 eax, DWORD PTR [esi]
  0003b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003e	8b 4c 30 28	 mov	 ecx, DWORD PTR [eax+esi+40]
  00042	ff 75 0c	 push	 DWORD PTR __Str$[ebp]
  00045	8b 01		 mov	 eax, DWORD PTR [ecx]
  00047	ff 50 18	 call	 DWORD PTR [eax+24]

; 658  : 			_Chcount += _Num;

  0004a	01 46 04	 add	 DWORD PTR [esi+4], eax

; 659  : 			if (_Num != _Count)

  0004d	3b 45 10	 cmp	 eax, DWORD PTR __Count$[ebp]
  00050	74 2c		 je	 SHORT $L26097

; 660  : 				_State |= ios_base::eofbit | ios_base::failbit;	// short read

  00052	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR __State$[ebp], 3
  00059	eb 23		 jmp	 SHORT $L26097
$L58909:

; 661  : 			_CATCH_IO_END

  0005b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00063	03 c8		 add	 ecx, eax
  00065	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00068	6a 01		 push	 1
  0006a	83 c8 04	 or	 eax, 4
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
  00073	b8 00 00 00 00	 mov	 eax, $L58939
  00078	c3		 ret	 0
$L58939:
  00079	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  0007c	33 db		 xor	 ebx, ebx
$L26097:
  0007e	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx

; 662  : 			}
; 663  : 
; 664  : 		_Myios::setstate(_State);

  00081	8b 06		 mov	 eax, DWORD PTR [esi]
  00083	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00086	53		 push	 ebx
  00087	ff 75 ec	 push	 DWORD PTR __State$[ebp]
  0008a	03 ce		 add	 ecx, esi
  0008c	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 665  : 		return (*this);

  00091	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  00095	8d 45 e4	 lea	 eax, DWORD PTR __Ok$[ebp]
  00098	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base

; 666  : 		}

  0009d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000a0	5f		 pop	 edi
  000a1	8b c6		 mov	 eax, esi
  000a3	5e		 pop	 esi
  000a4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ab	5b		 pop	 ebx
  000ac	c9		 leave
  000ad	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L58910:
  00000	8d 45 e4	 lea	 eax, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__ehhandler$?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADH@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T58938
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADH@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::read
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z PROC NEAR ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator,unsigned int>, COMDAT
; __Off$ = esi

; 469  : 	{	// add to _Off distance between bidirectional iterators (redundant)

  00000	57		 push	 edi

; 470  : 	for (; _First != _Last; ++_First)

  00001	8b 7c 24 0c	 mov	 edi, DWORD PTR __Last$[esp]
  00005	eb 0b		 jmp	 SHORT $L62202
$L62190:

; 471  : 		++_Off;

  00007	ff 06		 inc	 DWORD PTR [esi]
  00009	8d 54 24 08	 lea	 edx, DWORD PTR __First$[esp]
  0000d	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::_Inc
$L62202:

; 470  : 	for (; _First != _Last; ++_First)

  00012	39 7c 24 08	 cmp	 DWORD PTR __First$[esp], edi
  00016	75 ef		 jne	 SHORT $L62190
  00018	5f		 pop	 edi

; 472  : 	}

  00019	c3		 ret	 0
??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator,unsigned int>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z PROC NEAR ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator,unsigned int>, COMDAT
; __Off$ = esi

; 469  : 	{	// add to _Off distance between bidirectional iterators (redundant)

  00000	57		 push	 edi

; 470  : 	for (; _First != _Last; ++_First)

  00001	8b 7c 24 0c	 mov	 edi, DWORD PTR __Last$[esp]
  00005	eb 0b		 jmp	 SHORT $L62219
$L62207:

; 471  : 		++_Off;

  00007	ff 06		 inc	 DWORD PTR [esi]
  00009	8d 54 24 08	 lea	 edx, DWORD PTR __First$[esp]
  0000d	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::_Inc
$L62219:

; 470  : 	for (; _First != _Last; ++_First)

  00012	39 7c 24 08	 cmp	 DWORD PTR __First$[esp], edi
  00016	75 ef		 jne	 SHORT $L62207
  00018	5f		 pop	 edi

; 472  : 	}

  00019	c3		 ret	 0
??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator,unsigned int>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT
$T62223 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@0AAI@Z PROC NEAR ; std::_Distance<std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator,unsigned int>, COMDAT
; __Off$ = esi

; 497  : 	{	// add to _Off distance between iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 498  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

  00004	ff 75 fc	 push	 DWORD PTR $T62223[ebp]
  00007	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator,unsigned int>
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 499  : 	}

  00015	c9		 leave
  00016	c3		 ret	 0
??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@0@0AAI@Z ENDP ; std::_Distance<std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator,unsigned int>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT
$T62230 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@0AAI@Z PROC NEAR ; std::_Distance<std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator,unsigned int>, COMDAT
; __Off$ = esi

; 497  : 	{	// add to _Off distance between iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 498  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

  00004	ff 75 fc	 push	 DWORD PTR $T62230[ebp]
  00007	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Distance2@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator,unsigned int>
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 499  : 	}

  00015	c9		 leave
  00016	c3		 ret	 0
??$_Distance@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@I@std@@YAXVconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@0@0AAI@Z ENDP ; std::_Distance<std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator,unsigned int>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator::operator++, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = edi

; 332  : 			{	// postincrement

  00000	56		 push	 esi

; 333  : 			iterator _Tmp = *this;

  00001	8b 32		 mov	 esi, DWORD PTR [edx]

; 334  : 			++*this;

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::_Inc

; 335  : 			return (_Tmp);

  00008	89 37		 mov	 DWORD PTR [edi], esi
  0000a	8b c7		 mov	 eax, edi
  0000c	5e		 pop	 esi

; 336  : 			}

  0000d	c3		 ret	 0
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator::operator++, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = edi

; 332  : 			{	// postincrement

  00000	56		 push	 esi

; 333  : 			iterator _Tmp = *this;

  00001	8b 32		 mov	 esi, DWORD PTR [edx]

; 334  : 			++*this;

  00003	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::_Inc

; 335  : 			return (_Tmp);

  00008	89 37		 mov	 DWORD PTR [edi], esi
  0000a	8b c7		 mov	 eax, edi
  0000c	5e		 pop	 esi

; 336  : 			}

  0000d	c3		 ret	 0
??Eiterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?count@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z
_TEXT	SEGMENT
__Ans$ = -8						; size = 8
_this$ = 8						; size = 4
$T62290 = 12						; size = 4
__Keyval$ = 12						; size = 4
?count@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::count, COMDAT

; 801  : 		{	// count all elements that match _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 802  : 		_Paircc _Ans = equal_range(_Keyval);

  00007	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  0000a	8d 75 f8	 lea	 esi, DWORD PTR __Ans$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::equal_range

; 803  : 		size_type _Num = 0;
; 804  : 		_Distance(_Ans.first, _Ans.second, _Num);

  00015	8b 45 f8	 mov	 eax, DWORD PTR __Ans$[ebp]
  00018	8b 75 fc	 mov	 esi, DWORD PTR __Ans$[ebp+4]
  0001b	33 ff		 xor	 edi, edi
  0001d	3b c6		 cmp	 eax, esi
  0001f	89 45 0c	 mov	 DWORD PTR $T62290[ebp], eax
  00022	74 0e		 je	 SHORT $L62300
$L62302:
  00024	8d 55 0c	 lea	 edx, DWORD PTR $T62290[ebp]
  00027	47		 inc	 edi
  00028	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::_Inc
  0002d	39 75 0c	 cmp	 DWORD PTR $T62290[ebp], esi
  00030	75 f2		 jne	 SHORT $L62302
$L62300:

; 805  : 		return (_Num);

  00032	8b c7		 mov	 eax, edi
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi

; 806  : 		}

  00036	c9		 leave
  00037	c2 08 00	 ret	 8
?count@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::count
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?count@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z
_TEXT	SEGMENT
__Ans$ = -8						; size = 8
_this$ = 8						; size = 4
$T62345 = 12						; size = 4
__Keyval$ = 12						; size = 4
?count@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::count, COMDAT

; 801  : 		{	// count all elements that match _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 802  : 		_Paircc _Ans = equal_range(_Keyval);

  00007	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  0000a	8d 75 f8	 lea	 esi, DWORD PTR __Ans$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?equal_range@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBE?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@V123@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::equal_range

; 803  : 		size_type _Num = 0;
; 804  : 		_Distance(_Ans.first, _Ans.second, _Num);

  00015	8b 45 f8	 mov	 eax, DWORD PTR __Ans$[ebp]
  00018	8b 75 fc	 mov	 esi, DWORD PTR __Ans$[ebp+4]
  0001b	33 ff		 xor	 edi, edi
  0001d	3b c6		 cmp	 eax, esi
  0001f	89 45 0c	 mov	 DWORD PTR $T62345[ebp], eax
  00022	74 0e		 je	 SHORT $L62355
$L62357:
  00024	8d 55 0c	 lea	 edx, DWORD PTR $T62345[ebp]
  00027	47		 inc	 edi
  00028	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::_Inc
  0002d	39 75 0c	 cmp	 DWORD PTR $T62345[ebp], esi
  00030	75 f2		 jne	 SHORT $L62357
$L62355:

; 805  : 		return (_Num);

  00032	8b c7		 mov	 eax, edi
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi

; 806  : 		}

  00036	c9		 leave
  00037	c2 08 00	 ret	 8
?count@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::count
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xiosbase
xdata$x	SEGMENT
$T62400	DD	0ffffffffH
	DD	FLAT:$L62372
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T62402	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L62371
$T62401	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T62402
$T62396	DD	019930520H
	DD	03H
	DD	FLAT:$T62400
	DD	01H
	DD	FLAT:$T62401
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	ENDS
;	COMDAT ?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z
_TEXT	SEGMENT
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
__Str$ = 12						; size = 4
__Count$ = 16						; size = 4
?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::write, COMDAT

; 492  : 		{	// insert _Count characters from array _Str

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 10	 sub	 esp, 16			; 00000010H
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]

; 493  : 		ios_base::iostate _State = ios_base::goodbit;
; 494  : 		const sentry _Ok(*this);

  00013	8d 45 e4	 lea	 eax, DWORD PTR __Ok$[ebp]
  00016	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00019	33 db		 xor	 ebx, ebx
  0001b	50		 push	 eax
  0001c	89 5d ec	 mov	 DWORD PTR __State$[ebp], ebx
  0001f	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  00024	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx

; 495  : 
; 496  : 		if (!_Ok)

  00027	38 5d e8	 cmp	 BYTE PTR __Ok$[ebp+4], bl

; 497  : 			_State |= ios_base::badbit;
; 498  : 		else

  0002a	74 1d		 je	 SHORT $L62399

; 499  : 			{	// state okay, insert characters
; 500  : 			_TRY_IO_BEGIN
; 501  : 			if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count)

  0002c	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  0002f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00033	8b 07		 mov	 eax, DWORD PTR [edi]
  00035	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00038	8b 4c 38 28	 mov	 ecx, DWORD PTR [eax+edi+40]
  0003c	ff 75 0c	 push	 DWORD PTR __Str$[ebp]
  0003f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00041	ff 50 1c	 call	 DWORD PTR [eax+28]
  00044	3b 45 10	 cmp	 eax, DWORD PTR __Count$[ebp]
  00047	74 2c		 je	 SHORT $L26087
$L62399:

; 502  : 				_State |= ios_base::badbit;

  00049	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR __State$[ebp], 4
  00050	eb 23		 jmp	 SHORT $L26087
$L62371:

; 503  : 			_CATCH_IO_END

  00052	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8b 08		 mov	 ecx, DWORD PTR [eax]
  00057	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0005a	03 c8		 add	 ecx, eax
  0005c	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0005f	6a 01		 push	 1
  00061	83 c8 04	 or	 eax, 4
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
  0006a	b8 00 00 00 00	 mov	 eax, $L62397
  0006f	c3		 ret	 0
$L62397:
  00070	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  00073	33 db		 xor	 ebx, ebx
$L26087:
  00075	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx

; 504  : 			}
; 505  : 
; 506  : 		_Myios::setstate(_State);

  00078	8b 07		 mov	 eax, DWORD PTR [edi]
  0007a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007d	53		 push	 ebx
  0007e	ff 75 ec	 push	 DWORD PTR __State$[ebp]
  00081	03 cf		 add	 ecx, edi
  00083	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 507  : 		return (*this);

  00088	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0008c	8d 45 e4	 lea	 eax, DWORD PTR __Ok$[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry

; 508  : 		}

  00095	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00098	8b c7		 mov	 eax, edi
  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a3	5b		 pop	 ebx
  000a4	c9		 leave
  000a5	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L62372:
  00000	8d 45 e4	 lea	 eax, DWORD PTR __Ok$[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00009	c3		 ret	 0
__ehhandler$?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z:
  0000a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T62396
  0000f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::write
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\fstream
;	COMDAT ?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC NEAR ; std::basic_ofstream<char,std::char_traits<char> >::close, COMDAT
; _this$ = esi

; 630  : 		if (_Filebuffer.close() == 0)

  00000	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00003	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  00008	85 c0		 test	 eax, eax
  0000a	75 15		 jne	 SHORT $L64850

; 631  : 			_Myios::setstate(ios_base::failbit);

  0000c	8b 06		 mov	 eax, DWORD PTR [esi]
  0000e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00011	03 ce		 add	 ecx, esi
  00013	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00016	6a 00		 push	 0
  00018	83 c8 02	 or	 eax, 2
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
$L64850:

; 632  : 		}

  00021	c3		 ret	 0
?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::close
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xiosbase
xdata$x	SEGMENT
$T64902	DD	0ffffffffH
	DD	FLAT:$L64864
	DD	00H
	DD	FLAT:$L64865
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T64904	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L64863
$T64903	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T64904
$T64898	DD	019930520H
	DD	04H
	DD	FLAT:$T64902
	DD	01H
	DD	FLAT:$T64903
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	ENDS
;	COMDAT ??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z
_TEXT	SEGMENT
__Ok$ = -36						; size = 8
$T64860 = -28						; size = 8
$T64859 = -28						; size = 8
$T64856 = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
__Val$ = 12						; size = 4
??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z PROC NEAR ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::operator<<, COMDAT

; 253  : 		{	// insert an unsigned int

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 18	 sub	 esp, 24			; 00000018H
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]

; 254  : 		ios_base::iostate _State = ios_base::goodbit;
; 255  : 		const sentry _Ok(*this);

  00013	8d 45 dc	 lea	 eax, DWORD PTR __Ok$[ebp]
  00016	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00019	33 db		 xor	 ebx, ebx
  0001b	50		 push	 eax
  0001c	89 5d ec	 mov	 DWORD PTR __State$[ebp], ebx
  0001f	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::sentry::sentry
  00024	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx

; 256  : 
; 257  : 		if (_Ok)

  00027	38 5d e0	 cmp	 BYTE PTR __Ok$[ebp+4], bl
  0002a	0f 84 85 00 00
	00		 je	 $L25712

; 258  : 			{	// state okay, use facet to insert
; 259  : 			const _Nput& _Nput_fac = _USE(ios_base::getloc(), _Nput);

  00030	8d 45 e8	 lea	 eax, DWORD PTR $T64856[ebp]
  00033	50		 push	 eax
  00034	8b 07		 mov	 eax, DWORD PTR [edi]
  00036	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00039	03 cf		 add	 ecx, edi
  0003b	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00040	50		 push	 eax
  00041	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00045	e8 00 00 00 00	 call	 ??$use_facet@V?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@@std@@YAABV?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short> > > >
  0004a	59		 pop	 ecx
  0004b	8d 4d e8	 lea	 ecx, DWORD PTR $T64856[ebp]
  0004e	8b f0		 mov	 esi, eax
  00050	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale

; 260  : 
; 261  : 			_TRY_IO_BEGIN
; 262  : 			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
; 263  : 				_Myios::fill(), (unsigned long)_Val).failed())

  00055	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  00058	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  0005c	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0005e	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00061	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00064	03 cf		 add	 ecx, edi
  00066	33 d2		 xor	 edx, edx
  00068	66 8b 51 30	 mov	 dx, WORD PTR [ecx+48]
  0006c	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]
  0006f	03 c7		 add	 eax, edi
  00071	88 5d e4	 mov	 BYTE PTR $T64859[ebp], bl
  00074	52		 push	 edx
  00075	50		 push	 eax
  00076	51		 push	 ecx
  00077	ff 75 e4	 push	 DWORD PTR $T64859[ebp]
  0007a	8d 45 e4	 lea	 eax, DWORD PTR $T64860[ebp]
  0007d	50		 push	 eax
  0007e	8b ce		 mov	 ecx, esi
  00080	e8 00 00 00 00	 call	 ?put@?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@GU?$char_traits@G@std@@@2@V32@AAVios_base@2@GK@Z ; std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short> > >::put
  00085	38 18		 cmp	 BYTE PTR [eax], bl
  00087	74 2c		 je	 SHORT $L25712

; 264  : 				_State |= ios_base::badbit;

  00089	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR __State$[ebp], 4
  00090	eb 23		 jmp	 SHORT $L25712
$L64863:

; 265  : 			_CATCH_IO_END

  00092	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00095	8b 08		 mov	 ecx, DWORD PTR [eax]
  00097	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0009a	03 c8		 add	 ecx, eax
  0009c	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0009f	6a 01		 push	 1
  000a1	83 c8 04	 or	 eax, 4
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ?clear@?$basic_ios@GU?$char_traits@G@std@@@std@@QAEXH_N@Z ; std::basic_ios<unsigned short,std::char_traits<unsigned short> >::clear
  000aa	b8 00 00 00 00	 mov	 eax, $L64899
  000af	c3		 ret	 0
$L64899:
  000b0	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  000b3	33 db		 xor	 ebx, ebx
$L25712:
  000b5	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx

; 266  : 			}
; 267  : 
; 268  : 		_Myios::setstate(_State);

  000b8	8b 07		 mov	 eax, DWORD PTR [edi]
  000ba	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000bd	53		 push	 ebx
  000be	ff 75 ec	 push	 DWORD PTR __State$[ebp]
  000c1	03 cf		 add	 ecx, edi
  000c3	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@GU?$char_traits@G@std@@@std@@QAEXH_N@Z ; std::basic_ios<unsigned short,std::char_traits<unsigned short> >::setstate

; 269  : 		return (*this);

  000c8	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  000cc	8d 45 dc	 lea	 eax, DWORD PTR __Ok$[ebp]
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@XZ ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::sentry::~sentry

; 270  : 		}

  000d5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000d8	8b c7		 mov	 eax, edi
  000da	5f		 pop	 edi
  000db	5e		 pop	 esi
  000dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000e3	5b		 pop	 ebx
  000e4	c9		 leave
  000e5	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L64864:
  00000	8d 45 dc	 lea	 eax, DWORD PTR __Ok$[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@XZ ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::sentry::~sentry
  00009	c3		 ret	 0
$L64865:
  0000a	8d 4d e8	 lea	 ecx, DWORD PTR $T64856[ebp]
  0000d	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__ehhandler$??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z:
  00012	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T64898
  00017	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z ENDP ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::operator<<
PUBLIC	?saveASM@MusicFile@@QAEXPBD@Z			; MusicFile::saveASM
; Function compile flags: /Ogsy
; File f:\nes\nsdl\src\nsc\musicfile.cpp
_TEXT	SEGMENT
tv224 = -12						; size = 4
_iSE$ = -8						; size = 4
_iBGM$ = -4						; size = 4
tv245 = 8						; size = 4
_strFileName$ = 8					; size = 4
?saveASM@MusicFile@@QAEXPBD@Z PROC NEAR			; MusicFile::saveASM
; _this$ = edi

; 1050 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1051 : 	unsigned	int			iBGM	= 0;

  00006	83 65 fc 00	 and	 DWORD PTR _iBGM$[ebp], 0

; 1052 : 	unsigned	int			iSE		= 0;

  0000a	83 65 f8 00	 and	 DWORD PTR _iSE$[ebp], 0
  0000e	53		 push	 ebx
  0000f	56		 push	 esi

; 1053 : 
; 1054 : 	//----------------------
; 1055 : 	//File open
; 1056 : 	fileopen(strFileName);

  00010	ff 75 08	 push	 DWORD PTR _strFileName$[ebp]
  00013	8d 5f 3c	 lea	 ebx, DWORD PTR [edi+60]
  00016	8b c3		 mov	 eax, ebx
  00018	89 5d f4	 mov	 DWORD PTR tv224[ebp], ebx
  0001b	e8 00 00 00 00	 call	 ?fileopen@FileOutput@@QAEXPBD@Z ; FileOutput::fileopen

; 1057 : 
; 1058 : 	//Header
; 1059 : 	*this <<	";===============================================================\n"
; 1060 : 				";		Music file for NES Sound Driver & Library\n"
; 1061 : 				";			for assembly language (ca65.exe)\n"
; 1062 : 				";===============================================================\n"
; 1063 : 				<<endl;

  00020	8b f7		 mov	 esi, edi
  00022	f7 de		 neg	 esi
  00024	1b f6		 sbb	 esi, esi
  00026	23 f3		 and	 esi, ebx
  00028	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0NF@IGNECHBF@?$DL?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
  0002d	56		 push	 esi
  0002e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1064 : 
; 1065 : 	//Export of Sequence
; 1066 : 	while(iBGM < Header.iBGM){

  0003c	80 bf 9e 00 00
	00 00		 cmp	 BYTE PTR [edi+158], 0
  00043	bb 00 00 00 00	 mov	 ebx, OFFSET FLAT:??_C@_0L@HLHGGEDN@?7?4export?7?7?$AA@
  00048	76 42		 jbe	 SHORT $L64930
$L25635:

; 1067 : 		*this	<<	"	.export		"	<<	Header.Label	<<	"BGM"	<<	iBGM	<<	endl;

  0004a	ff 75 fc	 push	 DWORD PTR _iBGM$[ebp]
  0004d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_03NPKEBKFI@BGM?$AA@
  00052	53		 push	 ebx
  00053	56		 push	 esi
  00054	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00059	50		 push	 eax
  0005a	8d 8f a8 00 00
	00		 lea	 ecx, DWORD PTR [edi+168]
  00060	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0006e	59		 pop	 ecx
  0006f	59		 pop	 ecx
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
  0007c	0f b6 87 9e 00
	00 00		 movzx	 eax, BYTE PTR [edi+158]

; 1068 : 		iBGM++;

  00083	ff 45 fc	 inc	 DWORD PTR _iBGM$[ebp]
  00086	39 45 fc	 cmp	 DWORD PTR _iBGM$[ebp], eax
  00089	59		 pop	 ecx
  0008a	72 be		 jb	 SHORT $L25635
$L64930:

; 1069 : 	}
; 1070 : 	while(iSE < Header.iSE){

  0008c	80 bf 9f 00 00
	00 00		 cmp	 BYTE PTR [edi+159], 0
  00093	76 42		 jbe	 SHORT $L25649
$L25648:

; 1071 : 		*this	<<	"	.export		"	<<	Header.Label	<<	"SE"	<<	iSE	<<	endl;

  00095	ff 75 f8	 push	 DWORD PTR _iSE$[ebp]
  00098	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02ODEKANEE@SE?$AA@
  0009d	53		 push	 ebx
  0009e	56		 push	 esi
  0009f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000a4	50		 push	 eax
  000a5	8d 8f a8 00 00
	00		 lea	 ecx, DWORD PTR [edi+168]
  000ab	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
  000b0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000b9	59		 pop	 ecx
  000ba	59		 pop	 ecx
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
  000c7	0f b6 87 9f 00
	00 00		 movzx	 eax, BYTE PTR [edi+159]

; 1072 : 		iSE++;

  000ce	ff 45 f8	 inc	 DWORD PTR _iSE$[ebp]
  000d1	39 45 f8	 cmp	 DWORD PTR _iSE$[ebp], eax
  000d4	59		 pop	 ecx
  000d5	72 be		 jb	 SHORT $L25648
$L25649:

; 1073 : 	}
; 1074 : 
; 1075 : 	if(cDPCMinfo != NULL){

  000d7	83 bf cc 01 00
	00 00		 cmp	 DWORD PTR [edi+460], 0
  000de	74 32		 je	 SHORT $L64923

; 1076 : 		*this	<<	"	.export		"	<<	Header.Label	<<	"DPCMinfo"	<<	endl;

  000e0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08OIGPGJDM@DPCMinfo?$AA@
  000e5	8d 87 a8 00 00
	00		 lea	 eax, DWORD PTR [edi+168]
  000eb	53		 push	 ebx
  000ec	56		 push	 esi
  000ed	89 45 08	 mov	 DWORD PTR tv245[ebp], eax
  000f0	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000f5	50		 push	 eax
  000f6	8b 45 08	 mov	 eax, DWORD PTR tv245[ebp]
  000f9	8b c8		 mov	 ecx, eax
  000fb	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00109	50		 push	 eax
  0010a	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
  0010f	83 c4 0c	 add	 esp, 12			; 0000000cH
$L64923:

; 1077 : 	}
; 1078 : 
; 1079 : 	//MML
; 1080 : 	*this <<	"\n\n.segment	"	<<	'"'	<<	Header.segmentSEQ	<<	'"' << endl;

  00112	6a 22		 push	 34			; 00000022H
  00114	6a 22		 push	 34			; 00000022H
  00116	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@HOGJIGPO@?6?6?4segment?7?$AA@
  0011b	56		 push	 esi
  0011c	8d 9f 18 01 00
	00		 lea	 ebx, DWORD PTR [edi+280]
  00122	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00127	59		 pop	 ecx
  00128	59		 pop	 ecx
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
  0012f	50		 push	 eax
  00130	8b cb		 mov	 ecx, ebx
  00132	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
  00137	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl

; 1081 : 
; 1082 : 	getAsm(this);

  00146	8b 07		 mov	 eax, DWORD PTR [edi]
  00148	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014b	57		 push	 edi
  0014c	8b cf		 mov	 ecx, edi
  0014e	ff 50 08	 call	 DWORD PTR [eax+8]

; 1083 : 
; 1084 : 	//----------------------
; 1085 : 	//Close file
; 1086 : 	close();

  00151	8b 75 f4	 mov	 esi, DWORD PTR tv224[ebp]
  00154	e8 00 00 00 00	 call	 ?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ofstream<char,std::char_traits<char> >::close
  00159	5e		 pop	 esi
  0015a	5b		 pop	 ebx

; 1087 : }

  0015b	c9		 leave
  0015c	c2 04 00	 ret	 4
?saveASM@MusicFile@@QAEXPBD@Z ENDP			; MusicFile::saveASM
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T70661	DD	0ffffffffH
	DD	FLAT:$L70220
$T70645	DD	019930520H
	DD	01H
	DD	FLAT:$T70661
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
$T70214 = -80						; size = 40
$T70215 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Where$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::erase, COMDAT

; 590  : 		{	// erase element at _Where

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 44	 sub	 esp, 68			; 00000044H
  0000d	53		 push	 ebx

; 591  : 		if (_Isnil(_Where._Mynode()))

  0000e	8b 5d 10	 mov	 ebx, DWORD PTR __Where$[ebp]
  00011	80 7b 15 00	 cmp	 BYTE PTR [ebx+21], 0
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	74 32		 je	 SHORT $L70232

; 592  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  0001e	8d 4d d8	 lea	 ecx, DWORD PTR $T70215[ebp]
  00021	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00026	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002a	8d 45 d8	 lea	 eax, DWORD PTR $T70215[ebp]
  0002d	50		 push	 eax
  0002e	8d 4d b0	 lea	 ecx, DWORD PTR $T70214[ebp]
  00031	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00036	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVout_of_range@std@@
  0003b	8d 45 b0	 lea	 eax, DWORD PTR $T70214[ebp]
  0003e	50		 push	 eax
  0003f	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T70214[ebp], OFFSET FLAT:??_7out_of_range@std@@6B@
  00046	e8 00 00 00 00	 call	 __CxxThrowException@8
$L70662:
$L70232:

; 593  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 594  : 		++_Where;	// save successor iterator for return

  0004b	8d 55 10	 lea	 edx, DWORD PTR __Where$[ebp]
  0004e	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Inc

; 595  : 
; 596  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 597  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 598  : 		_Nodeptr _Pnode = _Erasednode;
; 599  : 
; 600  : 		if (_Isnil(_Left(_Pnode)))

  00053	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00055	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00059	74 05		 je	 SHORT $L31000

; 601  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

  0005b	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 602  : 		else if (_Isnil(_Right(_Pnode)))

  0005e	eb 17		 jmp	 SHORT $L70652
$L31000:
  00060	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00063	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00067	74 04		 je	 SHORT $L31002

; 603  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

  00069	8b f9		 mov	 edi, ecx

; 604  : 		else

  0006b	eb 0a		 jmp	 SHORT $L70652
$L31002:

; 605  : 			{	// two subtrees, must lift successor node to replace erased
; 606  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 607  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

  0006d	8b 45 10	 mov	 eax, DWORD PTR __Where$[ebp]

; 608  : 			}
; 609  : 
; 610  : 		if (_Pnode == _Erasednode)

  00070	3b c3		 cmp	 eax, ebx
  00072	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  00075	75 76		 jne	 SHORT $L31004
$L70652:

; 611  : 			{	// at most one subtree, relink it
; 612  : 			_Fixnodeparent = _Parent(_Erasednode);
; 613  : 			if (!_Isnil(_Fixnode))

  00077	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  0007b	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  0007e	75 03		 jne	 SHORT $L31005

; 614  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00080	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L31005:

; 615  : 
; 616  : 			if (_Root() == _Erasednode)

  00083	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00089	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  0008c	75 05		 jne	 SHORT $L31006

; 617  : 				_Root() = _Fixnode;	// link down from root

  0008e	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 618  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

  00091	eb 0b		 jmp	 SHORT $L31009
$L31006:
  00093	39 1e		 cmp	 DWORD PTR [esi], ebx
  00095	75 04		 jne	 SHORT $L31008

; 619  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  00097	89 3e		 mov	 DWORD PTR [esi], edi

; 620  : 			else

  00099	eb 03		 jmp	 SHORT $L31009
$L31008:

; 621  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

  0009b	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$L31009:

; 622  : 
; 623  : 			if (_Lmost() == _Erasednode)

  0009e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a1	39 1a		 cmp	 DWORD PTR [edx], ebx
  000a3	75 1c		 jne	 SHORT $L31010

; 624  : 				_Lmost() = _Isnil(_Fixnode)
; 625  : 					? _Fixnodeparent	// smallest is parent of erased node
; 626  : 					: _Min(_Fixnode);	// smallest in relinked subtree

  000a5	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  000a9	74 04		 je	 SHORT $L70216
  000ab	8b ce		 mov	 ecx, esi
  000ad	eb 10		 jmp	 SHORT $L70217
$L70216:
  000af	8b 07		 mov	 eax, DWORD PTR [edi]
  000b1	8b cf		 mov	 ecx, edi
  000b3	eb 04		 jmp	 SHORT $L70655
$L70326:
  000b5	8b c8		 mov	 ecx, eax
  000b7	8b 01		 mov	 eax, DWORD PTR [ecx]
$L70655:
  000b9	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  000bd	74 f6		 je	 SHORT $L70326
$L70217:
  000bf	89 0a		 mov	 DWORD PTR [edx], ecx
$L31010:

; 627  : 
; 628  : 			if (_Rmost() == _Erasednode)

  000c1	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c7	39 5a 08	 cmp	 DWORD PTR [edx+8], ebx
  000ca	75 7b		 jne	 SHORT $L70473

; 629  : 				_Rmost() = _Isnil(_Fixnode)
; 630  : 					? _Fixnodeparent	// largest is parent of erased node
; 631  : 					: _Max(_Fixnode);	// largest in relinked subtree

  000cc	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  000d0	74 04		 je	 SHORT $L70218
  000d2	8b ce		 mov	 ecx, esi
  000d4	eb 12		 jmp	 SHORT $L70219
$L70218:
  000d6	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000d9	8b cf		 mov	 ecx, edi
  000db	eb 05		 jmp	 SHORT $L70656
$L70367:
  000dd	8b c8		 mov	 ecx, eax
  000df	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
$L70656:
  000e2	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  000e6	74 f5		 je	 SHORT $L70367
$L70219:
  000e8	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 632  : 			}
; 633  : 		else

  000eb	eb 5a		 jmp	 SHORT $L70473
$L31004:

; 634  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 635  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

  000ed	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 636  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

  000f0	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000f2	89 08		 mov	 DWORD PTR [eax], ecx

; 637  : 
; 638  : 			if (_Pnode == _Right(_Erasednode))

  000f4	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  000f7	75 04		 jne	 SHORT $L31013

; 639  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000f9	8b f0		 mov	 esi, eax

; 640  : 			else

  000fb	eb 1a		 jmp	 SHORT $L31014
$L31013:

; 641  : 				{	// successor further down, link in place of erased
; 642  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 643  : 				if (!_Isnil(_Fixnode))

  000fd	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  00101	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00104	75 03		 jne	 SHORT $L31015

; 644  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  00106	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L31015:

; 645  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  00109	89 3e		 mov	 DWORD PTR [esi], edi

; 646  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

  0010b	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0010e	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 647  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

  00111	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00114	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L31014:

; 648  : 				}
; 649  : 
; 650  : 			if (_Root() == _Erasednode)

  00117	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0011a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0011d	39 59 04	 cmp	 DWORD PTR [ecx+4], ebx
  00120	75 05		 jne	 SHORT $L31016

; 651  : 				_Root() = _Pnode;	// link down from root

  00122	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 652  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

  00125	eb 0e		 jmp	 SHORT $L31019
$L31016:
  00127	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0012a	39 19		 cmp	 DWORD PTR [ecx], ebx
  0012c	75 04		 jne	 SHORT $L31018

; 653  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

  0012e	89 01		 mov	 DWORD PTR [ecx], eax

; 654  : 			else

  00130	eb 03		 jmp	 SHORT $L31019
$L31018:

; 655  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

  00132	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L31019:

; 656  : 
; 657  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

  00135	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00138	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 658  : 			std::swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

  0013b	8a 53 14	 mov	 dl, BYTE PTR [ebx+20]
  0013e	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00141	88 50 14	 mov	 BYTE PTR [eax+20], dl
  00144	88 4b 14	 mov	 BYTE PTR [ebx+20], cl
$L70473:

; 659  : 			}
; 660  : 
; 661  : 		if (_Color(_Erasednode) == _Black)

  00147	80 7b 14 01	 cmp	 BYTE PTR [ebx+20], 1
  0014b	0f 85 12 01 00
	00		 jne	 $L31020

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00151	e9 c1 00 00 00	 jmp	 $L70658
$L31021:
  00156	80 7f 14 01	 cmp	 BYTE PTR [edi+20], 1
  0015a	0f 85 ff 00 00
	00		 jne	 $L31023

; 665  : 				if (_Fixnode == _Left(_Fixnodeparent))

  00160	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00162	3b f9		 cmp	 edi, ecx
  00164	75 77		 jne	 SHORT $L31024

; 666  : 					{	// fixup left subtree
; 667  : 					_Pnode = _Right(_Fixnodeparent);

  00166	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 668  : 					if (_Color(_Pnode) == _Red)

  00169	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  0016d	75 15		 jne	 SHORT $L31025

; 669  : 						{	// rotate red up from right subtree
; 670  : 						_Color(_Pnode) = _Black;
; 671  : 						_Color(_Fixnodeparent) = _Red;
; 672  : 						_Lrotate(_Fixnodeparent);

  0016f	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00172	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1
  00176	8b ce		 mov	 ecx, esi
  00178	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  0017c	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Lrotate

; 673  : 						_Pnode = _Right(_Fixnodeparent);

  00181	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$L31025:

; 674  : 						}
; 675  : 
; 676  : 					if (_Isnil(_Pnode))

  00184	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0

; 677  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 678  : 					else if (_Color(_Left(_Pnode)) == _Black

  00188	0f 85 84 00 00
	00		 jne	 $L70659

; 679  : 						&& _Color(_Right(_Pnode)) == _Black)

  0018e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00190	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  00194	75 09		 jne	 SHORT $L31028
  00196	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00199	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0019d	74 6f		 je	 SHORT $L70660
$L31028:

; 680  : 						{	// redden right subtree with black children
; 681  : 						_Color(_Pnode) = _Red;
; 682  : 						_Fixnode = _Fixnodeparent;
; 683  : 						}
; 684  : 					else
; 685  : 						{	// must rearrange right subtree
; 686  : 						if (_Color(_Right(_Pnode)) == _Black)

  0019f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001a2	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  001a6	75 15		 jne	 SHORT $L31030

; 687  : 							{	// rotate red up from left sub-subtree
; 688  : 							_Color(_Left(_Pnode)) = _Black;

  001a8	8b 01		 mov	 eax, DWORD PTR [ecx]

; 689  : 							_Color(_Pnode) = _Red;
; 690  : 							_Rrotate(_Pnode);

  001aa	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001ad	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  001b1	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
  001b5	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Rrotate

; 691  : 							_Pnode = _Right(_Fixnodeparent);

  001ba	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$L31030:

; 692  : 							}
; 693  : 
; 694  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  001bd	8a 46 14	 mov	 al, BYTE PTR [esi+20]

; 695  : 						_Color(_Fixnodeparent) = _Black;
; 696  : 						_Color(_Right(_Pnode)) = _Black;
; 697  : 						_Lrotate(_Fixnodeparent);

  001c0	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001c3	88 41 14	 mov	 BYTE PTR [ecx+20], al
  001c6	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1
  001ca	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001cd	8b ce		 mov	 ecx, esi
  001cf	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  001d3	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Lrotate

; 698  : 						break;	// tree now recolored/rebalanced

  001d8	e9 82 00 00 00	 jmp	 $L31023
$L31024:

; 699  : 						}
; 700  : 					}
; 701  : 				else
; 702  : 					{	// fixup right subtree
; 703  : 					_Pnode = _Left(_Fixnodeparent);
; 704  : 					if (_Color(_Pnode) == _Red)

  001dd	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  001e1	75 14		 jne	 SHORT $L31032

; 705  : 						{	// rotate red up from left subtree
; 706  : 						_Color(_Pnode) = _Black;
; 707  : 						_Color(_Fixnodeparent) = _Red;
; 708  : 						_Rrotate(_Fixnodeparent);

  001e3	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001e6	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1
  001ea	8b ce		 mov	 ecx, esi
  001ec	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  001f0	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Rrotate

; 709  : 						_Pnode = _Left(_Fixnodeparent);

  001f5	8b 0e		 mov	 ecx, DWORD PTR [esi]
$L31032:

; 710  : 						}
; 711  : 					if (_Isnil(_Pnode))

  001f7	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0

; 712  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 713  : 					else if (_Color(_Right(_Pnode)) == _Black

  001fb	75 15		 jne	 SHORT $L70659

; 714  : 						&& _Color(_Left(_Pnode)) == _Black)

  001fd	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00200	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  00204	75 22		 jne	 SHORT $L31035
  00206	8b 01		 mov	 eax, DWORD PTR [ecx]
  00208	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0020c	75 1a		 jne	 SHORT $L31035
$L70660:

; 715  : 						{	// redden left subtree with black children
; 716  : 						_Color(_Pnode) = _Red;

  0020e	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
$L70659:

; 717  : 						_Fixnode = _Fixnodeparent;

  00212	8b fe		 mov	 edi, esi
  00214	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
$L70658:
  00217	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0021a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0021d	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  00220	0f 85 30 ff ff
	ff		 jne	 $L31021

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00226	eb 37		 jmp	 SHORT $L31023
$L31035:

; 718  : 						}
; 719  : 					else
; 720  : 						{	// must rearrange left subtree
; 721  : 						if (_Color(_Left(_Pnode)) == _Black)

  00228	8b 01		 mov	 eax, DWORD PTR [ecx]
  0022a	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0022e	75 15		 jne	 SHORT $L31037

; 722  : 							{	// rotate red up from right sub-subtree
; 723  : 							_Color(_Right(_Pnode)) = _Black;

  00230	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 724  : 							_Color(_Pnode) = _Red;
; 725  : 							_Lrotate(_Pnode);

  00233	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00236	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  0023a	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
  0023e	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Lrotate

; 726  : 							_Pnode = _Left(_Fixnodeparent);

  00243	8b 0e		 mov	 ecx, DWORD PTR [esi]
$L31037:

; 727  : 							}
; 728  : 
; 729  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  00245	8a 46 14	 mov	 al, BYTE PTR [esi+20]

; 730  : 						_Color(_Fixnodeparent) = _Black;
; 731  : 						_Color(_Left(_Pnode)) = _Black;
; 732  : 						_Rrotate(_Fixnodeparent);

  00248	ff 75 08	 push	 DWORD PTR _this$[ebp]
  0024b	88 41 14	 mov	 BYTE PTR [ecx+20], al
  0024e	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1
  00252	8b 01		 mov	 eax, DWORD PTR [ecx]
  00254	8b ce		 mov	 ecx, esi
  00256	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  0025a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Rrotate
$L31023:

; 733  : 						break;	// tree now recolored/rebalanced
; 734  : 						}
; 735  : 					}
; 736  : 
; 737  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

  0025f	c6 47 14 01	 mov	 BYTE PTR [edi+20], 1
$L31020:

; 738  : 			}
; 739  : 
; 740  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 741  : 		this->_Alnod.deallocate(_Erasednode, 1);

  00263	53		 push	 ebx
  00264	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00269	59		 pop	 ecx

; 742  : 
; 743  : 		if (0 < _Mysize)

  0026a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0026d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00270	85 c0		 test	 eax, eax
  00272	5f		 pop	 edi
  00273	5e		 pop	 esi
  00274	5b		 pop	 ebx
  00275	76 04		 jbe	 SHORT $L31038

; 744  : 			--_Mysize;

  00277	48		 dec	 eax
  00278	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L31038:

; 745  : 
; 746  : 		return (_Where);	// return successor iterator

  0027b	8b 4d 10	 mov	 ecx, DWORD PTR __Where$[ebp]
  0027e	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00281	89 08		 mov	 DWORD PTR [eax], ecx

; 747  : 		}

  00283	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00286	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0028d	c9		 leave
  0028e	c2 0c 00	 ret	 12			; 0000000cH
$L70654:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L70220:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T70215[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T70645
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::erase
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T71114	DD	0ffffffffH
	DD	FLAT:$L70673
$T71098	DD	019930520H
	DD	01H
	DD	FLAT:$T71114
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
$T70667 = -80						; size = 40
$T70668 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Where$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::erase, COMDAT

; 590  : 		{	// erase element at _Where

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 44	 sub	 esp, 68			; 00000044H
  0000d	53		 push	 ebx

; 591  : 		if (_Isnil(_Where._Mynode()))

  0000e	8b 5d 10	 mov	 ebx, DWORD PTR __Where$[ebp]
  00011	80 7b 15 00	 cmp	 BYTE PTR [ebx+21], 0
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	74 32		 je	 SHORT $L70686

; 592  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  0001e	8d 4d d8	 lea	 ecx, DWORD PTR $T70668[ebp]
  00021	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00026	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002a	8d 45 d8	 lea	 eax, DWORD PTR $T70668[ebp]
  0002d	50		 push	 eax
  0002e	8d 4d b0	 lea	 ecx, DWORD PTR $T70667[ebp]
  00031	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00036	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVout_of_range@std@@
  0003b	8d 45 b0	 lea	 eax, DWORD PTR $T70667[ebp]
  0003e	50		 push	 eax
  0003f	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T70667[ebp], OFFSET FLAT:??_7out_of_range@std@@6B@
  00046	e8 00 00 00 00	 call	 __CxxThrowException@8
$L71115:
$L70686:

; 593  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 594  : 		++_Where;	// save successor iterator for return

  0004b	8d 55 10	 lea	 edx, DWORD PTR __Where$[ebp]
  0004e	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::_Inc

; 595  : 
; 596  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 597  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 598  : 		_Nodeptr _Pnode = _Erasednode;
; 599  : 
; 600  : 		if (_Isnil(_Left(_Pnode)))

  00053	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00055	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00059	74 05		 je	 SHORT $L30888

; 601  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

  0005b	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 602  : 		else if (_Isnil(_Right(_Pnode)))

  0005e	eb 17		 jmp	 SHORT $L71105
$L30888:
  00060	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00063	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00067	74 04		 je	 SHORT $L30890

; 603  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

  00069	8b f9		 mov	 edi, ecx

; 604  : 		else

  0006b	eb 0a		 jmp	 SHORT $L71105
$L30890:

; 605  : 			{	// two subtrees, must lift successor node to replace erased
; 606  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 607  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

  0006d	8b 45 10	 mov	 eax, DWORD PTR __Where$[ebp]

; 608  : 			}
; 609  : 
; 610  : 		if (_Pnode == _Erasednode)

  00070	3b c3		 cmp	 eax, ebx
  00072	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  00075	75 76		 jne	 SHORT $L30892
$L71105:

; 611  : 			{	// at most one subtree, relink it
; 612  : 			_Fixnodeparent = _Parent(_Erasednode);
; 613  : 			if (!_Isnil(_Fixnode))

  00077	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  0007b	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  0007e	75 03		 jne	 SHORT $L30893

; 614  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00080	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L30893:

; 615  : 
; 616  : 			if (_Root() == _Erasednode)

  00083	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00089	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  0008c	75 05		 jne	 SHORT $L30894

; 617  : 				_Root() = _Fixnode;	// link down from root

  0008e	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 618  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

  00091	eb 0b		 jmp	 SHORT $L30897
$L30894:
  00093	39 1e		 cmp	 DWORD PTR [esi], ebx
  00095	75 04		 jne	 SHORT $L30896

; 619  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  00097	89 3e		 mov	 DWORD PTR [esi], edi

; 620  : 			else

  00099	eb 03		 jmp	 SHORT $L30897
$L30896:

; 621  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

  0009b	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$L30897:

; 622  : 
; 623  : 			if (_Lmost() == _Erasednode)

  0009e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a1	39 1a		 cmp	 DWORD PTR [edx], ebx
  000a3	75 1c		 jne	 SHORT $L30898

; 624  : 				_Lmost() = _Isnil(_Fixnode)
; 625  : 					? _Fixnodeparent	// smallest is parent of erased node
; 626  : 					: _Min(_Fixnode);	// smallest in relinked subtree

  000a5	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  000a9	74 04		 je	 SHORT $L70669
  000ab	8b ce		 mov	 ecx, esi
  000ad	eb 10		 jmp	 SHORT $L70670
$L70669:
  000af	8b 07		 mov	 eax, DWORD PTR [edi]
  000b1	8b cf		 mov	 ecx, edi
  000b3	eb 04		 jmp	 SHORT $L71108
$L70779:
  000b5	8b c8		 mov	 ecx, eax
  000b7	8b 01		 mov	 eax, DWORD PTR [ecx]
$L71108:
  000b9	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  000bd	74 f6		 je	 SHORT $L70779
$L70670:
  000bf	89 0a		 mov	 DWORD PTR [edx], ecx
$L30898:

; 627  : 
; 628  : 			if (_Rmost() == _Erasednode)

  000c1	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c7	39 5a 08	 cmp	 DWORD PTR [edx+8], ebx
  000ca	75 7b		 jne	 SHORT $L70926

; 629  : 				_Rmost() = _Isnil(_Fixnode)
; 630  : 					? _Fixnodeparent	// largest is parent of erased node
; 631  : 					: _Max(_Fixnode);	// largest in relinked subtree

  000cc	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  000d0	74 04		 je	 SHORT $L70671
  000d2	8b ce		 mov	 ecx, esi
  000d4	eb 12		 jmp	 SHORT $L70672
$L70671:
  000d6	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000d9	8b cf		 mov	 ecx, edi
  000db	eb 05		 jmp	 SHORT $L71109
$L70820:
  000dd	8b c8		 mov	 ecx, eax
  000df	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
$L71109:
  000e2	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  000e6	74 f5		 je	 SHORT $L70820
$L70672:
  000e8	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 632  : 			}
; 633  : 		else

  000eb	eb 5a		 jmp	 SHORT $L70926
$L30892:

; 634  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 635  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

  000ed	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 636  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

  000f0	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000f2	89 08		 mov	 DWORD PTR [eax], ecx

; 637  : 
; 638  : 			if (_Pnode == _Right(_Erasednode))

  000f4	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  000f7	75 04		 jne	 SHORT $L30901

; 639  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000f9	8b f0		 mov	 esi, eax

; 640  : 			else

  000fb	eb 1a		 jmp	 SHORT $L30902
$L30901:

; 641  : 				{	// successor further down, link in place of erased
; 642  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 643  : 				if (!_Isnil(_Fixnode))

  000fd	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  00101	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00104	75 03		 jne	 SHORT $L30903

; 644  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  00106	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L30903:

; 645  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  00109	89 3e		 mov	 DWORD PTR [esi], edi

; 646  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

  0010b	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0010e	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 647  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

  00111	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00114	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L30902:

; 648  : 				}
; 649  : 
; 650  : 			if (_Root() == _Erasednode)

  00117	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0011a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0011d	39 59 04	 cmp	 DWORD PTR [ecx+4], ebx
  00120	75 05		 jne	 SHORT $L30904

; 651  : 				_Root() = _Pnode;	// link down from root

  00122	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 652  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

  00125	eb 0e		 jmp	 SHORT $L30907
$L30904:
  00127	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0012a	39 19		 cmp	 DWORD PTR [ecx], ebx
  0012c	75 04		 jne	 SHORT $L30906

; 653  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

  0012e	89 01		 mov	 DWORD PTR [ecx], eax

; 654  : 			else

  00130	eb 03		 jmp	 SHORT $L30907
$L30906:

; 655  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

  00132	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L30907:

; 656  : 
; 657  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

  00135	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00138	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 658  : 			std::swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

  0013b	8a 53 14	 mov	 dl, BYTE PTR [ebx+20]
  0013e	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00141	88 50 14	 mov	 BYTE PTR [eax+20], dl
  00144	88 4b 14	 mov	 BYTE PTR [ebx+20], cl
$L70926:

; 659  : 			}
; 660  : 
; 661  : 		if (_Color(_Erasednode) == _Black)

  00147	80 7b 14 01	 cmp	 BYTE PTR [ebx+20], 1
  0014b	0f 85 12 01 00
	00		 jne	 $L30908

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00151	e9 c1 00 00 00	 jmp	 $L71111
$L30909:
  00156	80 7f 14 01	 cmp	 BYTE PTR [edi+20], 1
  0015a	0f 85 ff 00 00
	00		 jne	 $L30911

; 665  : 				if (_Fixnode == _Left(_Fixnodeparent))

  00160	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00162	3b f9		 cmp	 edi, ecx
  00164	75 77		 jne	 SHORT $L30912

; 666  : 					{	// fixup left subtree
; 667  : 					_Pnode = _Right(_Fixnodeparent);

  00166	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 668  : 					if (_Color(_Pnode) == _Red)

  00169	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  0016d	75 15		 jne	 SHORT $L30913

; 669  : 						{	// rotate red up from right subtree
; 670  : 						_Color(_Pnode) = _Black;
; 671  : 						_Color(_Fixnodeparent) = _Red;
; 672  : 						_Lrotate(_Fixnodeparent);

  0016f	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00172	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1
  00176	8b ce		 mov	 ecx, esi
  00178	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  0017c	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Lrotate

; 673  : 						_Pnode = _Right(_Fixnodeparent);

  00181	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$L30913:

; 674  : 						}
; 675  : 
; 676  : 					if (_Isnil(_Pnode))

  00184	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0

; 677  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 678  : 					else if (_Color(_Left(_Pnode)) == _Black

  00188	0f 85 84 00 00
	00		 jne	 $L71112

; 679  : 						&& _Color(_Right(_Pnode)) == _Black)

  0018e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00190	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  00194	75 09		 jne	 SHORT $L30916
  00196	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00199	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0019d	74 6f		 je	 SHORT $L71113
$L30916:

; 680  : 						{	// redden right subtree with black children
; 681  : 						_Color(_Pnode) = _Red;
; 682  : 						_Fixnode = _Fixnodeparent;
; 683  : 						}
; 684  : 					else
; 685  : 						{	// must rearrange right subtree
; 686  : 						if (_Color(_Right(_Pnode)) == _Black)

  0019f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001a2	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  001a6	75 15		 jne	 SHORT $L30918

; 687  : 							{	// rotate red up from left sub-subtree
; 688  : 							_Color(_Left(_Pnode)) = _Black;

  001a8	8b 01		 mov	 eax, DWORD PTR [ecx]

; 689  : 							_Color(_Pnode) = _Red;
; 690  : 							_Rrotate(_Pnode);

  001aa	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001ad	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  001b1	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
  001b5	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Rrotate

; 691  : 							_Pnode = _Right(_Fixnodeparent);

  001ba	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$L30918:

; 692  : 							}
; 693  : 
; 694  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  001bd	8a 46 14	 mov	 al, BYTE PTR [esi+20]

; 695  : 						_Color(_Fixnodeparent) = _Black;
; 696  : 						_Color(_Right(_Pnode)) = _Black;
; 697  : 						_Lrotate(_Fixnodeparent);

  001c0	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001c3	88 41 14	 mov	 BYTE PTR [ecx+20], al
  001c6	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1
  001ca	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001cd	8b ce		 mov	 ecx, esi
  001cf	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  001d3	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Lrotate

; 698  : 						break;	// tree now recolored/rebalanced

  001d8	e9 82 00 00 00	 jmp	 $L30911
$L30912:

; 699  : 						}
; 700  : 					}
; 701  : 				else
; 702  : 					{	// fixup right subtree
; 703  : 					_Pnode = _Left(_Fixnodeparent);
; 704  : 					if (_Color(_Pnode) == _Red)

  001dd	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  001e1	75 14		 jne	 SHORT $L30920

; 705  : 						{	// rotate red up from left subtree
; 706  : 						_Color(_Pnode) = _Black;
; 707  : 						_Color(_Fixnodeparent) = _Red;
; 708  : 						_Rrotate(_Fixnodeparent);

  001e3	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001e6	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1
  001ea	8b ce		 mov	 ecx, esi
  001ec	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  001f0	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Rrotate

; 709  : 						_Pnode = _Left(_Fixnodeparent);

  001f5	8b 0e		 mov	 ecx, DWORD PTR [esi]
$L30920:

; 710  : 						}
; 711  : 					if (_Isnil(_Pnode))

  001f7	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0

; 712  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 713  : 					else if (_Color(_Right(_Pnode)) == _Black

  001fb	75 15		 jne	 SHORT $L71112

; 714  : 						&& _Color(_Left(_Pnode)) == _Black)

  001fd	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00200	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  00204	75 22		 jne	 SHORT $L30923
  00206	8b 01		 mov	 eax, DWORD PTR [ecx]
  00208	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0020c	75 1a		 jne	 SHORT $L30923
$L71113:

; 715  : 						{	// redden left subtree with black children
; 716  : 						_Color(_Pnode) = _Red;

  0020e	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
$L71112:

; 717  : 						_Fixnode = _Fixnodeparent;

  00212	8b fe		 mov	 edi, esi
  00214	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
$L71111:
  00217	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0021a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0021d	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  00220	0f 85 30 ff ff
	ff		 jne	 $L30909

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00226	eb 37		 jmp	 SHORT $L30911
$L30923:

; 718  : 						}
; 719  : 					else
; 720  : 						{	// must rearrange left subtree
; 721  : 						if (_Color(_Left(_Pnode)) == _Black)

  00228	8b 01		 mov	 eax, DWORD PTR [ecx]
  0022a	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0022e	75 15		 jne	 SHORT $L30925

; 722  : 							{	// rotate red up from right sub-subtree
; 723  : 							_Color(_Right(_Pnode)) = _Black;

  00230	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 724  : 							_Color(_Pnode) = _Red;
; 725  : 							_Lrotate(_Pnode);

  00233	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00236	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  0023a	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
  0023e	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Lrotate

; 726  : 							_Pnode = _Left(_Fixnodeparent);

  00243	8b 0e		 mov	 ecx, DWORD PTR [esi]
$L30925:

; 727  : 							}
; 728  : 
; 729  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  00245	8a 46 14	 mov	 al, BYTE PTR [esi+20]

; 730  : 						_Color(_Fixnodeparent) = _Black;
; 731  : 						_Color(_Left(_Pnode)) = _Black;
; 732  : 						_Rrotate(_Fixnodeparent);

  00248	ff 75 08	 push	 DWORD PTR _this$[ebp]
  0024b	88 41 14	 mov	 BYTE PTR [ecx+20], al
  0024e	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1
  00252	8b 01		 mov	 eax, DWORD PTR [ecx]
  00254	8b ce		 mov	 ecx, esi
  00256	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  0025a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Rrotate
$L30911:

; 733  : 						break;	// tree now recolored/rebalanced
; 734  : 						}
; 735  : 					}
; 736  : 
; 737  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

  0025f	c6 47 14 01	 mov	 BYTE PTR [edi+20], 1
$L30908:

; 738  : 			}
; 739  : 
; 740  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 741  : 		this->_Alnod.deallocate(_Erasednode, 1);

  00263	53		 push	 ebx
  00264	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00269	59		 pop	 ecx

; 742  : 
; 743  : 		if (0 < _Mysize)

  0026a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0026d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00270	85 c0		 test	 eax, eax
  00272	5f		 pop	 edi
  00273	5e		 pop	 esi
  00274	5b		 pop	 ebx
  00275	76 04		 jbe	 SHORT $L30926

; 744  : 			--_Mysize;

  00277	48		 dec	 eax
  00278	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L30926:

; 745  : 
; 746  : 		return (_Where);	// return successor iterator

  0027b	8b 4d 10	 mov	 ecx, DWORD PTR __Where$[ebp]
  0027e	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00281	89 08		 mov	 DWORD PTR [eax], ecx

; 747  : 		}

  00283	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00286	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0028d	c9		 leave
  0028e	c2 0c 00	 ret	 12			; 0000000cH
$L71107:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L70673:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T70668[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T71098
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::erase
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T71567	DD	0ffffffffH
	DD	FLAT:$L71126
$T71551	DD	019930520H
	DD	01H
	DD	FLAT:$T71567
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
$T71120 = -80						; size = 40
$T71121 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Where$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::erase, COMDAT

; 590  : 		{	// erase element at _Where

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 44	 sub	 esp, 68			; 00000044H
  0000d	53		 push	 ebx

; 591  : 		if (_Isnil(_Where._Mynode()))

  0000e	8b 5d 10	 mov	 ebx, DWORD PTR __Where$[ebp]
  00011	80 7b 15 00	 cmp	 BYTE PTR [ebx+21], 0
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	74 32		 je	 SHORT $L71138

; 592  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  0001e	8d 4d d8	 lea	 ecx, DWORD PTR $T71121[ebp]
  00021	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00026	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002a	8d 45 d8	 lea	 eax, DWORD PTR $T71121[ebp]
  0002d	50		 push	 eax
  0002e	8d 4d b0	 lea	 ecx, DWORD PTR $T71120[ebp]
  00031	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00036	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVout_of_range@std@@
  0003b	8d 45 b0	 lea	 eax, DWORD PTR $T71120[ebp]
  0003e	50		 push	 eax
  0003f	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T71120[ebp], OFFSET FLAT:??_7out_of_range@std@@6B@
  00046	e8 00 00 00 00	 call	 __CxxThrowException@8
$L71568:
$L71138:

; 593  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 594  : 		++_Where;	// save successor iterator for return

  0004b	8d 55 10	 lea	 edx, DWORD PTR __Where$[ebp]
  0004e	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::_Inc

; 595  : 
; 596  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 597  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 598  : 		_Nodeptr _Pnode = _Erasednode;
; 599  : 
; 600  : 		if (_Isnil(_Left(_Pnode)))

  00053	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00055	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00059	74 05		 je	 SHORT $L30776

; 601  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

  0005b	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 602  : 		else if (_Isnil(_Right(_Pnode)))

  0005e	eb 17		 jmp	 SHORT $L71558
$L30776:
  00060	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00063	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00067	74 04		 je	 SHORT $L30778

; 603  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

  00069	8b f9		 mov	 edi, ecx

; 604  : 		else

  0006b	eb 0a		 jmp	 SHORT $L71558
$L30778:

; 605  : 			{	// two subtrees, must lift successor node to replace erased
; 606  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 607  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

  0006d	8b 45 10	 mov	 eax, DWORD PTR __Where$[ebp]

; 608  : 			}
; 609  : 
; 610  : 		if (_Pnode == _Erasednode)

  00070	3b c3		 cmp	 eax, ebx
  00072	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  00075	75 76		 jne	 SHORT $L30780
$L71558:

; 611  : 			{	// at most one subtree, relink it
; 612  : 			_Fixnodeparent = _Parent(_Erasednode);
; 613  : 			if (!_Isnil(_Fixnode))

  00077	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  0007b	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  0007e	75 03		 jne	 SHORT $L30781

; 614  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00080	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L30781:

; 615  : 
; 616  : 			if (_Root() == _Erasednode)

  00083	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00089	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  0008c	75 05		 jne	 SHORT $L30782

; 617  : 				_Root() = _Fixnode;	// link down from root

  0008e	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 618  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

  00091	eb 0b		 jmp	 SHORT $L30785
$L30782:
  00093	39 1e		 cmp	 DWORD PTR [esi], ebx
  00095	75 04		 jne	 SHORT $L30784

; 619  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  00097	89 3e		 mov	 DWORD PTR [esi], edi

; 620  : 			else

  00099	eb 03		 jmp	 SHORT $L30785
$L30784:

; 621  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

  0009b	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$L30785:

; 622  : 
; 623  : 			if (_Lmost() == _Erasednode)

  0009e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a1	39 1a		 cmp	 DWORD PTR [edx], ebx
  000a3	75 1c		 jne	 SHORT $L30786

; 624  : 				_Lmost() = _Isnil(_Fixnode)
; 625  : 					? _Fixnodeparent	// smallest is parent of erased node
; 626  : 					: _Min(_Fixnode);	// smallest in relinked subtree

  000a5	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  000a9	74 04		 je	 SHORT $L71122
  000ab	8b ce		 mov	 ecx, esi
  000ad	eb 10		 jmp	 SHORT $L71123
$L71122:
  000af	8b 07		 mov	 eax, DWORD PTR [edi]
  000b1	8b cf		 mov	 ecx, edi
  000b3	eb 04		 jmp	 SHORT $L71561
$L71239:
  000b5	8b c8		 mov	 ecx, eax
  000b7	8b 01		 mov	 eax, DWORD PTR [ecx]
$L71561:
  000b9	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  000bd	74 f6		 je	 SHORT $L71239
$L71123:
  000bf	89 0a		 mov	 DWORD PTR [edx], ecx
$L30786:

; 627  : 
; 628  : 			if (_Rmost() == _Erasednode)

  000c1	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c7	39 5a 08	 cmp	 DWORD PTR [edx+8], ebx
  000ca	75 7b		 jne	 SHORT $L71379

; 629  : 				_Rmost() = _Isnil(_Fixnode)
; 630  : 					? _Fixnodeparent	// largest is parent of erased node
; 631  : 					: _Max(_Fixnode);	// largest in relinked subtree

  000cc	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  000d0	74 04		 je	 SHORT $L71124
  000d2	8b ce		 mov	 ecx, esi
  000d4	eb 12		 jmp	 SHORT $L71125
$L71124:
  000d6	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000d9	8b cf		 mov	 ecx, edi
  000db	eb 05		 jmp	 SHORT $L71562
$L71280:
  000dd	8b c8		 mov	 ecx, eax
  000df	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
$L71562:
  000e2	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  000e6	74 f5		 je	 SHORT $L71280
$L71125:
  000e8	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 632  : 			}
; 633  : 		else

  000eb	eb 5a		 jmp	 SHORT $L71379
$L30780:

; 634  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 635  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

  000ed	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 636  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

  000f0	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000f2	89 08		 mov	 DWORD PTR [eax], ecx

; 637  : 
; 638  : 			if (_Pnode == _Right(_Erasednode))

  000f4	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  000f7	75 04		 jne	 SHORT $L30789

; 639  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000f9	8b f0		 mov	 esi, eax

; 640  : 			else

  000fb	eb 1a		 jmp	 SHORT $L30790
$L30789:

; 641  : 				{	// successor further down, link in place of erased
; 642  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 643  : 				if (!_Isnil(_Fixnode))

  000fd	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  00101	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00104	75 03		 jne	 SHORT $L30791

; 644  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  00106	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L30791:

; 645  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  00109	89 3e		 mov	 DWORD PTR [esi], edi

; 646  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

  0010b	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0010e	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 647  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

  00111	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00114	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L30790:

; 648  : 				}
; 649  : 
; 650  : 			if (_Root() == _Erasednode)

  00117	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0011a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0011d	39 59 04	 cmp	 DWORD PTR [ecx+4], ebx
  00120	75 05		 jne	 SHORT $L30792

; 651  : 				_Root() = _Pnode;	// link down from root

  00122	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 652  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

  00125	eb 0e		 jmp	 SHORT $L30795
$L30792:
  00127	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0012a	39 19		 cmp	 DWORD PTR [ecx], ebx
  0012c	75 04		 jne	 SHORT $L30794

; 653  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

  0012e	89 01		 mov	 DWORD PTR [ecx], eax

; 654  : 			else

  00130	eb 03		 jmp	 SHORT $L30795
$L30794:

; 655  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

  00132	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L30795:

; 656  : 
; 657  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

  00135	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00138	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 658  : 			std::swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

  0013b	8a 53 14	 mov	 dl, BYTE PTR [ebx+20]
  0013e	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00141	88 50 14	 mov	 BYTE PTR [eax+20], dl
  00144	88 4b 14	 mov	 BYTE PTR [ebx+20], cl
$L71379:

; 659  : 			}
; 660  : 
; 661  : 		if (_Color(_Erasednode) == _Black)

  00147	80 7b 14 01	 cmp	 BYTE PTR [ebx+20], 1
  0014b	0f 85 12 01 00
	00		 jne	 $L30796

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00151	e9 c1 00 00 00	 jmp	 $L71564
$L30797:
  00156	80 7f 14 01	 cmp	 BYTE PTR [edi+20], 1
  0015a	0f 85 ff 00 00
	00		 jne	 $L30799

; 665  : 				if (_Fixnode == _Left(_Fixnodeparent))

  00160	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00162	3b f9		 cmp	 edi, ecx
  00164	75 77		 jne	 SHORT $L30800

; 666  : 					{	// fixup left subtree
; 667  : 					_Pnode = _Right(_Fixnodeparent);

  00166	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 668  : 					if (_Color(_Pnode) == _Red)

  00169	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  0016d	75 15		 jne	 SHORT $L30801

; 669  : 						{	// rotate red up from right subtree
; 670  : 						_Color(_Pnode) = _Black;
; 671  : 						_Color(_Fixnodeparent) = _Red;
; 672  : 						_Lrotate(_Fixnodeparent);

  0016f	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00172	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1
  00176	8b ce		 mov	 ecx, esi
  00178	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  0017c	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Lrotate

; 673  : 						_Pnode = _Right(_Fixnodeparent);

  00181	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$L30801:

; 674  : 						}
; 675  : 
; 676  : 					if (_Isnil(_Pnode))

  00184	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0

; 677  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 678  : 					else if (_Color(_Left(_Pnode)) == _Black

  00188	0f 85 84 00 00
	00		 jne	 $L71565

; 679  : 						&& _Color(_Right(_Pnode)) == _Black)

  0018e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00190	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  00194	75 09		 jne	 SHORT $L30804
  00196	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00199	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0019d	74 6f		 je	 SHORT $L71566
$L30804:

; 680  : 						{	// redden right subtree with black children
; 681  : 						_Color(_Pnode) = _Red;
; 682  : 						_Fixnode = _Fixnodeparent;
; 683  : 						}
; 684  : 					else
; 685  : 						{	// must rearrange right subtree
; 686  : 						if (_Color(_Right(_Pnode)) == _Black)

  0019f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001a2	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  001a6	75 15		 jne	 SHORT $L30806

; 687  : 							{	// rotate red up from left sub-subtree
; 688  : 							_Color(_Left(_Pnode)) = _Black;

  001a8	8b 01		 mov	 eax, DWORD PTR [ecx]

; 689  : 							_Color(_Pnode) = _Red;
; 690  : 							_Rrotate(_Pnode);

  001aa	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001ad	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  001b1	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
  001b5	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Rrotate

; 691  : 							_Pnode = _Right(_Fixnodeparent);

  001ba	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$L30806:

; 692  : 							}
; 693  : 
; 694  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  001bd	8a 46 14	 mov	 al, BYTE PTR [esi+20]

; 695  : 						_Color(_Fixnodeparent) = _Black;
; 696  : 						_Color(_Right(_Pnode)) = _Black;
; 697  : 						_Lrotate(_Fixnodeparent);

  001c0	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001c3	88 41 14	 mov	 BYTE PTR [ecx+20], al
  001c6	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1
  001ca	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001cd	8b ce		 mov	 ecx, esi
  001cf	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  001d3	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Lrotate

; 698  : 						break;	// tree now recolored/rebalanced

  001d8	e9 82 00 00 00	 jmp	 $L30799
$L30800:

; 699  : 						}
; 700  : 					}
; 701  : 				else
; 702  : 					{	// fixup right subtree
; 703  : 					_Pnode = _Left(_Fixnodeparent);
; 704  : 					if (_Color(_Pnode) == _Red)

  001dd	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  001e1	75 14		 jne	 SHORT $L30808

; 705  : 						{	// rotate red up from left subtree
; 706  : 						_Color(_Pnode) = _Black;
; 707  : 						_Color(_Fixnodeparent) = _Red;
; 708  : 						_Rrotate(_Fixnodeparent);

  001e3	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001e6	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1
  001ea	8b ce		 mov	 ecx, esi
  001ec	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  001f0	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Rrotate

; 709  : 						_Pnode = _Left(_Fixnodeparent);

  001f5	8b 0e		 mov	 ecx, DWORD PTR [esi]
$L30808:

; 710  : 						}
; 711  : 					if (_Isnil(_Pnode))

  001f7	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0

; 712  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 713  : 					else if (_Color(_Right(_Pnode)) == _Black

  001fb	75 15		 jne	 SHORT $L71565

; 714  : 						&& _Color(_Left(_Pnode)) == _Black)

  001fd	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00200	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  00204	75 22		 jne	 SHORT $L30811
  00206	8b 01		 mov	 eax, DWORD PTR [ecx]
  00208	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0020c	75 1a		 jne	 SHORT $L30811
$L71566:

; 715  : 						{	// redden left subtree with black children
; 716  : 						_Color(_Pnode) = _Red;

  0020e	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
$L71565:

; 717  : 						_Fixnode = _Fixnodeparent;

  00212	8b fe		 mov	 edi, esi
  00214	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
$L71564:
  00217	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0021a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0021d	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  00220	0f 85 30 ff ff
	ff		 jne	 $L30797

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00226	eb 37		 jmp	 SHORT $L30799
$L30811:

; 718  : 						}
; 719  : 					else
; 720  : 						{	// must rearrange left subtree
; 721  : 						if (_Color(_Left(_Pnode)) == _Black)

  00228	8b 01		 mov	 eax, DWORD PTR [ecx]
  0022a	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0022e	75 15		 jne	 SHORT $L30813

; 722  : 							{	// rotate red up from right sub-subtree
; 723  : 							_Color(_Right(_Pnode)) = _Black;

  00230	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 724  : 							_Color(_Pnode) = _Red;
; 725  : 							_Lrotate(_Pnode);

  00233	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00236	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  0023a	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
  0023e	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Lrotate

; 726  : 							_Pnode = _Left(_Fixnodeparent);

  00243	8b 0e		 mov	 ecx, DWORD PTR [esi]
$L30813:

; 727  : 							}
; 728  : 
; 729  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  00245	8a 46 14	 mov	 al, BYTE PTR [esi+20]

; 730  : 						_Color(_Fixnodeparent) = _Black;
; 731  : 						_Color(_Left(_Pnode)) = _Black;
; 732  : 						_Rrotate(_Fixnodeparent);

  00248	ff 75 08	 push	 DWORD PTR _this$[ebp]
  0024b	88 41 14	 mov	 BYTE PTR [ecx+20], al
  0024e	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1
  00252	8b 01		 mov	 eax, DWORD PTR [ecx]
  00254	8b ce		 mov	 ecx, esi
  00256	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  0025a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Rrotate
$L30799:

; 733  : 						break;	// tree now recolored/rebalanced
; 734  : 						}
; 735  : 					}
; 736  : 
; 737  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

  0025f	c6 47 14 01	 mov	 BYTE PTR [edi+20], 1
$L30796:

; 738  : 			}
; 739  : 
; 740  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 741  : 		this->_Alnod.deallocate(_Erasednode, 1);

  00263	53		 push	 ebx
  00264	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00269	59		 pop	 ecx

; 742  : 
; 743  : 		if (0 < _Mysize)

  0026a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0026d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00270	85 c0		 test	 eax, eax
  00272	5f		 pop	 edi
  00273	5e		 pop	 esi
  00274	5b		 pop	 ebx
  00275	76 04		 jbe	 SHORT $L30814

; 744  : 			--_Mysize;

  00277	48		 dec	 eax
  00278	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L30814:

; 745  : 
; 746  : 		return (_Where);	// return successor iterator

  0027b	8b 4d 10	 mov	 ecx, DWORD PTR __Where$[ebp]
  0027e	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00281	89 08		 mov	 DWORD PTR [eax], ecx

; 747  : 		}

  00283	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00286	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0028d	c9		 leave
  0028e	c2 0c 00	 ret	 12			; 0000000cH
$L71560:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L71126:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T71121[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T71551
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::erase
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T72020	DD	0ffffffffH
	DD	FLAT:$L71579
$T72004	DD	019930520H
	DD	01H
	DD	FLAT:$T72020
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
$T71573 = -80						; size = 40
$T71574 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Where$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::erase, COMDAT

; 590  : 		{	// erase element at _Where

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 44	 sub	 esp, 68			; 00000044H
  0000d	53		 push	 ebx

; 591  : 		if (_Isnil(_Where._Mynode()))

  0000e	8b 5d 10	 mov	 ebx, DWORD PTR __Where$[ebp]
  00011	80 7b 15 00	 cmp	 BYTE PTR [ebx+21], 0
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	74 32		 je	 SHORT $L71591

; 592  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  0001e	8d 4d d8	 lea	 ecx, DWORD PTR $T71574[ebp]
  00021	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00026	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002a	8d 45 d8	 lea	 eax, DWORD PTR $T71574[ebp]
  0002d	50		 push	 eax
  0002e	8d 4d b0	 lea	 ecx, DWORD PTR $T71573[ebp]
  00031	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00036	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVout_of_range@std@@
  0003b	8d 45 b0	 lea	 eax, DWORD PTR $T71573[ebp]
  0003e	50		 push	 eax
  0003f	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T71573[ebp], OFFSET FLAT:??_7out_of_range@std@@6B@
  00046	e8 00 00 00 00	 call	 __CxxThrowException@8
$L72021:
$L71591:

; 593  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 594  : 		++_Where;	// save successor iterator for return

  0004b	8d 55 10	 lea	 edx, DWORD PTR __Where$[ebp]
  0004e	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::_Inc

; 595  : 
; 596  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 597  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 598  : 		_Nodeptr _Pnode = _Erasednode;
; 599  : 
; 600  : 		if (_Isnil(_Left(_Pnode)))

  00053	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00055	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00059	74 05		 je	 SHORT $L30666

; 601  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

  0005b	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 602  : 		else if (_Isnil(_Right(_Pnode)))

  0005e	eb 17		 jmp	 SHORT $L72011
$L30666:
  00060	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00063	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00067	74 04		 je	 SHORT $L30668

; 603  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

  00069	8b f9		 mov	 edi, ecx

; 604  : 		else

  0006b	eb 0a		 jmp	 SHORT $L72011
$L30668:

; 605  : 			{	// two subtrees, must lift successor node to replace erased
; 606  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 607  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

  0006d	8b 45 10	 mov	 eax, DWORD PTR __Where$[ebp]

; 608  : 			}
; 609  : 
; 610  : 		if (_Pnode == _Erasednode)

  00070	3b c3		 cmp	 eax, ebx
  00072	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  00075	75 76		 jne	 SHORT $L30670
$L72011:

; 611  : 			{	// at most one subtree, relink it
; 612  : 			_Fixnodeparent = _Parent(_Erasednode);
; 613  : 			if (!_Isnil(_Fixnode))

  00077	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  0007b	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  0007e	75 03		 jne	 SHORT $L30671

; 614  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00080	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L30671:

; 615  : 
; 616  : 			if (_Root() == _Erasednode)

  00083	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00089	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  0008c	75 05		 jne	 SHORT $L30672

; 617  : 				_Root() = _Fixnode;	// link down from root

  0008e	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 618  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

  00091	eb 0b		 jmp	 SHORT $L30675
$L30672:
  00093	39 1e		 cmp	 DWORD PTR [esi], ebx
  00095	75 04		 jne	 SHORT $L30674

; 619  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  00097	89 3e		 mov	 DWORD PTR [esi], edi

; 620  : 			else

  00099	eb 03		 jmp	 SHORT $L30675
$L30674:

; 621  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

  0009b	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$L30675:

; 622  : 
; 623  : 			if (_Lmost() == _Erasednode)

  0009e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a1	39 1a		 cmp	 DWORD PTR [edx], ebx
  000a3	75 1c		 jne	 SHORT $L30676

; 624  : 				_Lmost() = _Isnil(_Fixnode)
; 625  : 					? _Fixnodeparent	// smallest is parent of erased node
; 626  : 					: _Min(_Fixnode);	// smallest in relinked subtree

  000a5	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  000a9	74 04		 je	 SHORT $L71575
  000ab	8b ce		 mov	 ecx, esi
  000ad	eb 10		 jmp	 SHORT $L71576
$L71575:
  000af	8b 07		 mov	 eax, DWORD PTR [edi]
  000b1	8b cf		 mov	 ecx, edi
  000b3	eb 04		 jmp	 SHORT $L72014
$L71688:
  000b5	8b c8		 mov	 ecx, eax
  000b7	8b 01		 mov	 eax, DWORD PTR [ecx]
$L72014:
  000b9	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  000bd	74 f6		 je	 SHORT $L71688
$L71576:
  000bf	89 0a		 mov	 DWORD PTR [edx], ecx
$L30676:

; 627  : 
; 628  : 			if (_Rmost() == _Erasednode)

  000c1	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c7	39 5a 08	 cmp	 DWORD PTR [edx+8], ebx
  000ca	75 7b		 jne	 SHORT $L71833

; 629  : 				_Rmost() = _Isnil(_Fixnode)
; 630  : 					? _Fixnodeparent	// largest is parent of erased node
; 631  : 					: _Max(_Fixnode);	// largest in relinked subtree

  000cc	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  000d0	74 04		 je	 SHORT $L71577
  000d2	8b ce		 mov	 ecx, esi
  000d4	eb 12		 jmp	 SHORT $L71578
$L71577:
  000d6	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000d9	8b cf		 mov	 ecx, edi
  000db	eb 05		 jmp	 SHORT $L72015
$L71733:
  000dd	8b c8		 mov	 ecx, eax
  000df	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
$L72015:
  000e2	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  000e6	74 f5		 je	 SHORT $L71733
$L71578:
  000e8	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 632  : 			}
; 633  : 		else

  000eb	eb 5a		 jmp	 SHORT $L71833
$L30670:

; 634  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 635  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

  000ed	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 636  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

  000f0	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000f2	89 08		 mov	 DWORD PTR [eax], ecx

; 637  : 
; 638  : 			if (_Pnode == _Right(_Erasednode))

  000f4	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  000f7	75 04		 jne	 SHORT $L30679

; 639  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000f9	8b f0		 mov	 esi, eax

; 640  : 			else

  000fb	eb 1a		 jmp	 SHORT $L30680
$L30679:

; 641  : 				{	// successor further down, link in place of erased
; 642  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 643  : 				if (!_Isnil(_Fixnode))

  000fd	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  00101	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00104	75 03		 jne	 SHORT $L30681

; 644  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  00106	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L30681:

; 645  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  00109	89 3e		 mov	 DWORD PTR [esi], edi

; 646  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

  0010b	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0010e	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 647  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

  00111	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00114	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L30680:

; 648  : 				}
; 649  : 
; 650  : 			if (_Root() == _Erasednode)

  00117	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0011a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0011d	39 59 04	 cmp	 DWORD PTR [ecx+4], ebx
  00120	75 05		 jne	 SHORT $L30682

; 651  : 				_Root() = _Pnode;	// link down from root

  00122	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 652  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

  00125	eb 0e		 jmp	 SHORT $L30685
$L30682:
  00127	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0012a	39 19		 cmp	 DWORD PTR [ecx], ebx
  0012c	75 04		 jne	 SHORT $L30684

; 653  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

  0012e	89 01		 mov	 DWORD PTR [ecx], eax

; 654  : 			else

  00130	eb 03		 jmp	 SHORT $L30685
$L30684:

; 655  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

  00132	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L30685:

; 656  : 
; 657  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

  00135	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00138	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 658  : 			std::swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

  0013b	8a 53 14	 mov	 dl, BYTE PTR [ebx+20]
  0013e	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00141	88 50 14	 mov	 BYTE PTR [eax+20], dl
  00144	88 4b 14	 mov	 BYTE PTR [ebx+20], cl
$L71833:

; 659  : 			}
; 660  : 
; 661  : 		if (_Color(_Erasednode) == _Black)

  00147	80 7b 14 01	 cmp	 BYTE PTR [ebx+20], 1
  0014b	0f 85 12 01 00
	00		 jne	 $L30686

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00151	e9 c1 00 00 00	 jmp	 $L72017
$L30687:
  00156	80 7f 14 01	 cmp	 BYTE PTR [edi+20], 1
  0015a	0f 85 ff 00 00
	00		 jne	 $L30689

; 665  : 				if (_Fixnode == _Left(_Fixnodeparent))

  00160	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00162	3b f9		 cmp	 edi, ecx
  00164	75 77		 jne	 SHORT $L30690

; 666  : 					{	// fixup left subtree
; 667  : 					_Pnode = _Right(_Fixnodeparent);

  00166	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 668  : 					if (_Color(_Pnode) == _Red)

  00169	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  0016d	75 15		 jne	 SHORT $L30691

; 669  : 						{	// rotate red up from right subtree
; 670  : 						_Color(_Pnode) = _Black;
; 671  : 						_Color(_Fixnodeparent) = _Red;
; 672  : 						_Lrotate(_Fixnodeparent);

  0016f	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00172	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1
  00176	8b ce		 mov	 ecx, esi
  00178	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  0017c	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Lrotate

; 673  : 						_Pnode = _Right(_Fixnodeparent);

  00181	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$L30691:

; 674  : 						}
; 675  : 
; 676  : 					if (_Isnil(_Pnode))

  00184	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0

; 677  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 678  : 					else if (_Color(_Left(_Pnode)) == _Black

  00188	0f 85 84 00 00
	00		 jne	 $L72018

; 679  : 						&& _Color(_Right(_Pnode)) == _Black)

  0018e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00190	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  00194	75 09		 jne	 SHORT $L30694
  00196	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00199	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0019d	74 6f		 je	 SHORT $L72019
$L30694:

; 680  : 						{	// redden right subtree with black children
; 681  : 						_Color(_Pnode) = _Red;
; 682  : 						_Fixnode = _Fixnodeparent;
; 683  : 						}
; 684  : 					else
; 685  : 						{	// must rearrange right subtree
; 686  : 						if (_Color(_Right(_Pnode)) == _Black)

  0019f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001a2	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  001a6	75 15		 jne	 SHORT $L30696

; 687  : 							{	// rotate red up from left sub-subtree
; 688  : 							_Color(_Left(_Pnode)) = _Black;

  001a8	8b 01		 mov	 eax, DWORD PTR [ecx]

; 689  : 							_Color(_Pnode) = _Red;
; 690  : 							_Rrotate(_Pnode);

  001aa	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001ad	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  001b1	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
  001b5	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Rrotate

; 691  : 							_Pnode = _Right(_Fixnodeparent);

  001ba	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$L30696:

; 692  : 							}
; 693  : 
; 694  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  001bd	8a 46 14	 mov	 al, BYTE PTR [esi+20]

; 695  : 						_Color(_Fixnodeparent) = _Black;
; 696  : 						_Color(_Right(_Pnode)) = _Black;
; 697  : 						_Lrotate(_Fixnodeparent);

  001c0	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001c3	88 41 14	 mov	 BYTE PTR [ecx+20], al
  001c6	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1
  001ca	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001cd	8b ce		 mov	 ecx, esi
  001cf	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  001d3	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Lrotate

; 698  : 						break;	// tree now recolored/rebalanced

  001d8	e9 82 00 00 00	 jmp	 $L30689
$L30690:

; 699  : 						}
; 700  : 					}
; 701  : 				else
; 702  : 					{	// fixup right subtree
; 703  : 					_Pnode = _Left(_Fixnodeparent);
; 704  : 					if (_Color(_Pnode) == _Red)

  001dd	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  001e1	75 14		 jne	 SHORT $L30698

; 705  : 						{	// rotate red up from left subtree
; 706  : 						_Color(_Pnode) = _Black;
; 707  : 						_Color(_Fixnodeparent) = _Red;
; 708  : 						_Rrotate(_Fixnodeparent);

  001e3	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001e6	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1
  001ea	8b ce		 mov	 ecx, esi
  001ec	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  001f0	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Rrotate

; 709  : 						_Pnode = _Left(_Fixnodeparent);

  001f5	8b 0e		 mov	 ecx, DWORD PTR [esi]
$L30698:

; 710  : 						}
; 711  : 					if (_Isnil(_Pnode))

  001f7	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0

; 712  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 713  : 					else if (_Color(_Right(_Pnode)) == _Black

  001fb	75 15		 jne	 SHORT $L72018

; 714  : 						&& _Color(_Left(_Pnode)) == _Black)

  001fd	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00200	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  00204	75 22		 jne	 SHORT $L30701
  00206	8b 01		 mov	 eax, DWORD PTR [ecx]
  00208	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0020c	75 1a		 jne	 SHORT $L30701
$L72019:

; 715  : 						{	// redden left subtree with black children
; 716  : 						_Color(_Pnode) = _Red;

  0020e	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
$L72018:

; 717  : 						_Fixnode = _Fixnodeparent;

  00212	8b fe		 mov	 edi, esi
  00214	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
$L72017:
  00217	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0021a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0021d	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  00220	0f 85 30 ff ff
	ff		 jne	 $L30687

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00226	eb 37		 jmp	 SHORT $L30689
$L30701:

; 718  : 						}
; 719  : 					else
; 720  : 						{	// must rearrange left subtree
; 721  : 						if (_Color(_Left(_Pnode)) == _Black)

  00228	8b 01		 mov	 eax, DWORD PTR [ecx]
  0022a	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0022e	75 15		 jne	 SHORT $L30703

; 722  : 							{	// rotate red up from right sub-subtree
; 723  : 							_Color(_Right(_Pnode)) = _Black;

  00230	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 724  : 							_Color(_Pnode) = _Red;
; 725  : 							_Lrotate(_Pnode);

  00233	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00236	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  0023a	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
  0023e	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Lrotate

; 726  : 							_Pnode = _Left(_Fixnodeparent);

  00243	8b 0e		 mov	 ecx, DWORD PTR [esi]
$L30703:

; 727  : 							}
; 728  : 
; 729  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  00245	8a 46 14	 mov	 al, BYTE PTR [esi+20]

; 730  : 						_Color(_Fixnodeparent) = _Black;
; 731  : 						_Color(_Left(_Pnode)) = _Black;
; 732  : 						_Rrotate(_Fixnodeparent);

  00248	ff 75 08	 push	 DWORD PTR _this$[ebp]
  0024b	88 41 14	 mov	 BYTE PTR [ecx+20], al
  0024e	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1
  00252	8b 01		 mov	 eax, DWORD PTR [ecx]
  00254	8b ce		 mov	 ecx, esi
  00256	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  0025a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Rrotate
$L30689:

; 733  : 						break;	// tree now recolored/rebalanced
; 734  : 						}
; 735  : 					}
; 736  : 
; 737  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

  0025f	c6 47 14 01	 mov	 BYTE PTR [edi+20], 1
$L30686:

; 738  : 			}
; 739  : 
; 740  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 741  : 		this->_Alnod.deallocate(_Erasednode, 1);

  00263	53		 push	 ebx
  00264	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00269	59		 pop	 ecx

; 742  : 
; 743  : 		if (0 < _Mysize)

  0026a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0026d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00270	85 c0		 test	 eax, eax
  00272	5f		 pop	 edi
  00273	5e		 pop	 esi
  00274	5b		 pop	 ebx
  00275	76 04		 jbe	 SHORT $L30704

; 744  : 			--_Mysize;

  00277	48		 dec	 eax
  00278	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L30704:

; 745  : 
; 746  : 		return (_Where);	// return successor iterator

  0027b	8b 4d 10	 mov	 ecx, DWORD PTR __Where$[ebp]
  0027e	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00281	89 08		 mov	 DWORD PTR [eax], ecx

; 747  : 		}

  00283	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00286	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0028d	c9		 leave
  0028e	c2 0c 00	 ret	 12			; 0000000cH
$L72013:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L71579:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T71574[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T72004
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::erase
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T72473	DD	0ffffffffH
	DD	FLAT:$L72032
$T72457	DD	019930520H
	DD	01H
	DD	FLAT:$T72473
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
$T72026 = -80						; size = 40
$T72027 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Where$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::erase, COMDAT

; 590  : 		{	// erase element at _Where

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 44	 sub	 esp, 68			; 00000044H
  0000d	53		 push	 ebx

; 591  : 		if (_Isnil(_Where._Mynode()))

  0000e	8b 5d 10	 mov	 ebx, DWORD PTR __Where$[ebp]
  00011	80 7b 15 00	 cmp	 BYTE PTR [ebx+21], 0
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	74 32		 je	 SHORT $L72044

; 592  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  0001e	8d 4d d8	 lea	 ecx, DWORD PTR $T72027[ebp]
  00021	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00026	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002a	8d 45 d8	 lea	 eax, DWORD PTR $T72027[ebp]
  0002d	50		 push	 eax
  0002e	8d 4d b0	 lea	 ecx, DWORD PTR $T72026[ebp]
  00031	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00036	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVout_of_range@std@@
  0003b	8d 45 b0	 lea	 eax, DWORD PTR $T72026[ebp]
  0003e	50		 push	 eax
  0003f	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T72026[ebp], OFFSET FLAT:??_7out_of_range@std@@6B@
  00046	e8 00 00 00 00	 call	 __CxxThrowException@8
$L72474:
$L72044:

; 593  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 594  : 		++_Where;	// save successor iterator for return

  0004b	8d 55 10	 lea	 edx, DWORD PTR __Where$[ebp]
  0004e	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::_Inc

; 595  : 
; 596  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 597  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 598  : 		_Nodeptr _Pnode = _Erasednode;
; 599  : 
; 600  : 		if (_Isnil(_Left(_Pnode)))

  00053	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00055	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00059	74 05		 je	 SHORT $L30556

; 601  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

  0005b	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 602  : 		else if (_Isnil(_Right(_Pnode)))

  0005e	eb 17		 jmp	 SHORT $L72464
$L30556:
  00060	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00063	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00067	74 04		 je	 SHORT $L30558

; 603  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

  00069	8b f9		 mov	 edi, ecx

; 604  : 		else

  0006b	eb 0a		 jmp	 SHORT $L72464
$L30558:

; 605  : 			{	// two subtrees, must lift successor node to replace erased
; 606  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 607  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

  0006d	8b 45 10	 mov	 eax, DWORD PTR __Where$[ebp]

; 608  : 			}
; 609  : 
; 610  : 		if (_Pnode == _Erasednode)

  00070	3b c3		 cmp	 eax, ebx
  00072	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  00075	75 76		 jne	 SHORT $L30560
$L72464:

; 611  : 			{	// at most one subtree, relink it
; 612  : 			_Fixnodeparent = _Parent(_Erasednode);
; 613  : 			if (!_Isnil(_Fixnode))

  00077	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  0007b	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  0007e	75 03		 jne	 SHORT $L30561

; 614  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00080	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L30561:

; 615  : 
; 616  : 			if (_Root() == _Erasednode)

  00083	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00089	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  0008c	75 05		 jne	 SHORT $L30562

; 617  : 				_Root() = _Fixnode;	// link down from root

  0008e	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 618  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

  00091	eb 0b		 jmp	 SHORT $L30565
$L30562:
  00093	39 1e		 cmp	 DWORD PTR [esi], ebx
  00095	75 04		 jne	 SHORT $L30564

; 619  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  00097	89 3e		 mov	 DWORD PTR [esi], edi

; 620  : 			else

  00099	eb 03		 jmp	 SHORT $L30565
$L30564:

; 621  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

  0009b	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$L30565:

; 622  : 
; 623  : 			if (_Lmost() == _Erasednode)

  0009e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a1	39 1a		 cmp	 DWORD PTR [edx], ebx
  000a3	75 1c		 jne	 SHORT $L30566

; 624  : 				_Lmost() = _Isnil(_Fixnode)
; 625  : 					? _Fixnodeparent	// smallest is parent of erased node
; 626  : 					: _Min(_Fixnode);	// smallest in relinked subtree

  000a5	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  000a9	74 04		 je	 SHORT $L72028
  000ab	8b ce		 mov	 ecx, esi
  000ad	eb 10		 jmp	 SHORT $L72029
$L72028:
  000af	8b 07		 mov	 eax, DWORD PTR [edi]
  000b1	8b cf		 mov	 ecx, edi
  000b3	eb 04		 jmp	 SHORT $L72467
$L72145:
  000b5	8b c8		 mov	 ecx, eax
  000b7	8b 01		 mov	 eax, DWORD PTR [ecx]
$L72467:
  000b9	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  000bd	74 f6		 je	 SHORT $L72145
$L72029:
  000bf	89 0a		 mov	 DWORD PTR [edx], ecx
$L30566:

; 627  : 
; 628  : 			if (_Rmost() == _Erasednode)

  000c1	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c7	39 5a 08	 cmp	 DWORD PTR [edx+8], ebx
  000ca	75 7b		 jne	 SHORT $L72285

; 629  : 				_Rmost() = _Isnil(_Fixnode)
; 630  : 					? _Fixnodeparent	// largest is parent of erased node
; 631  : 					: _Max(_Fixnode);	// largest in relinked subtree

  000cc	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  000d0	74 04		 je	 SHORT $L72030
  000d2	8b ce		 mov	 ecx, esi
  000d4	eb 12		 jmp	 SHORT $L72031
$L72030:
  000d6	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000d9	8b cf		 mov	 ecx, edi
  000db	eb 05		 jmp	 SHORT $L72468
$L72186:
  000dd	8b c8		 mov	 ecx, eax
  000df	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
$L72468:
  000e2	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  000e6	74 f5		 je	 SHORT $L72186
$L72031:
  000e8	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 632  : 			}
; 633  : 		else

  000eb	eb 5a		 jmp	 SHORT $L72285
$L30560:

; 634  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 635  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

  000ed	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 636  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

  000f0	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000f2	89 08		 mov	 DWORD PTR [eax], ecx

; 637  : 
; 638  : 			if (_Pnode == _Right(_Erasednode))

  000f4	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  000f7	75 04		 jne	 SHORT $L30569

; 639  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000f9	8b f0		 mov	 esi, eax

; 640  : 			else

  000fb	eb 1a		 jmp	 SHORT $L30570
$L30569:

; 641  : 				{	// successor further down, link in place of erased
; 642  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 643  : 				if (!_Isnil(_Fixnode))

  000fd	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  00101	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00104	75 03		 jne	 SHORT $L30571

; 644  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  00106	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L30571:

; 645  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  00109	89 3e		 mov	 DWORD PTR [esi], edi

; 646  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

  0010b	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0010e	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 647  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

  00111	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00114	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L30570:

; 648  : 				}
; 649  : 
; 650  : 			if (_Root() == _Erasednode)

  00117	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0011a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0011d	39 59 04	 cmp	 DWORD PTR [ecx+4], ebx
  00120	75 05		 jne	 SHORT $L30572

; 651  : 				_Root() = _Pnode;	// link down from root

  00122	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 652  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

  00125	eb 0e		 jmp	 SHORT $L30575
$L30572:
  00127	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0012a	39 19		 cmp	 DWORD PTR [ecx], ebx
  0012c	75 04		 jne	 SHORT $L30574

; 653  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

  0012e	89 01		 mov	 DWORD PTR [ecx], eax

; 654  : 			else

  00130	eb 03		 jmp	 SHORT $L30575
$L30574:

; 655  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

  00132	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L30575:

; 656  : 
; 657  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

  00135	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00138	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 658  : 			std::swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

  0013b	8a 53 14	 mov	 dl, BYTE PTR [ebx+20]
  0013e	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00141	88 50 14	 mov	 BYTE PTR [eax+20], dl
  00144	88 4b 14	 mov	 BYTE PTR [ebx+20], cl
$L72285:

; 659  : 			}
; 660  : 
; 661  : 		if (_Color(_Erasednode) == _Black)

  00147	80 7b 14 01	 cmp	 BYTE PTR [ebx+20], 1
  0014b	0f 85 12 01 00
	00		 jne	 $L30576

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00151	e9 c1 00 00 00	 jmp	 $L72470
$L30577:
  00156	80 7f 14 01	 cmp	 BYTE PTR [edi+20], 1
  0015a	0f 85 ff 00 00
	00		 jne	 $L30579

; 665  : 				if (_Fixnode == _Left(_Fixnodeparent))

  00160	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00162	3b f9		 cmp	 edi, ecx
  00164	75 77		 jne	 SHORT $L30580

; 666  : 					{	// fixup left subtree
; 667  : 					_Pnode = _Right(_Fixnodeparent);

  00166	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 668  : 					if (_Color(_Pnode) == _Red)

  00169	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  0016d	75 15		 jne	 SHORT $L30581

; 669  : 						{	// rotate red up from right subtree
; 670  : 						_Color(_Pnode) = _Black;
; 671  : 						_Color(_Fixnodeparent) = _Red;
; 672  : 						_Lrotate(_Fixnodeparent);

  0016f	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00172	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1
  00176	8b ce		 mov	 ecx, esi
  00178	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  0017c	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Lrotate

; 673  : 						_Pnode = _Right(_Fixnodeparent);

  00181	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$L30581:

; 674  : 						}
; 675  : 
; 676  : 					if (_Isnil(_Pnode))

  00184	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0

; 677  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 678  : 					else if (_Color(_Left(_Pnode)) == _Black

  00188	0f 85 84 00 00
	00		 jne	 $L72471

; 679  : 						&& _Color(_Right(_Pnode)) == _Black)

  0018e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00190	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  00194	75 09		 jne	 SHORT $L30584
  00196	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00199	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0019d	74 6f		 je	 SHORT $L72472
$L30584:

; 680  : 						{	// redden right subtree with black children
; 681  : 						_Color(_Pnode) = _Red;
; 682  : 						_Fixnode = _Fixnodeparent;
; 683  : 						}
; 684  : 					else
; 685  : 						{	// must rearrange right subtree
; 686  : 						if (_Color(_Right(_Pnode)) == _Black)

  0019f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001a2	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  001a6	75 15		 jne	 SHORT $L30586

; 687  : 							{	// rotate red up from left sub-subtree
; 688  : 							_Color(_Left(_Pnode)) = _Black;

  001a8	8b 01		 mov	 eax, DWORD PTR [ecx]

; 689  : 							_Color(_Pnode) = _Red;
; 690  : 							_Rrotate(_Pnode);

  001aa	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001ad	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  001b1	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
  001b5	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Rrotate

; 691  : 							_Pnode = _Right(_Fixnodeparent);

  001ba	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$L30586:

; 692  : 							}
; 693  : 
; 694  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  001bd	8a 46 14	 mov	 al, BYTE PTR [esi+20]

; 695  : 						_Color(_Fixnodeparent) = _Black;
; 696  : 						_Color(_Right(_Pnode)) = _Black;
; 697  : 						_Lrotate(_Fixnodeparent);

  001c0	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001c3	88 41 14	 mov	 BYTE PTR [ecx+20], al
  001c6	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1
  001ca	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001cd	8b ce		 mov	 ecx, esi
  001cf	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  001d3	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Lrotate

; 698  : 						break;	// tree now recolored/rebalanced

  001d8	e9 82 00 00 00	 jmp	 $L30579
$L30580:

; 699  : 						}
; 700  : 					}
; 701  : 				else
; 702  : 					{	// fixup right subtree
; 703  : 					_Pnode = _Left(_Fixnodeparent);
; 704  : 					if (_Color(_Pnode) == _Red)

  001dd	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  001e1	75 14		 jne	 SHORT $L30588

; 705  : 						{	// rotate red up from left subtree
; 706  : 						_Color(_Pnode) = _Black;
; 707  : 						_Color(_Fixnodeparent) = _Red;
; 708  : 						_Rrotate(_Fixnodeparent);

  001e3	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001e6	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1
  001ea	8b ce		 mov	 ecx, esi
  001ec	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  001f0	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Rrotate

; 709  : 						_Pnode = _Left(_Fixnodeparent);

  001f5	8b 0e		 mov	 ecx, DWORD PTR [esi]
$L30588:

; 710  : 						}
; 711  : 					if (_Isnil(_Pnode))

  001f7	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0

; 712  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 713  : 					else if (_Color(_Right(_Pnode)) == _Black

  001fb	75 15		 jne	 SHORT $L72471

; 714  : 						&& _Color(_Left(_Pnode)) == _Black)

  001fd	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00200	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  00204	75 22		 jne	 SHORT $L30591
  00206	8b 01		 mov	 eax, DWORD PTR [ecx]
  00208	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0020c	75 1a		 jne	 SHORT $L30591
$L72472:

; 715  : 						{	// redden left subtree with black children
; 716  : 						_Color(_Pnode) = _Red;

  0020e	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
$L72471:

; 717  : 						_Fixnode = _Fixnodeparent;

  00212	8b fe		 mov	 edi, esi
  00214	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
$L72470:
  00217	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0021a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0021d	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  00220	0f 85 30 ff ff
	ff		 jne	 $L30577

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00226	eb 37		 jmp	 SHORT $L30579
$L30591:

; 718  : 						}
; 719  : 					else
; 720  : 						{	// must rearrange left subtree
; 721  : 						if (_Color(_Left(_Pnode)) == _Black)

  00228	8b 01		 mov	 eax, DWORD PTR [ecx]
  0022a	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0022e	75 15		 jne	 SHORT $L30593

; 722  : 							{	// rotate red up from right sub-subtree
; 723  : 							_Color(_Right(_Pnode)) = _Black;

  00230	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 724  : 							_Color(_Pnode) = _Red;
; 725  : 							_Lrotate(_Pnode);

  00233	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00236	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  0023a	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
  0023e	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Lrotate

; 726  : 							_Pnode = _Left(_Fixnodeparent);

  00243	8b 0e		 mov	 ecx, DWORD PTR [esi]
$L30593:

; 727  : 							}
; 728  : 
; 729  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  00245	8a 46 14	 mov	 al, BYTE PTR [esi+20]

; 730  : 						_Color(_Fixnodeparent) = _Black;
; 731  : 						_Color(_Left(_Pnode)) = _Black;
; 732  : 						_Rrotate(_Fixnodeparent);

  00248	ff 75 08	 push	 DWORD PTR _this$[ebp]
  0024b	88 41 14	 mov	 BYTE PTR [ecx+20], al
  0024e	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1
  00252	8b 01		 mov	 eax, DWORD PTR [ecx]
  00254	8b ce		 mov	 ecx, esi
  00256	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  0025a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Rrotate
$L30579:

; 733  : 						break;	// tree now recolored/rebalanced
; 734  : 						}
; 735  : 					}
; 736  : 
; 737  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

  0025f	c6 47 14 01	 mov	 BYTE PTR [edi+20], 1
$L30576:

; 738  : 			}
; 739  : 
; 740  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 741  : 		this->_Alnod.deallocate(_Erasednode, 1);

  00263	53		 push	 ebx
  00264	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00269	59		 pop	 ecx

; 742  : 
; 743  : 		if (0 < _Mysize)

  0026a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0026d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00270	85 c0		 test	 eax, eax
  00272	5f		 pop	 edi
  00273	5e		 pop	 esi
  00274	5b		 pop	 ebx
  00275	76 04		 jbe	 SHORT $L30594

; 744  : 			--_Mysize;

  00277	48		 dec	 eax
  00278	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L30594:

; 745  : 
; 746  : 		return (_Where);	// return successor iterator

  0027b	8b 4d 10	 mov	 ecx, DWORD PTR __Where$[ebp]
  0027e	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00281	89 08		 mov	 DWORD PTR [eax], ecx

; 747  : 		}

  00283	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00286	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0028d	c9		 leave
  0028e	c2 0c 00	 ret	 12			; 0000000cH
$L72466:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L72032:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T72027[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T72457
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::erase
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T72926	DD	0ffffffffH
	DD	FLAT:$L72485
$T72910	DD	019930520H
	DD	01H
	DD	FLAT:$T72926
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
$T72479 = -80						; size = 40
$T72480 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Where$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::erase, COMDAT

; 590  : 		{	// erase element at _Where

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 44	 sub	 esp, 68			; 00000044H
  0000d	53		 push	 ebx

; 591  : 		if (_Isnil(_Where._Mynode()))

  0000e	8b 5d 10	 mov	 ebx, DWORD PTR __Where$[ebp]
  00011	80 7b 15 00	 cmp	 BYTE PTR [ebx+21], 0
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	74 32		 je	 SHORT $L72497

; 592  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  0001e	8d 4d d8	 lea	 ecx, DWORD PTR $T72480[ebp]
  00021	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00026	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002a	8d 45 d8	 lea	 eax, DWORD PTR $T72480[ebp]
  0002d	50		 push	 eax
  0002e	8d 4d b0	 lea	 ecx, DWORD PTR $T72479[ebp]
  00031	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00036	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVout_of_range@std@@
  0003b	8d 45 b0	 lea	 eax, DWORD PTR $T72479[ebp]
  0003e	50		 push	 eax
  0003f	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T72479[ebp], OFFSET FLAT:??_7out_of_range@std@@6B@
  00046	e8 00 00 00 00	 call	 __CxxThrowException@8
$L72927:
$L72497:

; 593  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 594  : 		++_Where;	// save successor iterator for return

  0004b	8d 55 10	 lea	 edx, DWORD PTR __Where$[ebp]
  0004e	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::_Inc

; 595  : 
; 596  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 597  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 598  : 		_Nodeptr _Pnode = _Erasednode;
; 599  : 
; 600  : 		if (_Isnil(_Left(_Pnode)))

  00053	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00055	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00059	74 05		 je	 SHORT $L30446

; 601  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

  0005b	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 602  : 		else if (_Isnil(_Right(_Pnode)))

  0005e	eb 17		 jmp	 SHORT $L72917
$L30446:
  00060	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00063	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00067	74 04		 je	 SHORT $L30448

; 603  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

  00069	8b f9		 mov	 edi, ecx

; 604  : 		else

  0006b	eb 0a		 jmp	 SHORT $L72917
$L30448:

; 605  : 			{	// two subtrees, must lift successor node to replace erased
; 606  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 607  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

  0006d	8b 45 10	 mov	 eax, DWORD PTR __Where$[ebp]

; 608  : 			}
; 609  : 
; 610  : 		if (_Pnode == _Erasednode)

  00070	3b c3		 cmp	 eax, ebx
  00072	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  00075	75 76		 jne	 SHORT $L30450
$L72917:

; 611  : 			{	// at most one subtree, relink it
; 612  : 			_Fixnodeparent = _Parent(_Erasednode);
; 613  : 			if (!_Isnil(_Fixnode))

  00077	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  0007b	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  0007e	75 03		 jne	 SHORT $L30451

; 614  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00080	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L30451:

; 615  : 
; 616  : 			if (_Root() == _Erasednode)

  00083	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00089	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  0008c	75 05		 jne	 SHORT $L30452

; 617  : 				_Root() = _Fixnode;	// link down from root

  0008e	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 618  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

  00091	eb 0b		 jmp	 SHORT $L30455
$L30452:
  00093	39 1e		 cmp	 DWORD PTR [esi], ebx
  00095	75 04		 jne	 SHORT $L30454

; 619  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  00097	89 3e		 mov	 DWORD PTR [esi], edi

; 620  : 			else

  00099	eb 03		 jmp	 SHORT $L30455
$L30454:

; 621  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

  0009b	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$L30455:

; 622  : 
; 623  : 			if (_Lmost() == _Erasednode)

  0009e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a1	39 1a		 cmp	 DWORD PTR [edx], ebx
  000a3	75 1c		 jne	 SHORT $L30456

; 624  : 				_Lmost() = _Isnil(_Fixnode)
; 625  : 					? _Fixnodeparent	// smallest is parent of erased node
; 626  : 					: _Min(_Fixnode);	// smallest in relinked subtree

  000a5	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  000a9	74 04		 je	 SHORT $L72481
  000ab	8b ce		 mov	 ecx, esi
  000ad	eb 10		 jmp	 SHORT $L72482
$L72481:
  000af	8b 07		 mov	 eax, DWORD PTR [edi]
  000b1	8b cf		 mov	 ecx, edi
  000b3	eb 04		 jmp	 SHORT $L72920
$L72591:
  000b5	8b c8		 mov	 ecx, eax
  000b7	8b 01		 mov	 eax, DWORD PTR [ecx]
$L72920:
  000b9	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  000bd	74 f6		 je	 SHORT $L72591
$L72482:
  000bf	89 0a		 mov	 DWORD PTR [edx], ecx
$L30456:

; 627  : 
; 628  : 			if (_Rmost() == _Erasednode)

  000c1	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c7	39 5a 08	 cmp	 DWORD PTR [edx+8], ebx
  000ca	75 7b		 jne	 SHORT $L72739

; 629  : 				_Rmost() = _Isnil(_Fixnode)
; 630  : 					? _Fixnodeparent	// largest is parent of erased node
; 631  : 					: _Max(_Fixnode);	// largest in relinked subtree

  000cc	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  000d0	74 04		 je	 SHORT $L72483
  000d2	8b ce		 mov	 ecx, esi
  000d4	eb 12		 jmp	 SHORT $L72484
$L72483:
  000d6	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000d9	8b cf		 mov	 ecx, edi
  000db	eb 05		 jmp	 SHORT $L72921
$L72632:
  000dd	8b c8		 mov	 ecx, eax
  000df	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
$L72921:
  000e2	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  000e6	74 f5		 je	 SHORT $L72632
$L72484:
  000e8	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 632  : 			}
; 633  : 		else

  000eb	eb 5a		 jmp	 SHORT $L72739
$L30450:

; 634  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 635  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

  000ed	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 636  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

  000f0	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000f2	89 08		 mov	 DWORD PTR [eax], ecx

; 637  : 
; 638  : 			if (_Pnode == _Right(_Erasednode))

  000f4	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  000f7	75 04		 jne	 SHORT $L30459

; 639  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000f9	8b f0		 mov	 esi, eax

; 640  : 			else

  000fb	eb 1a		 jmp	 SHORT $L30460
$L30459:

; 641  : 				{	// successor further down, link in place of erased
; 642  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 643  : 				if (!_Isnil(_Fixnode))

  000fd	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  00101	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00104	75 03		 jne	 SHORT $L30461

; 644  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  00106	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L30461:

; 645  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  00109	89 3e		 mov	 DWORD PTR [esi], edi

; 646  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

  0010b	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0010e	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 647  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

  00111	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00114	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L30460:

; 648  : 				}
; 649  : 
; 650  : 			if (_Root() == _Erasednode)

  00117	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0011a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0011d	39 59 04	 cmp	 DWORD PTR [ecx+4], ebx
  00120	75 05		 jne	 SHORT $L30462

; 651  : 				_Root() = _Pnode;	// link down from root

  00122	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 652  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

  00125	eb 0e		 jmp	 SHORT $L30465
$L30462:
  00127	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0012a	39 19		 cmp	 DWORD PTR [ecx], ebx
  0012c	75 04		 jne	 SHORT $L30464

; 653  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

  0012e	89 01		 mov	 DWORD PTR [ecx], eax

; 654  : 			else

  00130	eb 03		 jmp	 SHORT $L30465
$L30464:

; 655  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

  00132	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L30465:

; 656  : 
; 657  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

  00135	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00138	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 658  : 			std::swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

  0013b	8a 53 14	 mov	 dl, BYTE PTR [ebx+20]
  0013e	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00141	88 50 14	 mov	 BYTE PTR [eax+20], dl
  00144	88 4b 14	 mov	 BYTE PTR [ebx+20], cl
$L72739:

; 659  : 			}
; 660  : 
; 661  : 		if (_Color(_Erasednode) == _Black)

  00147	80 7b 14 01	 cmp	 BYTE PTR [ebx+20], 1
  0014b	0f 85 12 01 00
	00		 jne	 $L30466

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00151	e9 c1 00 00 00	 jmp	 $L72923
$L30467:
  00156	80 7f 14 01	 cmp	 BYTE PTR [edi+20], 1
  0015a	0f 85 ff 00 00
	00		 jne	 $L30469

; 665  : 				if (_Fixnode == _Left(_Fixnodeparent))

  00160	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00162	3b f9		 cmp	 edi, ecx
  00164	75 77		 jne	 SHORT $L30470

; 666  : 					{	// fixup left subtree
; 667  : 					_Pnode = _Right(_Fixnodeparent);

  00166	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 668  : 					if (_Color(_Pnode) == _Red)

  00169	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  0016d	75 15		 jne	 SHORT $L30471

; 669  : 						{	// rotate red up from right subtree
; 670  : 						_Color(_Pnode) = _Black;
; 671  : 						_Color(_Fixnodeparent) = _Red;
; 672  : 						_Lrotate(_Fixnodeparent);

  0016f	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00172	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1
  00176	8b ce		 mov	 ecx, esi
  00178	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  0017c	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Lrotate

; 673  : 						_Pnode = _Right(_Fixnodeparent);

  00181	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$L30471:

; 674  : 						}
; 675  : 
; 676  : 					if (_Isnil(_Pnode))

  00184	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0

; 677  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 678  : 					else if (_Color(_Left(_Pnode)) == _Black

  00188	0f 85 84 00 00
	00		 jne	 $L72924

; 679  : 						&& _Color(_Right(_Pnode)) == _Black)

  0018e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00190	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  00194	75 09		 jne	 SHORT $L30474
  00196	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00199	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0019d	74 6f		 je	 SHORT $L72925
$L30474:

; 680  : 						{	// redden right subtree with black children
; 681  : 						_Color(_Pnode) = _Red;
; 682  : 						_Fixnode = _Fixnodeparent;
; 683  : 						}
; 684  : 					else
; 685  : 						{	// must rearrange right subtree
; 686  : 						if (_Color(_Right(_Pnode)) == _Black)

  0019f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001a2	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  001a6	75 15		 jne	 SHORT $L30476

; 687  : 							{	// rotate red up from left sub-subtree
; 688  : 							_Color(_Left(_Pnode)) = _Black;

  001a8	8b 01		 mov	 eax, DWORD PTR [ecx]

; 689  : 							_Color(_Pnode) = _Red;
; 690  : 							_Rrotate(_Pnode);

  001aa	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001ad	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  001b1	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
  001b5	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Rrotate

; 691  : 							_Pnode = _Right(_Fixnodeparent);

  001ba	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$L30476:

; 692  : 							}
; 693  : 
; 694  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  001bd	8a 46 14	 mov	 al, BYTE PTR [esi+20]

; 695  : 						_Color(_Fixnodeparent) = _Black;
; 696  : 						_Color(_Right(_Pnode)) = _Black;
; 697  : 						_Lrotate(_Fixnodeparent);

  001c0	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001c3	88 41 14	 mov	 BYTE PTR [ecx+20], al
  001c6	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1
  001ca	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001cd	8b ce		 mov	 ecx, esi
  001cf	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  001d3	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Lrotate

; 698  : 						break;	// tree now recolored/rebalanced

  001d8	e9 82 00 00 00	 jmp	 $L30469
$L30470:

; 699  : 						}
; 700  : 					}
; 701  : 				else
; 702  : 					{	// fixup right subtree
; 703  : 					_Pnode = _Left(_Fixnodeparent);
; 704  : 					if (_Color(_Pnode) == _Red)

  001dd	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  001e1	75 14		 jne	 SHORT $L30478

; 705  : 						{	// rotate red up from left subtree
; 706  : 						_Color(_Pnode) = _Black;
; 707  : 						_Color(_Fixnodeparent) = _Red;
; 708  : 						_Rrotate(_Fixnodeparent);

  001e3	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001e6	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1
  001ea	8b ce		 mov	 ecx, esi
  001ec	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  001f0	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Rrotate

; 709  : 						_Pnode = _Left(_Fixnodeparent);

  001f5	8b 0e		 mov	 ecx, DWORD PTR [esi]
$L30478:

; 710  : 						}
; 711  : 					if (_Isnil(_Pnode))

  001f7	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0

; 712  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 713  : 					else if (_Color(_Right(_Pnode)) == _Black

  001fb	75 15		 jne	 SHORT $L72924

; 714  : 						&& _Color(_Left(_Pnode)) == _Black)

  001fd	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00200	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  00204	75 22		 jne	 SHORT $L30481
  00206	8b 01		 mov	 eax, DWORD PTR [ecx]
  00208	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0020c	75 1a		 jne	 SHORT $L30481
$L72925:

; 715  : 						{	// redden left subtree with black children
; 716  : 						_Color(_Pnode) = _Red;

  0020e	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
$L72924:

; 717  : 						_Fixnode = _Fixnodeparent;

  00212	8b fe		 mov	 edi, esi
  00214	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
$L72923:
  00217	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0021a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0021d	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  00220	0f 85 30 ff ff
	ff		 jne	 $L30467

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00226	eb 37		 jmp	 SHORT $L30469
$L30481:

; 718  : 						}
; 719  : 					else
; 720  : 						{	// must rearrange left subtree
; 721  : 						if (_Color(_Left(_Pnode)) == _Black)

  00228	8b 01		 mov	 eax, DWORD PTR [ecx]
  0022a	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0022e	75 15		 jne	 SHORT $L30483

; 722  : 							{	// rotate red up from right sub-subtree
; 723  : 							_Color(_Right(_Pnode)) = _Black;

  00230	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 724  : 							_Color(_Pnode) = _Red;
; 725  : 							_Lrotate(_Pnode);

  00233	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00236	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  0023a	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
  0023e	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Lrotate

; 726  : 							_Pnode = _Left(_Fixnodeparent);

  00243	8b 0e		 mov	 ecx, DWORD PTR [esi]
$L30483:

; 727  : 							}
; 728  : 
; 729  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  00245	8a 46 14	 mov	 al, BYTE PTR [esi+20]

; 730  : 						_Color(_Fixnodeparent) = _Black;
; 731  : 						_Color(_Left(_Pnode)) = _Black;
; 732  : 						_Rrotate(_Fixnodeparent);

  00248	ff 75 08	 push	 DWORD PTR _this$[ebp]
  0024b	88 41 14	 mov	 BYTE PTR [ecx+20], al
  0024e	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1
  00252	8b 01		 mov	 eax, DWORD PTR [ecx]
  00254	8b ce		 mov	 ecx, esi
  00256	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  0025a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Rrotate
$L30469:

; 733  : 						break;	// tree now recolored/rebalanced
; 734  : 						}
; 735  : 					}
; 736  : 
; 737  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

  0025f	c6 47 14 01	 mov	 BYTE PTR [edi+20], 1
$L30466:

; 738  : 			}
; 739  : 
; 740  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 741  : 		this->_Alnod.deallocate(_Erasednode, 1);

  00263	53		 push	 ebx
  00264	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00269	59		 pop	 ecx

; 742  : 
; 743  : 		if (0 < _Mysize)

  0026a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0026d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00270	85 c0		 test	 eax, eax
  00272	5f		 pop	 edi
  00273	5e		 pop	 esi
  00274	5b		 pop	 ebx
  00275	76 04		 jbe	 SHORT $L30484

; 744  : 			--_Mysize;

  00277	48		 dec	 eax
  00278	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L30484:

; 745  : 
; 746  : 		return (_Where);	// return successor iterator

  0027b	8b 4d 10	 mov	 ecx, DWORD PTR __Where$[ebp]
  0027e	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00281	89 08		 mov	 DWORD PTR [eax], ecx

; 747  : 		}

  00283	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00286	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0028d	c9		 leave
  0028e	c2 0c 00	 ret	 12			; 0000000cH
$L72919:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L72485:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T72480[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T72910
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::erase
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T73379	DD	0ffffffffH
	DD	FLAT:$L72938
$T73363	DD	019930520H
	DD	01H
	DD	FLAT:$T73379
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
$T72932 = -80						; size = 40
$T72933 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Where$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::erase, COMDAT

; 590  : 		{	// erase element at _Where

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 44	 sub	 esp, 68			; 00000044H
  0000d	53		 push	 ebx

; 591  : 		if (_Isnil(_Where._Mynode()))

  0000e	8b 5d 10	 mov	 ebx, DWORD PTR __Where$[ebp]
  00011	80 7b 15 00	 cmp	 BYTE PTR [ebx+21], 0
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	74 32		 je	 SHORT $L72950

; 592  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  0001e	8d 4d d8	 lea	 ecx, DWORD PTR $T72933[ebp]
  00021	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00026	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002a	8d 45 d8	 lea	 eax, DWORD PTR $T72933[ebp]
  0002d	50		 push	 eax
  0002e	8d 4d b0	 lea	 ecx, DWORD PTR $T72932[ebp]
  00031	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00036	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVout_of_range@std@@
  0003b	8d 45 b0	 lea	 eax, DWORD PTR $T72932[ebp]
  0003e	50		 push	 eax
  0003f	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T72932[ebp], OFFSET FLAT:??_7out_of_range@std@@6B@
  00046	e8 00 00 00 00	 call	 __CxxThrowException@8
$L73380:
$L72950:

; 593  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 594  : 		++_Where;	// save successor iterator for return

  0004b	8d 55 10	 lea	 edx, DWORD PTR __Where$[ebp]
  0004e	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::_Inc

; 595  : 
; 596  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 597  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 598  : 		_Nodeptr _Pnode = _Erasednode;
; 599  : 
; 600  : 		if (_Isnil(_Left(_Pnode)))

  00053	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00055	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00059	74 05		 je	 SHORT $L30336

; 601  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

  0005b	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 602  : 		else if (_Isnil(_Right(_Pnode)))

  0005e	eb 17		 jmp	 SHORT $L73370
$L30336:
  00060	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00063	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00067	74 04		 je	 SHORT $L30338

; 603  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

  00069	8b f9		 mov	 edi, ecx

; 604  : 		else

  0006b	eb 0a		 jmp	 SHORT $L73370
$L30338:

; 605  : 			{	// two subtrees, must lift successor node to replace erased
; 606  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 607  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

  0006d	8b 45 10	 mov	 eax, DWORD PTR __Where$[ebp]

; 608  : 			}
; 609  : 
; 610  : 		if (_Pnode == _Erasednode)

  00070	3b c3		 cmp	 eax, ebx
  00072	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  00075	75 76		 jne	 SHORT $L30340
$L73370:

; 611  : 			{	// at most one subtree, relink it
; 612  : 			_Fixnodeparent = _Parent(_Erasednode);
; 613  : 			if (!_Isnil(_Fixnode))

  00077	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  0007b	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  0007e	75 03		 jne	 SHORT $L30341

; 614  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00080	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L30341:

; 615  : 
; 616  : 			if (_Root() == _Erasednode)

  00083	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00089	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  0008c	75 05		 jne	 SHORT $L30342

; 617  : 				_Root() = _Fixnode;	// link down from root

  0008e	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 618  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

  00091	eb 0b		 jmp	 SHORT $L30345
$L30342:
  00093	39 1e		 cmp	 DWORD PTR [esi], ebx
  00095	75 04		 jne	 SHORT $L30344

; 619  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  00097	89 3e		 mov	 DWORD PTR [esi], edi

; 620  : 			else

  00099	eb 03		 jmp	 SHORT $L30345
$L30344:

; 621  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

  0009b	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$L30345:

; 622  : 
; 623  : 			if (_Lmost() == _Erasednode)

  0009e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a1	39 1a		 cmp	 DWORD PTR [edx], ebx
  000a3	75 1c		 jne	 SHORT $L30346

; 624  : 				_Lmost() = _Isnil(_Fixnode)
; 625  : 					? _Fixnodeparent	// smallest is parent of erased node
; 626  : 					: _Min(_Fixnode);	// smallest in relinked subtree

  000a5	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  000a9	74 04		 je	 SHORT $L72934
  000ab	8b ce		 mov	 ecx, esi
  000ad	eb 10		 jmp	 SHORT $L72935
$L72934:
  000af	8b 07		 mov	 eax, DWORD PTR [edi]
  000b1	8b cf		 mov	 ecx, edi
  000b3	eb 04		 jmp	 SHORT $L73373
$L73051:
  000b5	8b c8		 mov	 ecx, eax
  000b7	8b 01		 mov	 eax, DWORD PTR [ecx]
$L73373:
  000b9	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  000bd	74 f6		 je	 SHORT $L73051
$L72935:
  000bf	89 0a		 mov	 DWORD PTR [edx], ecx
$L30346:

; 627  : 
; 628  : 			if (_Rmost() == _Erasednode)

  000c1	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c7	39 5a 08	 cmp	 DWORD PTR [edx+8], ebx
  000ca	75 7b		 jne	 SHORT $L73191

; 629  : 				_Rmost() = _Isnil(_Fixnode)
; 630  : 					? _Fixnodeparent	// largest is parent of erased node
; 631  : 					: _Max(_Fixnode);	// largest in relinked subtree

  000cc	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  000d0	74 04		 je	 SHORT $L72936
  000d2	8b ce		 mov	 ecx, esi
  000d4	eb 12		 jmp	 SHORT $L72937
$L72936:
  000d6	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000d9	8b cf		 mov	 ecx, edi
  000db	eb 05		 jmp	 SHORT $L73374
$L73092:
  000dd	8b c8		 mov	 ecx, eax
  000df	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
$L73374:
  000e2	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  000e6	74 f5		 je	 SHORT $L73092
$L72937:
  000e8	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 632  : 			}
; 633  : 		else

  000eb	eb 5a		 jmp	 SHORT $L73191
$L30340:

; 634  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 635  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

  000ed	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 636  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

  000f0	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000f2	89 08		 mov	 DWORD PTR [eax], ecx

; 637  : 
; 638  : 			if (_Pnode == _Right(_Erasednode))

  000f4	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  000f7	75 04		 jne	 SHORT $L30349

; 639  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000f9	8b f0		 mov	 esi, eax

; 640  : 			else

  000fb	eb 1a		 jmp	 SHORT $L30350
$L30349:

; 641  : 				{	// successor further down, link in place of erased
; 642  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 643  : 				if (!_Isnil(_Fixnode))

  000fd	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  00101	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00104	75 03		 jne	 SHORT $L30351

; 644  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  00106	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L30351:

; 645  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  00109	89 3e		 mov	 DWORD PTR [esi], edi

; 646  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

  0010b	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0010e	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 647  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

  00111	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00114	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L30350:

; 648  : 				}
; 649  : 
; 650  : 			if (_Root() == _Erasednode)

  00117	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0011a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0011d	39 59 04	 cmp	 DWORD PTR [ecx+4], ebx
  00120	75 05		 jne	 SHORT $L30352

; 651  : 				_Root() = _Pnode;	// link down from root

  00122	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 652  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

  00125	eb 0e		 jmp	 SHORT $L30355
$L30352:
  00127	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0012a	39 19		 cmp	 DWORD PTR [ecx], ebx
  0012c	75 04		 jne	 SHORT $L30354

; 653  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

  0012e	89 01		 mov	 DWORD PTR [ecx], eax

; 654  : 			else

  00130	eb 03		 jmp	 SHORT $L30355
$L30354:

; 655  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

  00132	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L30355:

; 656  : 
; 657  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

  00135	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00138	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 658  : 			std::swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

  0013b	8a 53 14	 mov	 dl, BYTE PTR [ebx+20]
  0013e	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00141	88 50 14	 mov	 BYTE PTR [eax+20], dl
  00144	88 4b 14	 mov	 BYTE PTR [ebx+20], cl
$L73191:

; 659  : 			}
; 660  : 
; 661  : 		if (_Color(_Erasednode) == _Black)

  00147	80 7b 14 01	 cmp	 BYTE PTR [ebx+20], 1
  0014b	0f 85 12 01 00
	00		 jne	 $L30356

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00151	e9 c1 00 00 00	 jmp	 $L73376
$L30357:
  00156	80 7f 14 01	 cmp	 BYTE PTR [edi+20], 1
  0015a	0f 85 ff 00 00
	00		 jne	 $L30359

; 665  : 				if (_Fixnode == _Left(_Fixnodeparent))

  00160	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00162	3b f9		 cmp	 edi, ecx
  00164	75 77		 jne	 SHORT $L30360

; 666  : 					{	// fixup left subtree
; 667  : 					_Pnode = _Right(_Fixnodeparent);

  00166	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 668  : 					if (_Color(_Pnode) == _Red)

  00169	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  0016d	75 15		 jne	 SHORT $L30361

; 669  : 						{	// rotate red up from right subtree
; 670  : 						_Color(_Pnode) = _Black;
; 671  : 						_Color(_Fixnodeparent) = _Red;
; 672  : 						_Lrotate(_Fixnodeparent);

  0016f	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00172	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1
  00176	8b ce		 mov	 ecx, esi
  00178	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  0017c	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Lrotate

; 673  : 						_Pnode = _Right(_Fixnodeparent);

  00181	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$L30361:

; 674  : 						}
; 675  : 
; 676  : 					if (_Isnil(_Pnode))

  00184	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0

; 677  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 678  : 					else if (_Color(_Left(_Pnode)) == _Black

  00188	0f 85 84 00 00
	00		 jne	 $L73377

; 679  : 						&& _Color(_Right(_Pnode)) == _Black)

  0018e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00190	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  00194	75 09		 jne	 SHORT $L30364
  00196	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00199	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0019d	74 6f		 je	 SHORT $L73378
$L30364:

; 680  : 						{	// redden right subtree with black children
; 681  : 						_Color(_Pnode) = _Red;
; 682  : 						_Fixnode = _Fixnodeparent;
; 683  : 						}
; 684  : 					else
; 685  : 						{	// must rearrange right subtree
; 686  : 						if (_Color(_Right(_Pnode)) == _Black)

  0019f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001a2	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  001a6	75 15		 jne	 SHORT $L30366

; 687  : 							{	// rotate red up from left sub-subtree
; 688  : 							_Color(_Left(_Pnode)) = _Black;

  001a8	8b 01		 mov	 eax, DWORD PTR [ecx]

; 689  : 							_Color(_Pnode) = _Red;
; 690  : 							_Rrotate(_Pnode);

  001aa	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001ad	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  001b1	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
  001b5	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Rrotate

; 691  : 							_Pnode = _Right(_Fixnodeparent);

  001ba	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$L30366:

; 692  : 							}
; 693  : 
; 694  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  001bd	8a 46 14	 mov	 al, BYTE PTR [esi+20]

; 695  : 						_Color(_Fixnodeparent) = _Black;
; 696  : 						_Color(_Right(_Pnode)) = _Black;
; 697  : 						_Lrotate(_Fixnodeparent);

  001c0	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001c3	88 41 14	 mov	 BYTE PTR [ecx+20], al
  001c6	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1
  001ca	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001cd	8b ce		 mov	 ecx, esi
  001cf	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  001d3	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Lrotate

; 698  : 						break;	// tree now recolored/rebalanced

  001d8	e9 82 00 00 00	 jmp	 $L30359
$L30360:

; 699  : 						}
; 700  : 					}
; 701  : 				else
; 702  : 					{	// fixup right subtree
; 703  : 					_Pnode = _Left(_Fixnodeparent);
; 704  : 					if (_Color(_Pnode) == _Red)

  001dd	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  001e1	75 14		 jne	 SHORT $L30368

; 705  : 						{	// rotate red up from left subtree
; 706  : 						_Color(_Pnode) = _Black;
; 707  : 						_Color(_Fixnodeparent) = _Red;
; 708  : 						_Rrotate(_Fixnodeparent);

  001e3	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001e6	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1
  001ea	8b ce		 mov	 ecx, esi
  001ec	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  001f0	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Rrotate

; 709  : 						_Pnode = _Left(_Fixnodeparent);

  001f5	8b 0e		 mov	 ecx, DWORD PTR [esi]
$L30368:

; 710  : 						}
; 711  : 					if (_Isnil(_Pnode))

  001f7	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0

; 712  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 713  : 					else if (_Color(_Right(_Pnode)) == _Black

  001fb	75 15		 jne	 SHORT $L73377

; 714  : 						&& _Color(_Left(_Pnode)) == _Black)

  001fd	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00200	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  00204	75 22		 jne	 SHORT $L30371
  00206	8b 01		 mov	 eax, DWORD PTR [ecx]
  00208	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0020c	75 1a		 jne	 SHORT $L30371
$L73378:

; 715  : 						{	// redden left subtree with black children
; 716  : 						_Color(_Pnode) = _Red;

  0020e	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
$L73377:

; 717  : 						_Fixnode = _Fixnodeparent;

  00212	8b fe		 mov	 edi, esi
  00214	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
$L73376:
  00217	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0021a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0021d	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  00220	0f 85 30 ff ff
	ff		 jne	 $L30357

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00226	eb 37		 jmp	 SHORT $L30359
$L30371:

; 718  : 						}
; 719  : 					else
; 720  : 						{	// must rearrange left subtree
; 721  : 						if (_Color(_Left(_Pnode)) == _Black)

  00228	8b 01		 mov	 eax, DWORD PTR [ecx]
  0022a	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0022e	75 15		 jne	 SHORT $L30373

; 722  : 							{	// rotate red up from right sub-subtree
; 723  : 							_Color(_Right(_Pnode)) = _Black;

  00230	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 724  : 							_Color(_Pnode) = _Red;
; 725  : 							_Lrotate(_Pnode);

  00233	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00236	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  0023a	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
  0023e	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Lrotate

; 726  : 							_Pnode = _Left(_Fixnodeparent);

  00243	8b 0e		 mov	 ecx, DWORD PTR [esi]
$L30373:

; 727  : 							}
; 728  : 
; 729  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  00245	8a 46 14	 mov	 al, BYTE PTR [esi+20]

; 730  : 						_Color(_Fixnodeparent) = _Black;
; 731  : 						_Color(_Left(_Pnode)) = _Black;
; 732  : 						_Rrotate(_Fixnodeparent);

  00248	ff 75 08	 push	 DWORD PTR _this$[ebp]
  0024b	88 41 14	 mov	 BYTE PTR [ecx+20], al
  0024e	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1
  00252	8b 01		 mov	 eax, DWORD PTR [ecx]
  00254	8b ce		 mov	 ecx, esi
  00256	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  0025a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Rrotate
$L30359:

; 733  : 						break;	// tree now recolored/rebalanced
; 734  : 						}
; 735  : 					}
; 736  : 
; 737  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

  0025f	c6 47 14 01	 mov	 BYTE PTR [edi+20], 1
$L30356:

; 738  : 			}
; 739  : 
; 740  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 741  : 		this->_Alnod.deallocate(_Erasednode, 1);

  00263	53		 push	 ebx
  00264	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00269	59		 pop	 ecx

; 742  : 
; 743  : 		if (0 < _Mysize)

  0026a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0026d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00270	85 c0		 test	 eax, eax
  00272	5f		 pop	 edi
  00273	5e		 pop	 esi
  00274	5b		 pop	 ebx
  00275	76 04		 jbe	 SHORT $L30374

; 744  : 			--_Mysize;

  00277	48		 dec	 eax
  00278	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L30374:

; 745  : 
; 746  : 		return (_Where);	// return successor iterator

  0027b	8b 4d 10	 mov	 ecx, DWORD PTR __Where$[ebp]
  0027e	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00281	89 08		 mov	 DWORD PTR [eax], ecx

; 747  : 		}

  00283	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00286	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0028d	c9		 leave
  0028e	c2 0c 00	 ret	 12			; 0000000cH
$L73372:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L72938:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T72933[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T73363
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::erase
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T73832	DD	0ffffffffH
	DD	FLAT:$L73391
$T73816	DD	019930520H
	DD	01H
	DD	FLAT:$T73832
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
$T73385 = -80						; size = 40
$T73386 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Where$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::erase, COMDAT

; 590  : 		{	// erase element at _Where

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 44	 sub	 esp, 68			; 00000044H
  0000d	53		 push	 ebx

; 591  : 		if (_Isnil(_Where._Mynode()))

  0000e	8b 5d 10	 mov	 ebx, DWORD PTR __Where$[ebp]
  00011	80 7b 15 00	 cmp	 BYTE PTR [ebx+21], 0
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	74 32		 je	 SHORT $L73403

; 592  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  0001e	8d 4d d8	 lea	 ecx, DWORD PTR $T73386[ebp]
  00021	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00026	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002a	8d 45 d8	 lea	 eax, DWORD PTR $T73386[ebp]
  0002d	50		 push	 eax
  0002e	8d 4d b0	 lea	 ecx, DWORD PTR $T73385[ebp]
  00031	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00036	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVout_of_range@std@@
  0003b	8d 45 b0	 lea	 eax, DWORD PTR $T73385[ebp]
  0003e	50		 push	 eax
  0003f	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T73385[ebp], OFFSET FLAT:??_7out_of_range@std@@6B@
  00046	e8 00 00 00 00	 call	 __CxxThrowException@8
$L73833:
$L73403:

; 593  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 594  : 		++_Where;	// save successor iterator for return

  0004b	8d 55 10	 lea	 edx, DWORD PTR __Where$[ebp]
  0004e	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::_Inc

; 595  : 
; 596  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 597  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 598  : 		_Nodeptr _Pnode = _Erasednode;
; 599  : 
; 600  : 		if (_Isnil(_Left(_Pnode)))

  00053	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00055	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00059	74 05		 je	 SHORT $L30221

; 601  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

  0005b	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 602  : 		else if (_Isnil(_Right(_Pnode)))

  0005e	eb 17		 jmp	 SHORT $L73823
$L30221:
  00060	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00063	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00067	74 04		 je	 SHORT $L30223

; 603  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

  00069	8b f9		 mov	 edi, ecx

; 604  : 		else

  0006b	eb 0a		 jmp	 SHORT $L73823
$L30223:

; 605  : 			{	// two subtrees, must lift successor node to replace erased
; 606  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 607  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

  0006d	8b 45 10	 mov	 eax, DWORD PTR __Where$[ebp]

; 608  : 			}
; 609  : 
; 610  : 		if (_Pnode == _Erasednode)

  00070	3b c3		 cmp	 eax, ebx
  00072	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  00075	75 76		 jne	 SHORT $L30225
$L73823:

; 611  : 			{	// at most one subtree, relink it
; 612  : 			_Fixnodeparent = _Parent(_Erasednode);
; 613  : 			if (!_Isnil(_Fixnode))

  00077	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  0007b	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  0007e	75 03		 jne	 SHORT $L30226

; 614  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00080	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L30226:

; 615  : 
; 616  : 			if (_Root() == _Erasednode)

  00083	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00089	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  0008c	75 05		 jne	 SHORT $L30227

; 617  : 				_Root() = _Fixnode;	// link down from root

  0008e	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 618  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

  00091	eb 0b		 jmp	 SHORT $L30230
$L30227:
  00093	39 1e		 cmp	 DWORD PTR [esi], ebx
  00095	75 04		 jne	 SHORT $L30229

; 619  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  00097	89 3e		 mov	 DWORD PTR [esi], edi

; 620  : 			else

  00099	eb 03		 jmp	 SHORT $L30230
$L30229:

; 621  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

  0009b	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$L30230:

; 622  : 
; 623  : 			if (_Lmost() == _Erasednode)

  0009e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a1	39 1a		 cmp	 DWORD PTR [edx], ebx
  000a3	75 1c		 jne	 SHORT $L30231

; 624  : 				_Lmost() = _Isnil(_Fixnode)
; 625  : 					? _Fixnodeparent	// smallest is parent of erased node
; 626  : 					: _Min(_Fixnode);	// smallest in relinked subtree

  000a5	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  000a9	74 04		 je	 SHORT $L73387
  000ab	8b ce		 mov	 ecx, esi
  000ad	eb 10		 jmp	 SHORT $L73388
$L73387:
  000af	8b 07		 mov	 eax, DWORD PTR [edi]
  000b1	8b cf		 mov	 ecx, edi
  000b3	eb 04		 jmp	 SHORT $L73826
$L73497:
  000b5	8b c8		 mov	 ecx, eax
  000b7	8b 01		 mov	 eax, DWORD PTR [ecx]
$L73826:
  000b9	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  000bd	74 f6		 je	 SHORT $L73497
$L73388:
  000bf	89 0a		 mov	 DWORD PTR [edx], ecx
$L30231:

; 627  : 
; 628  : 			if (_Rmost() == _Erasednode)

  000c1	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c7	39 5a 08	 cmp	 DWORD PTR [edx+8], ebx
  000ca	75 7b		 jne	 SHORT $L73644

; 629  : 				_Rmost() = _Isnil(_Fixnode)
; 630  : 					? _Fixnodeparent	// largest is parent of erased node
; 631  : 					: _Max(_Fixnode);	// largest in relinked subtree

  000cc	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  000d0	74 04		 je	 SHORT $L73389
  000d2	8b ce		 mov	 ecx, esi
  000d4	eb 12		 jmp	 SHORT $L73390
$L73389:
  000d6	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000d9	8b cf		 mov	 ecx, edi
  000db	eb 05		 jmp	 SHORT $L73827
$L73538:
  000dd	8b c8		 mov	 ecx, eax
  000df	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
$L73827:
  000e2	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  000e6	74 f5		 je	 SHORT $L73538
$L73390:
  000e8	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 632  : 			}
; 633  : 		else

  000eb	eb 5a		 jmp	 SHORT $L73644
$L30225:

; 634  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 635  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

  000ed	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 636  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

  000f0	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000f2	89 08		 mov	 DWORD PTR [eax], ecx

; 637  : 
; 638  : 			if (_Pnode == _Right(_Erasednode))

  000f4	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  000f7	75 04		 jne	 SHORT $L30234

; 639  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000f9	8b f0		 mov	 esi, eax

; 640  : 			else

  000fb	eb 1a		 jmp	 SHORT $L30235
$L30234:

; 641  : 				{	// successor further down, link in place of erased
; 642  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 643  : 				if (!_Isnil(_Fixnode))

  000fd	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  00101	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00104	75 03		 jne	 SHORT $L30236

; 644  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  00106	89 77 04	 mov	 DWORD PTR [edi+4], esi
$L30236:

; 645  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  00109	89 3e		 mov	 DWORD PTR [esi], edi

; 646  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

  0010b	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0010e	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 647  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

  00111	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00114	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$L30235:

; 648  : 				}
; 649  : 
; 650  : 			if (_Root() == _Erasednode)

  00117	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0011a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0011d	39 59 04	 cmp	 DWORD PTR [ecx+4], ebx
  00120	75 05		 jne	 SHORT $L30237

; 651  : 				_Root() = _Pnode;	// link down from root

  00122	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 652  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

  00125	eb 0e		 jmp	 SHORT $L30240
$L30237:
  00127	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0012a	39 19		 cmp	 DWORD PTR [ecx], ebx
  0012c	75 04		 jne	 SHORT $L30239

; 653  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

  0012e	89 01		 mov	 DWORD PTR [ecx], eax

; 654  : 			else

  00130	eb 03		 jmp	 SHORT $L30240
$L30239:

; 655  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

  00132	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L30240:

; 656  : 
; 657  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

  00135	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00138	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 658  : 			std::swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

  0013b	8a 53 14	 mov	 dl, BYTE PTR [ebx+20]
  0013e	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00141	88 50 14	 mov	 BYTE PTR [eax+20], dl
  00144	88 4b 14	 mov	 BYTE PTR [ebx+20], cl
$L73644:

; 659  : 			}
; 660  : 
; 661  : 		if (_Color(_Erasednode) == _Black)

  00147	80 7b 14 01	 cmp	 BYTE PTR [ebx+20], 1
  0014b	0f 85 12 01 00
	00		 jne	 $L30246

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00151	e9 c1 00 00 00	 jmp	 $L73829
$L30247:
  00156	80 7f 14 01	 cmp	 BYTE PTR [edi+20], 1
  0015a	0f 85 ff 00 00
	00		 jne	 $L30249

; 665  : 				if (_Fixnode == _Left(_Fixnodeparent))

  00160	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00162	3b f9		 cmp	 edi, ecx
  00164	75 77		 jne	 SHORT $L30250

; 666  : 					{	// fixup left subtree
; 667  : 					_Pnode = _Right(_Fixnodeparent);

  00166	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 668  : 					if (_Color(_Pnode) == _Red)

  00169	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  0016d	75 15		 jne	 SHORT $L30251

; 669  : 						{	// rotate red up from right subtree
; 670  : 						_Color(_Pnode) = _Black;
; 671  : 						_Color(_Fixnodeparent) = _Red;
; 672  : 						_Lrotate(_Fixnodeparent);

  0016f	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00172	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1
  00176	8b ce		 mov	 ecx, esi
  00178	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  0017c	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Lrotate

; 673  : 						_Pnode = _Right(_Fixnodeparent);

  00181	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$L30251:

; 674  : 						}
; 675  : 
; 676  : 					if (_Isnil(_Pnode))

  00184	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0

; 677  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 678  : 					else if (_Color(_Left(_Pnode)) == _Black

  00188	0f 85 84 00 00
	00		 jne	 $L73830

; 679  : 						&& _Color(_Right(_Pnode)) == _Black)

  0018e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00190	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  00194	75 09		 jne	 SHORT $L30254
  00196	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00199	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0019d	74 6f		 je	 SHORT $L73831
$L30254:

; 680  : 						{	// redden right subtree with black children
; 681  : 						_Color(_Pnode) = _Red;
; 682  : 						_Fixnode = _Fixnodeparent;
; 683  : 						}
; 684  : 					else
; 685  : 						{	// must rearrange right subtree
; 686  : 						if (_Color(_Right(_Pnode)) == _Black)

  0019f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001a2	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  001a6	75 15		 jne	 SHORT $L30256

; 687  : 							{	// rotate red up from left sub-subtree
; 688  : 							_Color(_Left(_Pnode)) = _Black;

  001a8	8b 01		 mov	 eax, DWORD PTR [ecx]

; 689  : 							_Color(_Pnode) = _Red;
; 690  : 							_Rrotate(_Pnode);

  001aa	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001ad	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  001b1	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
  001b5	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Rrotate

; 691  : 							_Pnode = _Right(_Fixnodeparent);

  001ba	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$L30256:

; 692  : 							}
; 693  : 
; 694  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  001bd	8a 46 14	 mov	 al, BYTE PTR [esi+20]

; 695  : 						_Color(_Fixnodeparent) = _Black;
; 696  : 						_Color(_Right(_Pnode)) = _Black;
; 697  : 						_Lrotate(_Fixnodeparent);

  001c0	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001c3	88 41 14	 mov	 BYTE PTR [ecx+20], al
  001c6	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1
  001ca	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001cd	8b ce		 mov	 ecx, esi
  001cf	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  001d3	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Lrotate

; 698  : 						break;	// tree now recolored/rebalanced

  001d8	e9 82 00 00 00	 jmp	 $L30249
$L30250:

; 699  : 						}
; 700  : 					}
; 701  : 				else
; 702  : 					{	// fixup right subtree
; 703  : 					_Pnode = _Left(_Fixnodeparent);
; 704  : 					if (_Color(_Pnode) == _Red)

  001dd	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  001e1	75 14		 jne	 SHORT $L30258

; 705  : 						{	// rotate red up from left subtree
; 706  : 						_Color(_Pnode) = _Black;
; 707  : 						_Color(_Fixnodeparent) = _Red;
; 708  : 						_Rrotate(_Fixnodeparent);

  001e3	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001e6	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1
  001ea	8b ce		 mov	 ecx, esi
  001ec	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  001f0	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Rrotate

; 709  : 						_Pnode = _Left(_Fixnodeparent);

  001f5	8b 0e		 mov	 ecx, DWORD PTR [esi]
$L30258:

; 710  : 						}
; 711  : 					if (_Isnil(_Pnode))

  001f7	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0

; 712  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 713  : 					else if (_Color(_Right(_Pnode)) == _Black

  001fb	75 15		 jne	 SHORT $L73830

; 714  : 						&& _Color(_Left(_Pnode)) == _Black)

  001fd	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00200	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  00204	75 22		 jne	 SHORT $L30261
  00206	8b 01		 mov	 eax, DWORD PTR [ecx]
  00208	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0020c	75 1a		 jne	 SHORT $L30261
$L73831:

; 715  : 						{	// redden left subtree with black children
; 716  : 						_Color(_Pnode) = _Red;

  0020e	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
$L73830:

; 717  : 						_Fixnode = _Fixnodeparent;

  00212	8b fe		 mov	 edi, esi
  00214	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
$L73829:
  00217	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0021a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0021d	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  00220	0f 85 30 ff ff
	ff		 jne	 $L30247

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

  00226	eb 37		 jmp	 SHORT $L30249
$L30261:

; 718  : 						}
; 719  : 					else
; 720  : 						{	// must rearrange left subtree
; 721  : 						if (_Color(_Left(_Pnode)) == _Black)

  00228	8b 01		 mov	 eax, DWORD PTR [ecx]
  0022a	80 78 14 01	 cmp	 BYTE PTR [eax+20], 1
  0022e	75 15		 jne	 SHORT $L30263

; 722  : 							{	// rotate red up from right sub-subtree
; 723  : 							_Color(_Right(_Pnode)) = _Black;

  00230	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 724  : 							_Color(_Pnode) = _Red;
; 725  : 							_Lrotate(_Pnode);

  00233	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00236	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  0023a	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
  0023e	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Lrotate

; 726  : 							_Pnode = _Left(_Fixnodeparent);

  00243	8b 0e		 mov	 ecx, DWORD PTR [esi]
$L30263:

; 727  : 							}
; 728  : 
; 729  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

  00245	8a 46 14	 mov	 al, BYTE PTR [esi+20]

; 730  : 						_Color(_Fixnodeparent) = _Black;
; 731  : 						_Color(_Left(_Pnode)) = _Black;
; 732  : 						_Rrotate(_Fixnodeparent);

  00248	ff 75 08	 push	 DWORD PTR _this$[ebp]
  0024b	88 41 14	 mov	 BYTE PTR [ecx+20], al
  0024e	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1
  00252	8b 01		 mov	 eax, DWORD PTR [ecx]
  00254	8b ce		 mov	 ecx, esi
  00256	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  0025a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Rrotate
$L30249:

; 733  : 						break;	// tree now recolored/rebalanced
; 734  : 						}
; 735  : 					}
; 736  : 
; 737  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

  0025f	c6 47 14 01	 mov	 BYTE PTR [edi+20], 1
$L30246:

; 738  : 			}
; 739  : 
; 740  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 741  : 		this->_Alnod.deallocate(_Erasednode, 1);

  00263	53		 push	 ebx
  00264	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00269	59		 pop	 ecx

; 742  : 
; 743  : 		if (0 < _Mysize)

  0026a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0026d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00270	85 c0		 test	 eax, eax
  00272	5f		 pop	 edi
  00273	5e		 pop	 esi
  00274	5b		 pop	 ebx
  00275	76 04		 jbe	 SHORT $L30264

; 744  : 			--_Mysize;

  00277	48		 dec	 eax
  00278	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L30264:

; 745  : 
; 746  : 		return (_Where);	// return successor iterator

  0027b	8b 4d 10	 mov	 ecx, DWORD PTR __Where$[ebp]
  0027e	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00281	89 08		 mov	 DWORD PTR [eax], ecx

; 747  : 		}

  00283	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00286	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0028d	c9		 leave
  0028e	c2 0c 00	 ret	 12			; 0000000cH
$L73825:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L73391:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T73386[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T73816
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::erase
; Function compile flags: /Ogsy
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT
$T73841 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::erase, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = ebx

; 750  : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 751  : 		if (_First == begin() && _Last == end())

  00004	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b f8		 mov	 edi, eax
  0000a	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0000d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000f	75 13		 jne	 SHORT $L73948
  00011	39 45 0c	 cmp	 DWORD PTR __Last$[ebp], eax
  00014	75 0e		 jne	 SHORT $L73948

; 752  : 			{	// erase all
; 753  : 			clear();

  00016	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::clear

; 754  : 			return (begin());

  0001b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 03		 mov	 DWORD PTR [ebx], eax
  00022	eb 26		 jmp	 SHORT $L73949
$L73948:

; 755  : 			}
; 756  : 		else
; 757  : 			{	// partial erase, one at a time
; 758  : 			while (_First != _Last)

  00024	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00027	74 1f		 je	 SHORT $L29700
  00029	56		 push	 esi
$L29699:

; 759  : 				erase(_First++);

  0002a	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  0002d	8b f1		 mov	 esi, ecx
  0002f	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Inc
  00034	56		 push	 esi
  00035	8d 45 fc	 lea	 eax, DWORD PTR $T73841[ebp]
  00038	50		 push	 eax
  00039	57		 push	 edi
  0003a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::erase
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00042	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00045	75 e3		 jne	 SHORT $L29699
  00047	5e		 pop	 esi
$L29700:

; 760  : 			return (_First);

  00048	89 0b		 mov	 DWORD PTR [ebx], ecx
$L73949:
  0004a	8b c3		 mov	 eax, ebx
  0004c	5f		 pop	 edi

; 761  : 			}
; 762  : 		}

  0004d	c9		 leave
  0004e	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::erase
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT
$T73955 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::erase, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = ebx

; 750  : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 751  : 		if (_First == begin() && _Last == end())

  00004	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b f8		 mov	 edi, eax
  0000a	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0000d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000f	75 13		 jne	 SHORT $L74062
  00011	39 45 0c	 cmp	 DWORD PTR __Last$[ebp], eax
  00014	75 0e		 jne	 SHORT $L74062

; 752  : 			{	// erase all
; 753  : 			clear();

  00016	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::clear

; 754  : 			return (begin());

  0001b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 03		 mov	 DWORD PTR [ebx], eax
  00022	eb 26		 jmp	 SHORT $L74063
$L74062:

; 755  : 			}
; 756  : 		else
; 757  : 			{	// partial erase, one at a time
; 758  : 			while (_First != _Last)

  00024	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00027	74 1f		 je	 SHORT $L29565
  00029	56		 push	 esi
$L29564:

; 759  : 				erase(_First++);

  0002a	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  0002d	8b f1		 mov	 esi, ecx
  0002f	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::_Inc
  00034	56		 push	 esi
  00035	8d 45 fc	 lea	 eax, DWORD PTR $T73955[ebp]
  00038	50		 push	 eax
  00039	57		 push	 edi
  0003a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::erase
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00042	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00045	75 e3		 jne	 SHORT $L29564
  00047	5e		 pop	 esi
$L29565:

; 760  : 			return (_First);

  00048	89 0b		 mov	 DWORD PTR [ebx], ecx
$L74063:
  0004a	8b c3		 mov	 eax, ebx
  0004c	5f		 pop	 edi

; 761  : 			}
; 762  : 		}

  0004d	c9		 leave
  0004e	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::erase
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT
$T74069 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::erase, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = ebx

; 750  : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 751  : 		if (_First == begin() && _Last == end())

  00004	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b f8		 mov	 edi, eax
  0000a	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0000d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000f	75 13		 jne	 SHORT $L74176
  00011	39 45 0c	 cmp	 DWORD PTR __Last$[ebp], eax
  00014	75 0e		 jne	 SHORT $L74176

; 752  : 			{	// erase all
; 753  : 			clear();

  00016	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::clear

; 754  : 			return (begin());

  0001b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 03		 mov	 DWORD PTR [ebx], eax
  00022	eb 26		 jmp	 SHORT $L74177
$L74176:

; 755  : 			}
; 756  : 		else
; 757  : 			{	// partial erase, one at a time
; 758  : 			while (_First != _Last)

  00024	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00027	74 1f		 je	 SHORT $L29424
  00029	56		 push	 esi
$L29423:

; 759  : 				erase(_First++);

  0002a	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  0002d	8b f1		 mov	 esi, ecx
  0002f	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::_Inc
  00034	56		 push	 esi
  00035	8d 45 fc	 lea	 eax, DWORD PTR $T74069[ebp]
  00038	50		 push	 eax
  00039	57		 push	 edi
  0003a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::erase
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00042	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00045	75 e3		 jne	 SHORT $L29423
  00047	5e		 pop	 esi
$L29424:

; 760  : 			return (_First);

  00048	89 0b		 mov	 DWORD PTR [ebx], ecx
$L74177:
  0004a	8b c3		 mov	 eax, ebx
  0004c	5f		 pop	 edi

; 761  : 			}
; 762  : 		}

  0004d	c9		 leave
  0004e	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::erase
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT
$T74183 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::erase, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = ebx

; 750  : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 751  : 		if (_First == begin() && _Last == end())

  00004	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b f8		 mov	 edi, eax
  0000a	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0000d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000f	75 13		 jne	 SHORT $L74290
  00011	39 45 0c	 cmp	 DWORD PTR __Last$[ebp], eax
  00014	75 0e		 jne	 SHORT $L74290

; 752  : 			{	// erase all
; 753  : 			clear();

  00016	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::clear

; 754  : 			return (begin());

  0001b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 03		 mov	 DWORD PTR [ebx], eax
  00022	eb 26		 jmp	 SHORT $L74291
$L74290:

; 755  : 			}
; 756  : 		else
; 757  : 			{	// partial erase, one at a time
; 758  : 			while (_First != _Last)

  00024	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00027	74 1f		 je	 SHORT $L29283
  00029	56		 push	 esi
$L29282:

; 759  : 				erase(_First++);

  0002a	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  0002d	8b f1		 mov	 esi, ecx
  0002f	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::_Inc
  00034	56		 push	 esi
  00035	8d 45 fc	 lea	 eax, DWORD PTR $T74183[ebp]
  00038	50		 push	 eax
  00039	57		 push	 edi
  0003a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::erase
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00042	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00045	75 e3		 jne	 SHORT $L29282
  00047	5e		 pop	 esi
$L29283:

; 760  : 			return (_First);

  00048	89 0b		 mov	 DWORD PTR [ebx], ecx
$L74291:
  0004a	8b c3		 mov	 eax, ebx
  0004c	5f		 pop	 edi

; 761  : 			}
; 762  : 		}

  0004d	c9		 leave
  0004e	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::erase
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT
$T74297 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::erase, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = ebx

; 750  : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 751  : 		if (_First == begin() && _Last == end())

  00004	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b f8		 mov	 edi, eax
  0000a	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0000d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000f	75 13		 jne	 SHORT $L74404
  00011	39 45 0c	 cmp	 DWORD PTR __Last$[ebp], eax
  00014	75 0e		 jne	 SHORT $L74404

; 752  : 			{	// erase all
; 753  : 			clear();

  00016	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::clear

; 754  : 			return (begin());

  0001b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 03		 mov	 DWORD PTR [ebx], eax
  00022	eb 26		 jmp	 SHORT $L74405
$L74404:

; 755  : 			}
; 756  : 		else
; 757  : 			{	// partial erase, one at a time
; 758  : 			while (_First != _Last)

  00024	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00027	74 1f		 je	 SHORT $L29148
  00029	56		 push	 esi
$L29147:

; 759  : 				erase(_First++);

  0002a	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  0002d	8b f1		 mov	 esi, ecx
  0002f	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::_Inc
  00034	56		 push	 esi
  00035	8d 45 fc	 lea	 eax, DWORD PTR $T74297[ebp]
  00038	50		 push	 eax
  00039	57		 push	 edi
  0003a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::erase
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00042	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00045	75 e3		 jne	 SHORT $L29147
  00047	5e		 pop	 esi
$L29148:

; 760  : 			return (_First);

  00048	89 0b		 mov	 DWORD PTR [ebx], ecx
$L74405:
  0004a	8b c3		 mov	 eax, ebx
  0004c	5f		 pop	 edi

; 761  : 			}
; 762  : 		}

  0004d	c9		 leave
  0004e	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::erase
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT
$T74411 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::erase, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = ebx

; 750  : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 751  : 		if (_First == begin() && _Last == end())

  00004	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b f8		 mov	 edi, eax
  0000a	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0000d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000f	75 13		 jne	 SHORT $L74518
  00011	39 45 0c	 cmp	 DWORD PTR __Last$[ebp], eax
  00014	75 0e		 jne	 SHORT $L74518

; 752  : 			{	// erase all
; 753  : 			clear();

  00016	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::clear

; 754  : 			return (begin());

  0001b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 03		 mov	 DWORD PTR [ebx], eax
  00022	eb 26		 jmp	 SHORT $L74519
$L74518:

; 755  : 			}
; 756  : 		else
; 757  : 			{	// partial erase, one at a time
; 758  : 			while (_First != _Last)

  00024	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00027	74 1f		 je	 SHORT $L29013
  00029	56		 push	 esi
$L29012:

; 759  : 				erase(_First++);

  0002a	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  0002d	8b f1		 mov	 esi, ecx
  0002f	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::_Inc
  00034	56		 push	 esi
  00035	8d 45 fc	 lea	 eax, DWORD PTR $T74411[ebp]
  00038	50		 push	 eax
  00039	57		 push	 edi
  0003a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::erase
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00042	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00045	75 e3		 jne	 SHORT $L29012
  00047	5e		 pop	 esi
$L29013:

; 760  : 			return (_First);

  00048	89 0b		 mov	 DWORD PTR [ebx], ecx
$L74519:
  0004a	8b c3		 mov	 eax, ebx
  0004c	5f		 pop	 edi

; 761  : 			}
; 762  : 		}

  0004d	c9		 leave
  0004e	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::erase
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT
$T74525 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::erase, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = ebx

; 750  : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 751  : 		if (_First == begin() && _Last == end())

  00004	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b f8		 mov	 edi, eax
  0000a	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0000d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000f	75 13		 jne	 SHORT $L74632
  00011	39 45 0c	 cmp	 DWORD PTR __Last$[ebp], eax
  00014	75 0e		 jne	 SHORT $L74632

; 752  : 			{	// erase all
; 753  : 			clear();

  00016	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::clear

; 754  : 			return (begin());

  0001b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 03		 mov	 DWORD PTR [ebx], eax
  00022	eb 26		 jmp	 SHORT $L74633
$L74632:

; 755  : 			}
; 756  : 		else
; 757  : 			{	// partial erase, one at a time
; 758  : 			while (_First != _Last)

  00024	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00027	74 1f		 je	 SHORT $L28878
  00029	56		 push	 esi
$L28877:

; 759  : 				erase(_First++);

  0002a	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  0002d	8b f1		 mov	 esi, ecx
  0002f	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::_Inc
  00034	56		 push	 esi
  00035	8d 45 fc	 lea	 eax, DWORD PTR $T74525[ebp]
  00038	50		 push	 eax
  00039	57		 push	 edi
  0003a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::erase
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00042	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00045	75 e3		 jne	 SHORT $L28877
  00047	5e		 pop	 esi
$L28878:

; 760  : 			return (_First);

  00048	89 0b		 mov	 DWORD PTR [ebx], ecx
$L74633:
  0004a	8b c3		 mov	 eax, ebx
  0004c	5f		 pop	 edi

; 761  : 			}
; 762  : 		}

  0004d	c9		 leave
  0004e	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::erase
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT
$T74639 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::erase, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = ebx

; 750  : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 751  : 		if (_First == begin() && _Last == end())

  00004	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b f8		 mov	 edi, eax
  0000a	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0000d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000f	75 13		 jne	 SHORT $L74746
  00011	39 45 0c	 cmp	 DWORD PTR __Last$[ebp], eax
  00014	75 0e		 jne	 SHORT $L74746

; 752  : 			{	// erase all
; 753  : 			clear();

  00016	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::clear

; 754  : 			return (begin());

  0001b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 03		 mov	 DWORD PTR [ebx], eax
  00022	eb 26		 jmp	 SHORT $L74747
$L74746:

; 755  : 			}
; 756  : 		else
; 757  : 			{	// partial erase, one at a time
; 758  : 			while (_First != _Last)

  00024	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00027	74 1f		 je	 SHORT $L28742
  00029	56		 push	 esi
$L28741:

; 759  : 				erase(_First++);

  0002a	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  0002d	8b f1		 mov	 esi, ecx
  0002f	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::_Inc
  00034	56		 push	 esi
  00035	8d 45 fc	 lea	 eax, DWORD PTR $T74639[ebp]
  00038	50		 push	 eax
  00039	57		 push	 edi
  0003a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::erase
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00042	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00045	75 e3		 jne	 SHORT $L28741
  00047	5e		 pop	 esi
$L28742:

; 760  : 			return (_First);

  00048	89 0b		 mov	 DWORD PTR [ebx], ecx
$L74747:
  0004a	8b c3		 mov	 eax, ebx
  0004c	5f		 pop	 edi

; 761  : 			}
; 762  : 		}

  0004d	c9		 leave
  0004e	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::erase
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T74752 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Tidy, COMDAT
; _this$ = esi

; 1142 : 		{	// free all storage

  00000	51		 push	 ecx

; 1143 : 		erase(begin(), end());

  00001	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	53		 push	 ebx
  00007	50		 push	 eax
  00008	51		 push	 ecx
  00009	8d 5c 24 0c	 lea	 ebx, DWORD PTR $T74752[esp+16]
  0000d	8b c6		 mov	 eax, esi
  0000f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::erase

; 1144 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1145 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1146 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1147 : 		this->_Alnod.deallocate(_Myhead, 1);

  00014	ff 76 04	 push	 DWORD PTR [esi+4]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1148 : 		_Myhead = 0, _Mysize = 0;

  0001c	83 66 04 00	 and	 DWORD PTR [esi+4], 0
  00020	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  00024	59		 pop	 ecx
  00025	5b		 pop	 ebx

; 1149 : 		}

  00026	59		 pop	 ecx
  00027	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Tidy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T74841 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Tidy, COMDAT
; _this$ = esi

; 1142 : 		{	// free all storage

  00000	51		 push	 ecx

; 1143 : 		erase(begin(), end());

  00001	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	53		 push	 ebx
  00007	50		 push	 eax
  00008	51		 push	 ecx
  00009	8d 5c 24 0c	 lea	 ebx, DWORD PTR $T74841[esp+16]
  0000d	8b c6		 mov	 eax, esi
  0000f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::erase

; 1144 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1145 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1146 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1147 : 		this->_Alnod.deallocate(_Myhead, 1);

  00014	ff 76 04	 push	 DWORD PTR [esi+4]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1148 : 		_Myhead = 0, _Mysize = 0;

  0001c	83 66 04 00	 and	 DWORD PTR [esi+4], 0
  00020	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  00024	59		 pop	 ecx
  00025	5b		 pop	 ebx

; 1149 : 		}

  00026	59		 pop	 ecx
  00027	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Tidy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T74930 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Tidy, COMDAT
; _this$ = esi

; 1142 : 		{	// free all storage

  00000	51		 push	 ecx

; 1143 : 		erase(begin(), end());

  00001	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	53		 push	 ebx
  00007	50		 push	 eax
  00008	51		 push	 ecx
  00009	8d 5c 24 0c	 lea	 ebx, DWORD PTR $T74930[esp+16]
  0000d	8b c6		 mov	 eax, esi
  0000f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::erase

; 1144 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1145 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1146 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1147 : 		this->_Alnod.deallocate(_Myhead, 1);

  00014	ff 76 04	 push	 DWORD PTR [esi+4]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1148 : 		_Myhead = 0, _Mysize = 0;

  0001c	83 66 04 00	 and	 DWORD PTR [esi+4], 0
  00020	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  00024	59		 pop	 ecx
  00025	5b		 pop	 ebx

; 1149 : 		}

  00026	59		 pop	 ecx
  00027	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Tidy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T75019 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Tidy, COMDAT
; _this$ = esi

; 1142 : 		{	// free all storage

  00000	51		 push	 ecx

; 1143 : 		erase(begin(), end());

  00001	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	53		 push	 ebx
  00007	50		 push	 eax
  00008	51		 push	 ecx
  00009	8d 5c 24 0c	 lea	 ebx, DWORD PTR $T75019[esp+16]
  0000d	8b c6		 mov	 eax, esi
  0000f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::erase

; 1144 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1145 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1146 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1147 : 		this->_Alnod.deallocate(_Myhead, 1);

  00014	ff 76 04	 push	 DWORD PTR [esi+4]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1148 : 		_Myhead = 0, _Mysize = 0;

  0001c	83 66 04 00	 and	 DWORD PTR [esi+4], 0
  00020	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  00024	59		 pop	 ecx
  00025	5b		 pop	 ebx

; 1149 : 		}

  00026	59		 pop	 ecx
  00027	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Tidy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T75108 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Tidy, COMDAT
; _this$ = esi

; 1142 : 		{	// free all storage

  00000	51		 push	 ecx

; 1143 : 		erase(begin(), end());

  00001	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	53		 push	 ebx
  00007	50		 push	 eax
  00008	51		 push	 ecx
  00009	8d 5c 24 0c	 lea	 ebx, DWORD PTR $T75108[esp+16]
  0000d	8b c6		 mov	 eax, esi
  0000f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::erase

; 1144 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1145 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1146 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1147 : 		this->_Alnod.deallocate(_Myhead, 1);

  00014	ff 76 04	 push	 DWORD PTR [esi+4]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1148 : 		_Myhead = 0, _Mysize = 0;

  0001c	83 66 04 00	 and	 DWORD PTR [esi+4], 0
  00020	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  00024	59		 pop	 ecx
  00025	5b		 pop	 ebx

; 1149 : 		}

  00026	59		 pop	 ecx
  00027	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Tidy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T75197 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Tidy, COMDAT
; _this$ = esi

; 1142 : 		{	// free all storage

  00000	51		 push	 ecx

; 1143 : 		erase(begin(), end());

  00001	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	53		 push	 ebx
  00007	50		 push	 eax
  00008	51		 push	 ecx
  00009	8d 5c 24 0c	 lea	 ebx, DWORD PTR $T75197[esp+16]
  0000d	8b c6		 mov	 eax, esi
  0000f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::erase

; 1144 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1145 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1146 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1147 : 		this->_Alnod.deallocate(_Myhead, 1);

  00014	ff 76 04	 push	 DWORD PTR [esi+4]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1148 : 		_Myhead = 0, _Mysize = 0;

  0001c	83 66 04 00	 and	 DWORD PTR [esi+4], 0
  00020	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  00024	59		 pop	 ecx
  00025	5b		 pop	 ebx

; 1149 : 		}

  00026	59		 pop	 ecx
  00027	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Tidy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T75286 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Tidy, COMDAT
; _this$ = esi

; 1142 : 		{	// free all storage

  00000	51		 push	 ecx

; 1143 : 		erase(begin(), end());

  00001	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	53		 push	 ebx
  00007	50		 push	 eax
  00008	51		 push	 ecx
  00009	8d 5c 24 0c	 lea	 ebx, DWORD PTR $T75286[esp+16]
  0000d	8b c6		 mov	 eax, esi
  0000f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::erase

; 1144 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1145 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1146 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1147 : 		this->_Alnod.deallocate(_Myhead, 1);

  00014	ff 76 04	 push	 DWORD PTR [esi+4]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1148 : 		_Myhead = 0, _Mysize = 0;

  0001c	83 66 04 00	 and	 DWORD PTR [esi+4], 0
  00020	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  00024	59		 pop	 ecx
  00025	5b		 pop	 ebx

; 1149 : 		}

  00026	59		 pop	 ecx
  00027	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Tidy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T75375 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Tidy, COMDAT
; _this$ = esi

; 1142 : 		{	// free all storage

  00000	51		 push	 ecx

; 1143 : 		erase(begin(), end());

  00001	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	53		 push	 ebx
  00007	50		 push	 eax
  00008	51		 push	 ecx
  00009	8d 5c 24 0c	 lea	 ebx, DWORD PTR $T75375[esp+16]
  0000d	8b c6		 mov	 eax, esi
  0000f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::erase

; 1144 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1145 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1146 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1147 : 		this->_Alnod.deallocate(_Myhead, 1);

  00014	ff 76 04	 push	 DWORD PTR [esi+4]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1148 : 		_Myhead = 0, _Mysize = 0;

  0001c	83 66 04 00	 and	 DWORD PTR [esi+4], 0
  00020	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  00024	59		 pop	 ecx
  00025	5b		 pop	 ebx

; 1149 : 		}

  00026	59		 pop	 ecx
  00027	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Tidy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::~_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >, COMDAT
; _this$ = esi

; 392  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Tidy
??1?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::~_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ??0?$map@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::map<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> > >::map<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> > >, COMDAT
; _this$ = eax

; 102  : 		{	// construct empty map from defaults

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax
  00003	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Init

; 103  : 		}

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi
  0000b	c3		 ret	 0
??0?$map@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> > >::map<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> > >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::~_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >, COMDAT
; _this$ = esi

; 392  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Tidy
??1?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::~_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ??0?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::map<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> > >::map<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> > >, COMDAT
; _this$ = eax

; 102  : 		{	// construct empty map from defaults

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax
  00003	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Init

; 103  : 		}

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi
  0000b	c3		 ret	 0
??0?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> > >::map<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> > >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::~_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >, COMDAT
; _this$ = esi

; 392  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Tidy
??1?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::~_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ??0?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::map<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> > >::map<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> > >, COMDAT
; _this$ = eax

; 102  : 		{	// construct empty map from defaults

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax
  00003	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Init

; 103  : 		}

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi
  0000b	c3		 ret	 0
??0?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> > >::map<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> > >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::~_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >, COMDAT
; _this$ = esi

; 392  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Tidy
??1?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::~_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ??0?$map@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::map<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> > >::map<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> > >, COMDAT
; _this$ = eax

; 102  : 		{	// construct empty map from defaults

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax
  00003	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Init

; 103  : 		}

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi
  0000b	c3		 ret	 0
??0?$map@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> > >::map<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> > >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::~_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >, COMDAT
; _this$ = esi

; 392  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Tidy
??1?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::~_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ??0?$map@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::map<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> > >::map<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> > >, COMDAT
; _this$ = eax

; 102  : 		{	// construct empty map from defaults

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax
  00003	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Init

; 103  : 		}

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi
  0000b	c3		 ret	 0
??0?$map@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> > >::map<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> > >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::~_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >, COMDAT
; _this$ = esi

; 392  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Tidy
??1?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::~_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ??0?$map@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::map<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> > >::map<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> > >, COMDAT
; _this$ = eax

; 102  : 		{	// construct empty map from defaults

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax
  00003	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Init

; 103  : 		}

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi
  0000b	c3		 ret	 0
??0?$map@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> > >::map<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> > >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::~_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >, COMDAT
; _this$ = esi

; 392  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Tidy
??1?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::~_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ??0?$map@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::map<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> > >::map<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> > >, COMDAT
; _this$ = eax

; 102  : 		{	// construct empty map from defaults

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax
  00003	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Init

; 103  : 		}

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi
  0000b	c3		 ret	 0
??0?$map@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> > >::map<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> > >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::~_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >, COMDAT
; _this$ = esi

; 392  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Tidy
??1?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::~_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ??0?$map@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::map<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> > >::map<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> > >, COMDAT
; _this$ = eax

; 102  : 		{	// construct empty map from defaults

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax
  00003	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Init

; 103  : 		}

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi
  0000b	c3		 ret	 0
??0?$map@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> > >::map<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> > >
_TEXT	ENDS
PUBLIC	?Warning@MusicFile@@QAEXQBG@Z			; MusicFile::Warning
; Function compile flags: /Ogsy
; File f:\nes\nsdl\src\nsc\musicfile.cpp
_TEXT	SEGMENT
_msg$ = 8						; size = 4
?Warning@MusicFile@@QAEXQBG@Z PROC NEAR			; MusicFile::Warning

; 1119 : 	//t@CAs\
; 1120 : 	if(cOptionSW->fErr == true){

  0015f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cOptionSW@@3PAVOPSW@@A ; cOptionSW
  00164	80 78 01 01	 cmp	 BYTE PTR [eax+1], 1

; 1121 : 		_CERR << _T("[WARNING] : ") << msg << endl;

  00168	ff 74 24 04	 push	 DWORD PTR _msg$[esp-4]
  0016c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BK@BNOPLHAN@?$AA?$FL?$AAW?$AAA?$AAR?$AAN?$AAI?$AAN?$AAG?$AA?$FN?$AA?5?$AA?3?$AA?5?$AA?$AA@
  00171	75 07		 jne	 SHORT $L25683
  00173	68 00 00 00 00	 push	 OFFSET FLAT:?wcerr@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A ; std::wcerr

; 1122 : 	} else {

  00178	eb 05		 jmp	 SHORT $L76326
$L25683:

; 1123 : 		_COUT << _T("[WARNING] : ") << msg << endl;

  0017a	68 00 00 00 00	 push	 OFFSET FLAT:?wcout@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A ; std::wcout
$L76326:
  0017f	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  00184	59		 pop	 ecx
  00185	59		 pop	 ecx
  00186	50		 push	 eax
  00187	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  0018c	50		 push	 eax
  0018d	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl
  00192	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1124 : 	}
; 1125 : }

  00195	c2 04 00	 ret	 4
?Warning@MusicFile@@QAEXQBG@Z ENDP			; MusicFile::Warning
_TEXT	ENDS
PUBLIC	?Err@MusicFile@@QAEXQBG@Z			; MusicFile::Err
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_msg$ = 8						; size = 4
?Err@MusicFile@@QAEXQBG@Z PROC NEAR			; MusicFile::Err

; 1099 : 	if(cOptionSW->fErr == true){

  00198	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cOptionSW@@3PAVOPSW@@A ; cOptionSW
  0019d	80 78 01 01	 cmp	 BYTE PTR [eax+1], 1

; 1100 : 		_CERR << _T("[ ERROR ] : ") << msg << endl;

  001a1	ff 74 24 04	 push	 DWORD PTR _msg$[esp-4]
  001a5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BK@KGHBAMLI@?$AA?$FL?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AA?$FN?$AA?5?$AA?3?$AA?5?$AA?$AA@
  001aa	75 07		 jne	 SHORT $L25672
  001ac	68 00 00 00 00	 push	 OFFSET FLAT:?wcerr@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A ; std::wcerr

; 1101 : 	} else {

  001b1	eb 05		 jmp	 SHORT $L76337
$L25672:

; 1102 : 		_COUT << _T("[ ERROR ] : ") << msg << endl;

  001b3	68 00 00 00 00	 push	 OFFSET FLAT:?wcout@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A ; std::wcout
$L76337:
  001b8	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  001bd	59		 pop	 ecx
  001be	59		 pop	 ecx
  001bf	50		 push	 eax
  001c0	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  001c5	50		 push	 eax
  001c6	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl

; 1103 : 	}
; 1104 : 
; 1105 : 	//I
; 1106 : 	nsc_exit(EXIT_FAILURE);

  001cb	33 c0		 xor	 eax, eax
  001cd	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d0	40		 inc	 eax
  001d1	e8 00 00 00 00	 call	 ?nsc_exit@@YAXH@Z	; nsc_exit
$L76338:
$L76336:
  001d6	cc		 int	 3
?Err@MusicFile@@QAEXQBG@Z ENDP				; MusicFile::Err
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??1?$map@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$map@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::map<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> > >::~map<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> > >, COMDAT
; _this$ = esi
  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Tidy
??1?$map@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> > >::~map<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> > >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??1?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::map<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> > >::~map<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> > >, COMDAT
; _this$ = esi
  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Tidy
??1?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> > >::~map<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> > >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??1?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::map<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> > >::~map<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> > >, COMDAT
; _this$ = esi
  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Tidy
??1?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> > >::~map<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> > >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??1?$map@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$map@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::map<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> > >::~map<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> > >, COMDAT
; _this$ = esi
  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Tidy
??1?$map@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> > >::~map<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> > >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??1?$map@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$map@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::map<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> > >::~map<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> > >, COMDAT
; _this$ = esi
  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Tidy
??1?$map@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> > >::~map<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> > >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??1?$map@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$map@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::map<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> > >::~map<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> > >, COMDAT
; _this$ = esi
  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Tidy
??1?$map@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> > >::~map<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> > >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??1?$map@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$map@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::map<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> > >::~map<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> > >, COMDAT
; _this$ = esi
  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Tidy
??1?$map@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> > >::~map<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> > >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??1?$map@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$map@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::map<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> > >::~map<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> > >, COMDAT
; _this$ = esi
  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Tidy
??1?$map@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> > >::~map<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T89626	DD	0ffffffffH
	DD	FLAT:$L89356
$T89618	DD	019930520H
	DD	01H
	DD	FLAT:$T89626
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVSub@@@2@@Z
_TEXT	SEGMENT
$T89354 = -80						; size = 40
$T89355 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Val$ = 16						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVSub@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Insert, COMDAT
; _this$ = edi
; __Wherenode$ = ecx

; 911  : 		{	// add node with value next to _Wherenode, to left if _Addnode

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVSub@@@2@@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 44	 sub	 esp, 68			; 00000044H

; 912  : 		if (max_size() - 1 <= _Mysize)

  0000d	81 7f 08 fe ff
	ff 1f		 cmp	 DWORD PTR [edi+8], 536870910 ; 1ffffffeH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	72 32		 jb	 SHORT $L89378

; 913  : 			_THROW(length_error, "map/set<T> too long");

  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4d d8	 lea	 ecx, DWORD PTR $T89355[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00027	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002b	8d 45 d8	 lea	 eax, DWORD PTR $T89355[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d b0	 lea	 ecx, DWORD PTR $T89354[ebp]
  00032	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00037	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  0003c	8d 45 b0	 lea	 eax, DWORD PTR $T89354[ebp]
  0003f	50		 push	 eax
  00040	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T89354[ebp], OFFSET FLAT:??_7length_error@std@@6B@
  00047	e8 00 00 00 00	 call	 __CxxThrowException@8
$L89627:
$L89378:

; 914  : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 915  : 			_Val, _Red);

  0004c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0004f	6a 00		 push	 0
  00051	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  00054	50		 push	 eax
  00055	56		 push	 esi
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVSub@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Buynode

; 916  : 
; 917  : 		++_Mysize;

  0005c	ff 47 08	 inc	 DWORD PTR [edi+8]
  0005f	8b d8		 mov	 ebx, eax

; 918  : 		if (_Wherenode == _Myhead)

  00061	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00064	3b f0		 cmp	 esi, eax
  00066	75 0d		 jne	 SHORT $L29721

; 919  : 			{	// first node in tree, just set head values
; 920  : 			_Root() = _Newnode;

  00068	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 921  : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

  0006b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0006e	89 18		 mov	 DWORD PTR [eax], ebx
  00070	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 922  : 			}
; 923  : 		else if (_Addleft)

  00073	eb 1e		 jmp	 SHORT $L89622
$L29721:
  00075	80 7d 0c 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  00079	74 0d		 je	 SHORT $L29723

; 924  : 			{	// add to left of _Wherenode
; 925  : 			_Left(_Wherenode) = _Newnode;

  0007b	89 1e		 mov	 DWORD PTR [esi], ebx

; 926  : 			if (_Wherenode == _Lmost())

  0007d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00080	3b 30		 cmp	 esi, DWORD PTR [eax]
  00082	75 12		 jne	 SHORT $L29726

; 927  : 				_Lmost() = _Newnode;

  00084	89 18		 mov	 DWORD PTR [eax], ebx

; 928  : 			}
; 929  : 		else

  00086	eb 0e		 jmp	 SHORT $L29726
$L29723:

; 930  : 			{	// add to right of _Wherenode
; 931  : 			_Right(_Wherenode) = _Newnode;

  00088	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 932  : 			if (_Wherenode == _Rmost())

  0008b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0008e	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00091	75 03		 jne	 SHORT $L29726
$L89622:

; 933  : 				_Rmost() = _Newnode;

  00093	89 58 08	 mov	 DWORD PTR [eax+8], ebx
$L29726:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

  00096	8b f3		 mov	 esi, ebx
  00098	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0009b	e9 8f 00 00 00	 jmp	 $L89624
$L29729:

; 937  : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

  000a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a2	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a5	8b 12		 mov	 edx, DWORD PTR [edx]
  000a7	3b ca		 cmp	 ecx, edx
  000a9	75 52		 jne	 SHORT $L29731

; 938  : 				{	// fixup red-red in left subtree
; 939  : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

  000ab	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ae	8b 52 08	 mov	 edx, DWORD PTR [edx+8]

; 940  : 				if (_Color(_Wherenode) == _Red)

  000b1	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0
  000b5	75 1a		 jne	 SHORT $L29732
$L89625:

; 941  : 					{	// parent has two red children, blacken both
; 942  : 					_Color(_Parent(_Pnode)) = _Black;

  000b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b9	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1

; 943  : 					_Color(_Wherenode) = _Black;

  000bd	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1

; 944  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  000c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c3	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000c6	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0

; 945  : 					_Pnode = _Parent(_Parent(_Pnode));

  000ca	8b 00		 mov	 eax, DWORD PTR [eax]
  000cc	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 946  : 					}
; 947  : 				else

  000cf	eb 5b		 jmp	 SHORT $L29737
$L29732:

; 948  : 					{	// parent has red and black children
; 949  : 					if (_Pnode == _Right(_Parent(_Pnode)))

  000d1	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  000d4	75 08		 jne	 SHORT $L29734

; 950  : 						{	// rotate right child to left
; 951  : 						_Pnode = _Parent(_Pnode);
; 952  : 						_Lrotate(_Pnode);

  000d6	57		 push	 edi
  000d7	8b f1		 mov	 esi, ecx
  000d9	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Lrotate
$L29734:

; 953  : 						}
; 954  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  000de	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e1	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 955  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  000e5	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000eb	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0

; 956  : 					_Rrotate(_Parent(_Parent(_Pnode)));

  000ef	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000f2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f5	57		 push	 edi
  000f6	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Rrotate

; 957  : 					}
; 958  : 				}
; 959  : 			else

  000fb	eb 2f		 jmp	 SHORT $L29737
$L29731:

; 960  : 				{	// fixup red-red in right subtree
; 961  : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));
; 962  : 				if (_Color(_Wherenode) == _Red)

  000fd	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0

; 963  : 					{	// parent has two red children, blacken both
; 964  : 					_Color(_Parent(_Pnode)) = _Black;
; 965  : 					_Color(_Wherenode) = _Black;
; 966  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;
; 967  : 					_Pnode = _Parent(_Parent(_Pnode));
; 968  : 					}
; 969  : 				else

  00101	74 b4		 je	 SHORT $L89625

; 970  : 					{	// parent has red and black children
; 971  : 					if (_Pnode == _Left(_Parent(_Pnode)))

  00103	3b 31		 cmp	 esi, DWORD PTR [ecx]
  00105	75 08		 jne	 SHORT $L29738

; 972  : 						{	// rotate left child to right
; 973  : 						_Pnode = _Parent(_Pnode);
; 974  : 						_Rrotate(_Pnode);

  00107	57		 push	 edi
  00108	8b f1		 mov	 esi, ecx
  0010a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Rrotate
$L29738:

; 975  : 						}
; 976  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  0010f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00112	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 977  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  00116	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00119	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0011c	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0

; 978  : 					_Lrotate(_Parent(_Parent(_Pnode)));

  00120	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00123	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00126	57		 push	 edi
  00127	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Lrotate
$L29737:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

  0012c	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
$L89624:
  0012f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00131	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00135	0f 84 65 ff ff
	ff		 je	 $L29729

; 979  : 					}
; 980  : 				}
; 981  : 
; 982  : 		_Color(_Root()) = _Black;	// root is always black

  0013b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 983  : 		return (_TREE_ITERATOR(_Newnode));
; 984  : 		}

  00141	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00144	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  00148	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0014b	89 18		 mov	 DWORD PTR [eax], ebx
  0014d	5e		 pop	 esi
  0014e	5b		 pop	 ebx
  0014f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00156	c9		 leave
  00157	c2 0c 00	 ret	 12			; 0000000cH
$L89621:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L89356:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T89355[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVSub@@@2@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T89618
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVSub@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Insert
; Function compile flags: /Ogsy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVSub@@@2@@Z
_TEXT	SEGMENT
__Where$29673 = -8					; size = 4
__Addleft$ = -4						; size = 1
$T89640 = 8						; size = 4
__Val$ = 8						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVSub@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::insert, COMDAT
; _this$ = ebx
; ___$ReturnUdt$ = esi

; 477  : 		{	// try to insert node with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 478  : 		_Nodeptr _Trynode = _Root();

  00005	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00008	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  0000b	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0000f	57		 push	 edi
  00010	8b f9		 mov	 edi, ecx
  00012	c6 45 fc 01	 mov	 BYTE PTR __Addleft$[ebp], 1
  00016	75 21		 jne	 SHORT $L89765

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  0001b	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L29662:
  0001d	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00020	8b f8		 mov	 edi, eax
  00022	0f 9c 45 fc	 setl	 BYTE PTR __Addleft$[ebp]
  00026	80 7d fc 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0002a	74 04		 je	 SHORT $L89632

; 482  : 			{	// look for leaf to insert before (_Addleft) or after
; 483  : 			_Wherenode = _Trynode;
; 484  : 			_Addleft = this->comp(this->_Kfn(_Val), _Key(_Trynode));
; 485  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	eb 03		 jmp	 SHORT $L89633
$L89632:
  00030	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$L89633:

; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  00033	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00037	74 e4		 je	 SHORT $L29662
$L89765:

; 486  : 			}
; 487  : 
; 488  : 		if (this->_Multi)
; 489  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 490  : 		else
; 491  : 			{	// insert only if unique
; 492  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);
; 493  : 			if (!_Addleft)

  00039	80 7d fc 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0003d	8b c7		 mov	 eax, edi
  0003f	89 45 f8	 mov	 DWORD PTR __Where$29673[ebp], eax
  00042	74 19		 je	 SHORT $L89732

; 494  : 				;	// need to test if insert after is okay
; 495  : 			else if (_Where == begin())

  00044	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00047	3b 38		 cmp	 edi, DWORD PTR [eax]
  00049	75 07		 jne	 SHORT $L29678

; 496  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

  0004b	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  0004e	6a 01		 push	 1
  00050	eb 19		 jmp	 SHORT $L89767
$L29678:

; 497  : 			else
; 498  : 				--_Where;	// need to test if insert before is okay

  00052	8d 4d f8	 lea	 ecx, DWORD PTR __Where$29673[ebp]
  00055	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Dec
  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Where$29673[ebp]
$L89732:

; 499  : 
; 500  : 			if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))

  0005d	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00063	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00065	7d 19		 jge	 SHORT $L29683

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  00067	51		 push	 ecx
  00068	ff 75 fc	 push	 DWORD PTR __Addleft$[ebp]
$L89767:
  0006b	8d 45 08	 lea	 eax, DWORD PTR $T89640[ebp]
  0006e	8b cf		 mov	 ecx, edi
  00070	50		 push	 eax
  00071	8b fb		 mov	 edi, ebx
  00073	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVSub@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Insert
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
  0007e	eb 04		 jmp	 SHORT $L89766
$L29683:

; 502  : 			else
; 503  : 				return (_Pairib(_Where, false));

  00080	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
$L89766:
  00084	89 06		 mov	 DWORD PTR [esi], eax
  00086	8b c6		 mov	 eax, esi
  00088	5f		 pop	 edi

; 504  : 			}
; 505  : 		}

  00089	c9		 leave
  0008a	c2 04 00	 ret	 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVSub@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::insert
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T90042	DD	0ffffffffH
	DD	FLAT:$L89772
$T90034	DD	019930520H
	DD	01H
	DD	FLAT:$T90042
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVSE@@@2@@Z
_TEXT	SEGMENT
$T89770 = -80						; size = 40
$T89771 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Val$ = 16						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVSE@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Insert, COMDAT
; _this$ = edi
; __Wherenode$ = ecx

; 911  : 		{	// add node with value next to _Wherenode, to left if _Addnode

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVSE@@@2@@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 44	 sub	 esp, 68			; 00000044H

; 912  : 		if (max_size() - 1 <= _Mysize)

  0000d	81 7f 08 fe ff
	ff 1f		 cmp	 DWORD PTR [edi+8], 536870910 ; 1ffffffeH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	72 32		 jb	 SHORT $L89794

; 913  : 			_THROW(length_error, "map/set<T> too long");

  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4d d8	 lea	 ecx, DWORD PTR $T89771[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00027	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002b	8d 45 d8	 lea	 eax, DWORD PTR $T89771[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d b0	 lea	 ecx, DWORD PTR $T89770[ebp]
  00032	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00037	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  0003c	8d 45 b0	 lea	 eax, DWORD PTR $T89770[ebp]
  0003f	50		 push	 eax
  00040	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T89770[ebp], OFFSET FLAT:??_7length_error@std@@6B@
  00047	e8 00 00 00 00	 call	 __CxxThrowException@8
$L90043:
$L89794:

; 914  : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 915  : 			_Val, _Red);

  0004c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0004f	6a 00		 push	 0
  00051	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  00054	50		 push	 eax
  00055	56		 push	 esi
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVSE@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Buynode

; 916  : 
; 917  : 		++_Mysize;

  0005c	ff 47 08	 inc	 DWORD PTR [edi+8]
  0005f	8b d8		 mov	 ebx, eax

; 918  : 		if (_Wherenode == _Myhead)

  00061	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00064	3b f0		 cmp	 esi, eax
  00066	75 0d		 jne	 SHORT $L29586

; 919  : 			{	// first node in tree, just set head values
; 920  : 			_Root() = _Newnode;

  00068	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 921  : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

  0006b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0006e	89 18		 mov	 DWORD PTR [eax], ebx
  00070	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 922  : 			}
; 923  : 		else if (_Addleft)

  00073	eb 1e		 jmp	 SHORT $L90038
$L29586:
  00075	80 7d 0c 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  00079	74 0d		 je	 SHORT $L29588

; 924  : 			{	// add to left of _Wherenode
; 925  : 			_Left(_Wherenode) = _Newnode;

  0007b	89 1e		 mov	 DWORD PTR [esi], ebx

; 926  : 			if (_Wherenode == _Lmost())

  0007d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00080	3b 30		 cmp	 esi, DWORD PTR [eax]
  00082	75 12		 jne	 SHORT $L29591

; 927  : 				_Lmost() = _Newnode;

  00084	89 18		 mov	 DWORD PTR [eax], ebx

; 928  : 			}
; 929  : 		else

  00086	eb 0e		 jmp	 SHORT $L29591
$L29588:

; 930  : 			{	// add to right of _Wherenode
; 931  : 			_Right(_Wherenode) = _Newnode;

  00088	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 932  : 			if (_Wherenode == _Rmost())

  0008b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0008e	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00091	75 03		 jne	 SHORT $L29591
$L90038:

; 933  : 				_Rmost() = _Newnode;

  00093	89 58 08	 mov	 DWORD PTR [eax+8], ebx
$L29591:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

  00096	8b f3		 mov	 esi, ebx
  00098	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0009b	e9 8f 00 00 00	 jmp	 $L90040
$L29594:

; 937  : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

  000a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a2	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a5	8b 12		 mov	 edx, DWORD PTR [edx]
  000a7	3b ca		 cmp	 ecx, edx
  000a9	75 52		 jne	 SHORT $L29596

; 938  : 				{	// fixup red-red in left subtree
; 939  : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

  000ab	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ae	8b 52 08	 mov	 edx, DWORD PTR [edx+8]

; 940  : 				if (_Color(_Wherenode) == _Red)

  000b1	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0
  000b5	75 1a		 jne	 SHORT $L29597
$L90041:

; 941  : 					{	// parent has two red children, blacken both
; 942  : 					_Color(_Parent(_Pnode)) = _Black;

  000b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b9	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1

; 943  : 					_Color(_Wherenode) = _Black;

  000bd	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1

; 944  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  000c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c3	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000c6	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0

; 945  : 					_Pnode = _Parent(_Parent(_Pnode));

  000ca	8b 00		 mov	 eax, DWORD PTR [eax]
  000cc	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 946  : 					}
; 947  : 				else

  000cf	eb 5b		 jmp	 SHORT $L29602
$L29597:

; 948  : 					{	// parent has red and black children
; 949  : 					if (_Pnode == _Right(_Parent(_Pnode)))

  000d1	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  000d4	75 08		 jne	 SHORT $L29599

; 950  : 						{	// rotate right child to left
; 951  : 						_Pnode = _Parent(_Pnode);
; 952  : 						_Lrotate(_Pnode);

  000d6	57		 push	 edi
  000d7	8b f1		 mov	 esi, ecx
  000d9	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Lrotate
$L29599:

; 953  : 						}
; 954  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  000de	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e1	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 955  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  000e5	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000eb	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0

; 956  : 					_Rrotate(_Parent(_Parent(_Pnode)));

  000ef	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000f2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f5	57		 push	 edi
  000f6	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Rrotate

; 957  : 					}
; 958  : 				}
; 959  : 			else

  000fb	eb 2f		 jmp	 SHORT $L29602
$L29596:

; 960  : 				{	// fixup red-red in right subtree
; 961  : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));
; 962  : 				if (_Color(_Wherenode) == _Red)

  000fd	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0

; 963  : 					{	// parent has two red children, blacken both
; 964  : 					_Color(_Parent(_Pnode)) = _Black;
; 965  : 					_Color(_Wherenode) = _Black;
; 966  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;
; 967  : 					_Pnode = _Parent(_Parent(_Pnode));
; 968  : 					}
; 969  : 				else

  00101	74 b4		 je	 SHORT $L90041

; 970  : 					{	// parent has red and black children
; 971  : 					if (_Pnode == _Left(_Parent(_Pnode)))

  00103	3b 31		 cmp	 esi, DWORD PTR [ecx]
  00105	75 08		 jne	 SHORT $L29603

; 972  : 						{	// rotate left child to right
; 973  : 						_Pnode = _Parent(_Pnode);
; 974  : 						_Rrotate(_Pnode);

  00107	57		 push	 edi
  00108	8b f1		 mov	 esi, ecx
  0010a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Rrotate
$L29603:

; 975  : 						}
; 976  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  0010f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00112	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 977  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  00116	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00119	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0011c	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0

; 978  : 					_Lrotate(_Parent(_Parent(_Pnode)));

  00120	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00123	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00126	57		 push	 edi
  00127	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Lrotate
$L29602:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

  0012c	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
$L90040:
  0012f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00131	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00135	0f 84 65 ff ff
	ff		 je	 $L29594

; 979  : 					}
; 980  : 				}
; 981  : 
; 982  : 		_Color(_Root()) = _Black;	// root is always black

  0013b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 983  : 		return (_TREE_ITERATOR(_Newnode));
; 984  : 		}

  00141	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00144	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  00148	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0014b	89 18		 mov	 DWORD PTR [eax], ebx
  0014d	5e		 pop	 esi
  0014e	5b		 pop	 ebx
  0014f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00156	c9		 leave
  00157	c2 0c 00	 ret	 12			; 0000000cH
$L90037:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L89772:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T89771[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVSE@@@2@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T90034
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVSE@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Insert
; Function compile flags: /Ogsy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVSE@@@2@@Z
_TEXT	SEGMENT
__Where$29538 = -8					; size = 4
__Addleft$ = -4						; size = 1
$T90056 = 8						; size = 4
__Val$ = 8						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVSE@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::insert, COMDAT
; _this$ = ebx
; ___$ReturnUdt$ = esi

; 477  : 		{	// try to insert node with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 478  : 		_Nodeptr _Trynode = _Root();

  00005	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00008	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  0000b	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0000f	57		 push	 edi
  00010	8b f9		 mov	 edi, ecx
  00012	c6 45 fc 01	 mov	 BYTE PTR __Addleft$[ebp], 1
  00016	75 21		 jne	 SHORT $L90181

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  0001b	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L29527:
  0001d	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00020	8b f8		 mov	 edi, eax
  00022	0f 9c 45 fc	 setl	 BYTE PTR __Addleft$[ebp]
  00026	80 7d fc 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0002a	74 04		 je	 SHORT $L90048

; 482  : 			{	// look for leaf to insert before (_Addleft) or after
; 483  : 			_Wherenode = _Trynode;
; 484  : 			_Addleft = this->comp(this->_Kfn(_Val), _Key(_Trynode));
; 485  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	eb 03		 jmp	 SHORT $L90049
$L90048:
  00030	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$L90049:

; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  00033	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00037	74 e4		 je	 SHORT $L29527
$L90181:

; 486  : 			}
; 487  : 
; 488  : 		if (this->_Multi)
; 489  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 490  : 		else
; 491  : 			{	// insert only if unique
; 492  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);
; 493  : 			if (!_Addleft)

  00039	80 7d fc 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0003d	8b c7		 mov	 eax, edi
  0003f	89 45 f8	 mov	 DWORD PTR __Where$29538[ebp], eax
  00042	74 19		 je	 SHORT $L90148

; 494  : 				;	// need to test if insert after is okay
; 495  : 			else if (_Where == begin())

  00044	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00047	3b 38		 cmp	 edi, DWORD PTR [eax]
  00049	75 07		 jne	 SHORT $L29543

; 496  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

  0004b	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  0004e	6a 01		 push	 1
  00050	eb 19		 jmp	 SHORT $L90183
$L29543:

; 497  : 			else
; 498  : 				--_Where;	// need to test if insert before is okay

  00052	8d 4d f8	 lea	 ecx, DWORD PTR __Where$29538[ebp]
  00055	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::_Dec
  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Where$29538[ebp]
$L90148:

; 499  : 
; 500  : 			if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))

  0005d	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00063	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00065	7d 19		 jge	 SHORT $L29548

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  00067	51		 push	 ecx
  00068	ff 75 fc	 push	 DWORD PTR __Addleft$[ebp]
$L90183:
  0006b	8d 45 08	 lea	 eax, DWORD PTR $T90056[ebp]
  0006e	8b cf		 mov	 ecx, edi
  00070	50		 push	 eax
  00071	8b fb		 mov	 edi, ebx
  00073	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVSE@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Insert
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
  0007e	eb 04		 jmp	 SHORT $L90182
$L29548:

; 502  : 			else
; 503  : 				return (_Pairib(_Where, false));

  00080	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
$L90182:
  00084	89 06		 mov	 DWORD PTR [esi], eax
  00086	8b c6		 mov	 eax, esi
  00088	5f		 pop	 edi

; 504  : 			}
; 505  : 		}

  00089	c9		 leave
  0008a	c2 04 00	 ret	 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVSE@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::insert
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T90458	DD	0ffffffffH
	DD	FLAT:$L90188
$T90450	DD	019930520H
	DD	01H
	DD	FLAT:$T90458
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVBGM@@@2@@Z
_TEXT	SEGMENT
$T90186 = -80						; size = 40
$T90187 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Val$ = 16						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVBGM@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Insert, COMDAT
; _this$ = edi
; __Wherenode$ = ecx

; 911  : 		{	// add node with value next to _Wherenode, to left if _Addnode

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVBGM@@@2@@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 44	 sub	 esp, 68			; 00000044H

; 912  : 		if (max_size() - 1 <= _Mysize)

  0000d	81 7f 08 fe ff
	ff 1f		 cmp	 DWORD PTR [edi+8], 536870910 ; 1ffffffeH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	72 32		 jb	 SHORT $L90211

; 913  : 			_THROW(length_error, "map/set<T> too long");

  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4d d8	 lea	 ecx, DWORD PTR $T90187[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00027	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002b	8d 45 d8	 lea	 eax, DWORD PTR $T90187[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d b0	 lea	 ecx, DWORD PTR $T90186[ebp]
  00032	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00037	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  0003c	8d 45 b0	 lea	 eax, DWORD PTR $T90186[ebp]
  0003f	50		 push	 eax
  00040	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T90186[ebp], OFFSET FLAT:??_7length_error@std@@6B@
  00047	e8 00 00 00 00	 call	 __CxxThrowException@8
$L90459:
$L90211:

; 914  : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 915  : 			_Val, _Red);

  0004c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0004f	6a 00		 push	 0
  00051	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  00054	50		 push	 eax
  00055	56		 push	 esi
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVBGM@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Buynode

; 916  : 
; 917  : 		++_Mysize;

  0005c	ff 47 08	 inc	 DWORD PTR [edi+8]
  0005f	8b d8		 mov	 ebx, eax

; 918  : 		if (_Wherenode == _Myhead)

  00061	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00064	3b f0		 cmp	 esi, eax
  00066	75 0d		 jne	 SHORT $L29445

; 919  : 			{	// first node in tree, just set head values
; 920  : 			_Root() = _Newnode;

  00068	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 921  : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

  0006b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0006e	89 18		 mov	 DWORD PTR [eax], ebx
  00070	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 922  : 			}
; 923  : 		else if (_Addleft)

  00073	eb 1e		 jmp	 SHORT $L90454
$L29445:
  00075	80 7d 0c 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  00079	74 0d		 je	 SHORT $L29447

; 924  : 			{	// add to left of _Wherenode
; 925  : 			_Left(_Wherenode) = _Newnode;

  0007b	89 1e		 mov	 DWORD PTR [esi], ebx

; 926  : 			if (_Wherenode == _Lmost())

  0007d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00080	3b 30		 cmp	 esi, DWORD PTR [eax]
  00082	75 12		 jne	 SHORT $L29450

; 927  : 				_Lmost() = _Newnode;

  00084	89 18		 mov	 DWORD PTR [eax], ebx

; 928  : 			}
; 929  : 		else

  00086	eb 0e		 jmp	 SHORT $L29450
$L29447:

; 930  : 			{	// add to right of _Wherenode
; 931  : 			_Right(_Wherenode) = _Newnode;

  00088	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 932  : 			if (_Wherenode == _Rmost())

  0008b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0008e	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00091	75 03		 jne	 SHORT $L29450
$L90454:

; 933  : 				_Rmost() = _Newnode;

  00093	89 58 08	 mov	 DWORD PTR [eax+8], ebx
$L29450:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

  00096	8b f3		 mov	 esi, ebx
  00098	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0009b	e9 8f 00 00 00	 jmp	 $L90456
$L29453:

; 937  : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

  000a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a2	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a5	8b 12		 mov	 edx, DWORD PTR [edx]
  000a7	3b ca		 cmp	 ecx, edx
  000a9	75 52		 jne	 SHORT $L29455

; 938  : 				{	// fixup red-red in left subtree
; 939  : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

  000ab	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ae	8b 52 08	 mov	 edx, DWORD PTR [edx+8]

; 940  : 				if (_Color(_Wherenode) == _Red)

  000b1	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0
  000b5	75 1a		 jne	 SHORT $L29456
$L90457:

; 941  : 					{	// parent has two red children, blacken both
; 942  : 					_Color(_Parent(_Pnode)) = _Black;

  000b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b9	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1

; 943  : 					_Color(_Wherenode) = _Black;

  000bd	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1

; 944  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  000c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c3	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000c6	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0

; 945  : 					_Pnode = _Parent(_Parent(_Pnode));

  000ca	8b 00		 mov	 eax, DWORD PTR [eax]
  000cc	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 946  : 					}
; 947  : 				else

  000cf	eb 5b		 jmp	 SHORT $L29461
$L29456:

; 948  : 					{	// parent has red and black children
; 949  : 					if (_Pnode == _Right(_Parent(_Pnode)))

  000d1	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  000d4	75 08		 jne	 SHORT $L29458

; 950  : 						{	// rotate right child to left
; 951  : 						_Pnode = _Parent(_Pnode);
; 952  : 						_Lrotate(_Pnode);

  000d6	57		 push	 edi
  000d7	8b f1		 mov	 esi, ecx
  000d9	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Lrotate
$L29458:

; 953  : 						}
; 954  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  000de	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e1	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 955  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  000e5	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000eb	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0

; 956  : 					_Rrotate(_Parent(_Parent(_Pnode)));

  000ef	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000f2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f5	57		 push	 edi
  000f6	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Rrotate

; 957  : 					}
; 958  : 				}
; 959  : 			else

  000fb	eb 2f		 jmp	 SHORT $L29461
$L29455:

; 960  : 				{	// fixup red-red in right subtree
; 961  : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));
; 962  : 				if (_Color(_Wherenode) == _Red)

  000fd	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0

; 963  : 					{	// parent has two red children, blacken both
; 964  : 					_Color(_Parent(_Pnode)) = _Black;
; 965  : 					_Color(_Wherenode) = _Black;
; 966  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;
; 967  : 					_Pnode = _Parent(_Parent(_Pnode));
; 968  : 					}
; 969  : 				else

  00101	74 b4		 je	 SHORT $L90457

; 970  : 					{	// parent has red and black children
; 971  : 					if (_Pnode == _Left(_Parent(_Pnode)))

  00103	3b 31		 cmp	 esi, DWORD PTR [ecx]
  00105	75 08		 jne	 SHORT $L29462

; 972  : 						{	// rotate left child to right
; 973  : 						_Pnode = _Parent(_Pnode);
; 974  : 						_Rrotate(_Pnode);

  00107	57		 push	 edi
  00108	8b f1		 mov	 esi, ecx
  0010a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Rrotate
$L29462:

; 975  : 						}
; 976  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  0010f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00112	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 977  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  00116	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00119	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0011c	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0

; 978  : 					_Lrotate(_Parent(_Parent(_Pnode)));

  00120	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00123	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00126	57		 push	 edi
  00127	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Lrotate
$L29461:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

  0012c	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
$L90456:
  0012f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00131	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00135	0f 84 65 ff ff
	ff		 je	 $L29453

; 979  : 					}
; 980  : 				}
; 981  : 
; 982  : 		_Color(_Root()) = _Black;	// root is always black

  0013b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 983  : 		return (_TREE_ITERATOR(_Newnode));
; 984  : 		}

  00141	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00144	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  00148	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0014b	89 18		 mov	 DWORD PTR [eax], ebx
  0014d	5e		 pop	 esi
  0014e	5b		 pop	 ebx
  0014f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00156	c9		 leave
  00157	c2 0c 00	 ret	 12			; 0000000cH
$L90453:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L90188:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T90187[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVBGM@@@2@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T90450
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVBGM@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Insert
; Function compile flags: /Ogsy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVBGM@@@2@@Z
_TEXT	SEGMENT
__Where$29397 = -8					; size = 4
__Addleft$ = -4						; size = 1
$T90472 = 8						; size = 4
__Val$ = 8						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVBGM@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::insert, COMDAT
; _this$ = ebx
; ___$ReturnUdt$ = esi

; 477  : 		{	// try to insert node with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 478  : 		_Nodeptr _Trynode = _Root();

  00005	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00008	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  0000b	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0000f	57		 push	 edi
  00010	8b f9		 mov	 edi, ecx
  00012	c6 45 fc 01	 mov	 BYTE PTR __Addleft$[ebp], 1
  00016	75 21		 jne	 SHORT $L90597

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  0001b	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L29386:
  0001d	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00020	8b f8		 mov	 edi, eax
  00022	0f 9c 45 fc	 setl	 BYTE PTR __Addleft$[ebp]
  00026	80 7d fc 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0002a	74 04		 je	 SHORT $L90464

; 482  : 			{	// look for leaf to insert before (_Addleft) or after
; 483  : 			_Wherenode = _Trynode;
; 484  : 			_Addleft = this->comp(this->_Kfn(_Val), _Key(_Trynode));
; 485  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	eb 03		 jmp	 SHORT $L90465
$L90464:
  00030	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$L90465:

; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  00033	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00037	74 e4		 je	 SHORT $L29386
$L90597:

; 486  : 			}
; 487  : 
; 488  : 		if (this->_Multi)
; 489  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 490  : 		else
; 491  : 			{	// insert only if unique
; 492  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);
; 493  : 			if (!_Addleft)

  00039	80 7d fc 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0003d	8b c7		 mov	 eax, edi
  0003f	89 45 f8	 mov	 DWORD PTR __Where$29397[ebp], eax
  00042	74 19		 je	 SHORT $L90564

; 494  : 				;	// need to test if insert after is okay
; 495  : 			else if (_Where == begin())

  00044	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00047	3b 38		 cmp	 edi, DWORD PTR [eax]
  00049	75 07		 jne	 SHORT $L29402

; 496  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

  0004b	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  0004e	6a 01		 push	 1
  00050	eb 19		 jmp	 SHORT $L90599
$L29402:

; 497  : 			else
; 498  : 				--_Where;	// need to test if insert before is okay

  00052	8d 4d f8	 lea	 ecx, DWORD PTR __Where$29397[ebp]
  00055	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::_Dec
  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Where$29397[ebp]
$L90564:

; 499  : 
; 500  : 			if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))

  0005d	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00063	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00065	7d 19		 jge	 SHORT $L29407

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  00067	51		 push	 ecx
  00068	ff 75 fc	 push	 DWORD PTR __Addleft$[ebp]
$L90599:
  0006b	8d 45 08	 lea	 eax, DWORD PTR $T90472[ebp]
  0006e	8b cf		 mov	 ecx, edi
  00070	50		 push	 eax
  00071	8b fb		 mov	 edi, ebx
  00073	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVBGM@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Insert
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
  0007e	eb 04		 jmp	 SHORT $L90598
$L29407:

; 502  : 			else
; 503  : 				return (_Pairib(_Where, false));

  00080	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
$L90598:
  00084	89 06		 mov	 DWORD PTR [esi], eax
  00086	8b c6		 mov	 eax, esi
  00088	5f		 pop	 edi

; 504  : 			}
; 505  : 		}

  00089	c9		 leave
  0008a	c2 04 00	 ret	 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVBGM@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::insert
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T90874	DD	0ffffffffH
	DD	FLAT:$L90604
$T90866	DD	019930520H
	DD	01H
	DD	FLAT:$T90874
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVEnvelop@@@2@@Z
_TEXT	SEGMENT
$T90602 = -80						; size = 40
$T90603 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Val$ = 16						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVEnvelop@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Insert, COMDAT
; _this$ = edi
; __Wherenode$ = ecx

; 911  : 		{	// add node with value next to _Wherenode, to left if _Addnode

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVEnvelop@@@2@@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 44	 sub	 esp, 68			; 00000044H

; 912  : 		if (max_size() - 1 <= _Mysize)

  0000d	81 7f 08 fe ff
	ff 1f		 cmp	 DWORD PTR [edi+8], 536870910 ; 1ffffffeH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	72 32		 jb	 SHORT $L90626

; 913  : 			_THROW(length_error, "map/set<T> too long");

  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4d d8	 lea	 ecx, DWORD PTR $T90603[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00027	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002b	8d 45 d8	 lea	 eax, DWORD PTR $T90603[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d b0	 lea	 ecx, DWORD PTR $T90602[ebp]
  00032	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00037	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  0003c	8d 45 b0	 lea	 eax, DWORD PTR $T90602[ebp]
  0003f	50		 push	 eax
  00040	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T90602[ebp], OFFSET FLAT:??_7length_error@std@@6B@
  00047	e8 00 00 00 00	 call	 __CxxThrowException@8
$L90875:
$L90626:

; 914  : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 915  : 			_Val, _Red);

  0004c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0004f	6a 00		 push	 0
  00051	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  00054	50		 push	 eax
  00055	56		 push	 esi
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVEnvelop@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Buynode

; 916  : 
; 917  : 		++_Mysize;

  0005c	ff 47 08	 inc	 DWORD PTR [edi+8]
  0005f	8b d8		 mov	 ebx, eax

; 918  : 		if (_Wherenode == _Myhead)

  00061	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00064	3b f0		 cmp	 esi, eax
  00066	75 0d		 jne	 SHORT $L29304

; 919  : 			{	// first node in tree, just set head values
; 920  : 			_Root() = _Newnode;

  00068	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 921  : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

  0006b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0006e	89 18		 mov	 DWORD PTR [eax], ebx
  00070	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 922  : 			}
; 923  : 		else if (_Addleft)

  00073	eb 1e		 jmp	 SHORT $L90870
$L29304:
  00075	80 7d 0c 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  00079	74 0d		 je	 SHORT $L29306

; 924  : 			{	// add to left of _Wherenode
; 925  : 			_Left(_Wherenode) = _Newnode;

  0007b	89 1e		 mov	 DWORD PTR [esi], ebx

; 926  : 			if (_Wherenode == _Lmost())

  0007d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00080	3b 30		 cmp	 esi, DWORD PTR [eax]
  00082	75 12		 jne	 SHORT $L29309

; 927  : 				_Lmost() = _Newnode;

  00084	89 18		 mov	 DWORD PTR [eax], ebx

; 928  : 			}
; 929  : 		else

  00086	eb 0e		 jmp	 SHORT $L29309
$L29306:

; 930  : 			{	// add to right of _Wherenode
; 931  : 			_Right(_Wherenode) = _Newnode;

  00088	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 932  : 			if (_Wherenode == _Rmost())

  0008b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0008e	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00091	75 03		 jne	 SHORT $L29309
$L90870:

; 933  : 				_Rmost() = _Newnode;

  00093	89 58 08	 mov	 DWORD PTR [eax+8], ebx
$L29309:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

  00096	8b f3		 mov	 esi, ebx
  00098	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0009b	e9 8f 00 00 00	 jmp	 $L90872
$L29312:

; 937  : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

  000a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a2	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a5	8b 12		 mov	 edx, DWORD PTR [edx]
  000a7	3b ca		 cmp	 ecx, edx
  000a9	75 52		 jne	 SHORT $L29314

; 938  : 				{	// fixup red-red in left subtree
; 939  : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

  000ab	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ae	8b 52 08	 mov	 edx, DWORD PTR [edx+8]

; 940  : 				if (_Color(_Wherenode) == _Red)

  000b1	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0
  000b5	75 1a		 jne	 SHORT $L29315
$L90873:

; 941  : 					{	// parent has two red children, blacken both
; 942  : 					_Color(_Parent(_Pnode)) = _Black;

  000b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b9	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1

; 943  : 					_Color(_Wherenode) = _Black;

  000bd	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1

; 944  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  000c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c3	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000c6	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0

; 945  : 					_Pnode = _Parent(_Parent(_Pnode));

  000ca	8b 00		 mov	 eax, DWORD PTR [eax]
  000cc	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 946  : 					}
; 947  : 				else

  000cf	eb 5b		 jmp	 SHORT $L29320
$L29315:

; 948  : 					{	// parent has red and black children
; 949  : 					if (_Pnode == _Right(_Parent(_Pnode)))

  000d1	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  000d4	75 08		 jne	 SHORT $L29317

; 950  : 						{	// rotate right child to left
; 951  : 						_Pnode = _Parent(_Pnode);
; 952  : 						_Lrotate(_Pnode);

  000d6	57		 push	 edi
  000d7	8b f1		 mov	 esi, ecx
  000d9	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Lrotate
$L29317:

; 953  : 						}
; 954  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  000de	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e1	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 955  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  000e5	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000eb	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0

; 956  : 					_Rrotate(_Parent(_Parent(_Pnode)));

  000ef	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000f2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f5	57		 push	 edi
  000f6	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Rrotate

; 957  : 					}
; 958  : 				}
; 959  : 			else

  000fb	eb 2f		 jmp	 SHORT $L29320
$L29314:

; 960  : 				{	// fixup red-red in right subtree
; 961  : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));
; 962  : 				if (_Color(_Wherenode) == _Red)

  000fd	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0

; 963  : 					{	// parent has two red children, blacken both
; 964  : 					_Color(_Parent(_Pnode)) = _Black;
; 965  : 					_Color(_Wherenode) = _Black;
; 966  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;
; 967  : 					_Pnode = _Parent(_Parent(_Pnode));
; 968  : 					}
; 969  : 				else

  00101	74 b4		 je	 SHORT $L90873

; 970  : 					{	// parent has red and black children
; 971  : 					if (_Pnode == _Left(_Parent(_Pnode)))

  00103	3b 31		 cmp	 esi, DWORD PTR [ecx]
  00105	75 08		 jne	 SHORT $L29321

; 972  : 						{	// rotate left child to right
; 973  : 						_Pnode = _Parent(_Pnode);
; 974  : 						_Rrotate(_Pnode);

  00107	57		 push	 edi
  00108	8b f1		 mov	 esi, ecx
  0010a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Rrotate
$L29321:

; 975  : 						}
; 976  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  0010f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00112	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 977  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  00116	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00119	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0011c	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0

; 978  : 					_Lrotate(_Parent(_Parent(_Pnode)));

  00120	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00123	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00126	57		 push	 edi
  00127	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Lrotate
$L29320:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

  0012c	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
$L90872:
  0012f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00131	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00135	0f 84 65 ff ff
	ff		 je	 $L29312

; 979  : 					}
; 980  : 				}
; 981  : 
; 982  : 		_Color(_Root()) = _Black;	// root is always black

  0013b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 983  : 		return (_TREE_ITERATOR(_Newnode));
; 984  : 		}

  00141	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00144	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  00148	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0014b	89 18		 mov	 DWORD PTR [eax], ebx
  0014d	5e		 pop	 esi
  0014e	5b		 pop	 ebx
  0014f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00156	c9		 leave
  00157	c2 0c 00	 ret	 12			; 0000000cH
$L90869:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L90604:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T90603[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVEnvelop@@@2@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T90866
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVEnvelop@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Insert
; Function compile flags: /Ogsy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVEnvelop@@@2@@Z
_TEXT	SEGMENT
__Where$29256 = -8					; size = 4
__Addleft$ = -4						; size = 1
$T90888 = 8						; size = 4
__Val$ = 8						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVEnvelop@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::insert, COMDAT
; _this$ = ebx
; ___$ReturnUdt$ = esi

; 477  : 		{	// try to insert node with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 478  : 		_Nodeptr _Trynode = _Root();

  00005	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00008	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  0000b	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0000f	57		 push	 edi
  00010	8b f9		 mov	 edi, ecx
  00012	c6 45 fc 01	 mov	 BYTE PTR __Addleft$[ebp], 1
  00016	75 21		 jne	 SHORT $L91013

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  0001b	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L29245:
  0001d	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00020	8b f8		 mov	 edi, eax
  00022	0f 9c 45 fc	 setl	 BYTE PTR __Addleft$[ebp]
  00026	80 7d fc 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0002a	74 04		 je	 SHORT $L90880

; 482  : 			{	// look for leaf to insert before (_Addleft) or after
; 483  : 			_Wherenode = _Trynode;
; 484  : 			_Addleft = this->comp(this->_Kfn(_Val), _Key(_Trynode));
; 485  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	eb 03		 jmp	 SHORT $L90881
$L90880:
  00030	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$L90881:

; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  00033	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00037	74 e4		 je	 SHORT $L29245
$L91013:

; 486  : 			}
; 487  : 
; 488  : 		if (this->_Multi)
; 489  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 490  : 		else
; 491  : 			{	// insert only if unique
; 492  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);
; 493  : 			if (!_Addleft)

  00039	80 7d fc 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0003d	8b c7		 mov	 eax, edi
  0003f	89 45 f8	 mov	 DWORD PTR __Where$29256[ebp], eax
  00042	74 19		 je	 SHORT $L90980

; 494  : 				;	// need to test if insert after is okay
; 495  : 			else if (_Where == begin())

  00044	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00047	3b 38		 cmp	 edi, DWORD PTR [eax]
  00049	75 07		 jne	 SHORT $L29261

; 496  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

  0004b	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  0004e	6a 01		 push	 1
  00050	eb 19		 jmp	 SHORT $L91015
$L29261:

; 497  : 			else
; 498  : 				--_Where;	// need to test if insert before is okay

  00052	8d 4d f8	 lea	 ecx, DWORD PTR __Where$29256[ebp]
  00055	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::_Dec
  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Where$29256[ebp]
$L90980:

; 499  : 
; 500  : 			if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))

  0005d	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00063	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00065	7d 19		 jge	 SHORT $L29266

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  00067	51		 push	 ecx
  00068	ff 75 fc	 push	 DWORD PTR __Addleft$[ebp]
$L91015:
  0006b	8d 45 08	 lea	 eax, DWORD PTR $T90888[ebp]
  0006e	8b cf		 mov	 ecx, edi
  00070	50		 push	 eax
  00071	8b fb		 mov	 edi, ebx
  00073	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVEnvelop@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Insert
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
  0007e	eb 04		 jmp	 SHORT $L91014
$L29266:

; 502  : 			else
; 503  : 				return (_Pairib(_Where, false));

  00080	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
$L91014:
  00084	89 06		 mov	 DWORD PTR [esi], eax
  00086	8b c6		 mov	 eax, esi
  00088	5f		 pop	 edi

; 504  : 			}
; 505  : 		}

  00089	c9		 leave
  0008a	c2 04 00	 ret	 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVEnvelop@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::insert
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T91290	DD	0ffffffffH
	DD	FLAT:$L91020
$T91282	DD	019930520H
	DD	01H
	DD	FLAT:$T91290
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVN163@@@2@@Z
_TEXT	SEGMENT
$T91018 = -80						; size = 40
$T91019 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Val$ = 16						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVN163@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Insert, COMDAT
; _this$ = edi
; __Wherenode$ = ecx

; 911  : 		{	// add node with value next to _Wherenode, to left if _Addnode

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVN163@@@2@@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 44	 sub	 esp, 68			; 00000044H

; 912  : 		if (max_size() - 1 <= _Mysize)

  0000d	81 7f 08 fe ff
	ff 1f		 cmp	 DWORD PTR [edi+8], 536870910 ; 1ffffffeH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	72 32		 jb	 SHORT $L91042

; 913  : 			_THROW(length_error, "map/set<T> too long");

  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4d d8	 lea	 ecx, DWORD PTR $T91019[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00027	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002b	8d 45 d8	 lea	 eax, DWORD PTR $T91019[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d b0	 lea	 ecx, DWORD PTR $T91018[ebp]
  00032	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00037	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  0003c	8d 45 b0	 lea	 eax, DWORD PTR $T91018[ebp]
  0003f	50		 push	 eax
  00040	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T91018[ebp], OFFSET FLAT:??_7length_error@std@@6B@
  00047	e8 00 00 00 00	 call	 __CxxThrowException@8
$L91291:
$L91042:

; 914  : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 915  : 			_Val, _Red);

  0004c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0004f	6a 00		 push	 0
  00051	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  00054	50		 push	 eax
  00055	56		 push	 esi
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVN163@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Buynode

; 916  : 
; 917  : 		++_Mysize;

  0005c	ff 47 08	 inc	 DWORD PTR [edi+8]
  0005f	8b d8		 mov	 ebx, eax

; 918  : 		if (_Wherenode == _Myhead)

  00061	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00064	3b f0		 cmp	 esi, eax
  00066	75 0d		 jne	 SHORT $L29169

; 919  : 			{	// first node in tree, just set head values
; 920  : 			_Root() = _Newnode;

  00068	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 921  : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

  0006b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0006e	89 18		 mov	 DWORD PTR [eax], ebx
  00070	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 922  : 			}
; 923  : 		else if (_Addleft)

  00073	eb 1e		 jmp	 SHORT $L91286
$L29169:
  00075	80 7d 0c 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  00079	74 0d		 je	 SHORT $L29171

; 924  : 			{	// add to left of _Wherenode
; 925  : 			_Left(_Wherenode) = _Newnode;

  0007b	89 1e		 mov	 DWORD PTR [esi], ebx

; 926  : 			if (_Wherenode == _Lmost())

  0007d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00080	3b 30		 cmp	 esi, DWORD PTR [eax]
  00082	75 12		 jne	 SHORT $L29174

; 927  : 				_Lmost() = _Newnode;

  00084	89 18		 mov	 DWORD PTR [eax], ebx

; 928  : 			}
; 929  : 		else

  00086	eb 0e		 jmp	 SHORT $L29174
$L29171:

; 930  : 			{	// add to right of _Wherenode
; 931  : 			_Right(_Wherenode) = _Newnode;

  00088	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 932  : 			if (_Wherenode == _Rmost())

  0008b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0008e	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00091	75 03		 jne	 SHORT $L29174
$L91286:

; 933  : 				_Rmost() = _Newnode;

  00093	89 58 08	 mov	 DWORD PTR [eax+8], ebx
$L29174:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

  00096	8b f3		 mov	 esi, ebx
  00098	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0009b	e9 8f 00 00 00	 jmp	 $L91288
$L29177:

; 937  : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

  000a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a2	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a5	8b 12		 mov	 edx, DWORD PTR [edx]
  000a7	3b ca		 cmp	 ecx, edx
  000a9	75 52		 jne	 SHORT $L29179

; 938  : 				{	// fixup red-red in left subtree
; 939  : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

  000ab	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ae	8b 52 08	 mov	 edx, DWORD PTR [edx+8]

; 940  : 				if (_Color(_Wherenode) == _Red)

  000b1	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0
  000b5	75 1a		 jne	 SHORT $L29180
$L91289:

; 941  : 					{	// parent has two red children, blacken both
; 942  : 					_Color(_Parent(_Pnode)) = _Black;

  000b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b9	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1

; 943  : 					_Color(_Wherenode) = _Black;

  000bd	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1

; 944  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  000c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c3	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000c6	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0

; 945  : 					_Pnode = _Parent(_Parent(_Pnode));

  000ca	8b 00		 mov	 eax, DWORD PTR [eax]
  000cc	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 946  : 					}
; 947  : 				else

  000cf	eb 5b		 jmp	 SHORT $L29185
$L29180:

; 948  : 					{	// parent has red and black children
; 949  : 					if (_Pnode == _Right(_Parent(_Pnode)))

  000d1	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  000d4	75 08		 jne	 SHORT $L29182

; 950  : 						{	// rotate right child to left
; 951  : 						_Pnode = _Parent(_Pnode);
; 952  : 						_Lrotate(_Pnode);

  000d6	57		 push	 edi
  000d7	8b f1		 mov	 esi, ecx
  000d9	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Lrotate
$L29182:

; 953  : 						}
; 954  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  000de	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e1	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 955  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  000e5	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000eb	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0

; 956  : 					_Rrotate(_Parent(_Parent(_Pnode)));

  000ef	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000f2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f5	57		 push	 edi
  000f6	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Rrotate

; 957  : 					}
; 958  : 				}
; 959  : 			else

  000fb	eb 2f		 jmp	 SHORT $L29185
$L29179:

; 960  : 				{	// fixup red-red in right subtree
; 961  : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));
; 962  : 				if (_Color(_Wherenode) == _Red)

  000fd	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0

; 963  : 					{	// parent has two red children, blacken both
; 964  : 					_Color(_Parent(_Pnode)) = _Black;
; 965  : 					_Color(_Wherenode) = _Black;
; 966  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;
; 967  : 					_Pnode = _Parent(_Parent(_Pnode));
; 968  : 					}
; 969  : 				else

  00101	74 b4		 je	 SHORT $L91289

; 970  : 					{	// parent has red and black children
; 971  : 					if (_Pnode == _Left(_Parent(_Pnode)))

  00103	3b 31		 cmp	 esi, DWORD PTR [ecx]
  00105	75 08		 jne	 SHORT $L29186

; 972  : 						{	// rotate left child to right
; 973  : 						_Pnode = _Parent(_Pnode);
; 974  : 						_Rrotate(_Pnode);

  00107	57		 push	 edi
  00108	8b f1		 mov	 esi, ecx
  0010a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Rrotate
$L29186:

; 975  : 						}
; 976  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  0010f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00112	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 977  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  00116	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00119	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0011c	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0

; 978  : 					_Lrotate(_Parent(_Parent(_Pnode)));

  00120	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00123	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00126	57		 push	 edi
  00127	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Lrotate
$L29185:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

  0012c	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
$L91288:
  0012f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00131	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00135	0f 84 65 ff ff
	ff		 je	 $L29177

; 979  : 					}
; 980  : 				}
; 981  : 
; 982  : 		_Color(_Root()) = _Black;	// root is always black

  0013b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 983  : 		return (_TREE_ITERATOR(_Newnode));
; 984  : 		}

  00141	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00144	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  00148	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0014b	89 18		 mov	 DWORD PTR [eax], ebx
  0014d	5e		 pop	 esi
  0014e	5b		 pop	 ebx
  0014f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00156	c9		 leave
  00157	c2 0c 00	 ret	 12			; 0000000cH
$L91285:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L91020:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T91019[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVN163@@@2@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T91282
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVN163@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Insert
; Function compile flags: /Ogsy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVN163@@@2@@Z
_TEXT	SEGMENT
__Where$29121 = -8					; size = 4
__Addleft$ = -4						; size = 1
$T91304 = 8						; size = 4
__Val$ = 8						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVN163@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::insert, COMDAT
; _this$ = ebx
; ___$ReturnUdt$ = esi

; 477  : 		{	// try to insert node with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 478  : 		_Nodeptr _Trynode = _Root();

  00005	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00008	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  0000b	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0000f	57		 push	 edi
  00010	8b f9		 mov	 edi, ecx
  00012	c6 45 fc 01	 mov	 BYTE PTR __Addleft$[ebp], 1
  00016	75 21		 jne	 SHORT $L91429

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  0001b	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L29110:
  0001d	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00020	8b f8		 mov	 edi, eax
  00022	0f 9c 45 fc	 setl	 BYTE PTR __Addleft$[ebp]
  00026	80 7d fc 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0002a	74 04		 je	 SHORT $L91296

; 482  : 			{	// look for leaf to insert before (_Addleft) or after
; 483  : 			_Wherenode = _Trynode;
; 484  : 			_Addleft = this->comp(this->_Kfn(_Val), _Key(_Trynode));
; 485  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	eb 03		 jmp	 SHORT $L91297
$L91296:
  00030	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$L91297:

; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  00033	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00037	74 e4		 je	 SHORT $L29110
$L91429:

; 486  : 			}
; 487  : 
; 488  : 		if (this->_Multi)
; 489  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 490  : 		else
; 491  : 			{	// insert only if unique
; 492  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);
; 493  : 			if (!_Addleft)

  00039	80 7d fc 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0003d	8b c7		 mov	 eax, edi
  0003f	89 45 f8	 mov	 DWORD PTR __Where$29121[ebp], eax
  00042	74 19		 je	 SHORT $L91397

; 494  : 				;	// need to test if insert after is okay
; 495  : 			else if (_Where == begin())

  00044	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00047	3b 38		 cmp	 edi, DWORD PTR [eax]
  00049	75 07		 jne	 SHORT $L29126

; 496  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

  0004b	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  0004e	6a 01		 push	 1
  00050	eb 19		 jmp	 SHORT $L91431
$L29126:

; 497  : 			else
; 498  : 				--_Where;	// need to test if insert before is okay

  00052	8d 4d f8	 lea	 ecx, DWORD PTR __Where$29121[ebp]
  00055	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::_Dec
  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Where$29121[ebp]
$L91397:

; 499  : 
; 500  : 			if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))

  0005d	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00063	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00065	7d 19		 jge	 SHORT $L29131

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  00067	51		 push	 ecx
  00068	ff 75 fc	 push	 DWORD PTR __Addleft$[ebp]
$L91431:
  0006b	8d 45 08	 lea	 eax, DWORD PTR $T91304[ebp]
  0006e	8b cf		 mov	 ecx, edi
  00070	50		 push	 eax
  00071	8b fb		 mov	 edi, ebx
  00073	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVN163@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Insert
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
  0007e	eb 04		 jmp	 SHORT $L91430
$L29131:

; 502  : 			else
; 503  : 				return (_Pairib(_Where, false));

  00080	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
$L91430:
  00084	89 06		 mov	 DWORD PTR [esi], eax
  00086	8b c6		 mov	 eax, esi
  00088	5f		 pop	 edi

; 504  : 			}
; 505  : 		}

  00089	c9		 leave
  0008a	c2 04 00	 ret	 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVN163@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::insert
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T91706	DD	0ffffffffH
	DD	FLAT:$L91436
$T91698	DD	019930520H
	DD	01H
	DD	FLAT:$T91706
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVVRC7@@@2@@Z
_TEXT	SEGMENT
$T91434 = -80						; size = 40
$T91435 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Val$ = 16						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVVRC7@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Insert, COMDAT
; _this$ = edi
; __Wherenode$ = ecx

; 911  : 		{	// add node with value next to _Wherenode, to left if _Addnode

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVVRC7@@@2@@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 44	 sub	 esp, 68			; 00000044H

; 912  : 		if (max_size() - 1 <= _Mysize)

  0000d	81 7f 08 fe ff
	ff 1f		 cmp	 DWORD PTR [edi+8], 536870910 ; 1ffffffeH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	72 32		 jb	 SHORT $L91458

; 913  : 			_THROW(length_error, "map/set<T> too long");

  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4d d8	 lea	 ecx, DWORD PTR $T91435[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00027	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002b	8d 45 d8	 lea	 eax, DWORD PTR $T91435[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d b0	 lea	 ecx, DWORD PTR $T91434[ebp]
  00032	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00037	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  0003c	8d 45 b0	 lea	 eax, DWORD PTR $T91434[ebp]
  0003f	50		 push	 eax
  00040	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T91434[ebp], OFFSET FLAT:??_7length_error@std@@6B@
  00047	e8 00 00 00 00	 call	 __CxxThrowException@8
$L91707:
$L91458:

; 914  : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 915  : 			_Val, _Red);

  0004c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0004f	6a 00		 push	 0
  00051	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  00054	50		 push	 eax
  00055	56		 push	 esi
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVVRC7@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Buynode

; 916  : 
; 917  : 		++_Mysize;

  0005c	ff 47 08	 inc	 DWORD PTR [edi+8]
  0005f	8b d8		 mov	 ebx, eax

; 918  : 		if (_Wherenode == _Myhead)

  00061	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00064	3b f0		 cmp	 esi, eax
  00066	75 0d		 jne	 SHORT $L29034

; 919  : 			{	// first node in tree, just set head values
; 920  : 			_Root() = _Newnode;

  00068	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 921  : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

  0006b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0006e	89 18		 mov	 DWORD PTR [eax], ebx
  00070	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 922  : 			}
; 923  : 		else if (_Addleft)

  00073	eb 1e		 jmp	 SHORT $L91702
$L29034:
  00075	80 7d 0c 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  00079	74 0d		 je	 SHORT $L29036

; 924  : 			{	// add to left of _Wherenode
; 925  : 			_Left(_Wherenode) = _Newnode;

  0007b	89 1e		 mov	 DWORD PTR [esi], ebx

; 926  : 			if (_Wherenode == _Lmost())

  0007d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00080	3b 30		 cmp	 esi, DWORD PTR [eax]
  00082	75 12		 jne	 SHORT $L29039

; 927  : 				_Lmost() = _Newnode;

  00084	89 18		 mov	 DWORD PTR [eax], ebx

; 928  : 			}
; 929  : 		else

  00086	eb 0e		 jmp	 SHORT $L29039
$L29036:

; 930  : 			{	// add to right of _Wherenode
; 931  : 			_Right(_Wherenode) = _Newnode;

  00088	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 932  : 			if (_Wherenode == _Rmost())

  0008b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0008e	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00091	75 03		 jne	 SHORT $L29039
$L91702:

; 933  : 				_Rmost() = _Newnode;

  00093	89 58 08	 mov	 DWORD PTR [eax+8], ebx
$L29039:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

  00096	8b f3		 mov	 esi, ebx
  00098	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0009b	e9 8f 00 00 00	 jmp	 $L91704
$L29042:

; 937  : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

  000a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a2	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a5	8b 12		 mov	 edx, DWORD PTR [edx]
  000a7	3b ca		 cmp	 ecx, edx
  000a9	75 52		 jne	 SHORT $L29044

; 938  : 				{	// fixup red-red in left subtree
; 939  : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

  000ab	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ae	8b 52 08	 mov	 edx, DWORD PTR [edx+8]

; 940  : 				if (_Color(_Wherenode) == _Red)

  000b1	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0
  000b5	75 1a		 jne	 SHORT $L29045
$L91705:

; 941  : 					{	// parent has two red children, blacken both
; 942  : 					_Color(_Parent(_Pnode)) = _Black;

  000b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b9	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1

; 943  : 					_Color(_Wherenode) = _Black;

  000bd	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1

; 944  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  000c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c3	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000c6	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0

; 945  : 					_Pnode = _Parent(_Parent(_Pnode));

  000ca	8b 00		 mov	 eax, DWORD PTR [eax]
  000cc	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 946  : 					}
; 947  : 				else

  000cf	eb 5b		 jmp	 SHORT $L29050
$L29045:

; 948  : 					{	// parent has red and black children
; 949  : 					if (_Pnode == _Right(_Parent(_Pnode)))

  000d1	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  000d4	75 08		 jne	 SHORT $L29047

; 950  : 						{	// rotate right child to left
; 951  : 						_Pnode = _Parent(_Pnode);
; 952  : 						_Lrotate(_Pnode);

  000d6	57		 push	 edi
  000d7	8b f1		 mov	 esi, ecx
  000d9	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Lrotate
$L29047:

; 953  : 						}
; 954  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  000de	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e1	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 955  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  000e5	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000eb	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0

; 956  : 					_Rrotate(_Parent(_Parent(_Pnode)));

  000ef	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000f2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f5	57		 push	 edi
  000f6	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Rrotate

; 957  : 					}
; 958  : 				}
; 959  : 			else

  000fb	eb 2f		 jmp	 SHORT $L29050
$L29044:

; 960  : 				{	// fixup red-red in right subtree
; 961  : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));
; 962  : 				if (_Color(_Wherenode) == _Red)

  000fd	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0

; 963  : 					{	// parent has two red children, blacken both
; 964  : 					_Color(_Parent(_Pnode)) = _Black;
; 965  : 					_Color(_Wherenode) = _Black;
; 966  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;
; 967  : 					_Pnode = _Parent(_Parent(_Pnode));
; 968  : 					}
; 969  : 				else

  00101	74 b4		 je	 SHORT $L91705

; 970  : 					{	// parent has red and black children
; 971  : 					if (_Pnode == _Left(_Parent(_Pnode)))

  00103	3b 31		 cmp	 esi, DWORD PTR [ecx]
  00105	75 08		 jne	 SHORT $L29051

; 972  : 						{	// rotate left child to right
; 973  : 						_Pnode = _Parent(_Pnode);
; 974  : 						_Rrotate(_Pnode);

  00107	57		 push	 edi
  00108	8b f1		 mov	 esi, ecx
  0010a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Rrotate
$L29051:

; 975  : 						}
; 976  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  0010f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00112	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 977  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  00116	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00119	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0011c	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0

; 978  : 					_Lrotate(_Parent(_Parent(_Pnode)));

  00120	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00123	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00126	57		 push	 edi
  00127	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Lrotate
$L29050:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

  0012c	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
$L91704:
  0012f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00131	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00135	0f 84 65 ff ff
	ff		 je	 $L29042

; 979  : 					}
; 980  : 				}
; 981  : 
; 982  : 		_Color(_Root()) = _Black;	// root is always black

  0013b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 983  : 		return (_TREE_ITERATOR(_Newnode));
; 984  : 		}

  00141	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00144	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  00148	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0014b	89 18		 mov	 DWORD PTR [eax], ebx
  0014d	5e		 pop	 esi
  0014e	5b		 pop	 ebx
  0014f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00156	c9		 leave
  00157	c2 0c 00	 ret	 12			; 0000000cH
$L91701:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L91436:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T91435[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVVRC7@@@2@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T91698
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVVRC7@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Insert
; Function compile flags: /Ogsy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVVRC7@@@2@@Z
_TEXT	SEGMENT
__Where$28986 = -8					; size = 4
__Addleft$ = -4						; size = 1
$T91720 = 8						; size = 4
__Val$ = 8						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVVRC7@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::insert, COMDAT
; _this$ = ebx
; ___$ReturnUdt$ = esi

; 477  : 		{	// try to insert node with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 478  : 		_Nodeptr _Trynode = _Root();

  00005	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00008	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  0000b	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0000f	57		 push	 edi
  00010	8b f9		 mov	 edi, ecx
  00012	c6 45 fc 01	 mov	 BYTE PTR __Addleft$[ebp], 1
  00016	75 21		 jne	 SHORT $L91845

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  0001b	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L28975:
  0001d	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00020	8b f8		 mov	 edi, eax
  00022	0f 9c 45 fc	 setl	 BYTE PTR __Addleft$[ebp]
  00026	80 7d fc 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0002a	74 04		 je	 SHORT $L91712

; 482  : 			{	// look for leaf to insert before (_Addleft) or after
; 483  : 			_Wherenode = _Trynode;
; 484  : 			_Addleft = this->comp(this->_Kfn(_Val), _Key(_Trynode));
; 485  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	eb 03		 jmp	 SHORT $L91713
$L91712:
  00030	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$L91713:

; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  00033	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00037	74 e4		 je	 SHORT $L28975
$L91845:

; 486  : 			}
; 487  : 
; 488  : 		if (this->_Multi)
; 489  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 490  : 		else
; 491  : 			{	// insert only if unique
; 492  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);
; 493  : 			if (!_Addleft)

  00039	80 7d fc 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0003d	8b c7		 mov	 eax, edi
  0003f	89 45 f8	 mov	 DWORD PTR __Where$28986[ebp], eax
  00042	74 19		 je	 SHORT $L91812

; 494  : 				;	// need to test if insert after is okay
; 495  : 			else if (_Where == begin())

  00044	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00047	3b 38		 cmp	 edi, DWORD PTR [eax]
  00049	75 07		 jne	 SHORT $L28991

; 496  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

  0004b	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  0004e	6a 01		 push	 1
  00050	eb 19		 jmp	 SHORT $L91847
$L28991:

; 497  : 			else
; 498  : 				--_Where;	// need to test if insert before is okay

  00052	8d 4d f8	 lea	 ecx, DWORD PTR __Where$28986[ebp]
  00055	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::_Dec
  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Where$28986[ebp]
$L91812:

; 499  : 
; 500  : 			if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))

  0005d	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00063	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00065	7d 19		 jge	 SHORT $L28996

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  00067	51		 push	 ecx
  00068	ff 75 fc	 push	 DWORD PTR __Addleft$[ebp]
$L91847:
  0006b	8d 45 08	 lea	 eax, DWORD PTR $T91720[ebp]
  0006e	8b cf		 mov	 ecx, edi
  00070	50		 push	 eax
  00071	8b fb		 mov	 edi, ebx
  00073	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVVRC7@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Insert
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
  0007e	eb 04		 jmp	 SHORT $L91846
$L28996:

; 502  : 			else
; 503  : 				return (_Pairib(_Where, false));

  00080	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
$L91846:
  00084	89 06		 mov	 DWORD PTR [esi], eax
  00086	8b c6		 mov	 eax, esi
  00088	5f		 pop	 edi

; 504  : 			}
; 505  : 		}

  00089	c9		 leave
  0008a	c2 04 00	 ret	 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVVRC7@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::insert
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T92122	DD	0ffffffffH
	DD	FLAT:$L91852
$T92114	DD	019930520H
	DD	01H
	DD	FLAT:$T92122
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVFDSM@@@2@@Z
_TEXT	SEGMENT
$T91850 = -80						; size = 40
$T91851 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Val$ = 16						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVFDSM@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Insert, COMDAT
; _this$ = edi
; __Wherenode$ = ecx

; 911  : 		{	// add node with value next to _Wherenode, to left if _Addnode

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVFDSM@@@2@@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 44	 sub	 esp, 68			; 00000044H

; 912  : 		if (max_size() - 1 <= _Mysize)

  0000d	81 7f 08 fe ff
	ff 1f		 cmp	 DWORD PTR [edi+8], 536870910 ; 1ffffffeH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	72 32		 jb	 SHORT $L91874

; 913  : 			_THROW(length_error, "map/set<T> too long");

  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4d d8	 lea	 ecx, DWORD PTR $T91851[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00027	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002b	8d 45 d8	 lea	 eax, DWORD PTR $T91851[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d b0	 lea	 ecx, DWORD PTR $T91850[ebp]
  00032	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00037	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  0003c	8d 45 b0	 lea	 eax, DWORD PTR $T91850[ebp]
  0003f	50		 push	 eax
  00040	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T91850[ebp], OFFSET FLAT:??_7length_error@std@@6B@
  00047	e8 00 00 00 00	 call	 __CxxThrowException@8
$L92123:
$L91874:

; 914  : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 915  : 			_Val, _Red);

  0004c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0004f	6a 00		 push	 0
  00051	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  00054	50		 push	 eax
  00055	56		 push	 esi
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVFDSM@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Buynode

; 916  : 
; 917  : 		++_Mysize;

  0005c	ff 47 08	 inc	 DWORD PTR [edi+8]
  0005f	8b d8		 mov	 ebx, eax

; 918  : 		if (_Wherenode == _Myhead)

  00061	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00064	3b f0		 cmp	 esi, eax
  00066	75 0d		 jne	 SHORT $L28899

; 919  : 			{	// first node in tree, just set head values
; 920  : 			_Root() = _Newnode;

  00068	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 921  : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

  0006b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0006e	89 18		 mov	 DWORD PTR [eax], ebx
  00070	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 922  : 			}
; 923  : 		else if (_Addleft)

  00073	eb 1e		 jmp	 SHORT $L92118
$L28899:
  00075	80 7d 0c 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  00079	74 0d		 je	 SHORT $L28901

; 924  : 			{	// add to left of _Wherenode
; 925  : 			_Left(_Wherenode) = _Newnode;

  0007b	89 1e		 mov	 DWORD PTR [esi], ebx

; 926  : 			if (_Wherenode == _Lmost())

  0007d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00080	3b 30		 cmp	 esi, DWORD PTR [eax]
  00082	75 12		 jne	 SHORT $L28904

; 927  : 				_Lmost() = _Newnode;

  00084	89 18		 mov	 DWORD PTR [eax], ebx

; 928  : 			}
; 929  : 		else

  00086	eb 0e		 jmp	 SHORT $L28904
$L28901:

; 930  : 			{	// add to right of _Wherenode
; 931  : 			_Right(_Wherenode) = _Newnode;

  00088	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 932  : 			if (_Wherenode == _Rmost())

  0008b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0008e	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00091	75 03		 jne	 SHORT $L28904
$L92118:

; 933  : 				_Rmost() = _Newnode;

  00093	89 58 08	 mov	 DWORD PTR [eax+8], ebx
$L28904:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

  00096	8b f3		 mov	 esi, ebx
  00098	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0009b	e9 8f 00 00 00	 jmp	 $L92120
$L28907:

; 937  : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

  000a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a2	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a5	8b 12		 mov	 edx, DWORD PTR [edx]
  000a7	3b ca		 cmp	 ecx, edx
  000a9	75 52		 jne	 SHORT $L28909

; 938  : 				{	// fixup red-red in left subtree
; 939  : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

  000ab	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ae	8b 52 08	 mov	 edx, DWORD PTR [edx+8]

; 940  : 				if (_Color(_Wherenode) == _Red)

  000b1	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0
  000b5	75 1a		 jne	 SHORT $L28910
$L92121:

; 941  : 					{	// parent has two red children, blacken both
; 942  : 					_Color(_Parent(_Pnode)) = _Black;

  000b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b9	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1

; 943  : 					_Color(_Wherenode) = _Black;

  000bd	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1

; 944  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  000c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c3	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000c6	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0

; 945  : 					_Pnode = _Parent(_Parent(_Pnode));

  000ca	8b 00		 mov	 eax, DWORD PTR [eax]
  000cc	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 946  : 					}
; 947  : 				else

  000cf	eb 5b		 jmp	 SHORT $L28915
$L28910:

; 948  : 					{	// parent has red and black children
; 949  : 					if (_Pnode == _Right(_Parent(_Pnode)))

  000d1	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  000d4	75 08		 jne	 SHORT $L28912

; 950  : 						{	// rotate right child to left
; 951  : 						_Pnode = _Parent(_Pnode);
; 952  : 						_Lrotate(_Pnode);

  000d6	57		 push	 edi
  000d7	8b f1		 mov	 esi, ecx
  000d9	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Lrotate
$L28912:

; 953  : 						}
; 954  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  000de	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e1	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 955  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  000e5	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000eb	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0

; 956  : 					_Rrotate(_Parent(_Parent(_Pnode)));

  000ef	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000f2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f5	57		 push	 edi
  000f6	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Rrotate

; 957  : 					}
; 958  : 				}
; 959  : 			else

  000fb	eb 2f		 jmp	 SHORT $L28915
$L28909:

; 960  : 				{	// fixup red-red in right subtree
; 961  : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));
; 962  : 				if (_Color(_Wherenode) == _Red)

  000fd	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0

; 963  : 					{	// parent has two red children, blacken both
; 964  : 					_Color(_Parent(_Pnode)) = _Black;
; 965  : 					_Color(_Wherenode) = _Black;
; 966  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;
; 967  : 					_Pnode = _Parent(_Parent(_Pnode));
; 968  : 					}
; 969  : 				else

  00101	74 b4		 je	 SHORT $L92121

; 970  : 					{	// parent has red and black children
; 971  : 					if (_Pnode == _Left(_Parent(_Pnode)))

  00103	3b 31		 cmp	 esi, DWORD PTR [ecx]
  00105	75 08		 jne	 SHORT $L28916

; 972  : 						{	// rotate left child to right
; 973  : 						_Pnode = _Parent(_Pnode);
; 974  : 						_Rrotate(_Pnode);

  00107	57		 push	 edi
  00108	8b f1		 mov	 esi, ecx
  0010a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Rrotate
$L28916:

; 975  : 						}
; 976  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  0010f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00112	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 977  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  00116	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00119	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0011c	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0

; 978  : 					_Lrotate(_Parent(_Parent(_Pnode)));

  00120	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00123	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00126	57		 push	 edi
  00127	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Lrotate
$L28915:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

  0012c	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
$L92120:
  0012f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00131	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00135	0f 84 65 ff ff
	ff		 je	 $L28907

; 979  : 					}
; 980  : 				}
; 981  : 
; 982  : 		_Color(_Root()) = _Black;	// root is always black

  0013b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 983  : 		return (_TREE_ITERATOR(_Newnode));
; 984  : 		}

  00141	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00144	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  00148	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0014b	89 18		 mov	 DWORD PTR [eax], ebx
  0014d	5e		 pop	 esi
  0014e	5b		 pop	 ebx
  0014f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00156	c9		 leave
  00157	c2 0c 00	 ret	 12			; 0000000cH
$L92117:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L91852:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T91851[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVFDSM@@@2@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T92114
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVFDSM@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Insert
; Function compile flags: /Ogsy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVFDSM@@@2@@Z
_TEXT	SEGMENT
__Where$28851 = -8					; size = 4
__Addleft$ = -4						; size = 1
$T92136 = 8						; size = 4
__Val$ = 8						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVFDSM@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::insert, COMDAT
; _this$ = ebx
; ___$ReturnUdt$ = esi

; 477  : 		{	// try to insert node with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 478  : 		_Nodeptr _Trynode = _Root();

  00005	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00008	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  0000b	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0000f	57		 push	 edi
  00010	8b f9		 mov	 edi, ecx
  00012	c6 45 fc 01	 mov	 BYTE PTR __Addleft$[ebp], 1
  00016	75 21		 jne	 SHORT $L92261

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  0001b	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L28840:
  0001d	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00020	8b f8		 mov	 edi, eax
  00022	0f 9c 45 fc	 setl	 BYTE PTR __Addleft$[ebp]
  00026	80 7d fc 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0002a	74 04		 je	 SHORT $L92128

; 482  : 			{	// look for leaf to insert before (_Addleft) or after
; 483  : 			_Wherenode = _Trynode;
; 484  : 			_Addleft = this->comp(this->_Kfn(_Val), _Key(_Trynode));
; 485  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	eb 03		 jmp	 SHORT $L92129
$L92128:
  00030	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$L92129:

; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  00033	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00037	74 e4		 je	 SHORT $L28840
$L92261:

; 486  : 			}
; 487  : 
; 488  : 		if (this->_Multi)
; 489  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 490  : 		else
; 491  : 			{	// insert only if unique
; 492  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);
; 493  : 			if (!_Addleft)

  00039	80 7d fc 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0003d	8b c7		 mov	 eax, edi
  0003f	89 45 f8	 mov	 DWORD PTR __Where$28851[ebp], eax
  00042	74 19		 je	 SHORT $L92228

; 494  : 				;	// need to test if insert after is okay
; 495  : 			else if (_Where == begin())

  00044	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00047	3b 38		 cmp	 edi, DWORD PTR [eax]
  00049	75 07		 jne	 SHORT $L28856

; 496  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

  0004b	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  0004e	6a 01		 push	 1
  00050	eb 19		 jmp	 SHORT $L92263
$L28856:

; 497  : 			else
; 498  : 				--_Where;	// need to test if insert before is okay

  00052	8d 4d f8	 lea	 ecx, DWORD PTR __Where$28851[ebp]
  00055	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::_Dec
  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Where$28851[ebp]
$L92228:

; 499  : 
; 500  : 			if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))

  0005d	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00063	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00065	7d 19		 jge	 SHORT $L28861

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  00067	51		 push	 ecx
  00068	ff 75 fc	 push	 DWORD PTR __Addleft$[ebp]
$L92263:
  0006b	8d 45 08	 lea	 eax, DWORD PTR $T92136[ebp]
  0006e	8b cf		 mov	 ecx, edi
  00070	50		 push	 eax
  00071	8b fb		 mov	 edi, ebx
  00073	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVFDSM@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Insert
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
  0007e	eb 04		 jmp	 SHORT $L92262
$L28861:

; 502  : 			else
; 503  : 				return (_Pairib(_Where, false));

  00080	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
$L92262:
  00084	89 06		 mov	 DWORD PTR [esi], eax
  00086	8b c6		 mov	 eax, esi
  00088	5f		 pop	 edi

; 504  : 			}
; 505  : 		}

  00089	c9		 leave
  0008a	c2 04 00	 ret	 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVFDSM@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::insert
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T92538	DD	0ffffffffH
	DD	FLAT:$L92268
$T92530	DD	019930520H
	DD	01H
	DD	FLAT:$T92538
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVFDSC@@@2@@Z
_TEXT	SEGMENT
$T92266 = -80						; size = 40
$T92267 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Val$ = 16						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVFDSC@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Insert, COMDAT
; _this$ = edi
; __Wherenode$ = ecx

; 911  : 		{	// add node with value next to _Wherenode, to left if _Addnode

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVFDSC@@@2@@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 44	 sub	 esp, 68			; 00000044H

; 912  : 		if (max_size() - 1 <= _Mysize)

  0000d	81 7f 08 fe ff
	ff 1f		 cmp	 DWORD PTR [edi+8], 536870910 ; 1ffffffeH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	72 32		 jb	 SHORT $L92291

; 913  : 			_THROW(length_error, "map/set<T> too long");

  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4d d8	 lea	 ecx, DWORD PTR $T92267[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00027	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002b	8d 45 d8	 lea	 eax, DWORD PTR $T92267[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d b0	 lea	 ecx, DWORD PTR $T92266[ebp]
  00032	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00037	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  0003c	8d 45 b0	 lea	 eax, DWORD PTR $T92266[ebp]
  0003f	50		 push	 eax
  00040	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T92266[ebp], OFFSET FLAT:??_7length_error@std@@6B@
  00047	e8 00 00 00 00	 call	 __CxxThrowException@8
$L92539:
$L92291:

; 914  : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 915  : 			_Val, _Red);

  0004c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0004f	6a 00		 push	 0
  00051	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  00054	50		 push	 eax
  00055	56		 push	 esi
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHPAVFDSC@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Buynode

; 916  : 
; 917  : 		++_Mysize;

  0005c	ff 47 08	 inc	 DWORD PTR [edi+8]
  0005f	8b d8		 mov	 ebx, eax

; 918  : 		if (_Wherenode == _Myhead)

  00061	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00064	3b f0		 cmp	 esi, eax
  00066	75 0d		 jne	 SHORT $L28764

; 919  : 			{	// first node in tree, just set head values
; 920  : 			_Root() = _Newnode;

  00068	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 921  : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

  0006b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0006e	89 18		 mov	 DWORD PTR [eax], ebx
  00070	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 922  : 			}
; 923  : 		else if (_Addleft)

  00073	eb 1e		 jmp	 SHORT $L92534
$L28764:
  00075	80 7d 0c 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  00079	74 0d		 je	 SHORT $L28766

; 924  : 			{	// add to left of _Wherenode
; 925  : 			_Left(_Wherenode) = _Newnode;

  0007b	89 1e		 mov	 DWORD PTR [esi], ebx

; 926  : 			if (_Wherenode == _Lmost())

  0007d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00080	3b 30		 cmp	 esi, DWORD PTR [eax]
  00082	75 12		 jne	 SHORT $L28769

; 927  : 				_Lmost() = _Newnode;

  00084	89 18		 mov	 DWORD PTR [eax], ebx

; 928  : 			}
; 929  : 		else

  00086	eb 0e		 jmp	 SHORT $L28769
$L28766:

; 930  : 			{	// add to right of _Wherenode
; 931  : 			_Right(_Wherenode) = _Newnode;

  00088	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 932  : 			if (_Wherenode == _Rmost())

  0008b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0008e	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00091	75 03		 jne	 SHORT $L28769
$L92534:

; 933  : 				_Rmost() = _Newnode;

  00093	89 58 08	 mov	 DWORD PTR [eax+8], ebx
$L28769:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

  00096	8b f3		 mov	 esi, ebx
  00098	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0009b	e9 8f 00 00 00	 jmp	 $L92536
$L28772:

; 937  : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

  000a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a2	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a5	8b 12		 mov	 edx, DWORD PTR [edx]
  000a7	3b ca		 cmp	 ecx, edx
  000a9	75 52		 jne	 SHORT $L28774

; 938  : 				{	// fixup red-red in left subtree
; 939  : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

  000ab	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ae	8b 52 08	 mov	 edx, DWORD PTR [edx+8]

; 940  : 				if (_Color(_Wherenode) == _Red)

  000b1	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0
  000b5	75 1a		 jne	 SHORT $L28775
$L92537:

; 941  : 					{	// parent has two red children, blacken both
; 942  : 					_Color(_Parent(_Pnode)) = _Black;

  000b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b9	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1

; 943  : 					_Color(_Wherenode) = _Black;

  000bd	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1

; 944  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  000c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c3	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000c6	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0

; 945  : 					_Pnode = _Parent(_Parent(_Pnode));

  000ca	8b 00		 mov	 eax, DWORD PTR [eax]
  000cc	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 946  : 					}
; 947  : 				else

  000cf	eb 5b		 jmp	 SHORT $L28780
$L28775:

; 948  : 					{	// parent has red and black children
; 949  : 					if (_Pnode == _Right(_Parent(_Pnode)))

  000d1	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  000d4	75 08		 jne	 SHORT $L28777

; 950  : 						{	// rotate right child to left
; 951  : 						_Pnode = _Parent(_Pnode);
; 952  : 						_Lrotate(_Pnode);

  000d6	57		 push	 edi
  000d7	8b f1		 mov	 esi, ecx
  000d9	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Lrotate
$L28777:

; 953  : 						}
; 954  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  000de	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e1	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 955  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  000e5	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000eb	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0

; 956  : 					_Rrotate(_Parent(_Parent(_Pnode)));

  000ef	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000f2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f5	57		 push	 edi
  000f6	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Rrotate

; 957  : 					}
; 958  : 				}
; 959  : 			else

  000fb	eb 2f		 jmp	 SHORT $L28780
$L28774:

; 960  : 				{	// fixup red-red in right subtree
; 961  : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));
; 962  : 				if (_Color(_Wherenode) == _Red)

  000fd	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0

; 963  : 					{	// parent has two red children, blacken both
; 964  : 					_Color(_Parent(_Pnode)) = _Black;
; 965  : 					_Color(_Wherenode) = _Black;
; 966  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;
; 967  : 					_Pnode = _Parent(_Parent(_Pnode));
; 968  : 					}
; 969  : 				else

  00101	74 b4		 je	 SHORT $L92537

; 970  : 					{	// parent has red and black children
; 971  : 					if (_Pnode == _Left(_Parent(_Pnode)))

  00103	3b 31		 cmp	 esi, DWORD PTR [ecx]
  00105	75 08		 jne	 SHORT $L28781

; 972  : 						{	// rotate left child to right
; 973  : 						_Pnode = _Parent(_Pnode);
; 974  : 						_Rrotate(_Pnode);

  00107	57		 push	 edi
  00108	8b f1		 mov	 esi, ecx
  0010a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Rrotate
$L28781:

; 975  : 						}
; 976  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  0010f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00112	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 977  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  00116	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00119	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0011c	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0

; 978  : 					_Lrotate(_Parent(_Parent(_Pnode)));

  00120	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00123	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00126	57		 push	 edi
  00127	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Lrotate
$L28780:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

  0012c	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
$L92536:
  0012f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00131	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00135	0f 84 65 ff ff
	ff		 je	 $L28772

; 979  : 					}
; 980  : 				}
; 981  : 
; 982  : 		_Color(_Root()) = _Black;	// root is always black

  0013b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 983  : 		return (_TREE_ITERATOR(_Newnode));
; 984  : 		}

  00141	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00144	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  00148	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0014b	89 18		 mov	 DWORD PTR [eax], ebx
  0014d	5e		 pop	 esi
  0014e	5b		 pop	 ebx
  0014f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00156	c9		 leave
  00157	c2 0c 00	 ret	 12			; 0000000cH
$L92533:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L92268:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T92267[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVFDSC@@@2@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T92530
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVFDSC@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Insert
; Function compile flags: /Ogsy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVFDSC@@@2@@Z
_TEXT	SEGMENT
__Where$28715 = -8					; size = 4
__Addleft$ = -4						; size = 1
$T92552 = 8						; size = 4
__Val$ = 8						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVFDSC@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::insert, COMDAT
; _this$ = ebx
; ___$ReturnUdt$ = esi

; 477  : 		{	// try to insert node with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 478  : 		_Nodeptr _Trynode = _Root();

  00005	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00008	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  0000b	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0000f	57		 push	 edi
  00010	8b f9		 mov	 edi, ecx
  00012	c6 45 fc 01	 mov	 BYTE PTR __Addleft$[ebp], 1
  00016	75 21		 jne	 SHORT $L92677

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  0001b	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L28704:
  0001d	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00020	8b f8		 mov	 edi, eax
  00022	0f 9c 45 fc	 setl	 BYTE PTR __Addleft$[ebp]
  00026	80 7d fc 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0002a	74 04		 je	 SHORT $L92544

; 482  : 			{	// look for leaf to insert before (_Addleft) or after
; 483  : 			_Wherenode = _Trynode;
; 484  : 			_Addleft = this->comp(this->_Kfn(_Val), _Key(_Trynode));
; 485  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	eb 03		 jmp	 SHORT $L92545
$L92544:
  00030	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$L92545:

; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  00033	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00037	74 e4		 je	 SHORT $L28704
$L92677:

; 486  : 			}
; 487  : 
; 488  : 		if (this->_Multi)
; 489  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 490  : 		else
; 491  : 			{	// insert only if unique
; 492  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);
; 493  : 			if (!_Addleft)

  00039	80 7d fc 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0003d	8b c7		 mov	 eax, edi
  0003f	89 45 f8	 mov	 DWORD PTR __Where$28715[ebp], eax
  00042	74 19		 je	 SHORT $L92644

; 494  : 				;	// need to test if insert after is okay
; 495  : 			else if (_Where == begin())

  00044	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00047	3b 38		 cmp	 edi, DWORD PTR [eax]
  00049	75 07		 jne	 SHORT $L28720

; 496  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

  0004b	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  0004e	6a 01		 push	 1
  00050	eb 19		 jmp	 SHORT $L92679
$L28720:

; 497  : 			else
; 498  : 				--_Where;	// need to test if insert before is okay

  00052	8d 4d f8	 lea	 ecx, DWORD PTR __Where$28715[ebp]
  00055	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::_Dec
  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Where$28715[ebp]
$L92644:

; 499  : 
; 500  : 			if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))

  0005d	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00063	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00065	7d 19		 jge	 SHORT $L28725

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  00067	51		 push	 ecx
  00068	ff 75 fc	 push	 DWORD PTR __Addleft$[ebp]
$L92679:
  0006b	8d 45 08	 lea	 eax, DWORD PTR $T92552[ebp]
  0006e	8b cf		 mov	 ecx, edi
  00070	50		 push	 eax
  00071	8b fb		 mov	 edi, ebx
  00073	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVFDSC@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Insert
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
  0007e	eb 04		 jmp	 SHORT $L92678
$L28725:

; 502  : 			else
; 503  : 				return (_Pairib(_Where, false));

  00080	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
$L92678:
  00084	89 06		 mov	 DWORD PTR [esi], eax
  00086	8b c6		 mov	 eax, esi
  00088	5f		 pop	 edi

; 504  : 			}
; 505  : 		}

  00089	c9		 leave
  0008a	c2 04 00	 ret	 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVFDSC@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::insert
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xstring
xdata$x	SEGMENT
$T92712	DD	0ffffffffH
	DD	FLAT:$L92684
$T92709	DD	019930520H
	DD	01H
	DD	FLAT:$T92712
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
xdata$x	ENDS
;	COMDAT ?_Incsize@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T92682 = -80						; size = 40
$T92683 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?_Incsize@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@IAEXI@Z PROC NEAR ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Incsize, COMDAT
; _this$ = ecx
; __Count$ = edx

; 956  : 		{	// alter element count, with checking

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?_Incsize@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@IAEXI@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 44	 sub	 esp, 68			; 00000044H

; 957  : 		if (max_size() - _Mysize < _Count)

  0000d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00010	56		 push	 esi
  00011	be ff ff ff 3f	 mov	 esi, 1073741823		; 3fffffffH
  00016	2b f0		 sub	 esi, eax
  00018	3b f2		 cmp	 esi, edx
  0001a	5e		 pop	 esi
  0001b	73 32		 jae	 SHORT $L92706

; 958  : 			_THROW(length_error, "list<T> too long");

  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00022	8d 4d d8	 lea	 ecx, DWORD PTR $T92683[ebp]
  00025	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002e	8d 45 d8	 lea	 eax, DWORD PTR $T92683[ebp]
  00031	50		 push	 eax
  00032	8d 4d b0	 lea	 ecx, DWORD PTR $T92682[ebp]
  00035	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  0003f	8d 45 b0	 lea	 eax, DWORD PTR $T92682[ebp]
  00042	50		 push	 eax
  00043	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T92682[ebp], OFFSET FLAT:??_7length_error@std@@6B@
  0004a	e8 00 00 00 00	 call	 __CxxThrowException@8
$L92713:
$L92706:

; 959  : 		_Mysize += _Count;

  0004f	03 c2		 add	 eax, edx
  00051	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 960  : 		}

  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0005e	c9		 leave
  0005f	c3		 ret	 0
$L92711:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L92684:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T92683[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Incsize@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@IAEXI@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T92709
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Incsize@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@IAEXI@Z ENDP ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Incsize
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVSub@@@2@@Z
_TEXT	SEGMENT
$T92724 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Next$ = 12						; size = 4
__Where$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVSub@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::insert, COMDAT
; _this$ = ecx
; __Val$ = eax

; 509  : 		{	// try to insert node with value _Val using _Where as a hint

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	8b d9		 mov	 ebx, ecx

; 510  : 		iterator _Next;
; 511  : 
; 512  : 		if (size() == 0)

  00008	83 7b 08 00	 cmp	 DWORD PTR [ebx+8], 0
  0000c	57		 push	 edi
  0000d	8b f8		 mov	 edi, eax
  0000f	75 18		 jne	 SHORT $L27560

; 513  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

  00011	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00014	57		 push	 edi
  00015	6a 01		 push	 1
  00017	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0001a	8b fb		 mov	 edi, ebx
  0001c	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVSub@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Insert
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00024	e9 c0 00 00 00	 jmp	 $L27558
$L27560:

; 514  : 		else if (this->_Multi)
; 515  : 			{	// insert even if duplicate
; 516  : 			if (_Where == begin())
; 517  : 				{	// insert at beginning if before first element
; 518  : 				if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 519  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 520  : 				}
; 521  : 			else if (_Where == end())
; 522  : 				{	// insert at end if after last element
; 523  : 				if (!this->comp(this->_Kfn(_Val), _Key(_Rmost())))
; 524  : 					return (_Insert(false, _Rmost(), _Val));
; 525  : 				}
; 526  : 			else if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 527  : 				&& !this->comp(this->_Kfn(_Val),
; 528  : 					_Key((--(_Next = _Where))._Mynode())))
; 529  : 				{	// insert before _Where
; 530  : 				if (_Isnil(_Right(_Next._Mynode())))
; 531  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 532  : 				else
; 533  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 534  : 				}
; 535  : 			else if (!this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 536  : 				&& (++(_Next = _Where) == end()
; 537  : 					|| !this->comp(_Key(_Next._Mynode()),
; 538  : 						this->_Kfn(_Val))))
; 539  : 				{	// insert after _Where
; 540  : 				if (_Isnil(_Right(_Where._Mynode())))
; 541  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 542  : 				else
; 543  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 544  : 				}
; 545  : 			}
; 546  : 		else
; 547  : 			{	// insert only if unique
; 548  : 			if (_Where == begin())

  00029	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0002c	56		 push	 esi
  0002d	8b 75 0c	 mov	 esi, DWORD PTR __Where$[ebp]
  00030	3b 30		 cmp	 esi, DWORD PTR [eax]
  00032	75 22		 jne	 SHORT $L27589

; 549  : 				{	// insert at beginning if before first element
; 550  : 				if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode())))

  00034	8b 07		 mov	 eax, DWORD PTR [edi]
  00036	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00039	0f 8d 99 00 00
	00		 jge	 $L27609

; 551  : 					return (_Insert(true, _Where._Mynode(), _Val));

  0003f	57		 push	 edi
  00040	6a 01		 push	 1
  00042	8b ce		 mov	 ecx, esi
$L93270:
  00044	8b fb		 mov	 edi, ebx
$L93271:
  00046	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVSub@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Insert
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00051	e9 92 00 00 00	 jmp	 $L93265
$L27589:

; 552  : 				}
; 553  : 			else if (_Where == end())

  00056	3b f0		 cmp	 esi, eax
  00058	75 11		 jne	 SHORT $L27594

; 554  : 				{	// insert at end if after last element
; 555  : 				if (this->comp(_Key(_Rmost()), this->_Kfn(_Val)))

  0005a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0005d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00060	3b 0f		 cmp	 ecx, DWORD PTR [edi]
  00062	7d 74		 jge	 SHORT $L27609

; 556  : 					return (_Insert(false, _Rmost(), _Val));

  00064	57		 push	 edi
  00065	6a 00		 push	 0
  00067	8b c8		 mov	 ecx, eax
  00069	eb d9		 jmp	 SHORT $L93270
$L27594:

; 557  : 				}
; 558  : 			else if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 559  : 				&& this->comp(_Key((--(_Next = _Where))._Mynode()),
; 560  : 					this->_Kfn(_Val)))

  0006b	8b 07		 mov	 eax, DWORD PTR [edi]
  0006d	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00070	7d 29		 jge	 SHORT $L27598
  00072	8d 4d 0c	 lea	 ecx, DWORD PTR __Next$[ebp]
  00075	89 75 0c	 mov	 DWORD PTR __Next$[ebp], esi
  00078	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Dec
  0007d	8b 4d 0c	 mov	 ecx, DWORD PTR __Next$[ebp]
  00080	8b 07		 mov	 eax, DWORD PTR [edi]
  00082	39 41 0c	 cmp	 DWORD PTR [ecx+12], eax
  00085	7d 14		 jge	 SHORT $L27598

; 561  : 				{	// insert before _Where
; 562  : 				if (_Isnil(_Right(_Next._Mynode())))

  00087	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0008a	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0

; 563  : 					return (_Insert(false, _Next._Mynode(), _Val));

  0008e	57		 push	 edi
  0008f	8b fb		 mov	 edi, ebx
  00091	74 04		 je	 SHORT $L27599
  00093	6a 00		 push	 0
  00095	eb af		 jmp	 SHORT $L93271
$L27599:

; 564  : 				else
; 565  : 					return (_Insert(true, _Where._Mynode(), _Val));

  00097	6a 01		 push	 1
  00099	eb 2f		 jmp	 SHORT $L93268
$L27598:

; 566  : 				}
; 567  : 			else if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 568  : 				&& (++(_Next = _Where) == end()
; 569  : 					|| this->comp(this->_Kfn(_Val),
; 570  : 						_Key(_Next._Mynode()))))

  0009b	8b 07		 mov	 eax, DWORD PTR [edi]
  0009d	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  000a0	7d 36		 jge	 SHORT $L27609
  000a2	8d 55 0c	 lea	 edx, DWORD PTR __Next$[ebp]
  000a5	89 75 0c	 mov	 DWORD PTR __Next$[ebp], esi
  000a8	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Inc
  000ad	8b 4d 0c	 mov	 ecx, DWORD PTR __Next$[ebp]
  000b0	3b 4b 04	 cmp	 ecx, DWORD PTR [ebx+4]
  000b3	74 07		 je	 SHORT $L27606
  000b5	8b 07		 mov	 eax, DWORD PTR [edi]
  000b7	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  000ba	7d 1c		 jge	 SHORT $L27609
$L27606:

; 571  : 				{	// insert after _Where
; 572  : 				if (_Isnil(_Right(_Where._Mynode())))

  000bc	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000bf	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0

; 573  : 					return (_Insert(false, _Where._Mynode(), _Val));

  000c3	57		 push	 edi
  000c4	8b fb		 mov	 edi, ebx
  000c6	74 09		 je	 SHORT $L27607
  000c8	6a 00		 push	 0
$L93268:
  000ca	8b ce		 mov	 ecx, esi
  000cc	e9 75 ff ff ff	 jmp	 $L93271
$L27607:

; 574  : 				else
; 575  : 					return (_Insert(true, _Next._Mynode(), _Val));

  000d1	6a 01		 push	 1
  000d3	e9 6e ff ff ff	 jmp	 $L93271
$L27609:

; 576  : 				}
; 577  : 			}
; 578  : 
; 579  : 		return (insert(_Val).first);	// try usual insert if all else fails

  000d8	57		 push	 edi
  000d9	8d 75 f8	 lea	 esi, DWORD PTR $T92724[ebp]
  000dc	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVSub@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::insert
  000e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000e6	89 08		 mov	 DWORD PTR [eax], ecx
$L93265:
  000e8	5e		 pop	 esi
$L27558:
  000e9	5f		 pop	 edi
  000ea	5b		 pop	 ebx

; 580  : 		}

  000eb	c9		 leave
  000ec	c2 08 00	 ret	 8
?insert@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVSub@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::insert
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVSE@@@2@@Z
_TEXT	SEGMENT
$T93280 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Next$ = 12						; size = 4
__Where$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVSE@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::insert, COMDAT
; _this$ = ecx
; __Val$ = eax

; 509  : 		{	// try to insert node with value _Val using _Where as a hint

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	8b d9		 mov	 ebx, ecx

; 510  : 		iterator _Next;
; 511  : 
; 512  : 		if (size() == 0)

  00008	83 7b 08 00	 cmp	 DWORD PTR [ebx+8], 0
  0000c	57		 push	 edi
  0000d	8b f8		 mov	 edi, eax
  0000f	75 18		 jne	 SHORT $L27458

; 513  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

  00011	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00014	57		 push	 edi
  00015	6a 01		 push	 1
  00017	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0001a	8b fb		 mov	 edi, ebx
  0001c	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVSE@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Insert
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00024	e9 c0 00 00 00	 jmp	 $L27456
$L27458:

; 514  : 		else if (this->_Multi)
; 515  : 			{	// insert even if duplicate
; 516  : 			if (_Where == begin())
; 517  : 				{	// insert at beginning if before first element
; 518  : 				if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 519  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 520  : 				}
; 521  : 			else if (_Where == end())
; 522  : 				{	// insert at end if after last element
; 523  : 				if (!this->comp(this->_Kfn(_Val), _Key(_Rmost())))
; 524  : 					return (_Insert(false, _Rmost(), _Val));
; 525  : 				}
; 526  : 			else if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 527  : 				&& !this->comp(this->_Kfn(_Val),
; 528  : 					_Key((--(_Next = _Where))._Mynode())))
; 529  : 				{	// insert before _Where
; 530  : 				if (_Isnil(_Right(_Next._Mynode())))
; 531  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 532  : 				else
; 533  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 534  : 				}
; 535  : 			else if (!this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 536  : 				&& (++(_Next = _Where) == end()
; 537  : 					|| !this->comp(_Key(_Next._Mynode()),
; 538  : 						this->_Kfn(_Val))))
; 539  : 				{	// insert after _Where
; 540  : 				if (_Isnil(_Right(_Where._Mynode())))
; 541  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 542  : 				else
; 543  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 544  : 				}
; 545  : 			}
; 546  : 		else
; 547  : 			{	// insert only if unique
; 548  : 			if (_Where == begin())

  00029	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0002c	56		 push	 esi
  0002d	8b 75 0c	 mov	 esi, DWORD PTR __Where$[ebp]
  00030	3b 30		 cmp	 esi, DWORD PTR [eax]
  00032	75 22		 jne	 SHORT $L27487

; 549  : 				{	// insert at beginning if before first element
; 550  : 				if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode())))

  00034	8b 07		 mov	 eax, DWORD PTR [edi]
  00036	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00039	0f 8d 99 00 00
	00		 jge	 $L27507

; 551  : 					return (_Insert(true, _Where._Mynode(), _Val));

  0003f	57		 push	 edi
  00040	6a 01		 push	 1
  00042	8b ce		 mov	 ecx, esi
$L93826:
  00044	8b fb		 mov	 edi, ebx
$L93827:
  00046	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVSE@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Insert
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00051	e9 92 00 00 00	 jmp	 $L93821
$L27487:

; 552  : 				}
; 553  : 			else if (_Where == end())

  00056	3b f0		 cmp	 esi, eax
  00058	75 11		 jne	 SHORT $L27492

; 554  : 				{	// insert at end if after last element
; 555  : 				if (this->comp(_Key(_Rmost()), this->_Kfn(_Val)))

  0005a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0005d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00060	3b 0f		 cmp	 ecx, DWORD PTR [edi]
  00062	7d 74		 jge	 SHORT $L27507

; 556  : 					return (_Insert(false, _Rmost(), _Val));

  00064	57		 push	 edi
  00065	6a 00		 push	 0
  00067	8b c8		 mov	 ecx, eax
  00069	eb d9		 jmp	 SHORT $L93826
$L27492:

; 557  : 				}
; 558  : 			else if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 559  : 				&& this->comp(_Key((--(_Next = _Where))._Mynode()),
; 560  : 					this->_Kfn(_Val)))

  0006b	8b 07		 mov	 eax, DWORD PTR [edi]
  0006d	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00070	7d 29		 jge	 SHORT $L27496
  00072	8d 4d 0c	 lea	 ecx, DWORD PTR __Next$[ebp]
  00075	89 75 0c	 mov	 DWORD PTR __Next$[ebp], esi
  00078	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::_Dec
  0007d	8b 4d 0c	 mov	 ecx, DWORD PTR __Next$[ebp]
  00080	8b 07		 mov	 eax, DWORD PTR [edi]
  00082	39 41 0c	 cmp	 DWORD PTR [ecx+12], eax
  00085	7d 14		 jge	 SHORT $L27496

; 561  : 				{	// insert before _Where
; 562  : 				if (_Isnil(_Right(_Next._Mynode())))

  00087	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0008a	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0

; 563  : 					return (_Insert(false, _Next._Mynode(), _Val));

  0008e	57		 push	 edi
  0008f	8b fb		 mov	 edi, ebx
  00091	74 04		 je	 SHORT $L27497
  00093	6a 00		 push	 0
  00095	eb af		 jmp	 SHORT $L93827
$L27497:

; 564  : 				else
; 565  : 					return (_Insert(true, _Where._Mynode(), _Val));

  00097	6a 01		 push	 1
  00099	eb 2f		 jmp	 SHORT $L93824
$L27496:

; 566  : 				}
; 567  : 			else if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 568  : 				&& (++(_Next = _Where) == end()
; 569  : 					|| this->comp(this->_Kfn(_Val),
; 570  : 						_Key(_Next._Mynode()))))

  0009b	8b 07		 mov	 eax, DWORD PTR [edi]
  0009d	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  000a0	7d 36		 jge	 SHORT $L27507
  000a2	8d 55 0c	 lea	 edx, DWORD PTR __Next$[ebp]
  000a5	89 75 0c	 mov	 DWORD PTR __Next$[ebp], esi
  000a8	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::const_iterator::_Inc
  000ad	8b 4d 0c	 mov	 ecx, DWORD PTR __Next$[ebp]
  000b0	3b 4b 04	 cmp	 ecx, DWORD PTR [ebx+4]
  000b3	74 07		 je	 SHORT $L27504
  000b5	8b 07		 mov	 eax, DWORD PTR [edi]
  000b7	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  000ba	7d 1c		 jge	 SHORT $L27507
$L27504:

; 571  : 				{	// insert after _Where
; 572  : 				if (_Isnil(_Right(_Where._Mynode())))

  000bc	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000bf	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0

; 573  : 					return (_Insert(false, _Where._Mynode(), _Val));

  000c3	57		 push	 edi
  000c4	8b fb		 mov	 edi, ebx
  000c6	74 09		 je	 SHORT $L27505
  000c8	6a 00		 push	 0
$L93824:
  000ca	8b ce		 mov	 ecx, esi
  000cc	e9 75 ff ff ff	 jmp	 $L93827
$L27505:

; 574  : 				else
; 575  : 					return (_Insert(true, _Next._Mynode(), _Val));

  000d1	6a 01		 push	 1
  000d3	e9 6e ff ff ff	 jmp	 $L93827
$L27507:

; 576  : 				}
; 577  : 			}
; 578  : 
; 579  : 		return (insert(_Val).first);	// try usual insert if all else fails

  000d8	57		 push	 edi
  000d9	8d 75 f8	 lea	 esi, DWORD PTR $T93280[ebp]
  000dc	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVSE@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::insert
  000e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000e6	89 08		 mov	 DWORD PTR [eax], ecx
$L93821:
  000e8	5e		 pop	 esi
$L27456:
  000e9	5f		 pop	 edi
  000ea	5b		 pop	 ebx

; 580  : 		}

  000eb	c9		 leave
  000ec	c2 08 00	 ret	 8
?insert@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVSE@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::insert
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVBGM@@@2@@Z
_TEXT	SEGMENT
$T93836 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Next$ = 12						; size = 4
__Where$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVBGM@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::insert, COMDAT
; _this$ = ecx
; __Val$ = eax

; 509  : 		{	// try to insert node with value _Val using _Where as a hint

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	8b d9		 mov	 ebx, ecx

; 510  : 		iterator _Next;
; 511  : 
; 512  : 		if (size() == 0)

  00008	83 7b 08 00	 cmp	 DWORD PTR [ebx+8], 0
  0000c	57		 push	 edi
  0000d	8b f8		 mov	 edi, eax
  0000f	75 18		 jne	 SHORT $L27354

; 513  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

  00011	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00014	57		 push	 edi
  00015	6a 01		 push	 1
  00017	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0001a	8b fb		 mov	 edi, ebx
  0001c	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVBGM@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Insert
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00024	e9 c0 00 00 00	 jmp	 $L27352
$L27354:

; 514  : 		else if (this->_Multi)
; 515  : 			{	// insert even if duplicate
; 516  : 			if (_Where == begin())
; 517  : 				{	// insert at beginning if before first element
; 518  : 				if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 519  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 520  : 				}
; 521  : 			else if (_Where == end())
; 522  : 				{	// insert at end if after last element
; 523  : 				if (!this->comp(this->_Kfn(_Val), _Key(_Rmost())))
; 524  : 					return (_Insert(false, _Rmost(), _Val));
; 525  : 				}
; 526  : 			else if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 527  : 				&& !this->comp(this->_Kfn(_Val),
; 528  : 					_Key((--(_Next = _Where))._Mynode())))
; 529  : 				{	// insert before _Where
; 530  : 				if (_Isnil(_Right(_Next._Mynode())))
; 531  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 532  : 				else
; 533  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 534  : 				}
; 535  : 			else if (!this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 536  : 				&& (++(_Next = _Where) == end()
; 537  : 					|| !this->comp(_Key(_Next._Mynode()),
; 538  : 						this->_Kfn(_Val))))
; 539  : 				{	// insert after _Where
; 540  : 				if (_Isnil(_Right(_Where._Mynode())))
; 541  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 542  : 				else
; 543  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 544  : 				}
; 545  : 			}
; 546  : 		else
; 547  : 			{	// insert only if unique
; 548  : 			if (_Where == begin())

  00029	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0002c	56		 push	 esi
  0002d	8b 75 0c	 mov	 esi, DWORD PTR __Where$[ebp]
  00030	3b 30		 cmp	 esi, DWORD PTR [eax]
  00032	75 22		 jne	 SHORT $L27383

; 549  : 				{	// insert at beginning if before first element
; 550  : 				if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode())))

  00034	8b 07		 mov	 eax, DWORD PTR [edi]
  00036	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00039	0f 8d 99 00 00
	00		 jge	 $L27403

; 551  : 					return (_Insert(true, _Where._Mynode(), _Val));

  0003f	57		 push	 edi
  00040	6a 01		 push	 1
  00042	8b ce		 mov	 ecx, esi
$L94382:
  00044	8b fb		 mov	 edi, ebx
$L94383:
  00046	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVBGM@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Insert
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00051	e9 92 00 00 00	 jmp	 $L94377
$L27383:

; 552  : 				}
; 553  : 			else if (_Where == end())

  00056	3b f0		 cmp	 esi, eax
  00058	75 11		 jne	 SHORT $L27388

; 554  : 				{	// insert at end if after last element
; 555  : 				if (this->comp(_Key(_Rmost()), this->_Kfn(_Val)))

  0005a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0005d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00060	3b 0f		 cmp	 ecx, DWORD PTR [edi]
  00062	7d 74		 jge	 SHORT $L27403

; 556  : 					return (_Insert(false, _Rmost(), _Val));

  00064	57		 push	 edi
  00065	6a 00		 push	 0
  00067	8b c8		 mov	 ecx, eax
  00069	eb d9		 jmp	 SHORT $L94382
$L27388:

; 557  : 				}
; 558  : 			else if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 559  : 				&& this->comp(_Key((--(_Next = _Where))._Mynode()),
; 560  : 					this->_Kfn(_Val)))

  0006b	8b 07		 mov	 eax, DWORD PTR [edi]
  0006d	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00070	7d 29		 jge	 SHORT $L27392
  00072	8d 4d 0c	 lea	 ecx, DWORD PTR __Next$[ebp]
  00075	89 75 0c	 mov	 DWORD PTR __Next$[ebp], esi
  00078	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::_Dec
  0007d	8b 4d 0c	 mov	 ecx, DWORD PTR __Next$[ebp]
  00080	8b 07		 mov	 eax, DWORD PTR [edi]
  00082	39 41 0c	 cmp	 DWORD PTR [ecx+12], eax
  00085	7d 14		 jge	 SHORT $L27392

; 561  : 				{	// insert before _Where
; 562  : 				if (_Isnil(_Right(_Next._Mynode())))

  00087	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0008a	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0

; 563  : 					return (_Insert(false, _Next._Mynode(), _Val));

  0008e	57		 push	 edi
  0008f	8b fb		 mov	 edi, ebx
  00091	74 04		 je	 SHORT $L27393
  00093	6a 00		 push	 0
  00095	eb af		 jmp	 SHORT $L94383
$L27393:

; 564  : 				else
; 565  : 					return (_Insert(true, _Where._Mynode(), _Val));

  00097	6a 01		 push	 1
  00099	eb 2f		 jmp	 SHORT $L94380
$L27392:

; 566  : 				}
; 567  : 			else if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 568  : 				&& (++(_Next = _Where) == end()
; 569  : 					|| this->comp(this->_Kfn(_Val),
; 570  : 						_Key(_Next._Mynode()))))

  0009b	8b 07		 mov	 eax, DWORD PTR [edi]
  0009d	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  000a0	7d 36		 jge	 SHORT $L27403
  000a2	8d 55 0c	 lea	 edx, DWORD PTR __Next$[ebp]
  000a5	89 75 0c	 mov	 DWORD PTR __Next$[ebp], esi
  000a8	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::const_iterator::_Inc
  000ad	8b 4d 0c	 mov	 ecx, DWORD PTR __Next$[ebp]
  000b0	3b 4b 04	 cmp	 ecx, DWORD PTR [ebx+4]
  000b3	74 07		 je	 SHORT $L27400
  000b5	8b 07		 mov	 eax, DWORD PTR [edi]
  000b7	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  000ba	7d 1c		 jge	 SHORT $L27403
$L27400:

; 571  : 				{	// insert after _Where
; 572  : 				if (_Isnil(_Right(_Where._Mynode())))

  000bc	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000bf	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0

; 573  : 					return (_Insert(false, _Where._Mynode(), _Val));

  000c3	57		 push	 edi
  000c4	8b fb		 mov	 edi, ebx
  000c6	74 09		 je	 SHORT $L27401
  000c8	6a 00		 push	 0
$L94380:
  000ca	8b ce		 mov	 ecx, esi
  000cc	e9 75 ff ff ff	 jmp	 $L94383
$L27401:

; 574  : 				else
; 575  : 					return (_Insert(true, _Next._Mynode(), _Val));

  000d1	6a 01		 push	 1
  000d3	e9 6e ff ff ff	 jmp	 $L94383
$L27403:

; 576  : 				}
; 577  : 			}
; 578  : 
; 579  : 		return (insert(_Val).first);	// try usual insert if all else fails

  000d8	57		 push	 edi
  000d9	8d 75 f8	 lea	 esi, DWORD PTR $T93836[ebp]
  000dc	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVBGM@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::insert
  000e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000e6	89 08		 mov	 DWORD PTR [eax], ecx
$L94377:
  000e8	5e		 pop	 esi
$L27352:
  000e9	5f		 pop	 edi
  000ea	5b		 pop	 ebx

; 580  : 		}

  000eb	c9		 leave
  000ec	c2 08 00	 ret	 8
?insert@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVBGM@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::insert
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVEnvelop@@@2@@Z
_TEXT	SEGMENT
$T94392 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Next$ = 12						; size = 4
__Where$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVEnvelop@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::insert, COMDAT
; _this$ = ecx
; __Val$ = eax

; 509  : 		{	// try to insert node with value _Val using _Where as a hint

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	8b d9		 mov	 ebx, ecx

; 510  : 		iterator _Next;
; 511  : 
; 512  : 		if (size() == 0)

  00008	83 7b 08 00	 cmp	 DWORD PTR [ebx+8], 0
  0000c	57		 push	 edi
  0000d	8b f8		 mov	 edi, eax
  0000f	75 18		 jne	 SHORT $L27248

; 513  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

  00011	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00014	57		 push	 edi
  00015	6a 01		 push	 1
  00017	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0001a	8b fb		 mov	 edi, ebx
  0001c	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVEnvelop@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Insert
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00024	e9 c0 00 00 00	 jmp	 $L27246
$L27248:

; 514  : 		else if (this->_Multi)
; 515  : 			{	// insert even if duplicate
; 516  : 			if (_Where == begin())
; 517  : 				{	// insert at beginning if before first element
; 518  : 				if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 519  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 520  : 				}
; 521  : 			else if (_Where == end())
; 522  : 				{	// insert at end if after last element
; 523  : 				if (!this->comp(this->_Kfn(_Val), _Key(_Rmost())))
; 524  : 					return (_Insert(false, _Rmost(), _Val));
; 525  : 				}
; 526  : 			else if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 527  : 				&& !this->comp(this->_Kfn(_Val),
; 528  : 					_Key((--(_Next = _Where))._Mynode())))
; 529  : 				{	// insert before _Where
; 530  : 				if (_Isnil(_Right(_Next._Mynode())))
; 531  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 532  : 				else
; 533  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 534  : 				}
; 535  : 			else if (!this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 536  : 				&& (++(_Next = _Where) == end()
; 537  : 					|| !this->comp(_Key(_Next._Mynode()),
; 538  : 						this->_Kfn(_Val))))
; 539  : 				{	// insert after _Where
; 540  : 				if (_Isnil(_Right(_Where._Mynode())))
; 541  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 542  : 				else
; 543  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 544  : 				}
; 545  : 			}
; 546  : 		else
; 547  : 			{	// insert only if unique
; 548  : 			if (_Where == begin())

  00029	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0002c	56		 push	 esi
  0002d	8b 75 0c	 mov	 esi, DWORD PTR __Where$[ebp]
  00030	3b 30		 cmp	 esi, DWORD PTR [eax]
  00032	75 22		 jne	 SHORT $L27277

; 549  : 				{	// insert at beginning if before first element
; 550  : 				if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode())))

  00034	8b 07		 mov	 eax, DWORD PTR [edi]
  00036	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00039	0f 8d 99 00 00
	00		 jge	 $L27297

; 551  : 					return (_Insert(true, _Where._Mynode(), _Val));

  0003f	57		 push	 edi
  00040	6a 01		 push	 1
  00042	8b ce		 mov	 ecx, esi
$L94938:
  00044	8b fb		 mov	 edi, ebx
$L94939:
  00046	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVEnvelop@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Insert
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00051	e9 92 00 00 00	 jmp	 $L94933
$L27277:

; 552  : 				}
; 553  : 			else if (_Where == end())

  00056	3b f0		 cmp	 esi, eax
  00058	75 11		 jne	 SHORT $L27282

; 554  : 				{	// insert at end if after last element
; 555  : 				if (this->comp(_Key(_Rmost()), this->_Kfn(_Val)))

  0005a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0005d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00060	3b 0f		 cmp	 ecx, DWORD PTR [edi]
  00062	7d 74		 jge	 SHORT $L27297

; 556  : 					return (_Insert(false, _Rmost(), _Val));

  00064	57		 push	 edi
  00065	6a 00		 push	 0
  00067	8b c8		 mov	 ecx, eax
  00069	eb d9		 jmp	 SHORT $L94938
$L27282:

; 557  : 				}
; 558  : 			else if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 559  : 				&& this->comp(_Key((--(_Next = _Where))._Mynode()),
; 560  : 					this->_Kfn(_Val)))

  0006b	8b 07		 mov	 eax, DWORD PTR [edi]
  0006d	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00070	7d 29		 jge	 SHORT $L27286
  00072	8d 4d 0c	 lea	 ecx, DWORD PTR __Next$[ebp]
  00075	89 75 0c	 mov	 DWORD PTR __Next$[ebp], esi
  00078	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::_Dec
  0007d	8b 4d 0c	 mov	 ecx, DWORD PTR __Next$[ebp]
  00080	8b 07		 mov	 eax, DWORD PTR [edi]
  00082	39 41 0c	 cmp	 DWORD PTR [ecx+12], eax
  00085	7d 14		 jge	 SHORT $L27286

; 561  : 				{	// insert before _Where
; 562  : 				if (_Isnil(_Right(_Next._Mynode())))

  00087	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0008a	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0

; 563  : 					return (_Insert(false, _Next._Mynode(), _Val));

  0008e	57		 push	 edi
  0008f	8b fb		 mov	 edi, ebx
  00091	74 04		 je	 SHORT $L27287
  00093	6a 00		 push	 0
  00095	eb af		 jmp	 SHORT $L94939
$L27287:

; 564  : 				else
; 565  : 					return (_Insert(true, _Where._Mynode(), _Val));

  00097	6a 01		 push	 1
  00099	eb 2f		 jmp	 SHORT $L94936
$L27286:

; 566  : 				}
; 567  : 			else if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 568  : 				&& (++(_Next = _Where) == end()
; 569  : 					|| this->comp(this->_Kfn(_Val),
; 570  : 						_Key(_Next._Mynode()))))

  0009b	8b 07		 mov	 eax, DWORD PTR [edi]
  0009d	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  000a0	7d 36		 jge	 SHORT $L27297
  000a2	8d 55 0c	 lea	 edx, DWORD PTR __Next$[ebp]
  000a5	89 75 0c	 mov	 DWORD PTR __Next$[ebp], esi
  000a8	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::_Inc
  000ad	8b 4d 0c	 mov	 ecx, DWORD PTR __Next$[ebp]
  000b0	3b 4b 04	 cmp	 ecx, DWORD PTR [ebx+4]
  000b3	74 07		 je	 SHORT $L27294
  000b5	8b 07		 mov	 eax, DWORD PTR [edi]
  000b7	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  000ba	7d 1c		 jge	 SHORT $L27297
$L27294:

; 571  : 				{	// insert after _Where
; 572  : 				if (_Isnil(_Right(_Where._Mynode())))

  000bc	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000bf	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0

; 573  : 					return (_Insert(false, _Where._Mynode(), _Val));

  000c3	57		 push	 edi
  000c4	8b fb		 mov	 edi, ebx
  000c6	74 09		 je	 SHORT $L27295
  000c8	6a 00		 push	 0
$L94936:
  000ca	8b ce		 mov	 ecx, esi
  000cc	e9 75 ff ff ff	 jmp	 $L94939
$L27295:

; 574  : 				else
; 575  : 					return (_Insert(true, _Next._Mynode(), _Val));

  000d1	6a 01		 push	 1
  000d3	e9 6e ff ff ff	 jmp	 $L94939
$L27297:

; 576  : 				}
; 577  : 			}
; 578  : 
; 579  : 		return (insert(_Val).first);	// try usual insert if all else fails

  000d8	57		 push	 edi
  000d9	8d 75 f8	 lea	 esi, DWORD PTR $T94392[ebp]
  000dc	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVEnvelop@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::insert
  000e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000e6	89 08		 mov	 DWORD PTR [eax], ecx
$L94933:
  000e8	5e		 pop	 esi
$L27246:
  000e9	5f		 pop	 edi
  000ea	5b		 pop	 ebx

; 580  : 		}

  000eb	c9		 leave
  000ec	c2 08 00	 ret	 8
?insert@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVEnvelop@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::insert
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVN163@@@2@@Z
_TEXT	SEGMENT
$T94948 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Next$ = 12						; size = 4
__Where$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVN163@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::insert, COMDAT
; _this$ = ecx
; __Val$ = eax

; 509  : 		{	// try to insert node with value _Val using _Where as a hint

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	8b d9		 mov	 ebx, ecx

; 510  : 		iterator _Next;
; 511  : 
; 512  : 		if (size() == 0)

  00008	83 7b 08 00	 cmp	 DWORD PTR [ebx+8], 0
  0000c	57		 push	 edi
  0000d	8b f8		 mov	 edi, eax
  0000f	75 18		 jne	 SHORT $L27144

; 513  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

  00011	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00014	57		 push	 edi
  00015	6a 01		 push	 1
  00017	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0001a	8b fb		 mov	 edi, ebx
  0001c	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVN163@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Insert
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00024	e9 c0 00 00 00	 jmp	 $L27142
$L27144:

; 514  : 		else if (this->_Multi)
; 515  : 			{	// insert even if duplicate
; 516  : 			if (_Where == begin())
; 517  : 				{	// insert at beginning if before first element
; 518  : 				if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 519  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 520  : 				}
; 521  : 			else if (_Where == end())
; 522  : 				{	// insert at end if after last element
; 523  : 				if (!this->comp(this->_Kfn(_Val), _Key(_Rmost())))
; 524  : 					return (_Insert(false, _Rmost(), _Val));
; 525  : 				}
; 526  : 			else if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 527  : 				&& !this->comp(this->_Kfn(_Val),
; 528  : 					_Key((--(_Next = _Where))._Mynode())))
; 529  : 				{	// insert before _Where
; 530  : 				if (_Isnil(_Right(_Next._Mynode())))
; 531  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 532  : 				else
; 533  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 534  : 				}
; 535  : 			else if (!this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 536  : 				&& (++(_Next = _Where) == end()
; 537  : 					|| !this->comp(_Key(_Next._Mynode()),
; 538  : 						this->_Kfn(_Val))))
; 539  : 				{	// insert after _Where
; 540  : 				if (_Isnil(_Right(_Where._Mynode())))
; 541  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 542  : 				else
; 543  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 544  : 				}
; 545  : 			}
; 546  : 		else
; 547  : 			{	// insert only if unique
; 548  : 			if (_Where == begin())

  00029	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0002c	56		 push	 esi
  0002d	8b 75 0c	 mov	 esi, DWORD PTR __Where$[ebp]
  00030	3b 30		 cmp	 esi, DWORD PTR [eax]
  00032	75 22		 jne	 SHORT $L27173

; 549  : 				{	// insert at beginning if before first element
; 550  : 				if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode())))

  00034	8b 07		 mov	 eax, DWORD PTR [edi]
  00036	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00039	0f 8d 99 00 00
	00		 jge	 $L27193

; 551  : 					return (_Insert(true, _Where._Mynode(), _Val));

  0003f	57		 push	 edi
  00040	6a 01		 push	 1
  00042	8b ce		 mov	 ecx, esi
$L95494:
  00044	8b fb		 mov	 edi, ebx
$L95495:
  00046	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVN163@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Insert
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00051	e9 92 00 00 00	 jmp	 $L95489
$L27173:

; 552  : 				}
; 553  : 			else if (_Where == end())

  00056	3b f0		 cmp	 esi, eax
  00058	75 11		 jne	 SHORT $L27178

; 554  : 				{	// insert at end if after last element
; 555  : 				if (this->comp(_Key(_Rmost()), this->_Kfn(_Val)))

  0005a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0005d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00060	3b 0f		 cmp	 ecx, DWORD PTR [edi]
  00062	7d 74		 jge	 SHORT $L27193

; 556  : 					return (_Insert(false, _Rmost(), _Val));

  00064	57		 push	 edi
  00065	6a 00		 push	 0
  00067	8b c8		 mov	 ecx, eax
  00069	eb d9		 jmp	 SHORT $L95494
$L27178:

; 557  : 				}
; 558  : 			else if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 559  : 				&& this->comp(_Key((--(_Next = _Where))._Mynode()),
; 560  : 					this->_Kfn(_Val)))

  0006b	8b 07		 mov	 eax, DWORD PTR [edi]
  0006d	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00070	7d 29		 jge	 SHORT $L27182
  00072	8d 4d 0c	 lea	 ecx, DWORD PTR __Next$[ebp]
  00075	89 75 0c	 mov	 DWORD PTR __Next$[ebp], esi
  00078	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::_Dec
  0007d	8b 4d 0c	 mov	 ecx, DWORD PTR __Next$[ebp]
  00080	8b 07		 mov	 eax, DWORD PTR [edi]
  00082	39 41 0c	 cmp	 DWORD PTR [ecx+12], eax
  00085	7d 14		 jge	 SHORT $L27182

; 561  : 				{	// insert before _Where
; 562  : 				if (_Isnil(_Right(_Next._Mynode())))

  00087	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0008a	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0

; 563  : 					return (_Insert(false, _Next._Mynode(), _Val));

  0008e	57		 push	 edi
  0008f	8b fb		 mov	 edi, ebx
  00091	74 04		 je	 SHORT $L27183
  00093	6a 00		 push	 0
  00095	eb af		 jmp	 SHORT $L95495
$L27183:

; 564  : 				else
; 565  : 					return (_Insert(true, _Where._Mynode(), _Val));

  00097	6a 01		 push	 1
  00099	eb 2f		 jmp	 SHORT $L95492
$L27182:

; 566  : 				}
; 567  : 			else if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 568  : 				&& (++(_Next = _Where) == end()
; 569  : 					|| this->comp(this->_Kfn(_Val),
; 570  : 						_Key(_Next._Mynode()))))

  0009b	8b 07		 mov	 eax, DWORD PTR [edi]
  0009d	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  000a0	7d 36		 jge	 SHORT $L27193
  000a2	8d 55 0c	 lea	 edx, DWORD PTR __Next$[ebp]
  000a5	89 75 0c	 mov	 DWORD PTR __Next$[ebp], esi
  000a8	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::_Inc
  000ad	8b 4d 0c	 mov	 ecx, DWORD PTR __Next$[ebp]
  000b0	3b 4b 04	 cmp	 ecx, DWORD PTR [ebx+4]
  000b3	74 07		 je	 SHORT $L27190
  000b5	8b 07		 mov	 eax, DWORD PTR [edi]
  000b7	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  000ba	7d 1c		 jge	 SHORT $L27193
$L27190:

; 571  : 				{	// insert after _Where
; 572  : 				if (_Isnil(_Right(_Where._Mynode())))

  000bc	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000bf	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0

; 573  : 					return (_Insert(false, _Where._Mynode(), _Val));

  000c3	57		 push	 edi
  000c4	8b fb		 mov	 edi, ebx
  000c6	74 09		 je	 SHORT $L27191
  000c8	6a 00		 push	 0
$L95492:
  000ca	8b ce		 mov	 ecx, esi
  000cc	e9 75 ff ff ff	 jmp	 $L95495
$L27191:

; 574  : 				else
; 575  : 					return (_Insert(true, _Next._Mynode(), _Val));

  000d1	6a 01		 push	 1
  000d3	e9 6e ff ff ff	 jmp	 $L95495
$L27193:

; 576  : 				}
; 577  : 			}
; 578  : 
; 579  : 		return (insert(_Val).first);	// try usual insert if all else fails

  000d8	57		 push	 edi
  000d9	8d 75 f8	 lea	 esi, DWORD PTR $T94948[ebp]
  000dc	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVN163@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::insert
  000e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000e6	89 08		 mov	 DWORD PTR [eax], ecx
$L95489:
  000e8	5e		 pop	 esi
$L27142:
  000e9	5f		 pop	 edi
  000ea	5b		 pop	 ebx

; 580  : 		}

  000eb	c9		 leave
  000ec	c2 08 00	 ret	 8
?insert@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVN163@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::insert
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVVRC7@@@2@@Z
_TEXT	SEGMENT
$T95504 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Next$ = 12						; size = 4
__Where$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVVRC7@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::insert, COMDAT
; _this$ = ecx
; __Val$ = eax

; 509  : 		{	// try to insert node with value _Val using _Where as a hint

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	8b d9		 mov	 ebx, ecx

; 510  : 		iterator _Next;
; 511  : 
; 512  : 		if (size() == 0)

  00008	83 7b 08 00	 cmp	 DWORD PTR [ebx+8], 0
  0000c	57		 push	 edi
  0000d	8b f8		 mov	 edi, eax
  0000f	75 18		 jne	 SHORT $L27040

; 513  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

  00011	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00014	57		 push	 edi
  00015	6a 01		 push	 1
  00017	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0001a	8b fb		 mov	 edi, ebx
  0001c	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVVRC7@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Insert
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00024	e9 c0 00 00 00	 jmp	 $L27038
$L27040:

; 514  : 		else if (this->_Multi)
; 515  : 			{	// insert even if duplicate
; 516  : 			if (_Where == begin())
; 517  : 				{	// insert at beginning if before first element
; 518  : 				if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 519  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 520  : 				}
; 521  : 			else if (_Where == end())
; 522  : 				{	// insert at end if after last element
; 523  : 				if (!this->comp(this->_Kfn(_Val), _Key(_Rmost())))
; 524  : 					return (_Insert(false, _Rmost(), _Val));
; 525  : 				}
; 526  : 			else if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 527  : 				&& !this->comp(this->_Kfn(_Val),
; 528  : 					_Key((--(_Next = _Where))._Mynode())))
; 529  : 				{	// insert before _Where
; 530  : 				if (_Isnil(_Right(_Next._Mynode())))
; 531  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 532  : 				else
; 533  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 534  : 				}
; 535  : 			else if (!this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 536  : 				&& (++(_Next = _Where) == end()
; 537  : 					|| !this->comp(_Key(_Next._Mynode()),
; 538  : 						this->_Kfn(_Val))))
; 539  : 				{	// insert after _Where
; 540  : 				if (_Isnil(_Right(_Where._Mynode())))
; 541  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 542  : 				else
; 543  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 544  : 				}
; 545  : 			}
; 546  : 		else
; 547  : 			{	// insert only if unique
; 548  : 			if (_Where == begin())

  00029	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0002c	56		 push	 esi
  0002d	8b 75 0c	 mov	 esi, DWORD PTR __Where$[ebp]
  00030	3b 30		 cmp	 esi, DWORD PTR [eax]
  00032	75 22		 jne	 SHORT $L27069

; 549  : 				{	// insert at beginning if before first element
; 550  : 				if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode())))

  00034	8b 07		 mov	 eax, DWORD PTR [edi]
  00036	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00039	0f 8d 99 00 00
	00		 jge	 $L27089

; 551  : 					return (_Insert(true, _Where._Mynode(), _Val));

  0003f	57		 push	 edi
  00040	6a 01		 push	 1
  00042	8b ce		 mov	 ecx, esi
$L96050:
  00044	8b fb		 mov	 edi, ebx
$L96051:
  00046	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVVRC7@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Insert
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00051	e9 92 00 00 00	 jmp	 $L96045
$L27069:

; 552  : 				}
; 553  : 			else if (_Where == end())

  00056	3b f0		 cmp	 esi, eax
  00058	75 11		 jne	 SHORT $L27074

; 554  : 				{	// insert at end if after last element
; 555  : 				if (this->comp(_Key(_Rmost()), this->_Kfn(_Val)))

  0005a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0005d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00060	3b 0f		 cmp	 ecx, DWORD PTR [edi]
  00062	7d 74		 jge	 SHORT $L27089

; 556  : 					return (_Insert(false, _Rmost(), _Val));

  00064	57		 push	 edi
  00065	6a 00		 push	 0
  00067	8b c8		 mov	 ecx, eax
  00069	eb d9		 jmp	 SHORT $L96050
$L27074:

; 557  : 				}
; 558  : 			else if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 559  : 				&& this->comp(_Key((--(_Next = _Where))._Mynode()),
; 560  : 					this->_Kfn(_Val)))

  0006b	8b 07		 mov	 eax, DWORD PTR [edi]
  0006d	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00070	7d 29		 jge	 SHORT $L27078
  00072	8d 4d 0c	 lea	 ecx, DWORD PTR __Next$[ebp]
  00075	89 75 0c	 mov	 DWORD PTR __Next$[ebp], esi
  00078	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::_Dec
  0007d	8b 4d 0c	 mov	 ecx, DWORD PTR __Next$[ebp]
  00080	8b 07		 mov	 eax, DWORD PTR [edi]
  00082	39 41 0c	 cmp	 DWORD PTR [ecx+12], eax
  00085	7d 14		 jge	 SHORT $L27078

; 561  : 				{	// insert before _Where
; 562  : 				if (_Isnil(_Right(_Next._Mynode())))

  00087	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0008a	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0

; 563  : 					return (_Insert(false, _Next._Mynode(), _Val));

  0008e	57		 push	 edi
  0008f	8b fb		 mov	 edi, ebx
  00091	74 04		 je	 SHORT $L27079
  00093	6a 00		 push	 0
  00095	eb af		 jmp	 SHORT $L96051
$L27079:

; 564  : 				else
; 565  : 					return (_Insert(true, _Where._Mynode(), _Val));

  00097	6a 01		 push	 1
  00099	eb 2f		 jmp	 SHORT $L96048
$L27078:

; 566  : 				}
; 567  : 			else if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 568  : 				&& (++(_Next = _Where) == end()
; 569  : 					|| this->comp(this->_Kfn(_Val),
; 570  : 						_Key(_Next._Mynode()))))

  0009b	8b 07		 mov	 eax, DWORD PTR [edi]
  0009d	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  000a0	7d 36		 jge	 SHORT $L27089
  000a2	8d 55 0c	 lea	 edx, DWORD PTR __Next$[ebp]
  000a5	89 75 0c	 mov	 DWORD PTR __Next$[ebp], esi
  000a8	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::_Inc
  000ad	8b 4d 0c	 mov	 ecx, DWORD PTR __Next$[ebp]
  000b0	3b 4b 04	 cmp	 ecx, DWORD PTR [ebx+4]
  000b3	74 07		 je	 SHORT $L27086
  000b5	8b 07		 mov	 eax, DWORD PTR [edi]
  000b7	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  000ba	7d 1c		 jge	 SHORT $L27089
$L27086:

; 571  : 				{	// insert after _Where
; 572  : 				if (_Isnil(_Right(_Where._Mynode())))

  000bc	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000bf	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0

; 573  : 					return (_Insert(false, _Where._Mynode(), _Val));

  000c3	57		 push	 edi
  000c4	8b fb		 mov	 edi, ebx
  000c6	74 09		 je	 SHORT $L27087
  000c8	6a 00		 push	 0
$L96048:
  000ca	8b ce		 mov	 ecx, esi
  000cc	e9 75 ff ff ff	 jmp	 $L96051
$L27087:

; 574  : 				else
; 575  : 					return (_Insert(true, _Next._Mynode(), _Val));

  000d1	6a 01		 push	 1
  000d3	e9 6e ff ff ff	 jmp	 $L96051
$L27089:

; 576  : 				}
; 577  : 			}
; 578  : 
; 579  : 		return (insert(_Val).first);	// try usual insert if all else fails

  000d8	57		 push	 edi
  000d9	8d 75 f8	 lea	 esi, DWORD PTR $T95504[ebp]
  000dc	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVVRC7@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::insert
  000e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000e6	89 08		 mov	 DWORD PTR [eax], ecx
$L96045:
  000e8	5e		 pop	 esi
$L27038:
  000e9	5f		 pop	 edi
  000ea	5b		 pop	 ebx

; 580  : 		}

  000eb	c9		 leave
  000ec	c2 08 00	 ret	 8
?insert@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVVRC7@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::insert
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVFDSM@@@2@@Z
_TEXT	SEGMENT
$T96060 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Next$ = 12						; size = 4
__Where$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVFDSM@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::insert, COMDAT
; _this$ = ecx
; __Val$ = eax

; 509  : 		{	// try to insert node with value _Val using _Where as a hint

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	8b d9		 mov	 ebx, ecx

; 510  : 		iterator _Next;
; 511  : 
; 512  : 		if (size() == 0)

  00008	83 7b 08 00	 cmp	 DWORD PTR [ebx+8], 0
  0000c	57		 push	 edi
  0000d	8b f8		 mov	 edi, eax
  0000f	75 18		 jne	 SHORT $L26936

; 513  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

  00011	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00014	57		 push	 edi
  00015	6a 01		 push	 1
  00017	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0001a	8b fb		 mov	 edi, ebx
  0001c	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVFDSM@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Insert
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00024	e9 c0 00 00 00	 jmp	 $L26934
$L26936:

; 514  : 		else if (this->_Multi)
; 515  : 			{	// insert even if duplicate
; 516  : 			if (_Where == begin())
; 517  : 				{	// insert at beginning if before first element
; 518  : 				if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 519  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 520  : 				}
; 521  : 			else if (_Where == end())
; 522  : 				{	// insert at end if after last element
; 523  : 				if (!this->comp(this->_Kfn(_Val), _Key(_Rmost())))
; 524  : 					return (_Insert(false, _Rmost(), _Val));
; 525  : 				}
; 526  : 			else if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 527  : 				&& !this->comp(this->_Kfn(_Val),
; 528  : 					_Key((--(_Next = _Where))._Mynode())))
; 529  : 				{	// insert before _Where
; 530  : 				if (_Isnil(_Right(_Next._Mynode())))
; 531  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 532  : 				else
; 533  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 534  : 				}
; 535  : 			else if (!this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 536  : 				&& (++(_Next = _Where) == end()
; 537  : 					|| !this->comp(_Key(_Next._Mynode()),
; 538  : 						this->_Kfn(_Val))))
; 539  : 				{	// insert after _Where
; 540  : 				if (_Isnil(_Right(_Where._Mynode())))
; 541  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 542  : 				else
; 543  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 544  : 				}
; 545  : 			}
; 546  : 		else
; 547  : 			{	// insert only if unique
; 548  : 			if (_Where == begin())

  00029	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0002c	56		 push	 esi
  0002d	8b 75 0c	 mov	 esi, DWORD PTR __Where$[ebp]
  00030	3b 30		 cmp	 esi, DWORD PTR [eax]
  00032	75 22		 jne	 SHORT $L26965

; 549  : 				{	// insert at beginning if before first element
; 550  : 				if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode())))

  00034	8b 07		 mov	 eax, DWORD PTR [edi]
  00036	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00039	0f 8d 99 00 00
	00		 jge	 $L26985

; 551  : 					return (_Insert(true, _Where._Mynode(), _Val));

  0003f	57		 push	 edi
  00040	6a 01		 push	 1
  00042	8b ce		 mov	 ecx, esi
$L96606:
  00044	8b fb		 mov	 edi, ebx
$L96607:
  00046	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVFDSM@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Insert
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00051	e9 92 00 00 00	 jmp	 $L96601
$L26965:

; 552  : 				}
; 553  : 			else if (_Where == end())

  00056	3b f0		 cmp	 esi, eax
  00058	75 11		 jne	 SHORT $L26970

; 554  : 				{	// insert at end if after last element
; 555  : 				if (this->comp(_Key(_Rmost()), this->_Kfn(_Val)))

  0005a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0005d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00060	3b 0f		 cmp	 ecx, DWORD PTR [edi]
  00062	7d 74		 jge	 SHORT $L26985

; 556  : 					return (_Insert(false, _Rmost(), _Val));

  00064	57		 push	 edi
  00065	6a 00		 push	 0
  00067	8b c8		 mov	 ecx, eax
  00069	eb d9		 jmp	 SHORT $L96606
$L26970:

; 557  : 				}
; 558  : 			else if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 559  : 				&& this->comp(_Key((--(_Next = _Where))._Mynode()),
; 560  : 					this->_Kfn(_Val)))

  0006b	8b 07		 mov	 eax, DWORD PTR [edi]
  0006d	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00070	7d 29		 jge	 SHORT $L26974
  00072	8d 4d 0c	 lea	 ecx, DWORD PTR __Next$[ebp]
  00075	89 75 0c	 mov	 DWORD PTR __Next$[ebp], esi
  00078	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::_Dec
  0007d	8b 4d 0c	 mov	 ecx, DWORD PTR __Next$[ebp]
  00080	8b 07		 mov	 eax, DWORD PTR [edi]
  00082	39 41 0c	 cmp	 DWORD PTR [ecx+12], eax
  00085	7d 14		 jge	 SHORT $L26974

; 561  : 				{	// insert before _Where
; 562  : 				if (_Isnil(_Right(_Next._Mynode())))

  00087	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0008a	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0

; 563  : 					return (_Insert(false, _Next._Mynode(), _Val));

  0008e	57		 push	 edi
  0008f	8b fb		 mov	 edi, ebx
  00091	74 04		 je	 SHORT $L26975
  00093	6a 00		 push	 0
  00095	eb af		 jmp	 SHORT $L96607
$L26975:

; 564  : 				else
; 565  : 					return (_Insert(true, _Where._Mynode(), _Val));

  00097	6a 01		 push	 1
  00099	eb 2f		 jmp	 SHORT $L96604
$L26974:

; 566  : 				}
; 567  : 			else if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 568  : 				&& (++(_Next = _Where) == end()
; 569  : 					|| this->comp(this->_Kfn(_Val),
; 570  : 						_Key(_Next._Mynode()))))

  0009b	8b 07		 mov	 eax, DWORD PTR [edi]
  0009d	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  000a0	7d 36		 jge	 SHORT $L26985
  000a2	8d 55 0c	 lea	 edx, DWORD PTR __Next$[ebp]
  000a5	89 75 0c	 mov	 DWORD PTR __Next$[ebp], esi
  000a8	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::_Inc
  000ad	8b 4d 0c	 mov	 ecx, DWORD PTR __Next$[ebp]
  000b0	3b 4b 04	 cmp	 ecx, DWORD PTR [ebx+4]
  000b3	74 07		 je	 SHORT $L26982
  000b5	8b 07		 mov	 eax, DWORD PTR [edi]
  000b7	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  000ba	7d 1c		 jge	 SHORT $L26985
$L26982:

; 571  : 				{	// insert after _Where
; 572  : 				if (_Isnil(_Right(_Where._Mynode())))

  000bc	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000bf	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0

; 573  : 					return (_Insert(false, _Where._Mynode(), _Val));

  000c3	57		 push	 edi
  000c4	8b fb		 mov	 edi, ebx
  000c6	74 09		 je	 SHORT $L26983
  000c8	6a 00		 push	 0
$L96604:
  000ca	8b ce		 mov	 ecx, esi
  000cc	e9 75 ff ff ff	 jmp	 $L96607
$L26983:

; 574  : 				else
; 575  : 					return (_Insert(true, _Next._Mynode(), _Val));

  000d1	6a 01		 push	 1
  000d3	e9 6e ff ff ff	 jmp	 $L96607
$L26985:

; 576  : 				}
; 577  : 			}
; 578  : 
; 579  : 		return (insert(_Val).first);	// try usual insert if all else fails

  000d8	57		 push	 edi
  000d9	8d 75 f8	 lea	 esi, DWORD PTR $T96060[ebp]
  000dc	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVFDSM@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::insert
  000e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000e6	89 08		 mov	 DWORD PTR [eax], ecx
$L96601:
  000e8	5e		 pop	 esi
$L26934:
  000e9	5f		 pop	 edi
  000ea	5b		 pop	 ebx

; 580  : 		}

  000eb	c9		 leave
  000ec	c2 08 00	 ret	 8
?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVFDSM@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::insert
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVFDSC@@@2@@Z
_TEXT	SEGMENT
$T96616 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Next$ = 12						; size = 4
__Where$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVFDSC@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::insert, COMDAT
; _this$ = ecx
; __Val$ = eax

; 509  : 		{	// try to insert node with value _Val using _Where as a hint

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	8b d9		 mov	 ebx, ecx

; 510  : 		iterator _Next;
; 511  : 
; 512  : 		if (size() == 0)

  00008	83 7b 08 00	 cmp	 DWORD PTR [ebx+8], 0
  0000c	57		 push	 edi
  0000d	8b f8		 mov	 edi, eax
  0000f	75 18		 jne	 SHORT $L26832

; 513  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

  00011	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00014	57		 push	 edi
  00015	6a 01		 push	 1
  00017	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0001a	8b fb		 mov	 edi, ebx
  0001c	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVFDSC@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Insert
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00024	e9 c0 00 00 00	 jmp	 $L26830
$L26832:

; 514  : 		else if (this->_Multi)
; 515  : 			{	// insert even if duplicate
; 516  : 			if (_Where == begin())
; 517  : 				{	// insert at beginning if before first element
; 518  : 				if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 519  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 520  : 				}
; 521  : 			else if (_Where == end())
; 522  : 				{	// insert at end if after last element
; 523  : 				if (!this->comp(this->_Kfn(_Val), _Key(_Rmost())))
; 524  : 					return (_Insert(false, _Rmost(), _Val));
; 525  : 				}
; 526  : 			else if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 527  : 				&& !this->comp(this->_Kfn(_Val),
; 528  : 					_Key((--(_Next = _Where))._Mynode())))
; 529  : 				{	// insert before _Where
; 530  : 				if (_Isnil(_Right(_Next._Mynode())))
; 531  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 532  : 				else
; 533  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 534  : 				}
; 535  : 			else if (!this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 536  : 				&& (++(_Next = _Where) == end()
; 537  : 					|| !this->comp(_Key(_Next._Mynode()),
; 538  : 						this->_Kfn(_Val))))
; 539  : 				{	// insert after _Where
; 540  : 				if (_Isnil(_Right(_Where._Mynode())))
; 541  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 542  : 				else
; 543  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 544  : 				}
; 545  : 			}
; 546  : 		else
; 547  : 			{	// insert only if unique
; 548  : 			if (_Where == begin())

  00029	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0002c	56		 push	 esi
  0002d	8b 75 0c	 mov	 esi, DWORD PTR __Where$[ebp]
  00030	3b 30		 cmp	 esi, DWORD PTR [eax]
  00032	75 22		 jne	 SHORT $L26861

; 549  : 				{	// insert at beginning if before first element
; 550  : 				if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode())))

  00034	8b 07		 mov	 eax, DWORD PTR [edi]
  00036	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00039	0f 8d 99 00 00
	00		 jge	 $L26881

; 551  : 					return (_Insert(true, _Where._Mynode(), _Val));

  0003f	57		 push	 edi
  00040	6a 01		 push	 1
  00042	8b ce		 mov	 ecx, esi
$L97162:
  00044	8b fb		 mov	 edi, ebx
$L97163:
  00046	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBHPAVFDSC@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Insert
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00051	e9 92 00 00 00	 jmp	 $L97157
$L26861:

; 552  : 				}
; 553  : 			else if (_Where == end())

  00056	3b f0		 cmp	 esi, eax
  00058	75 11		 jne	 SHORT $L26866

; 554  : 				{	// insert at end if after last element
; 555  : 				if (this->comp(_Key(_Rmost()), this->_Kfn(_Val)))

  0005a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0005d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00060	3b 0f		 cmp	 ecx, DWORD PTR [edi]
  00062	7d 74		 jge	 SHORT $L26881

; 556  : 					return (_Insert(false, _Rmost(), _Val));

  00064	57		 push	 edi
  00065	6a 00		 push	 0
  00067	8b c8		 mov	 ecx, eax
  00069	eb d9		 jmp	 SHORT $L97162
$L26866:

; 557  : 				}
; 558  : 			else if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 559  : 				&& this->comp(_Key((--(_Next = _Where))._Mynode()),
; 560  : 					this->_Kfn(_Val)))

  0006b	8b 07		 mov	 eax, DWORD PTR [edi]
  0006d	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00070	7d 29		 jge	 SHORT $L26870
  00072	8d 4d 0c	 lea	 ecx, DWORD PTR __Next$[ebp]
  00075	89 75 0c	 mov	 DWORD PTR __Next$[ebp], esi
  00078	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::_Dec
  0007d	8b 4d 0c	 mov	 ecx, DWORD PTR __Next$[ebp]
  00080	8b 07		 mov	 eax, DWORD PTR [edi]
  00082	39 41 0c	 cmp	 DWORD PTR [ecx+12], eax
  00085	7d 14		 jge	 SHORT $L26870

; 561  : 				{	// insert before _Where
; 562  : 				if (_Isnil(_Right(_Next._Mynode())))

  00087	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0008a	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0

; 563  : 					return (_Insert(false, _Next._Mynode(), _Val));

  0008e	57		 push	 edi
  0008f	8b fb		 mov	 edi, ebx
  00091	74 04		 je	 SHORT $L26871
  00093	6a 00		 push	 0
  00095	eb af		 jmp	 SHORT $L97163
$L26871:

; 564  : 				else
; 565  : 					return (_Insert(true, _Where._Mynode(), _Val));

  00097	6a 01		 push	 1
  00099	eb 2f		 jmp	 SHORT $L97160
$L26870:

; 566  : 				}
; 567  : 			else if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 568  : 				&& (++(_Next = _Where) == end()
; 569  : 					|| this->comp(this->_Kfn(_Val),
; 570  : 						_Key(_Next._Mynode()))))

  0009b	8b 07		 mov	 eax, DWORD PTR [edi]
  0009d	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  000a0	7d 36		 jge	 SHORT $L26881
  000a2	8d 55 0c	 lea	 edx, DWORD PTR __Next$[ebp]
  000a5	89 75 0c	 mov	 DWORD PTR __Next$[ebp], esi
  000a8	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::_Inc
  000ad	8b 4d 0c	 mov	 ecx, DWORD PTR __Next$[ebp]
  000b0	3b 4b 04	 cmp	 ecx, DWORD PTR [ebx+4]
  000b3	74 07		 je	 SHORT $L26878
  000b5	8b 07		 mov	 eax, DWORD PTR [edi]
  000b7	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  000ba	7d 1c		 jge	 SHORT $L26881
$L26878:

; 571  : 				{	// insert after _Where
; 572  : 				if (_Isnil(_Right(_Where._Mynode())))

  000bc	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000bf	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0

; 573  : 					return (_Insert(false, _Where._Mynode(), _Val));

  000c3	57		 push	 edi
  000c4	8b fb		 mov	 edi, ebx
  000c6	74 09		 je	 SHORT $L26879
  000c8	6a 00		 push	 0
$L97160:
  000ca	8b ce		 mov	 ecx, esi
  000cc	e9 75 ff ff ff	 jmp	 $L97163
$L26879:

; 574  : 				else
; 575  : 					return (_Insert(true, _Next._Mynode(), _Val));

  000d1	6a 01		 push	 1
  000d3	e9 6e ff ff ff	 jmp	 $L97163
$L26881:

; 576  : 				}
; 577  : 			}
; 578  : 
; 579  : 		return (insert(_Val).first);	// try usual insert if all else fails

  000d8	57		 push	 edi
  000d9	8d 75 f8	 lea	 esi, DWORD PTR $T96616[ebp]
  000dc	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHPAVFDSC@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::insert
  000e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000e6	89 08		 mov	 DWORD PTR [eax], ecx
$L97157:
  000e8	5e		 pop	 esi
$L26830:
  000e9	5f		 pop	 edi
  000ea	5b		 pop	 ebx

; 580  : 		}

  000eb	c9		 leave
  000ec	c2 08 00	 ret	 8
?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVFDSC@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::insert
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?_Insert@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEXViterator@12@ABQAVMusicItem@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEXViterator@12@ABQAVMusicItem@@@Z PROC NEAR ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Insert, COMDAT

; 521  : 		{	// insert _Val at _Where

  00000	56		 push	 esi
  00001	57		 push	 edi

; 522  : 		_Nodeptr _Pnode = _Where._Mynode();
; 523  : 		_Nodeptr _Newnode = _Buynode(_Pnode, _Prevnode(_Pnode), _Val);

  00002	ff 74 24 14	 push	 DWORD PTR __Val$[esp+4]
  00006	8b 7c 24 14	 mov	 edi, DWORD PTR __Where$[esp+8]
  0000a	ff 77 04	 push	 DWORD PTR [edi+4]
  0000d	57		 push	 edi
  0000e	e8 00 00 00 00	 call	 ?_Buynode@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@PAU342@0ABQAVMusicItem@@@Z ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Buynode

; 524  : 		_Incsize(1);

  00013	8b 4c 24 0c	 mov	 ecx, DWORD PTR _this$[esp+4]
  00017	33 d2		 xor	 edx, edx
  00019	42		 inc	 edx
  0001a	8b f0		 mov	 esi, eax
  0001c	e8 00 00 00 00	 call	 ?_Incsize@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@IAEXI@Z ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Incsize

; 525  : 		_Prevnode(_Pnode) = _Newnode;

  00021	89 77 04	 mov	 DWORD PTR [edi+4], esi

; 526  : 		_Nextnode(_Prevnode(_Newnode)) = _Newnode;

  00024	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00027	5f		 pop	 edi
  00028	89 30		 mov	 DWORD PTR [eax], esi
  0002a	5e		 pop	 esi

; 527  : 		}

  0002b	c2 0c 00	 ret	 12			; 0000000cH
?_Insert@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEXViterator@12@ABQAVMusicItem@@@Z ENDP ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Insert
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ??A?$map@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@@std@@QAEAAPAVSub@@ABH@Z
_TEXT	SEGMENT
$T97186 = -12						; size = 8
$T97188 = -4						; size = 4
??A?$map@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@@std@@QAEAAPAVSub@@ABH@Z PROC NEAR ; std::map<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> > >::operator[], COMDAT
; _this$ = edi
; __Keyval$ = esi

; 142  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 143  : 		iterator _Where = this->lower_bound(_Keyval);

  00006	8b d6		 mov	 edx, esi
  00008	8b c7		 mov	 eax, edi
  0000a	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Lbound

; 144  : 		if (_Where == this->end() || this->comp(_Keyval, this->_Key(_Where._Mynode())))

  0000f	3b 47 04	 cmp	 eax, DWORD PTR [edi+4]
  00012	74 07		 je	 SHORT $L26647
  00014	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00016	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00019	7d 1a		 jge	 SHORT $L26646
$L26647:

; 145  : 			_Where = this->insert(_Where,
; 146  : 				value_type(_Keyval, mapped_type()));

  0001b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001d	83 65 f8 00	 and	 DWORD PTR $T97186[ebp+4], 0
  00021	50		 push	 eax
  00022	8d 45 fc	 lea	 eax, DWORD PTR $T97188[ebp]
  00025	89 4d f4	 mov	 DWORD PTR $T97186[ebp], ecx
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR $T97186[ebp]
  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVSub@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::insert
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
$L26646:

; 147  : 		return ((*_Where).second);

  00035	83 c0 10	 add	 eax, 16			; 00000010H

; 148  : 		}

  00038	c9		 leave
  00039	c3		 ret	 0
??A?$map@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@@std@@QAEAAPAVSub@@ABH@Z ENDP ; std::map<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> > >::operator[]
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??A?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAEAAPAVSE@@ABH@Z
_TEXT	SEGMENT
$T97264 = -12						; size = 8
$T97266 = -4						; size = 4
??A?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAEAAPAVSE@@ABH@Z PROC NEAR ; std::map<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> > >::operator[], COMDAT
; _this$ = edi
; __Keyval$ = esi

; 142  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 143  : 		iterator _Where = this->lower_bound(_Keyval);

  00006	8b d6		 mov	 edx, esi
  00008	8b c7		 mov	 eax, edi
  0000a	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Lbound

; 144  : 		if (_Where == this->end() || this->comp(_Keyval, this->_Key(_Where._Mynode())))

  0000f	3b 47 04	 cmp	 eax, DWORD PTR [edi+4]
  00012	74 07		 je	 SHORT $L26577
  00014	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00016	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00019	7d 1a		 jge	 SHORT $L26576
$L26577:

; 145  : 			_Where = this->insert(_Where,
; 146  : 				value_type(_Keyval, mapped_type()));

  0001b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001d	83 65 f8 00	 and	 DWORD PTR $T97264[ebp+4], 0
  00021	50		 push	 eax
  00022	8d 45 fc	 lea	 eax, DWORD PTR $T97266[ebp]
  00025	89 4d f4	 mov	 DWORD PTR $T97264[ebp], ecx
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR $T97264[ebp]
  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVSE@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::insert
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
$L26576:

; 147  : 		return ((*_Where).second);

  00035	83 c0 10	 add	 eax, 16			; 00000010H

; 148  : 		}

  00038	c9		 leave
  00039	c3		 ret	 0
??A?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAEAAPAVSE@@ABH@Z ENDP ; std::map<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> > >::operator[]
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??A?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAEAAPAVBGM@@ABH@Z
_TEXT	SEGMENT
$T97342 = -12						; size = 8
$T97344 = -4						; size = 4
??A?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAEAAPAVBGM@@ABH@Z PROC NEAR ; std::map<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> > >::operator[], COMDAT
; _this$ = edi
; __Keyval$ = esi

; 142  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 143  : 		iterator _Where = this->lower_bound(_Keyval);

  00006	8b d6		 mov	 edx, esi
  00008	8b c7		 mov	 eax, edi
  0000a	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Lbound

; 144  : 		if (_Where == this->end() || this->comp(_Keyval, this->_Key(_Where._Mynode())))

  0000f	3b 47 04	 cmp	 eax, DWORD PTR [edi+4]
  00012	74 07		 je	 SHORT $L26507
  00014	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00016	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00019	7d 1a		 jge	 SHORT $L26506
$L26507:

; 145  : 			_Where = this->insert(_Where,
; 146  : 				value_type(_Keyval, mapped_type()));

  0001b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001d	83 65 f8 00	 and	 DWORD PTR $T97342[ebp+4], 0
  00021	50		 push	 eax
  00022	8d 45 fc	 lea	 eax, DWORD PTR $T97344[ebp]
  00025	89 4d f4	 mov	 DWORD PTR $T97342[ebp], ecx
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR $T97342[ebp]
  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVBGM@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::insert
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
$L26506:

; 147  : 		return ((*_Where).second);

  00035	83 c0 10	 add	 eax, 16			; 00000010H

; 148  : 		}

  00038	c9		 leave
  00039	c3		 ret	 0
??A?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAEAAPAVBGM@@ABH@Z ENDP ; std::map<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> > >::operator[]
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??A?$map@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@@std@@QAEAAPAVEnvelop@@ABH@Z
_TEXT	SEGMENT
$T97420 = -12						; size = 8
$T97422 = -4						; size = 4
??A?$map@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@@std@@QAEAAPAVEnvelop@@ABH@Z PROC NEAR ; std::map<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> > >::operator[], COMDAT
; _this$ = edi
; __Keyval$ = esi

; 142  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 143  : 		iterator _Where = this->lower_bound(_Keyval);

  00006	8b d6		 mov	 edx, esi
  00008	8b c7		 mov	 eax, edi
  0000a	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Lbound

; 144  : 		if (_Where == this->end() || this->comp(_Keyval, this->_Key(_Where._Mynode())))

  0000f	3b 47 04	 cmp	 eax, DWORD PTR [edi+4]
  00012	74 07		 je	 SHORT $L26445
  00014	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00016	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00019	7d 1a		 jge	 SHORT $L26444
$L26445:

; 145  : 			_Where = this->insert(_Where,
; 146  : 				value_type(_Keyval, mapped_type()));

  0001b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001d	83 65 f8 00	 and	 DWORD PTR $T97420[ebp+4], 0
  00021	50		 push	 eax
  00022	8d 45 fc	 lea	 eax, DWORD PTR $T97422[ebp]
  00025	89 4d f4	 mov	 DWORD PTR $T97420[ebp], ecx
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR $T97420[ebp]
  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVEnvelop@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::insert
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
$L26444:

; 147  : 		return ((*_Where).second);

  00035	83 c0 10	 add	 eax, 16			; 00000010H

; 148  : 		}

  00038	c9		 leave
  00039	c3		 ret	 0
??A?$map@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@@std@@QAEAAPAVEnvelop@@ABH@Z ENDP ; std::map<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> > >::operator[]
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??A?$map@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@@std@@QAEAAPAVN163@@ABH@Z
_TEXT	SEGMENT
$T97498 = -12						; size = 8
$T97500 = -4						; size = 4
??A?$map@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@@std@@QAEAAPAVN163@@ABH@Z PROC NEAR ; std::map<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> > >::operator[], COMDAT
; _this$ = edi
; __Keyval$ = esi

; 142  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 143  : 		iterator _Where = this->lower_bound(_Keyval);

  00006	8b d6		 mov	 edx, esi
  00008	8b c7		 mov	 eax, edi
  0000a	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Lbound

; 144  : 		if (_Where == this->end() || this->comp(_Keyval, this->_Key(_Where._Mynode())))

  0000f	3b 47 04	 cmp	 eax, DWORD PTR [edi+4]
  00012	74 07		 je	 SHORT $L26383
  00014	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00016	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00019	7d 1a		 jge	 SHORT $L26382
$L26383:

; 145  : 			_Where = this->insert(_Where,
; 146  : 				value_type(_Keyval, mapped_type()));

  0001b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001d	83 65 f8 00	 and	 DWORD PTR $T97498[ebp+4], 0
  00021	50		 push	 eax
  00022	8d 45 fc	 lea	 eax, DWORD PTR $T97500[ebp]
  00025	89 4d f4	 mov	 DWORD PTR $T97498[ebp], ecx
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR $T97498[ebp]
  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVN163@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::insert
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
$L26382:

; 147  : 		return ((*_Where).second);

  00035	83 c0 10	 add	 eax, 16			; 00000010H

; 148  : 		}

  00038	c9		 leave
  00039	c3		 ret	 0
??A?$map@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@@std@@QAEAAPAVN163@@ABH@Z ENDP ; std::map<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> > >::operator[]
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??A?$map@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@@std@@QAEAAPAVVRC7@@ABH@Z
_TEXT	SEGMENT
$T97576 = -12						; size = 8
$T97578 = -4						; size = 4
??A?$map@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@@std@@QAEAAPAVVRC7@@ABH@Z PROC NEAR ; std::map<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> > >::operator[], COMDAT
; _this$ = edi
; __Keyval$ = esi

; 142  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 143  : 		iterator _Where = this->lower_bound(_Keyval);

  00006	8b d6		 mov	 edx, esi
  00008	8b c7		 mov	 eax, edi
  0000a	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Lbound

; 144  : 		if (_Where == this->end() || this->comp(_Keyval, this->_Key(_Where._Mynode())))

  0000f	3b 47 04	 cmp	 eax, DWORD PTR [edi+4]
  00012	74 07		 je	 SHORT $L26321
  00014	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00016	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00019	7d 1a		 jge	 SHORT $L26320
$L26321:

; 145  : 			_Where = this->insert(_Where,
; 146  : 				value_type(_Keyval, mapped_type()));

  0001b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001d	83 65 f8 00	 and	 DWORD PTR $T97576[ebp+4], 0
  00021	50		 push	 eax
  00022	8d 45 fc	 lea	 eax, DWORD PTR $T97578[ebp]
  00025	89 4d f4	 mov	 DWORD PTR $T97576[ebp], ecx
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR $T97576[ebp]
  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVVRC7@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::insert
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
$L26320:

; 147  : 		return ((*_Where).second);

  00035	83 c0 10	 add	 eax, 16			; 00000010H

; 148  : 		}

  00038	c9		 leave
  00039	c3		 ret	 0
??A?$map@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@@std@@QAEAAPAVVRC7@@ABH@Z ENDP ; std::map<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> > >::operator[]
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??A?$map@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@@std@@QAEAAPAVFDSM@@ABH@Z
_TEXT	SEGMENT
$T97654 = -12						; size = 8
$T97656 = -4						; size = 4
??A?$map@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@@std@@QAEAAPAVFDSM@@ABH@Z PROC NEAR ; std::map<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> > >::operator[], COMDAT
; _this$ = edi
; __Keyval$ = esi

; 142  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 143  : 		iterator _Where = this->lower_bound(_Keyval);

  00006	8b d6		 mov	 edx, esi
  00008	8b c7		 mov	 eax, edi
  0000a	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Lbound

; 144  : 		if (_Where == this->end() || this->comp(_Keyval, this->_Key(_Where._Mynode())))

  0000f	3b 47 04	 cmp	 eax, DWORD PTR [edi+4]
  00012	74 07		 je	 SHORT $L26259
  00014	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00016	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00019	7d 1a		 jge	 SHORT $L26258
$L26259:

; 145  : 			_Where = this->insert(_Where,
; 146  : 				value_type(_Keyval, mapped_type()));

  0001b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001d	83 65 f8 00	 and	 DWORD PTR $T97654[ebp+4], 0
  00021	50		 push	 eax
  00022	8d 45 fc	 lea	 eax, DWORD PTR $T97656[ebp]
  00025	89 4d f4	 mov	 DWORD PTR $T97654[ebp], ecx
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR $T97654[ebp]
  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVFDSM@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::insert
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
$L26258:

; 147  : 		return ((*_Where).second);

  00035	83 c0 10	 add	 eax, 16			; 00000010H

; 148  : 		}

  00038	c9		 leave
  00039	c3		 ret	 0
??A?$map@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@@std@@QAEAAPAVFDSM@@ABH@Z ENDP ; std::map<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> > >::operator[]
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??A?$map@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@@std@@QAEAAPAVFDSC@@ABH@Z
_TEXT	SEGMENT
$T97732 = -12						; size = 8
$T97734 = -4						; size = 4
??A?$map@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@@std@@QAEAAPAVFDSC@@ABH@Z PROC NEAR ; std::map<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> > >::operator[], COMDAT
; _this$ = edi
; __Keyval$ = esi

; 142  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 143  : 		iterator _Where = this->lower_bound(_Keyval);

  00006	8b d6		 mov	 edx, esi
  00008	8b c7		 mov	 eax, edi
  0000a	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Lbound

; 144  : 		if (_Where == this->end() || this->comp(_Keyval, this->_Key(_Where._Mynode())))

  0000f	3b 47 04	 cmp	 eax, DWORD PTR [edi+4]
  00012	74 07		 je	 SHORT $L26197
  00014	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00016	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00019	7d 1a		 jge	 SHORT $L26196
$L26197:

; 145  : 			_Where = this->insert(_Where,
; 146  : 				value_type(_Keyval, mapped_type()));

  0001b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001d	83 65 f8 00	 and	 DWORD PTR $T97732[ebp+4], 0
  00021	50		 push	 eax
  00022	8d 45 fc	 lea	 eax, DWORD PTR $T97734[ebp]
  00025	89 4d f4	 mov	 DWORD PTR $T97732[ebp], ecx
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR $T97732[ebp]
  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBHPAVFDSC@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::insert
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
$L26196:

; 147  : 		return ((*_Where).second);

  00035	83 c0 10	 add	 eax, 16			; 00000010H

; 148  : 		}

  00038	c9		 leave
  00039	c3		 ret	 0
??A?$map@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@@std@@QAEAAPAVFDSC@@ABH@Z ENDP ; std::map<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> > >::operator[]
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?push_back@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEXABQAVMusicItem@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEXABQAVMusicItem@@@Z PROC NEAR ; std::list<MusicItem *,std::allocator<MusicItem *> >::push_back, COMDAT
; _this$ = eax

; 481  : 		_Insert(end(), _Val);

  00000	ff 74 24 04	 push	 DWORD PTR __Val$[esp-4]
  00004	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00007	51		 push	 ecx
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?_Insert@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEXViterator@12@ABQAVMusicItem@@@Z ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Insert

; 482  : 		}

  0000e	c2 04 00	 ret	 4
?push_back@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEXABQAVMusicItem@@@Z ENDP ; std::list<MusicItem *,std::allocator<MusicItem *> >::push_back
_TEXT	ENDS
PUBLIC	?make_bin@MusicFile@@QAEXIH@Z			; MusicFile::make_bin
$T97991	DD	0ffffffffH
	DD	FLAT:$L97834
$T97975	DD	019930520H
	DD	01H
	DD	FLAT:$T97991
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
; File f:\nes\nsdl\src\nsc\musicfile.cpp
_TEXT	SEGMENT
__size$ = -68						; size = 4
$T97833 = -64						; size = 4
$T97831 = -64						; size = 4
$T97830 = -64						; size = 4
_i$ = -60						; size = 4
_iSE$ = -56						; size = 4
_iBGM$ = -52						; size = 4
tv579 = -48						; size = 4
_pt$ = -48						; size = 4
__str$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
tv605 = 8						; size = 4
$T97832 = 8						; size = 4
_rom_size$ = 8						; size = 4
_ptOffset$ = 12						; size = 4
?make_bin@MusicFile@@QAEXIH@Z PROC NEAR			; MusicFile::make_bin
; _this$ = ecx

; 732  : {

  001d7	b8 00 00 00 00	 mov	 eax, __ehhandler$?make_bin@MusicFile@@QAEXIH@Z
  001dc	e8 00 00 00 00	 call	 __EH_prolog
  001e1	83 ec 38	 sub	 esp, 56			; 00000038H
  001e4	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  001e9	53		 push	 ebx
  001ea	56		 push	 esi
  001eb	57		 push	 edi
  001ec	8b d9		 mov	 ebx, ecx

; 733  : 				string		_str;

  001ee	33 ff		 xor	 edi, edi
  001f0	57		 push	 edi
  001f1	8d 4d d4	 lea	 ecx, DWORD PTR __str$[ebp]
  001f4	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  001f7	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR __str$[ebp+24], 15 ; 0000000fH
  001fe	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
  00203	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi

; 734  : 	unsigned	int			i		= 2;
; 735  : 	unsigned	int			iBGM	= 0;
; 736  : 	unsigned	int			iSE		= 0;
; 737  : 	unsigned	short*		pt;
; 738  : 
; 739  : 				size_t		_size	= 4 + (Header.iBGM + Header.iSE)*2;

  00206	0f b6 83 9e 00
	00 00		 movzx	 eax, BYTE PTR [ebx+158]
  0020d	0f b6 b3 9f 00
	00 00		 movzx	 esi, BYTE PTR [ebx+159]
  00214	03 f0		 add	 esi, eax
  00216	8d 74 36 04	 lea	 esi, DWORD PTR [esi+esi+4]

; 740  : 
; 741  : 
; 742  : 	//oCi[
; 743  : 	_str.clear();

  0021a	8d 45 d4	 lea	 eax, DWORD PTR __str$[ebp]
  0021d	c7 45 c4 02 00
	00 00		 mov	 DWORD PTR _i$[ebp], 2
  00224	89 7d cc	 mov	 DWORD PTR _iBGM$[ebp], edi
  00227	89 7d c8	 mov	 DWORD PTR _iSE$[ebp], edi
  0022a	89 75 bc	 mov	 DWORD PTR __size$[ebp], esi
  0022d	e8 00 00 00 00	 call	 ?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear

; 744  : 	_str.resize(_size);

  00232	57		 push	 edi
  00233	8b c6		 mov	 eax, esi
  00235	8d 4d d4	 lea	 ecx, DWORD PTR __str$[ebp]
  00238	e8 00 00 00 00	 call	 ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 745  : 
; 746  : 	pt = (unsigned short*)_str.c_str();

  0023d	83 7d ec 10	 cmp	 DWORD PTR __str$[ebp+24], 16 ; 00000010H
  00241	8b 7d d8	 mov	 edi, DWORD PTR __str$[ebp+4]
  00244	72 07		 jb	 SHORT $L97902
  00246	8b c7		 mov	 eax, edi
  00248	89 45 d0	 mov	 DWORD PTR _pt$[ebp], eax
  0024b	eb 06		 jmp	 SHORT $L97903
$L97902:
  0024d	8d 45 d8	 lea	 eax, DWORD PTR __str$[ebp+4]
  00250	89 45 d0	 mov	 DWORD PTR _pt$[ebp], eax
$L97903:

; 747  : 
; 748  : 	_str[0] = Header.iBGM;

  00253	83 7d ec 10	 cmp	 DWORD PTR __str$[ebp+24], 16 ; 00000010H
  00257	73 03		 jae	 SHORT $L97917
  00259	8d 7d d8	 lea	 edi, DWORD PTR __str$[ebp+4]
$L97917:
  0025c	8a 8b 9e 00 00
	00		 mov	 cl, BYTE PTR [ebx+158]
  00262	88 0f		 mov	 BYTE PTR [edi], cl

; 749  : 	_str[1] = Header.iSE;

  00264	83 7d ec 10	 cmp	 DWORD PTR __str$[ebp+24], 16 ; 00000010H
  00268	8b 7d d8	 mov	 edi, DWORD PTR __str$[ebp+4]
  0026b	73 03		 jae	 SHORT $L97932
  0026d	8d 7d d8	 lea	 edi, DWORD PTR __str$[ebp+4]
$L97932:
  00270	8a 8b 9f 00 00
	00		 mov	 cl, BYTE PTR [ebx+159]
  00276	88 4f 01	 mov	 BYTE PTR [edi+1], cl

; 750  : 
; 751  : 	if(Header.bank == false){

  00279	80 bb 9c 00 00
	00 00		 cmp	 BYTE PTR [ebx+156], 0

; 752  : 
; 753  : 		if(cDPCMinfo != NULL){

  00280	8b 8b cc 01 00
	00		 mov	 ecx, DWORD PTR [ebx+460]
  00286	0f 85 c9 00 00
	00		 jne	 $L25255
  0028c	85 c9		 test	 ecx, ecx
  0028e	74 15		 je	 SHORT $L25256

; 754  : 			pt[1]	= (unsigned short)(ptOffset + rom_size - 0x80 + _size + cDPCMinfo->getOffset());	//PCM info AhX

  00290	0f b7 49 34	 movzx	 ecx, WORD PTR [ecx+52]
  00294	66 03 4d 0c	 add	 cx, WORD PTR _ptOffset$[ebp]
  00298	03 4d 08	 add	 ecx, DWORD PTR _rom_size$[ebp]
  0029b	8d 4c 31 80	 lea	 ecx, DWORD PTR [ecx+esi-128]
  0029f	66 89 48 02	 mov	 WORD PTR [eax+2], cx

; 755  : 		} else {

  002a3	eb 05		 jmp	 SHORT $L97976
$L25256:

; 756  : 			pt[1]	= 0;

  002a5	66 83 60 02 00	 and	 WORD PTR [eax+2], 0
$L97976:

; 757  : 		}
; 758  : 
; 759  : 		while(iBGM < Header.iBGM){

  002aa	80 bb 9e 00 00
	00 00		 cmp	 BYTE PTR [ebx+158], 0
  002b1	76 46		 jbe	 SHORT $L97977
  002b3	8d bb a8 01 00
	00		 lea	 edi, DWORD PTR [ebx+424]
$L25260:

; 760  : 			pt[i] = (unsigned short)(ptOffset + rom_size - 0x80 + _size + ptcBGM[iBGM]->getOffset());

  002b9	8b 45 cc	 mov	 eax, DWORD PTR _iBGM$[ebp]
  002bc	8d 75 c0	 lea	 esi, DWORD PTR $T97830[ebp]
  002bf	89 45 c0	 mov	 DWORD PTR $T97830[ebp], eax
  002c2	e8 00 00 00 00	 call	 ??A?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAEAAPAVBGM@@ABH@Z ; std::map<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> > >::operator[]
  002c7	8b 00		 mov	 eax, DWORD PTR [eax]
  002c9	0f b7 40 34	 movzx	 eax, WORD PTR [eax+52]
  002cd	66 03 45 0c	 add	 ax, WORD PTR _ptOffset$[ebp]
  002d1	8b 4d bc	 mov	 ecx, DWORD PTR __size$[ebp]
  002d4	8b 55 c4	 mov	 edx, DWORD PTR _i$[ebp]
  002d7	03 45 08	 add	 eax, DWORD PTR _rom_size$[ebp]

; 761  : 			i++;

  002da	ff 45 c4	 inc	 DWORD PTR _i$[ebp]

; 762  : 			iBGM++;

  002dd	ff 45 cc	 inc	 DWORD PTR _iBGM$[ebp]
  002e0	8d 44 08 80	 lea	 eax, DWORD PTR [eax+ecx-128]
  002e4	8b 4d d0	 mov	 ecx, DWORD PTR _pt$[ebp]
  002e7	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax
  002eb	0f b6 83 9e 00
	00 00		 movzx	 eax, BYTE PTR [ebx+158]
  002f2	39 45 cc	 cmp	 DWORD PTR _iBGM$[ebp], eax
  002f5	72 c2		 jb	 SHORT $L25260

; 757  : 		}
; 758  : 
; 759  : 		while(iBGM < Header.iBGM){

  002f7	8b c1		 mov	 eax, ecx
$L97977:

; 763  : 		}
; 764  : 		while(iSE < Header.iSE){

  002f9	80 bb 9f 00 00
	00 00		 cmp	 BYTE PTR [ebx+159], 0
  00300	0f 86 fc 00 00
	00		 jbe	 $L97988
  00306	8b 4d c4	 mov	 ecx, DWORD PTR _i$[ebp]
  00309	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  0030c	8d bb b4 01 00
	00		 lea	 edi, DWORD PTR [ebx+436]
  00312	89 45 d0	 mov	 DWORD PTR tv579[ebp], eax
$L25265:

; 765  : 			pt[i] = (unsigned short)(ptOffset + rom_size - 0x80 + _size + ptcSE[iSE]->getOffset());

  00315	8b 45 c8	 mov	 eax, DWORD PTR _iSE$[ebp]
  00318	8d 75 c0	 lea	 esi, DWORD PTR $T97831[ebp]
  0031b	89 45 c0	 mov	 DWORD PTR $T97831[ebp], eax
  0031e	e8 00 00 00 00	 call	 ??A?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAEAAPAVSE@@ABH@Z ; std::map<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> > >::operator[]
  00323	8b 00		 mov	 eax, DWORD PTR [eax]
  00325	0f b7 40 34	 movzx	 eax, WORD PTR [eax+52]
  00329	66 03 45 0c	 add	 ax, WORD PTR _ptOffset$[ebp]
  0032d	8b 4d bc	 mov	 ecx, DWORD PTR __size$[ebp]
  00330	03 45 08	 add	 eax, DWORD PTR _rom_size$[ebp]
  00333	8d 44 08 80	 lea	 eax, DWORD PTR [eax+ecx-128]
  00337	8b 4d d0	 mov	 ecx, DWORD PTR tv579[ebp]

; 766  : 			i++;

  0033a	83 45 d0 02	 add	 DWORD PTR tv579[ebp], 2

; 767  : 			iSE++;

  0033e	ff 45 c8	 inc	 DWORD PTR _iSE$[ebp]
  00341	66 89 01	 mov	 WORD PTR [ecx], ax
  00344	0f b6 83 9f 00
	00 00		 movzx	 eax, BYTE PTR [ebx+159]
  0034b	39 45 c8	 cmp	 DWORD PTR _iSE$[ebp], eax
  0034e	72 c5		 jb	 SHORT $L25265

; 768  : 		}
; 769  : 
; 770  : 	} else {

  00350	e9 ad 00 00 00	 jmp	 $L97988
$L25255:

; 771  : 
; 772  : 		if(cDPCMinfo != NULL){

  00355	85 c9		 test	 ecx, ecx
  00357	74 10		 je	 SHORT $L25270

; 798  : 	}
; 799  : 
; 800  : }

  00359	0f b7 49 34	 movzx	 ecx, WORD PTR [ecx+52]
  0035d	66 03 4d 0c	 add	 cx, WORD PTR _ptOffset$[ebp]
  00361	03 ce		 add	 ecx, esi
  00363	66 89 48 02	 mov	 WORD PTR [eax+2], cx
  00367	eb 05		 jmp	 SHORT $L97978
$L25270:

; 773  : 			pt[1] = (unsigned short)(ptOffset + _size + cDPCMinfo->getOffset());	//PCM info AhX
; 774  : 		} else {
; 775  : 			pt[1]	= 0;

  00369	66 83 60 02 00	 and	 WORD PTR [eax+2], 0
$L97978:

; 776  : 		}
; 777  : 
; 778  : 		while(iBGM < Header.iBGM){

  0036e	80 bb 9e 00 00
	00 00		 cmp	 BYTE PTR [ebx+158], 0
  00375	76 3f		 jbe	 SHORT $L97979
  00377	8d bb a8 01 00
	00		 lea	 edi, DWORD PTR [ebx+424]
$L25274:

; 779  : 			pt[i] = (unsigned short)(ptOffset + _size + ptcBGM[iBGM]->getOffset());

  0037d	8b 45 cc	 mov	 eax, DWORD PTR _iBGM$[ebp]
  00380	8d 75 08	 lea	 esi, DWORD PTR $T97832[ebp]
  00383	89 45 08	 mov	 DWORD PTR $T97832[ebp], eax
  00386	e8 00 00 00 00	 call	 ??A?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAEAAPAVBGM@@ABH@Z ; std::map<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> > >::operator[]
  0038b	8b 00		 mov	 eax, DWORD PTR [eax]

; 798  : 	}
; 799  : 
; 800  : }

  0038d	0f b7 40 34	 movzx	 eax, WORD PTR [eax+52]
  00391	66 03 45 0c	 add	 ax, WORD PTR _ptOffset$[ebp]
  00395	8b 55 c4	 mov	 edx, DWORD PTR _i$[ebp]
  00398	8b 4d d0	 mov	 ecx, DWORD PTR _pt$[ebp]
  0039b	03 45 bc	 add	 eax, DWORD PTR __size$[ebp]
  0039e	ff 45 c4	 inc	 DWORD PTR _i$[ebp]
  003a1	ff 45 cc	 inc	 DWORD PTR _iBGM$[ebp]
  003a4	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax
  003a8	0f b6 83 9e 00
	00 00		 movzx	 eax, BYTE PTR [ebx+158]
  003af	39 45 cc	 cmp	 DWORD PTR _iBGM$[ebp], eax
  003b2	72 c9		 jb	 SHORT $L25274

; 776  : 		}
; 777  : 
; 778  : 		while(iBGM < Header.iBGM){

  003b4	8b c1		 mov	 eax, ecx
$L97979:

; 780  : 			i++;
; 781  : 			iBGM++;
; 782  : 		}
; 783  : 		while(iSE < Header.iSE){

  003b6	80 bb 9f 00 00
	00 00		 cmp	 BYTE PTR [ebx+159], 0
  003bd	76 43		 jbe	 SHORT $L97988
  003bf	8b 4d c4	 mov	 ecx, DWORD PTR _i$[ebp]
  003c2	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  003c5	8d bb b4 01 00
	00		 lea	 edi, DWORD PTR [ebx+436]
  003cb	89 45 08	 mov	 DWORD PTR tv605[ebp], eax
$L25279:

; 784  : 			pt[i] = (unsigned short)(ptOffset + _size + ptcSE[iSE]->getOffset());

  003ce	8b 45 c8	 mov	 eax, DWORD PTR _iSE$[ebp]
  003d1	8d 75 c0	 lea	 esi, DWORD PTR $T97833[ebp]
  003d4	89 45 c0	 mov	 DWORD PTR $T97833[ebp], eax
  003d7	e8 00 00 00 00	 call	 ??A?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAEAAPAVSE@@ABH@Z ; std::map<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> > >::operator[]
  003dc	8b 00		 mov	 eax, DWORD PTR [eax]

; 798  : 	}
; 799  : 
; 800  : }

  003de	0f b7 40 34	 movzx	 eax, WORD PTR [eax+52]
  003e2	66 03 45 0c	 add	 ax, WORD PTR _ptOffset$[ebp]
  003e6	8b 4d 08	 mov	 ecx, DWORD PTR tv605[ebp]
  003e9	83 45 08 02	 add	 DWORD PTR tv605[ebp], 2
  003ed	03 45 bc	 add	 eax, DWORD PTR __size$[ebp]
  003f0	ff 45 c8	 inc	 DWORD PTR _iSE$[ebp]
  003f3	66 89 01	 mov	 WORD PTR [ecx], ax
  003f6	0f b6 83 9f 00
	00 00		 movzx	 eax, BYTE PTR [ebx+159]
  003fd	39 45 c8	 cmp	 DWORD PTR _iSE$[ebp], eax
  00400	72 cc		 jb	 SHORT $L25279
$L97988:

; 785  : 			i++;
; 786  : 			iSE++;
; 787  : 		}
; 788  : 
; 789  : 	}
; 790  : 
; 791  : 	getCode(&_str);

  00402	8b 03		 mov	 eax, DWORD PTR [ebx]
  00404	8d 4d d4	 lea	 ecx, DWORD PTR __str$[ebp]
  00407	51		 push	 ecx
  00408	8b cb		 mov	 ecx, ebx
  0040a	ff 10		 call	 DWORD PTR [eax]

; 792  : 	code = _str;

  0040c	6a ff		 push	 -1
  0040e	6a 00		 push	 0
  00410	8d 45 d4	 lea	 eax, DWORD PTR __str$[ebp]
  00413	50		 push	 eax
  00414	8d 4b 14	 lea	 ecx, DWORD PTR [ebx+20]
  00417	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 793  : 
; 794  : 	//PCM
; 795  : 	dpcm_code.clear();

  0041c	8d b3 d0 01 00
	00		 lea	 esi, DWORD PTR [ebx+464]
  00422	8b c6		 mov	 eax, esi
  00424	e8 00 00 00 00	 call	 ?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear

; 796  : 	if(cDPCMinfo != NULL){

  00429	8b 9b cc 01 00
	00		 mov	 ebx, DWORD PTR [ebx+460]
  0042f	85 db		 test	 ebx, ebx
  00431	74 08		 je	 SHORT $L25283

; 797  : 		cDPCMinfo->getDPCMCode(&dpcm_code);

  00433	56		 push	 esi
  00434	8b fb		 mov	 edi, ebx
  00436	e8 00 00 00 00	 call	 ?getDPCMCode@DPCMinfo@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; DPCMinfo::getDPCMCode
$L25283:

; 798  : 	}
; 799  : 
; 800  : }

  0043b	6a 00		 push	 0
  0043d	6a 01		 push	 1
  0043f	8d 4d d4	 lea	 ecx, DWORD PTR __str$[ebp]
  00442	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00447	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0044a	5f		 pop	 edi
  0044b	5e		 pop	 esi
  0044c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00453	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00456	5b		 pop	 ebx
  00457	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0045c	c9		 leave
  0045d	c2 08 00	 ret	 8
$L97834:
  0028e	8d 4d d4	 lea	 ecx, DWORD PTR __str$[ebp]
  00291	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?make_bin@MusicFile@@QAEXIH@Z:
  00296	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T97975
  0029b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?make_bin@MusicFile@@QAEXIH@Z ENDP			; MusicFile::make_bin
PUBLIC	??1MusicFile@@UAE@XZ				; MusicFile::~MusicFile
$T98091	DD	0ffffffffH
	DD	FLAT:$L97993
	DD	00H
	DD	FLAT:$L97994
	DD	01H
	DD	FLAT:$L97995
	DD	02H
	DD	FLAT:$L97996
	DD	03H
	DD	FLAT:$L97997
	DD	04H
	DD	FLAT:$L97998
	DD	05H
	DD	FLAT:$L97999
	DD	06H
	DD	FLAT:$L98000
	DD	07H
	DD	FLAT:$L98001
	DD	08H
	DD	FLAT:$L98002
$T98089	DD	019930520H
	DD	0aH
	DD	FLAT:$T98091
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
tv258 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1MusicFile@@UAE@XZ PROC NEAR				; MusicFile::~MusicFile

; 514  : {

  00460	b8 00 00 00 00	 mov	 eax, __ehhandler$??1MusicFile@@UAE@XZ
  00465	e8 00 00 00 00	 call	 __EH_prolog
  0046a	51		 push	 ecx
  0046b	53		 push	 ebx
  0046c	56		 push	 esi
  0046d	57		 push	 edi
  0046e	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  00471	8d 87 4c fe ff
	ff		 lea	 eax, DWORD PTR [edi-436]
  00477	89 45 f0	 mov	 DWORD PTR tv258[ebp], eax
  0047a	8b 00		 mov	 eax, DWORD PTR [eax]
  0047c	8d 9f 10 fe ff
	ff		 lea	 ebx, DWORD PTR [edi-496]
  00482	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7MusicFile@@6BMusicItem@@@
  00488	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0048b	c7 84 38 4c fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR [eax+edi-436], OFFSET FLAT:??_7MusicFile@@6BFileOutput@@@

; 515  : }

  00496	6a 00		 push	 0
  00498	6a 01		 push	 1
  0049a	8d 4f e0	 lea	 ecx, DWORD PTR [edi-32]
  0049d	c7 45 fc 09 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 9
  004a4	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  004a9	8d 77 d0	 lea	 esi, DWORD PTR [edi-48]
  004ac	e8 00 00 00 00	 call	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Tidy
  004b1	8d 77 c4	 lea	 esi, DWORD PTR [edi-60]
  004b4	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  004b8	e8 00 00 00 00	 call	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Tidy
  004bd	8d 77 b8	 lea	 esi, DWORD PTR [edi-72]
  004c0	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  004c4	e8 00 00 00 00	 call	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Tidy
  004c9	8d 77 ac	 lea	 esi, DWORD PTR [edi-84]
  004cc	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  004d0	e8 00 00 00 00	 call	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Tidy
  004d5	8d 77 a0	 lea	 esi, DWORD PTR [edi-96]
  004d8	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  004dc	e8 00 00 00 00	 call	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Tidy
  004e1	8d 77 94	 lea	 esi, DWORD PTR [edi-108]
  004e4	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  004e8	e8 00 00 00 00	 call	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Tidy
  004ed	8d 77 88	 lea	 esi, DWORD PTR [edi-120]
  004f0	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  004f4	e8 00 00 00 00	 call	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Tidy
  004f9	8d b7 7c ff ff
	ff		 lea	 esi, DWORD PTR [edi-132]
  004ff	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00503	e8 00 00 00 00	 call	 ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Tidy
  00508	8d b7 ac fe ff
	ff		 lea	 esi, DWORD PTR [edi-340]
  0050e	e8 00 00 00 00	 call	 ??1MusicHeader@@QAE@XZ	; MusicHeader::~MusicHeader
  00513	8b cb		 mov	 ecx, ebx
  00515	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00519	e8 00 00 00 00	 call	 ??1MusicItem@@QAE@XZ	; MusicItem::~MusicItem
  0051e	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00522	8d 8f 10 fe ff
	ff		 lea	 ecx, DWORD PTR [edi-496]
  00528	f7 d9		 neg	 ecx
  0052a	1b c9		 sbb	 ecx, ecx
  0052c	23 4d f0	 and	 ecx, DWORD PTR tv258[ebp]
  0052f	83 c1 60	 add	 ecx, 96			; 00000060H
  00532	e8 00 00 00 00	 call	 ??1FileOutput@@UAE@XZ	; FileOutput::~FileOutput
  00537	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0053a	5f		 pop	 edi
  0053b	5e		 pop	 esi
  0053c	5b		 pop	 ebx
  0053d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00544	c9		 leave
  00545	c2 04 00	 ret	 4
$L97993:
  002a0	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002a3	81 e9 f0 01 00
	00		 sub	 ecx, 496		; 000001f0H
  002a9	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  002ac	2d b4 01 00 00	 sub	 eax, 436		; 000001b4H
  002b1	f7 d9		 neg	 ecx
  002b3	1b c9		 sbb	 ecx, ecx
  002b5	23 c8		 and	 ecx, eax
  002b7	83 c1 60	 add	 ecx, 96			; 00000060H
  002ba	e9 00 00 00 00	 jmp	 ??1FileOutput@@UAE@XZ	; FileOutput::~FileOutput
$L97994:
  002bf	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002c2	81 e9 f0 01 00
	00		 sub	 ecx, 496		; 000001f0H
  002c8	e9 00 00 00 00	 jmp	 ??1MusicItem@@QAE@XZ	; MusicItem::~MusicItem
$L97995:
  002cd	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  002d0	81 ee 54 01 00
	00		 sub	 esi, 340		; 00000154H
  002d6	e9 00 00 00 00	 jmp	 ??1MusicHeader@@QAE@XZ	; MusicHeader::~MusicHeader
$L97996:
  002db	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  002de	81 ee 84 00 00
	00		 sub	 esi, 132		; 00000084H
  002e4	e9 00 00 00 00	 jmp	 ??1?$map@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@@std@@QAE@XZ
$L97997:
  002e9	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  002ec	83 ee 78	 sub	 esi, 120		; 00000078H
  002ef	e9 00 00 00 00	 jmp	 ??1?$map@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@@std@@QAE@XZ
$L97998:
  002f4	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  002f7	83 ee 6c	 sub	 esi, 108		; 0000006cH
  002fa	e9 00 00 00 00	 jmp	 ??1?$map@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@@std@@QAE@XZ
$L97999:
  002ff	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00302	83 ee 60	 sub	 esi, 96			; 00000060H
  00305	e9 00 00 00 00	 jmp	 ??1?$map@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@@std@@QAE@XZ
$L98000:
  0030a	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  0030d	83 ee 54	 sub	 esi, 84			; 00000054H
  00310	e9 00 00 00 00	 jmp	 ??1?$map@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@@std@@QAE@XZ
$L98001:
  00315	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00318	83 ee 48	 sub	 esi, 72			; 00000048H
  0031b	e9 00 00 00 00	 jmp	 ??1?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAE@XZ
$L98002:
  00320	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00323	83 ee 3c	 sub	 esi, 60			; 0000003cH
  00326	e9 00 00 00 00	 jmp	 ??1?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAE@XZ
__ehhandler$??1MusicFile@@UAE@XZ:
  0032b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T98089
  00330	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
??1MusicFile@@UAE@XZ ENDP				; MusicFile::~MusicFile
; Function compile flags: /Ogsy
;	COMDAT ??_DMusicFile@@QAEXXZ
_TEXT	SEGMENT
??_DMusicFile@@QAEXXZ PROC NEAR				; MusicFile::`vbase destructor', COMDAT
; _this$ = eax
  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax
  00003	81 c6 f0 01 00
	00		 add	 esi, 496		; 000001f0H
  00009	56		 push	 esi
  0000a	e8 00 00 00 00	 call	 ??1MusicFile@@UAE@XZ	; MusicFile::~MusicFile
  0000f	8b ce		 mov	 ecx, esi
  00011	5e		 pop	 esi
  00012	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
??_DMusicFile@@QAEXXZ ENDP				; MusicFile::`vbase destructor'
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??_GMusicFile@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GMusicFile@@UAEPAXI@Z PROC NEAR			; MusicFile::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8d b1 10 fe ff
	ff		 lea	 esi, DWORD PTR [ecx-496]
  00007	8b c6		 mov	 eax, esi
  00009	e8 00 00 00 00	 call	 ??_DMusicFile@@QAEXXZ
  0000e	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  00013	74 07		 je	 SHORT $L24606
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001b	59		 pop	 ecx
$L24606:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	c2 04 00	 ret	 4
??_GMusicFile@@UAEPAXI@Z ENDP				; MusicFile::`scalar deleting destructor'
PUBLIC	?saveNSF@MusicFile@@QAEXPBD@Z			; MusicFile::saveNSF
$T104368 DD	0ffffffffH
	DD	FLAT:$L104092
$T104330 DD	019930520H
	DD	01H
	DD	FLAT:$T104368
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
tv858 = -36						; size = 4
$T104084 = -36						; size = 4
_bin_size$ = -32					; size = 4
_romimg$ = -28						; size = 4
_pcm_size$ = -24					; size = 4
_mus_size$ = -20					; size = 4
_flag_Optimize$ = -15					; size = 1
_dpcm_bank$ = -14					; size = 1
_mus_bank$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_strFileName$ = 8					; size = 4
?saveNSF@MusicFile@@QAEXPBD@Z PROC NEAR			; MusicFile::saveNSF
; _this$ = ecx

; 812  : {

  00548	b8 00 00 00 00	 mov	 eax, __ehhandler$?saveNSF@MusicFile@@QAEXPBD@Z
  0054d	e8 00 00 00 00	 call	 __EH_prolog
  00552	83 ec 18	 sub	 esp, 24			; 00000018H
  00555	53		 push	 ebx
  00556	56		 push	 esi
  00557	57		 push	 edi

; 813  : 
; 814  : 	unsigned	int		i,j;
; 815  : 				size_t	bin_size;
; 816  : 				size_t	mus_size;
; 817  : 				size_t	pcm_size;
; 818  : 	unsigned	char	mus_bank;
; 819  : 	unsigned	char	pcm_bank;
; 820  : 				char*	romimg			= new char[0xC000+0x80];

  00558	68 80 c0 00 00	 push	 49280			; 0000c080H
  0055d	8b d9		 mov	 ebx, ecx
  0055f	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 821  : 	NSF_Header*			nsf				= (NSF_Header*)romimg;
; 822  : 	FileInput*			_romcode		= new FileInput();

  00564	68 bc 00 00 00	 push	 188			; 000000bcH
  00569	89 45 e4	 mov	 DWORD PTR _romimg$[ebp], eax
  0056c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00571	59		 pop	 ecx
  00572	59		 pop	 ecx
  00573	89 45 dc	 mov	 DWORD PTR $T104084[ebp], eax
  00576	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0057a	85 c0		 test	 eax, eax
  0057c	74 0c		 je	 SHORT $L104085
  0057e	6a 01		 push	 1
  00580	50		 push	 eax
  00581	e8 00 00 00 00	 call	 ??0FileInput@@QAE@XZ	; FileInput::FileInput
  00586	8b f0		 mov	 esi, eax
  00588	eb 02		 jmp	 SHORT $L104086
$L104085:
  0058a	33 f6		 xor	 esi, esi
$L104086:
  0058c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 823  : 				bool	dpcm_bank		= false;
; 824  : 				bool	flag_Optimize	= cOptionSW->flag_Optimize;

  00590	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cOptionSW@@3PAVOPSW@@A ; cOptionSW
  00595	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  00598	88 4d f1	 mov	 BYTE PTR _flag_Optimize$[ebp], cl

; 825  : 
; 826  : 	//NSFpR[h]
; 827  : 	_romcode->fileopen(Header.romcode.c_str(), &(cOptionSW->m_pass_code));

  0059b	8d 8b 50 01 00
	00		 lea	 ecx, DWORD PTR [ebx+336]
  005a1	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  005a5	c6 45 f2 00	 mov	 BYTE PTR _dpcm_bank$[ebp], 0
  005a9	72 05		 jb	 SHORT $L104104
  005ab	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  005ae	eb 03		 jmp	 SHORT $L104105
$L104104:
  005b0	83 c1 04	 add	 ecx, 4
$L104105:
  005b3	83 c0 7c	 add	 eax, 124		; 0000007cH
  005b6	50		 push	 eax
  005b7	51		 push	 ecx
  005b8	8b ce		 mov	 ecx, esi
  005ba	e8 00 00 00 00	 call	 ?fileopen@FileInput@@QAEXPBDPAVSearchPass@@@Z ; FileInput::fileopen

; 828  : 	bin_size = _romcode->GetSize();

  005bf	56		 push	 esi
  005c0	e8 00 00 00 00	 call	 ?GetSize@FileInput@@QAEIXZ ; FileInput::GetSize

; 829  : 	_romcode->read(romimg, bin_size);

  005c5	50		 push	 eax
  005c6	ff 75 e4	 push	 DWORD PTR _romimg$[ebp]
  005c9	89 45 e0	 mov	 DWORD PTR _bin_size$[ebp], eax
  005cc	56		 push	 esi
  005cd	e8 00 00 00 00	 call	 ?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PADH@Z ; std::basic_istream<char,std::char_traits<char> >::read

; 830  : 	_romcode->close();

  005d2	e8 00 00 00 00	 call	 ?close@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ifstream<char,std::char_traits<char> >::close

; 831  : 	delete		_romcode;

  005d7	85 f6		 test	 esi, esi
  005d9	74 0e		 je	 SHORT $L104089
  005db	8b 06		 mov	 eax, DWORD PTR [esi]
  005dd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  005e0	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  005e3	8b 01		 mov	 eax, DWORD PTR [ecx]
  005e5	6a 01		 push	 1
  005e7	ff 10		 call	 DWORD PTR [eax]
$L104089:

; 832  : 
; 833  : 	//NSFwb_[XV
; 834  : 	memcpy(&nsf->Title, Header.title.c_str(), 32);

  005e9	8d 83 c4 00 00
	00		 lea	 eax, DWORD PTR [ebx+196]
  005ef	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  005f3	72 05		 jb	 SHORT $L104119
  005f5	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  005f8	eb 03		 jmp	 SHORT $L104120
$L104119:
  005fa	8d 70 04	 lea	 esi, DWORD PTR [eax+4]
$L104120:
  005fd	8b 45 e4	 mov	 eax, DWORD PTR _romimg$[ebp]
  00600	6a 08		 push	 8
  00602	8d 78 0e	 lea	 edi, DWORD PTR [eax+14]
  00605	59		 pop	 ecx
  00606	f3 a5		 rep movsd

; 835  : 	memcpy(&nsf->Composer, Header.composer.c_str(), 32);

  00608	8d 8b fc 00 00
	00		 lea	 ecx, DWORD PTR [ebx+252]
  0060e	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00612	72 05		 jb	 SHORT $L104134
  00614	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00617	eb 03		 jmp	 SHORT $L104135
$L104134:
  00619	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
$L104135:
  0061c	6a 08		 push	 8
  0061e	8d 78 2e	 lea	 edi, DWORD PTR [eax+46]
  00621	59		 pop	 ecx
  00622	f3 a5		 rep movsd

; 836  : 	memcpy(&nsf->Copyright, Header.copyright.c_str(), 32);

  00624	8d 8b e0 00 00
	00		 lea	 ecx, DWORD PTR [ebx+224]
  0062a	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  0062e	72 05		 jb	 SHORT $L104149
  00630	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00633	eb 03		 jmp	 SHORT $L104150
$L104149:
  00635	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
$L104150:
  00638	6a 08		 push	 8
  0063a	8d 78 4e	 lea	 edi, DWORD PTR [eax+78]
  0063d	59		 pop	 ecx
  0063e	f3 a5		 rep movsd

; 837  : 	nsf->MusicNumber	= Header.iBGM + Header.iSE;

  00640	8a 8b 9f 00 00
	00		 mov	 cl, BYTE PTR [ebx+159]
  00646	02 8b 9e 00 00
	00		 add	 cl, BYTE PTR [ebx+158]

; 838  : 	if(Header.iExternal != -1){

  0064c	8d b3 a4 00 00
	00		 lea	 esi, DWORD PTR [ebx+164]
  00652	88 48 06	 mov	 BYTE PTR [eax+6], cl
  00655	83 3e ff	 cmp	 DWORD PTR [esi], -1
  00658	74 05		 je	 SHORT $L25309

; 839  : 		nsf->External	= (unsigned char)Header.iExternal;

  0065a	8a 0e		 mov	 cl, BYTE PTR [esi]
  0065c	88 48 7b	 mov	 BYTE PTR [eax+123], cl
$L25309:

; 840  : 	}
; 841  : 
; 842  : 	_COUT << _T("----------------------------------------") << endl;

  0065f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1FC@OJNKDJBH@?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9?$AA?9@
  00664	be 00 00 00 00	 mov	 esi, OFFSET FLAT:?wcout@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A ; std::wcout
  00669	56		 push	 esi
  0066a	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  0066f	50		 push	 eax
  00670	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl

; 843  : 	_COUT << _T("*NSF build process") << endl;

  00675	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CG@JFAJBGGI@?$AA?$CK?$AAN?$AAS?$AAF?$AA?5?$AAb?$AAu?$AAi?$AAl?$AAd?$AA?5?$AAp?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?$AA@
  0067a	56		 push	 esi
  0067b	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  00680	50		 push	 eax
  00681	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl

; 844  : 
; 845  : 
; 846  : 	if((nsf->Bank[0] == 0) && (nsf->Bank[1] == 0) && (nsf->Bank[2] == 0) && (nsf->Bank[3] == 0)){

  00686	8b 45 e4	 mov	 eax, DWORD PTR _romimg$[ebp]
  00689	83 c4 18	 add	 esp, 24			; 00000018H
  0068c	80 78 70 00	 cmp	 BYTE PTR [eax+112], 0
  00690	0f 85 fb 00 00
	00		 jne	 $L25510
  00696	80 78 71 00	 cmp	 BYTE PTR [eax+113], 0
  0069a	0f 85 f1 00 00
	00		 jne	 $L25510
  006a0	80 78 72 00	 cmp	 BYTE PTR [eax+114], 0
  006a4	0f 85 e7 00 00
	00		 jne	 $L25510
  006aa	80 78 73 00	 cmp	 BYTE PTR [eax+115], 0
  006ae	0f 85 dd 00 00
	00		 jne	 $L25510

; 847  : 
; 848  : 		//------------------------------
; 849  : 		//Bank bin
; 850  : 
; 851  : 		//V[PXoCi
; 852  : 		make_bin(bin_size, 0x8000);

  006b4	8b 7d e0	 mov	 edi, DWORD PTR _bin_size$[ebp]
  006b7	68 00 80 00 00	 push	 32768			; 00008000H
  006bc	57		 push	 edi
  006bd	8b cb		 mov	 ecx, ebx
  006bf	e8 00 00 00 00	 call	 ?make_bin@MusicFile@@QAEXIH@Z ; MusicFile::make_bin

; 853  : 
; 854  : 		if(Header.bank == true){

  006c4	80 bb 9c 00 00
	00 01		 cmp	 BYTE PTR [ebx+156], 1
  006cb	75 0a		 jne	 SHORT $L25511

; 855  : 			Err(_T("w.bint@CAPCMoNB\nPCMoN.bint@CwB"));

  006cd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1IA@DNNIGADP@c?$AH?$FL?$JK0n?$AA?4?$AAb?$AAi?$AAn0?U0?$KB0?$KE0?k0o0?$AB?$CC?$LP?$AAP?$AAC?$AAM0n0?P0?s@
  006d2	e9 9e 02 00 00	 jmp	 $L104366
$L25511:

; 856  : 		}
; 857  : 
; 858  : 		mus_size = bin_size - 0x80 + code.size();

  006d7	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  006da	8d 4c 38 80	 lea	 ecx, DWORD PTR [eax+edi-128]

; 859  : 		mus_bank = (unsigned char)(mus_size >> 12);

  006de	8b c1		 mov	 eax, ecx
  006e0	c1 e8 0c	 shr	 eax, 12			; 0000000cH

; 860  : 		if((mus_size & 0x0FFF) != 0){

  006e3	66 f7 c1 ff 0f	 test	 cx, 4095		; 00000fffH
  006e8	89 4d ec	 mov	 DWORD PTR _mus_size$[ebp], ecx
  006eb	88 45 f3	 mov	 BYTE PTR _mus_bank$[ebp], al
  006ee	74 05		 je	 SHORT $L25514

; 861  : 			mus_bank++;

  006f0	fe c0		 inc	 al
  006f2	88 45 f3	 mov	 BYTE PTR _mus_bank$[ebp], al
$L25514:

; 862  : 		}
; 863  : 
; 864  : 		//TCY`FbN
; 865  : 		_COUT << _T("[CODE & MUSIC]") << endl;

  006f5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BO@NLLFDPGO@?$AA?$FL?$AAC?$AAO?$AAD?$AAE?$AA?5?$AA?$CG?$AA?5?$AAM?$AAU?$AAS?$AAI?$AAC?$AA?$FN?$AA?$AA@
  006fa	56		 push	 esi
  006fb	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  00700	50		 push	 eax
  00701	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl

; 866  : 		_COUT << _T("  Bank = ") << (unsigned int)mus_bank << endl;

  00706	0f b6 45 f3	 movzx	 eax, BYTE PTR _mus_bank$[ebp]
  0070a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0070d	50		 push	 eax
  0070e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@GFIKIAF@?$AA?5?$AA?5?$AAB?$AAa?$AAn?$AAk?$AA?5?$AA?$DN?$AA?5?$AA?$AA@
  00713	56		 push	 esi
  00714	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  00719	59		 pop	 ecx
  0071a	59		 pop	 ecx
  0071b	50		 push	 eax
  0071c	e8 00 00 00 00	 call	 ??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::operator<<
  00721	50		 push	 eax
  00722	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl

; 867  : 		_COUT << _T("  Size = ") << (unsigned int)mus_size << _T(" [Byte] / ") << Header.offsetPCM - 0x8000 << _T(" [Byte]") << endl;

  00727	8b 83 a0 00 00
	00		 mov	 eax, DWORD PTR [ebx+160]
  0072d	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET FLAT:??_C@_1BA@PDAIGOGG@?$AA?5?$AA?$FL?$AAB?$AAy?$AAt?$AAe?$AA?$FN?$AA?$AA@
  00734	2d 00 80 00 00	 sub	 eax, 32768		; 00008000H
  00739	50		 push	 eax
  0073a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BG@CFCHLKIG@?$AA?5?$AA?$FL?$AAB?$AAy?$AAt?$AAe?$AA?$FN?$AA?5?$AA?1?$AA?5?$AA?$AA@
  0073f	ff 75 ec	 push	 DWORD PTR _mus_size$[ebp]
  00742	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:??_C@_1BE@GMJJPPAM@?$AA?5?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?5?$AA?$AA@
  00747	57		 push	 edi
  00748	56		 push	 esi
  00749	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  0074e	59		 pop	 ecx
  0074f	59		 pop	 ecx
  00750	50		 push	 eax
  00751	e8 00 00 00 00	 call	 ??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::operator<<
  00756	50		 push	 eax
  00757	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  0075c	59		 pop	 ecx
  0075d	59		 pop	 ecx
  0075e	50		 push	 eax
  0075f	e8 00 00 00 00	 call	 ??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::operator<<
  00764	50		 push	 eax
  00765	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  0076a	50		 push	 eax
  0076b	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl

; 868  : 
; 869  : 		if((0x8000 + mus_size) > Header.offsetPCM){

  00770	8b 45 ec	 mov	 eax, DWORD PTR _mus_size$[ebp]
  00773	05 00 80 00 00	 add	 eax, 32768		; 00008000H
  00778	83 c4 0c	 add	 esp, 12			; 0000000cH
  0077b	3b 83 a0 00 00
	00		 cmp	 eax, DWORD PTR [ebx+160]
$L104367:
  00781	0f 86 fd 00 00
	00		 jbe	 $L104351

; 870  : 			Err(_T("R[hEV[PXTCYelzB"));

  00787	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DC@EMBJGJOO@0?$LD0?$PM0?I0?$PL0?$LH0?$PM0?$LB0?s0?$LJ0n0?$LF0?$KE0?$LK0L?$IK1?$FL?$LJP$0?$JC?$IN?$IK0H@
  0078c	e9 e4 01 00 00	 jmp	 $L104366
$L25510:

; 871  : 		}
; 872  : 
; 873  : 	} else {
; 874  : 
; 875  : 		//------------------------------
; 876  : 		//BankbinH
; 877  : 
; 878  : 		unsigned	int	iSizeLimit = 0x10000;	//gRAM]L
; 879  : 
; 880  : 		//V[PXoCi
; 881  : 		make_bin(bin_size, 0x0000);

  00791	6a 00		 push	 0
  00793	ff 75 e0	 push	 DWORD PTR _bin_size$[ebp]
  00796	8b cb		 mov	 ecx, ebx
  00798	e8 00 00 00 00	 call	 ?make_bin@MusicFile@@QAEXIH@Z ; MusicFile::make_bin

; 882  : 
; 883  : 		if(Header.bank == false){

  0079d	80 bb 9c 00 00
	00 00		 cmp	 BYTE PTR [ebx+156], 0
  007a4	75 0a		 jne	 SHORT $L25532

; 884  : 			Err(_T("w.bint@CAPCMoNB\n#BankR}hwB"));

  007a6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1GG@KLHECIMD@c?$AH?$FL?$JK0n?$AA?4?$AAb?$AAi?$AAn0?U0?$KB0?$KE0?k0o0?$AB?$CC?$LP?$AAP?$AAC?$AAM0n0?P0?s@
  007ab	e9 c5 01 00 00	 jmp	 $L104366
$L25532:

; 885  : 		}
; 886  : 
; 887  : 		dpcm_bank = true;
; 888  : 		mus_size = code.size();

  007b0	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]

; 889  : 		mus_bank = (unsigned char)(mus_size >> 12);

  007b3	8b c1		 mov	 eax, ecx
  007b5	c1 e8 0c	 shr	 eax, 12			; 0000000cH

; 890  : 		if((mus_size & 0x0FFF) != 0){

  007b8	66 f7 c1 ff 0f	 test	 cx, 4095		; 00000fffH
  007bd	c6 45 f2 01	 mov	 BYTE PTR _dpcm_bank$[ebp], 1
  007c1	89 4d ec	 mov	 DWORD PTR _mus_size$[ebp], ecx
  007c4	88 45 f3	 mov	 BYTE PTR _mus_bank$[ebp], al
  007c7	74 05		 je	 SHORT $L25535

; 891  : 			mus_bank++;

  007c9	fe c0		 inc	 al
  007cb	88 45 f3	 mov	 BYTE PTR _mus_bank$[ebp], al
$L25535:

; 892  : 		}
; 893  : 
; 894  : 		_COUT << _T("[CODE]") << endl;

  007ce	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1O@KFBOMPNC@?$AA?$FL?$AAC?$AAO?$AAD?$AAE?$AA?$FN?$AA?$AA@
  007d3	56		 push	 esi
  007d4	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  007d9	50		 push	 eax
  007da	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl

; 895  : 		_COUT << _T("  Bank = 3") << endl;

  007df	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BG@EHOEIOII@?$AA?5?$AA?5?$AAB?$AAa?$AAn?$AAk?$AA?5?$AA?$DN?$AA?5?$AA3?$AA?$AA@
  007e4	56		 push	 esi
  007e5	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  007ea	50		 push	 eax
  007eb	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl

; 896  : 		_COUT << _T("  Size = 12288 [Byte]") << endl;

  007f0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CM@KKKMFICH@?$AA?5?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?5?$AA1?$AA2?$AA2?$AA8?$AA8?$AA?5?$AA?$FL?$AAB?$AAy?$AAt?$AAe@
  007f5	56		 push	 esi
  007f6	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  007fb	50		 push	 eax
  007fc	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl

; 897  : 
; 898  : 		_COUT << _T("[MUSIC]") << endl;

  00801	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BA@HAHLGPF@?$AA?$FL?$AAM?$AAU?$AAS?$AAI?$AAC?$AA?$FN?$AA?$AA@
  00806	56		 push	 esi
  00807	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  0080c	50		 push	 eax
  0080d	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl

; 899  : 		_COUT << _T("  Bank = ") << (unsigned int)mus_bank << endl;

  00812	0f b6 45 f3	 movzx	 eax, BYTE PTR _mus_bank$[ebp]
  00816	83 c4 30	 add	 esp, 48			; 00000030H
  00819	50		 push	 eax
  0081a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@GFIKIAF@?$AA?5?$AA?5?$AAB?$AAa?$AAn?$AAk?$AA?5?$AA?$DN?$AA?5?$AA?$AA@
  0081f	56		 push	 esi
  00820	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  00825	59		 pop	 ecx
  00826	59		 pop	 ecx
  00827	50		 push	 eax
  00828	e8 00 00 00 00	 call	 ??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::operator<<
  0082d	50		 push	 eax
  0082e	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl

; 900  : 		_COUT << _T("  Size = ") << (unsigned int)mus_size << _T(" [Byte] / ") << iSizeLimit << _T(" [Byte]") << endl;

  00833	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET FLAT:??_C@_1BA@PDAIGOGG@?$AA?5?$AA?$FL?$AAB?$AAy?$AAt?$AAe?$AA?$FN?$AA?$AA@
  0083a	68 00 00 01 00	 push	 65536			; 00010000H
  0083f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BG@CFCHLKIG@?$AA?5?$AA?$FL?$AAB?$AAy?$AAt?$AAe?$AA?$FN?$AA?5?$AA?1?$AA?5?$AA?$AA@
  00844	ff 75 ec	 push	 DWORD PTR _mus_size$[ebp]
  00847	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:??_C@_1BE@GMJJPPAM@?$AA?5?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?5?$AA?$AA@
  0084c	57		 push	 edi
  0084d	56		 push	 esi
  0084e	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  00853	59		 pop	 ecx
  00854	59		 pop	 ecx
  00855	50		 push	 eax
  00856	e8 00 00 00 00	 call	 ??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::operator<<
  0085b	50		 push	 eax
  0085c	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  00861	59		 pop	 ecx
  00862	59		 pop	 ecx
  00863	50		 push	 eax
  00864	e8 00 00 00 00	 call	 ??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::operator<<
  00869	50		 push	 eax
  0086a	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  0086f	50		 push	 eax
  00870	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl
  00875	83 c4 0c	 add	 esp, 12			; 0000000cH

; 901  : 
; 902  : 		//TCY`FbN
; 903  : 		if(mus_size > iSizeLimit){

  00878	81 7d ec 00 00
	01 00		 cmp	 DWORD PTR _mus_size$[ebp], 65536 ; 00010000H

; 904  : 			Err(_T("R[hEV[PXTCYelzB"));

  0087f	e9 fd fe ff ff	 jmp	 $L104367
$L104351:

; 905  : 		}
; 906  : 
; 907  : 	}
; 908  : 
; 909  : 	//PCM
; 910  : 	_COUT << _T("[DPCM]") << endl;

  00884	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1O@OBLFHHEM@?$AA?$FL?$AAD?$AAP?$AAC?$AAM?$AA?$FN?$AA?$AA@
  00889	56		 push	 esi
  0088a	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  0088f	50		 push	 eax
  00890	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl

; 911  : 
; 912  : 	pcm_size = dpcm_code.size();

  00895	8b 93 e4 01 00
	00		 mov	 edx, DWORD PTR [ebx+484]

; 913  : 	pcm_bank = (unsigned char)((pcm_size + (Header.offsetPCM & 0x0FFF)) >> 12);

  0089b	8b 83 a0 00 00
	00		 mov	 eax, DWORD PTR [ebx+160]
  008a1	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  008a6	23 c1		 and	 eax, ecx
  008a8	03 c2		 add	 eax, edx
  008aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  008ad	c1 e8 0c	 shr	 eax, 12			; 0000000cH

; 914  : 	if((pcm_size & 0x0FFF) != 0){

  008b0	85 d1		 test	 edx, ecx
  008b2	89 55 e8	 mov	 DWORD PTR _pcm_size$[ebp], edx
  008b5	74 02		 je	 SHORT $L25559

; 915  : 		pcm_bank++;

  008b7	fe c0		 inc	 al
$L25559:

; 916  : 	}
; 917  : 
; 918  : 
; 919  : 	if(dpcm_bank == false){
; 920  : 		//PCMTCY`FbN
; 921  : 		_COUT << _T("  Bank = ") << (unsigned int)pcm_bank << endl;

  008b9	0f b6 c0	 movzx	 eax, al
  008bc	50		 push	 eax
  008bd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@GFIKIAF@?$AA?5?$AA?5?$AAB?$AAa?$AAn?$AAk?$AA?5?$AA?$DN?$AA?5?$AA?$AA@
  008c2	56		 push	 esi
  008c3	89 45 dc	 mov	 DWORD PTR tv858[ebp], eax
  008c6	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  008cb	59		 pop	 ecx
  008cc	59		 pop	 ecx
  008cd	50		 push	 eax
  008ce	e8 00 00 00 00	 call	 ??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::operator<<
  008d3	50		 push	 eax
  008d4	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl
  008d9	80 7d f2 00	 cmp	 BYTE PTR _dpcm_bank$[ebp], 0

; 922  : 		_COUT << _T("  Size = ") << (unsigned int)pcm_size << _T(" [Byte] / ") << 0x10000 - Header.offsetPCM << _T(" [Byte]") << endl;

  008dd	c7 04 24 00 00
	00 00		 mov	 DWORD PTR [esp], OFFSET FLAT:??_C@_1BA@PDAIGOGG@?$AA?5?$AA?$FL?$AAB?$AAy?$AAt?$AAe?$AA?$FN?$AA?$AA@
  008e4	75 57		 jne	 SHORT $L25560
  008e6	b8 00 00 01 00	 mov	 eax, 65536		; 00010000H
  008eb	2b 83 a0 00 00
	00		 sub	 eax, DWORD PTR [ebx+160]
  008f1	50		 push	 eax
  008f2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BG@CFCHLKIG@?$AA?5?$AA?$FL?$AAB?$AAy?$AAt?$AAe?$AA?$FN?$AA?5?$AA?1?$AA?5?$AA?$AA@
  008f7	ff 75 e8	 push	 DWORD PTR _pcm_size$[ebp]
  008fa	57		 push	 edi
  008fb	56		 push	 esi
  008fc	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  00901	59		 pop	 ecx
  00902	59		 pop	 ecx
  00903	50		 push	 eax
  00904	e8 00 00 00 00	 call	 ??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::operator<<
  00909	50		 push	 eax
  0090a	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  0090f	59		 pop	 ecx
  00910	59		 pop	 ecx
  00911	50		 push	 eax
  00912	e8 00 00 00 00	 call	 ??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::operator<<
  00917	50		 push	 eax
  00918	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  0091d	50		 push	 eax
  0091e	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl

; 923  : 
; 924  : 		if(	(Header.offsetPCM + pcm_size) > 0x10000	){

  00923	8b 83 a0 00 00
	00		 mov	 eax, DWORD PTR [ebx+160]
  00929	03 45 e8	 add	 eax, DWORD PTR _pcm_size$[ebp]
  0092c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0092f	3d 00 00 01 00	 cmp	 eax, 65536		; 00010000H
  00934	76 44		 jbe	 SHORT $L25576

; 925  : 			Err(_T("PCMTCYelzB"));

  00936	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CI@GAIMJLAM@?$CC?$LP?$AAP?$AAC?$AAM0n0?$LF0?$KE0?$LK0L?$IK1?$FL?$LJP$0?$JC?$IN?$IK0H0?$HO0W0_0?$AC?$AA?$AA@
  0093b	eb 38		 jmp	 SHORT $L104366
$L25560:

; 926  : 		}
; 927  : 
; 928  : 	} else {
; 929  : 		//PCMTCY`FbN
; 930  : 		_COUT << _T("  Bank = ") << (unsigned int)pcm_bank << endl;
; 931  : 		_COUT << _T("  Size = ") << (unsigned int)pcm_size << _T(" [Byte]") << endl;

  0093d	ff 75 e8	 push	 DWORD PTR _pcm_size$[ebp]
  00940	57		 push	 edi
  00941	56		 push	 esi
  00942	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  00947	59		 pop	 ecx
  00948	59		 pop	 ecx
  00949	50		 push	 eax
  0094a	e8 00 00 00 00	 call	 ??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::operator<<
  0094f	50		 push	 eax
  00950	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  00955	50		 push	 eax
  00956	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl

; 932  : 
; 933  : 		i = mus_bank + pcm_bank + 3;
; 934  : 		if(i > 255){

  0095b	0f b6 45 f3	 movzx	 eax, BYTE PTR _mus_bank$[ebp]
  0095f	8b 4d dc	 mov	 ecx, DWORD PTR tv858[ebp]
  00962	8d 44 01 03	 lea	 eax, DWORD PTR [ecx+eax+3]
  00966	83 c4 0c	 add	 esp, 12			; 0000000cH
  00969	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0096e	76 0a		 jbe	 SHORT $L25576

; 935  : 			Err(_T("oNv255zB"));

  00970	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CG@LIOGKFKL@0?P0?s0?$KPep0nT?$AI?$IK?$AI0L?$AA2?$AA5?$AA50?$JC?$IN?$IK0H0?$HO0W0_0?$AC?$AA?$AA@
$L104366:
  00975	e8 00 00 00 00	 call	 ?Err@MusicFile@@QAEXQBG@Z ; MusicFile::Err
$L104369:
$L25576:

; 936  : 		}
; 937  : 	}
; 938  : 
; 939  : 	//----------------------
; 940  : 	//mre
; 941  : 	fileopen(strFileName);

  0097a	ff 75 08	 push	 DWORD PTR _strFileName$[ebp]
  0097d	8d 7b 3c	 lea	 edi, DWORD PTR [ebx+60]
  00980	8b c7		 mov	 eax, edi
  00982	e8 00 00 00 00	 call	 ?fileopen@FileOutput@@QAEXPBD@Z ; FileOutput::fileopen

; 942  : 
; 943  : 	if(dpcm_bank == false){

  00987	80 7d f2 00	 cmp	 BYTE PTR _dpcm_bank$[ebp], 0
  0098b	0f 85 72 01 00
	00		 jne	 $L25578

; 944  : 		if(cDPCMinfo == NULL){

  00991	33 c0		 xor	 eax, eax
  00993	39 83 cc 01 00
	00		 cmp	 DWORD PTR [ebx+460], eax
  00999	75 2a		 jne	 SHORT $L25579

; 945  : 			//PCMg
; 946  : 			write(romimg, bin_size);			//NSFwb_[  R[h

  0099b	ff 75 e0	 push	 DWORD PTR _bin_size$[ebp]
  0099e	ff 75 e4	 push	 DWORD PTR _romimg$[ebp]
  009a1	57		 push	 edi
  009a2	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z ; std::basic_ostream<char,std::char_traits<char> >::write

; 947  : 			write(code.c_str(), code.size());	//V[PX

  009a7	83 7b 2c 10	 cmp	 DWORD PTR [ebx+44], 16	; 00000010H
  009ab	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  009ae	72 05		 jb	 SHORT $L104242
  009b0	8b 5b 18	 mov	 ebx, DWORD PTR [ebx+24]
  009b3	eb 03		 jmp	 SHORT $L104243
$L104242:
  009b5	83 c3 18	 add	 ebx, 24			; 00000018H
$L104243:
  009b8	50		 push	 eax
$L104365:
  009b9	53		 push	 ebx
  009ba	57		 push	 edi
  009bb	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z ; std::basic_ostream<char,std::char_traits<char> >::write

; 948  : 
; 949  : 		} else {

  009c0	e9 e3 01 00 00	 jmp	 $L25623
$L25579:

; 950  : 			//PCMg
; 951  : 			if(flag_Optimize == true){

  009c5	80 7d f1 01	 cmp	 BYTE PTR _flag_Optimize$[ebp], 1
  009c9	75 55		 jne	 SHORT $L104354

; 952  : 				//KLAwb_[oNB
; 953  : 				i = 0;
; 954  : 				while(i < mus_bank){

  009cb	0f b6 4d f3	 movzx	 ecx, BYTE PTR _mus_bank$[ebp]
  009cf	3b c8		 cmp	 ecx, eax
  009d1	76 0c		 jbe	 SHORT $L104352
$L25583:

; 955  : 					nsf->Bank[i] = (unsigned char)i;

  009d3	8b 55 e4	 mov	 edx, DWORD PTR _romimg$[ebp]
  009d6	88 44 02 70	 mov	 BYTE PTR [edx+eax+112], al

; 956  : 					i++;

  009da	40		 inc	 eax
  009db	3b c1		 cmp	 eax, ecx
  009dd	72 f4		 jb	 SHORT $L25583
$L104352:

; 957  : 				}
; 958  : 				while(i < ((Header.offsetPCM - 0x8000)>>12)){

  009df	8b 7d e4	 mov	 edi, DWORD PTR _romimg$[ebp]
  009e2	be 00 80 00 00	 mov	 esi, 32768		; 00008000H
$L104362:
  009e7	8b 8b a0 00 00
	00		 mov	 ecx, DWORD PTR [ebx+160]
  009ed	2b ce		 sub	 ecx, esi
  009ef	c1 e9 0c	 shr	 ecx, 12			; 0000000cH
  009f2	3b c1		 cmp	 eax, ecx
  009f4	73 08		 jae	 SHORT $L25588

; 959  : 					nsf->Bank[i] = 0;

  009f6	c6 44 07 70 00	 mov	 BYTE PTR [edi+eax+112], 0

; 960  : 					i++;

  009fb	40		 inc	 eax
  009fc	eb e9		 jmp	 SHORT $L104362
$L25588:

; 961  : 				}
; 962  : 				j = 0;

  009fe	33 c9		 xor	 ecx, ecx
  00a00	eb 17		 jmp	 SHORT $L104363
$L25590:

; 964  : 					if(j < pcm_bank){

  00a02	3b 4d dc	 cmp	 ecx, DWORD PTR tv858[ebp]
  00a05	73 0b		 jae	 SHORT $L25592

; 965  : 						nsf->Bank[i] = mus_bank + (unsigned char)j;

  00a07	8a d1		 mov	 dl, cl
  00a09	02 55 f3	 add	 dl, BYTE PTR _mus_bank$[ebp]
  00a0c	88 54 07 70	 mov	 BYTE PTR [edi+eax+112], dl

; 966  : 					} else {

  00a10	eb 05		 jmp	 SHORT $L25594
$L25592:

; 967  : 						nsf->Bank[i] = 0;

  00a12	c6 44 07 70 00	 mov	 BYTE PTR [edi+eax+112], 0
$L25594:

; 968  : 					}
; 969  : 					i++;

  00a17	40		 inc	 eax

; 970  : 					j++;

  00a18	41		 inc	 ecx
$L104363:

; 963  : 				while(i < 8){

  00a19	83 f8 08	 cmp	 eax, 8
  00a1c	72 e4		 jb	 SHORT $L25590
  00a1e	eb 05		 jmp	 SHORT $L25591
$L104354:
  00a20	be 00 80 00 00	 mov	 esi, 32768		; 00008000H
$L25591:

; 971  : 				}
; 972  : 			}
; 973  : 
; 974  : 			//R[hV[PX
; 975  : 			write(romimg, bin_size);			//NSFwb_[  R[h

  00a25	ff 75 e0	 push	 DWORD PTR _bin_size$[ebp]
  00a28	8d 7b 3c	 lea	 edi, DWORD PTR [ebx+60]
  00a2b	ff 75 e4	 push	 DWORD PTR _romimg$[ebp]
  00a2e	57		 push	 edi
  00a2f	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z ; std::basic_ostream<char,std::char_traits<char> >::write

; 976  : 			write(code.c_str(), code.size());	//V[PX

  00a34	83 7b 2c 10	 cmp	 DWORD PTR [ebx+44], 16	; 00000010H
  00a38	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  00a3b	72 05		 jb	 SHORT $L104261
  00a3d	8b 4b 18	 mov	 ecx, DWORD PTR [ebx+24]
  00a40	eb 03		 jmp	 SHORT $L104262
$L104261:
  00a42	8d 4b 18	 lea	 ecx, DWORD PTR [ebx+24]
$L104262:
  00a45	50		 push	 eax
  00a46	51		 push	 ecx
  00a47	57		 push	 edi
  00a48	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z ; std::basic_ostream<char,std::char_traits<char> >::write

; 977  : 
; 978  : 			if(flag_Optimize == true){

  00a4d	80 7d f1 01	 cmp	 BYTE PTR _flag_Optimize$[ebp], 1
  00a51	0f 85 83 00 00
	00		 jne	 $L104337

; 979  : 				//GAP
; 980  : 				while(mus_size < ((unsigned int)mus_bank<<12)){

  00a57	0f b6 45 f3	 movzx	 eax, BYTE PTR _mus_bank$[ebp]
  00a5b	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  00a5e	39 45 ec	 cmp	 DWORD PTR _mus_size$[ebp], eax
  00a61	73 10		 jae	 SHORT $L104357
  00a63	2b 45 ec	 sub	 eax, DWORD PTR _mus_size$[ebp]
  00a66	8b f0		 mov	 esi, eax
$L25597:

; 981  : 					put(0);		//0 padding

  00a68	6a 00		 push	 0
  00a6a	57		 push	 edi
  00a6b	e8 00 00 00 00	 call	 ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
  00a70	4e		 dec	 esi
  00a71	75 f5		 jne	 SHORT $L25597
$L104357:

; 982  : 					mus_size++;
; 983  : 				}
; 984  : 				//GAP2
; 985  : 				mus_size = Header.offsetPCM & 0x0FFF;

  00a73	8b 83 a0 00 00
	00		 mov	 eax, DWORD PTR [ebx+160]
  00a79	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH

; 986  : 				while(mus_size > 0 ){

  00a7e	76 0d		 jbe	 SHORT $L25602

; 982  : 					mus_size++;
; 983  : 				}
; 984  : 				//GAP2
; 985  : 				mus_size = Header.offsetPCM & 0x0FFF;

  00a80	8b f0		 mov	 esi, eax
$L25601:

; 987  : 					put(0);		//0 padding

  00a82	6a 00		 push	 0
  00a84	57		 push	 edi
  00a85	e8 00 00 00 00	 call	 ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
  00a8a	4e		 dec	 esi
  00a8b	75 f5		 jne	 SHORT $L25601
$L25602:

; 988  : 					mus_size--;
; 989  : 				}
; 990  : 				//PCM
; 991  : 				write(dpcm_code.c_str(), pcm_size);		//PCM

  00a8d	81 c3 d0 01 00
	00		 add	 ebx, 464		; 000001d0H
  00a93	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  00a97	72 05		 jb	 SHORT $L104276
  00a99	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  00a9c	eb 03		 jmp	 SHORT $L104277
$L104276:
  00a9e	83 c3 04	 add	 ebx, 4
$L104277:
  00aa1	ff 75 e8	 push	 DWORD PTR _pcm_size$[ebp]
  00aa4	53		 push	 ebx
  00aa5	57		 push	 edi
  00aa6	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z ; std::basic_ostream<char,std::char_traits<char> >::write

; 992  : 				while(pcm_size < ((unsigned int)pcm_bank<<12)){

  00aab	8b 45 dc	 mov	 eax, DWORD PTR tv858[ebp]
  00aae	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  00ab1	39 45 e8	 cmp	 DWORD PTR _pcm_size$[ebp], eax
  00ab4	0f 83 ee 00 00
	00		 jae	 $L25623
  00aba	2b 45 e8	 sub	 eax, DWORD PTR _pcm_size$[ebp]
  00abd	8b f0		 mov	 esi, eax
$L25604:

; 993  : 					put(0);		//0 padding

  00abf	6a 00		 push	 0
  00ac1	57		 push	 edi
  00ac2	e8 00 00 00 00	 call	 ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
  00ac7	4e		 dec	 esi
  00ac8	75 f5		 jne	 SHORT $L25604

; 994  : 					pcm_size++;
; 995  : 				}
; 996  : 			} else {

  00aca	e9 d9 00 00 00	 jmp	 $L25623
$L25609:

; 997  : 				//GAP
; 998  : 				while(mus_size < (Header.offsetPCM - 0x8000)){
; 999  : 					put(0);		//0 padding

  00acf	6a 00		 push	 0
  00ad1	57		 push	 edi
  00ad2	e8 00 00 00 00	 call	 ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put

; 1000 : 					mus_size++;

  00ad7	ff 45 ec	 inc	 DWORD PTR _mus_size$[ebp]
$L104337:
  00ada	8b 83 a0 00 00
	00		 mov	 eax, DWORD PTR [ebx+160]
  00ae0	2b c6		 sub	 eax, esi
  00ae2	39 45 ec	 cmp	 DWORD PTR _mus_size$[ebp], eax
  00ae5	72 e8		 jb	 SHORT $L25609

; 1001 : 				}
; 1002 : 				//PCM
; 1003 : 				write(dpcm_code.c_str(), pcm_size);		//PCM

  00ae7	81 c3 d0 01 00
	00		 add	 ebx, 464		; 000001d0H
  00aed	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  00af1	72 05		 jb	 SHORT $L104291
  00af3	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  00af6	eb 03		 jmp	 SHORT $L104292
$L104291:
  00af8	83 c3 04	 add	 ebx, 4
$L104292:
  00afb	ff 75 e8	 push	 DWORD PTR _pcm_size$[ebp]

; 1004 : 			}
; 1005 : 		}
; 1006 : 	} else {

  00afe	e9 b6 fe ff ff	 jmp	 $L104365
$L25578:

; 1007 : 		//Bank bin
; 1008 : 		write(&romimg[0x0000], bin_size);	//NSFwb_[  R[h

  00b03	ff 75 e0	 push	 DWORD PTR _bin_size$[ebp]
  00b06	ff 75 e4	 push	 DWORD PTR _romimg$[ebp]
  00b09	57		 push	 edi
  00b0a	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z ; std::basic_ostream<char,std::char_traits<char> >::write

; 1009 : 		write(code.c_str(), code.size());	//V[PX

  00b0f	83 7b 2c 10	 cmp	 DWORD PTR [ebx+44], 16	; 00000010H
  00b13	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  00b16	72 05		 jb	 SHORT $L104310
  00b18	8b 4b 18	 mov	 ecx, DWORD PTR [ebx+24]
  00b1b	eb 03		 jmp	 SHORT $L104311
$L104310:
  00b1d	8d 4b 18	 lea	 ecx, DWORD PTR [ebx+24]
$L104311:
  00b20	50		 push	 eax
  00b21	51		 push	 ecx
  00b22	57		 push	 edi
  00b23	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z ; std::basic_ostream<char,std::char_traits<char> >::write

; 1010 : 		//GAP
; 1011 : 		while(mus_size < ((unsigned int)mus_bank<<12)){

  00b28	0f b6 45 f3	 movzx	 eax, BYTE PTR _mus_bank$[ebp]
  00b2c	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  00b2f	39 45 ec	 cmp	 DWORD PTR _mus_size$[ebp], eax
  00b32	73 10		 jae	 SHORT $L104355
  00b34	2b 45 ec	 sub	 eax, DWORD PTR _mus_size$[ebp]
  00b37	8b f0		 mov	 esi, eax
$L25613:

; 1012 : 			put(0);		//0 padding

  00b39	6a 00		 push	 0
  00b3b	57		 push	 edi
  00b3c	e8 00 00 00 00	 call	 ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
  00b41	4e		 dec	 esi
  00b42	75 f5		 jne	 SHORT $L25613
$L104355:

; 1013 : 			mus_size++;
; 1014 : 		}
; 1015 : 
; 1016 : 		write(dpcm_code.c_str(), pcm_size);		//PCM

  00b44	81 c3 d0 01 00
	00		 add	 ebx, 464		; 000001d0H
  00b4a	83 7b 18 10	 cmp	 DWORD PTR [ebx+24], 16	; 00000010H
  00b4e	72 05		 jb	 SHORT $L104325
  00b50	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  00b53	eb 03		 jmp	 SHORT $L104326
$L104325:
  00b55	83 c3 04	 add	 ebx, 4
$L104326:
  00b58	ff 75 e8	 push	 DWORD PTR _pcm_size$[ebp]
  00b5b	53		 push	 ebx
  00b5c	57		 push	 edi
  00b5d	e8 00 00 00 00	 call	 ?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBDH@Z ; std::basic_ostream<char,std::char_traits<char> >::write

; 1017 : 		//GAP
; 1018 : 		while(pcm_size < ((unsigned int)pcm_bank<<12)){

  00b62	8b 75 dc	 mov	 esi, DWORD PTR tv858[ebp]
  00b65	8b c6		 mov	 eax, esi
  00b67	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  00b6a	39 45 e8	 cmp	 DWORD PTR _pcm_size$[ebp], eax
  00b6d	73 10		 jae	 SHORT $L104358
  00b6f	2b 45 e8	 sub	 eax, DWORD PTR _pcm_size$[ebp]
  00b72	8b d8		 mov	 ebx, eax
$L25617:

; 1019 : 			put(0);		//0 padding

  00b74	6a 00		 push	 0
  00b76	57		 push	 edi
  00b77	e8 00 00 00 00	 call	 ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
  00b7c	4b		 dec	 ebx
  00b7d	75 f5		 jne	 SHORT $L25617
$L104358:

; 1020 : 			pcm_size++;
; 1021 : 		}
; 1022 : 
; 1023 : 		if(flag_Optimize != true){

  00b7f	80 7d f1 01	 cmp	 BYTE PTR _flag_Optimize$[ebp], 1
  00b83	74 23		 je	 SHORT $L25623

; 1024 : 			//GAPiKA32kByteBj
; 1025 : 			i = (mus_bank + pcm_bank + 3) << 12;

  00b85	0f b6 45 f3	 movzx	 eax, BYTE PTR _mus_bank$[ebp]
  00b89	8d 44 06 03	 lea	 eax, DWORD PTR [esi+eax+3]
  00b8d	c1 e0 0c	 shl	 eax, 12			; 0000000cH

; 1026 : 			while(i < 0x8000){

  00b90	b9 00 80 00 00	 mov	 ecx, 32768		; 00008000H
  00b95	3b c1		 cmp	 eax, ecx
  00b97	73 0f		 jae	 SHORT $L25623
  00b99	8b f1		 mov	 esi, ecx
  00b9b	2b f0		 sub	 esi, eax
$L25622:

; 1027 : 				put(0);		//0 padding

  00b9d	6a 00		 push	 0
  00b9f	57		 push	 edi
  00ba0	e8 00 00 00 00	 call	 ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
  00ba5	4e		 dec	 esi
  00ba6	75 f5		 jne	 SHORT $L25622
$L25623:

; 1028 : 				i++;
; 1029 : 			}
; 1030 : 		}
; 1031 : 
; 1032 : 	}
; 1033 : 
; 1034 : 	close();

  00ba8	8b f7		 mov	 esi, edi
  00baa	e8 00 00 00 00	 call	 ?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ofstream<char,std::char_traits<char> >::close

; 1035 : 
; 1036 : 	//----------------------
; 1037 : 	//Exit
; 1038 : 	delete[]	romimg;

  00baf	ff 75 e4	 push	 DWORD PTR _romimg$[ebp]
  00bb2	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00bb7	59		 pop	 ecx

; 1039 : }

  00bb8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00bbb	5f		 pop	 edi
  00bbc	5e		 pop	 esi
  00bbd	5b		 pop	 ebx
  00bbe	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00bc5	c9		 leave
  00bc6	c2 04 00	 ret	 4
$L104360:
$L104092:
  005ff	ff 75 dc	 push	 DWORD PTR $T104084[ebp]
  00602	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00607	59		 pop	 ecx
  00608	c3		 ret	 0
__ehhandler$?saveNSF@MusicFile@@QAEXPBD@Z:
  00609	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T104330
  0060e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?saveNSF@MusicFile@@QAEXPBD@Z ENDP			; MusicFile::saveNSF
PUBLIC	?SetDPCMOffset@MusicFile@@QAEII@Z		; MusicFile::SetDPCMOffset
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_mus_bank$ = -1						; size = 1
_iMusSize$ = 8						; size = 4
?SetDPCMOffset@MusicFile@@QAEII@Z PROC NEAR		; MusicFile::SetDPCMOffset
; _this$ = ebx

; 655  : {

  00bc9	55		 push	 ebp
  00bca	8b ec		 mov	 ebp, esp
  00bcc	51		 push	 ecx

; 656  : 	unsigned	int		i;
; 657  : 	unsigned	char	mus_bank = (unsigned char)(iMusSize >> 12);

  00bcd	8b 45 08	 mov	 eax, DWORD PTR _iMusSize$[ebp]
  00bd0	c1 e8 0c	 shr	 eax, 12			; 0000000cH

; 658  : 
; 659  : 	if((iMusSize & 0x0FFF) != 0){

  00bd3	66 f7 45 08 ff
	0f		 test	 WORD PTR _iMusSize$[ebp], 4095 ; 00000fffH
  00bd9	88 45 ff	 mov	 BYTE PTR _mus_bank$[ebp], al
  00bdc	74 05		 je	 SHORT $L25213

; 660  : 		mus_bank++;

  00bde	fe c0		 inc	 al
  00be0	88 45 ff	 mov	 BYTE PTR _mus_bank$[ebp], al
$L25213:
  00be3	56		 push	 esi

; 661  : 	}
; 662  : 
; 663  : 
; 664  : 	dpcm_code.clear();

  00be4	8d b3 d0 01 00
	00		 lea	 esi, DWORD PTR [ebx+464]
  00bea	57		 push	 edi
  00beb	8b c6		 mov	 eax, esi
  00bed	e8 00 00 00 00	 call	 ?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear

; 665  : 	if(cDPCMinfo != NULL){

  00bf2	8b bb cc 01 00
	00		 mov	 edi, DWORD PTR [ebx+460]
  00bf8	85 ff		 test	 edi, edi
  00bfa	74 21		 je	 SHORT $L25214

; 666  : 		cDPCMinfo->getDPCMCode(&dpcm_code);

  00bfc	56		 push	 esi
  00bfd	e8 00 00 00 00	 call	 ?getDPCMCode@DPCMinfo@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; DPCMinfo::getDPCMCode

; 667  : 		i = cDPCMinfo->setDPCMoffset(Header.offsetPCM, mus_bank+3);

  00c02	8b b3 cc 01 00
	00		 mov	 esi, DWORD PTR [ebx+460]
  00c08	33 c0		 xor	 eax, eax
  00c0a	8a 45 ff	 mov	 al, BYTE PTR _mus_bank$[ebp]
  00c0d	04 03		 add	 al, 3
  00c0f	50		 push	 eax
  00c10	ff b3 a0 00 00
	00		 push	 DWORD PTR [ebx+160]
  00c16	e8 00 00 00 00	 call	 ?setDPCMoffset@DPCMinfo@@QAEIIE@Z ; DPCMinfo::setDPCMoffset

; 668  : 	} else {

  00c1b	eb 06		 jmp	 SHORT $L25215
$L25214:

; 669  : 		i = Header.offsetPCM;

  00c1d	8b 83 a0 00 00
	00		 mov	 eax, DWORD PTR [ebx+160]
$L25215:

; 670  : 	}
; 671  : 	return(i - Header.offsetPCM);

  00c23	2b 83 a0 00 00
	00		 sub	 eax, DWORD PTR [ebx+160]
  00c29	5f		 pop	 edi
  00c2a	5e		 pop	 esi

; 672  : }

  00c2b	c9		 leave
  00c2c	c2 04 00	 ret	 4
?SetDPCMOffset@MusicFile@@QAEII@Z ENDP			; MusicFile::SetDPCMOffset
PUBLIC	?Fix_Address@MusicFile@@QAEXXZ			; MusicFile::Fix_Address
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T105255 = -12						; size = 4
$T105254 = -12						; size = 4
_iSE$ = -8						; size = 4
_itSub$ = -8						; size = 4
_iBGM$ = -4						; size = 4
?Fix_Address@MusicFile@@QAEXXZ PROC NEAR		; MusicFile::Fix_Address
; _this$ = ebx

; 683  : {

  00c2f	55		 push	 ebp
  00c30	8b ec		 mov	 ebp, esp
  00c32	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 684  : 	map<int,Sub*	>::iterator	itSub;
; 685  : 
; 686  : 	unsigned	int			iBGM	= 0;

  00c35	83 65 fc 00	 and	 DWORD PTR _iBGM$[ebp], 0

; 687  : 	unsigned	int			iSE		= 0;

  00c39	83 65 f8 00	 and	 DWORD PTR _iSE$[ebp], 0

; 688  : 
; 689  : 
; 690  : 	while(iBGM < Header.iBGM){

  00c3d	80 bb 9e 00 00
	00 00		 cmp	 BYTE PTR [ebx+158], 0
  00c44	56		 push	 esi
  00c45	57		 push	 edi
  00c46	76 2b		 jbe	 SHORT $L105370
  00c48	8d bb a8 01 00
	00		 lea	 edi, DWORD PTR [ebx+424]
$L25229:

; 691  : 		ptcBGM[iBGM]->Fix_Address(this);

  00c4e	8b 45 fc	 mov	 eax, DWORD PTR _iBGM$[ebp]
  00c51	8d 75 f4	 lea	 esi, DWORD PTR $T105254[ebp]
  00c54	89 45 f4	 mov	 DWORD PTR $T105254[ebp], eax
  00c57	e8 00 00 00 00	 call	 ??A?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAEAAPAVBGM@@ABH@Z ; std::map<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> > >::operator[]
  00c5c	53		 push	 ebx
  00c5d	ff 30		 push	 DWORD PTR [eax]
  00c5f	e8 00 00 00 00	 call	 ?Fix_Address@TrackSet@@QAEXPAVMusicFile@@@Z ; TrackSet::Fix_Address
  00c64	0f b6 83 9e 00
	00 00		 movzx	 eax, BYTE PTR [ebx+158]

; 692  : 		iBGM++;

  00c6b	ff 45 fc	 inc	 DWORD PTR _iBGM$[ebp]
  00c6e	39 45 fc	 cmp	 DWORD PTR _iBGM$[ebp], eax
  00c71	72 db		 jb	 SHORT $L25229
$L105370:

; 693  : 	}
; 694  : 
; 695  : 	while(iSE < Header.iSE){

  00c73	80 bb 9f 00 00
	00 00		 cmp	 BYTE PTR [ebx+159], 0
  00c7a	76 2b		 jbe	 SHORT $L25234
  00c7c	8d bb b4 01 00
	00		 lea	 edi, DWORD PTR [ebx+436]
$L25233:

; 696  : 		ptcSE[iSE]->Fix_Address(this);

  00c82	8b 45 f8	 mov	 eax, DWORD PTR _iSE$[ebp]
  00c85	8d 75 f4	 lea	 esi, DWORD PTR $T105255[ebp]
  00c88	89 45 f4	 mov	 DWORD PTR $T105255[ebp], eax
  00c8b	e8 00 00 00 00	 call	 ??A?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAEAAPAVSE@@ABH@Z ; std::map<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> > >::operator[]
  00c90	53		 push	 ebx
  00c91	ff 30		 push	 DWORD PTR [eax]
  00c93	e8 00 00 00 00	 call	 ?Fix_Address@TrackSet@@QAEXPAVMusicFile@@@Z ; TrackSet::Fix_Address
  00c98	0f b6 83 9f 00
	00 00		 movzx	 eax, BYTE PTR [ebx+159]

; 697  : 		iSE++;

  00c9f	ff 45 f8	 inc	 DWORD PTR _iSE$[ebp]
  00ca2	39 45 f8	 cmp	 DWORD PTR _iSE$[ebp], eax
  00ca5	72 db		 jb	 SHORT $L25233
$L25234:

; 698  : 	}
; 699  : 
; 700  : 	if(!ptcSub.empty()){

  00ca7	83 bb c8 01 00
	00 00		 cmp	 DWORD PTR [ebx+456], 0
  00cae	5f		 pop	 edi
  00caf	5e		 pop	 esi
  00cb0	74 2b		 je	 SHORT $L25240

; 701  : 		itSub = ptcSub.begin();

  00cb2	8b 8b c4 01 00
	00		 mov	 ecx, DWORD PTR [ebx+452]
  00cb8	8b 01		 mov	 eax, DWORD PTR [ecx]

; 702  : 		while(itSub != ptcSub.end()){

  00cba	3b c1		 cmp	 eax, ecx
  00cbc	89 45 f8	 mov	 DWORD PTR _itSub$[ebp], eax
  00cbf	74 1c		 je	 SHORT $L25240
$L25239:

; 703  : 			itSub->second->Fix_Address(this);

  00cc1	53		 push	 ebx
  00cc2	ff 70 10	 push	 DWORD PTR [eax+16]
  00cc5	e8 00 00 00 00	 call	 ?Fix_Address@TrackSet@@QAEXPAVMusicFile@@@Z ; TrackSet::Fix_Address

; 704  : 			itSub++;

  00cca	8d 55 f8	 lea	 edx, DWORD PTR _itSub$[ebp]
  00ccd	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Inc
  00cd2	8b 45 f8	 mov	 eax, DWORD PTR _itSub$[ebp]
  00cd5	3b 83 c4 01 00
	00		 cmp	 eax, DWORD PTR [ebx+452]
  00cdb	75 e4		 jne	 SHORT $L25239
$L25240:

; 705  : 		}
; 706  : 	}
; 707  : }

  00cdd	c9		 leave
  00cde	c3		 ret	 0
?Fix_Address@MusicFile@@QAEXXZ ENDP			; MusicFile::Fix_Address
PUBLIC	?TickCount@MusicFile@@QAEXXZ			; MusicFile::TickCount
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T107760 = -12						; size = 4
$T107759 = -12						; size = 4
$T107758 = -12						; size = 4
$T107757 = -12						; size = 4
_iSE$ = -8						; size = 4
_itSub$ = -8						; size = 4
_iBGM$ = -4						; size = 4
_itEnv$ = 8						; size = 4
_itN163$ = 8						; size = 4
_itVRC7$ = 8						; size = 4
_itFDSM$ = 8						; size = 4
_itFDSC$ = 8						; size = 4
_this$ = 8						; size = 4
?TickCount@MusicFile@@QAEXXZ PROC NEAR			; MusicFile::TickCount

; 527  : {

  00cdf	55		 push	 ebp
  00ce0	8b ec		 mov	 ebp, esp
  00ce2	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 528  : 	map<	int, FDSC*		>::iterator	itFDSC;		//FDS  wave table (career)
; 529  : 	map<	int, FDSM*		>::iterator	itFDSM;		//FDS  wave table (modulator)
; 530  : 	map<	int, VRC7*		>::iterator	itVRC7;		//VRC7 User Instrument
; 531  : 	map<	int, N163*		>::iterator	itN163;		//N163 wave table
; 532  : 	map<	int, Envelop*	>::iterator	itEnv;		//Envelop
; 533  : 	map<	int, Sub*		>::iterator	itSub;		//Subroutine
; 534  : 
; 535  : 	unsigned	int			iBGM	= 0;

  00ce5	83 65 fc 00	 and	 DWORD PTR _iBGM$[ebp], 0

; 536  : 	unsigned	int			iSE		= 0;

  00ce9	83 65 f8 00	 and	 DWORD PTR _iSE$[ebp], 0
  00ced	53		 push	 ebx

; 537  : 
; 538  : 	//----------------------
; 539  : 	//Tick Count & KW
; 540  : 
; 541  : 	while(iBGM < Header.iBGM){

  00cee	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00cf1	80 bb 9e 00 00
	00 00		 cmp	 BYTE PTR [ebx+158], 0
  00cf8	56		 push	 esi
  00cf9	57		 push	 edi
  00cfa	76 72		 jbe	 SHORT $L108789
  00cfc	8d bb a8 01 00
	00		 lea	 edi, DWORD PTR [ebx+424]
$L108798:

; 542  : 		cout << "---- BGM(" << iBGM << ") ----" <<endl;

  00d02	8b 75 fc	 mov	 esi, DWORD PTR _iBGM$[ebp]
  00d05	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06EEKMEKPC@?$CJ?5?9?9?9?9?$AA@
  00d0a	56		 push	 esi
  00d0b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09BPDCILGE@?9?9?9?9?5BGM?$CI?$AA@
  00d10	68 00 00 00 00	 push	 OFFSET FLAT:?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  00d15	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00d1a	59		 pop	 ecx
  00d1b	59		 pop	 ecx
  00d1c	50		 push	 eax
  00d1d	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
  00d22	50		 push	 eax
  00d23	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00d28	50		 push	 eax
  00d29	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl

; 543  : 		ptcBGM[iBGM]->TickCount(this);				//JEeBOAsvR}h`FbN

  00d2e	89 75 f4	 mov	 DWORD PTR $T107757[ebp], esi
  00d31	83 c4 0c	 add	 esp, 12			; 0000000cH
  00d34	8d 75 f4	 lea	 esi, DWORD PTR $T107757[ebp]
  00d37	e8 00 00 00 00	 call	 ??A?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAEAAPAVBGM@@ABH@Z ; std::map<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> > >::operator[]
  00d3c	53		 push	 ebx
  00d3d	8b 18		 mov	 ebx, DWORD PTR [eax]
  00d3f	e8 00 00 00 00	 call	 ?TickCount@TrackSet@@QAEXPAVMusicFile@@@Z ; TrackSet::TickCount

; 544  : 		ptcBGM[iBGM]->OptimizeDefineCheck(this);	//g``FbN

  00d44	8b 45 fc	 mov	 eax, DWORD PTR _iBGM$[ebp]
  00d47	8d 75 f4	 lea	 esi, DWORD PTR $T107758[ebp]
  00d4a	89 45 f4	 mov	 DWORD PTR $T107758[ebp], eax
  00d4d	e8 00 00 00 00	 call	 ??A?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAEAAPAVBGM@@ABH@Z ; std::map<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> > >::operator[]
  00d52	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00d55	8b 18		 mov	 ebx, DWORD PTR [eax]
  00d57	56		 push	 esi
  00d58	e8 00 00 00 00	 call	 ?OptimizeDefineCheck@TrackSet@@QAEXPAVMusicFile@@@Z ; TrackSet::OptimizeDefineCheck
  00d5d	0f b6 86 9e 00
	00 00		 movzx	 eax, BYTE PTR [esi+158]

; 545  : 		iBGM++;

  00d64	ff 45 fc	 inc	 DWORD PTR _iBGM$[ebp]
  00d67	39 45 fc	 cmp	 DWORD PTR _iBGM$[ebp], eax
  00d6a	8b de		 mov	 ebx, esi
  00d6c	72 94		 jb	 SHORT $L108798
$L108789:

; 546  : 	}
; 547  : 
; 548  : 	while(iSE < Header.iSE){

  00d6e	80 bb 9f 00 00
	00 00		 cmp	 BYTE PTR [ebx+159], 0
  00d75	76 72		 jbe	 SHORT $L25041
  00d77	8d bb b4 01 00
	00		 lea	 edi, DWORD PTR [ebx+436]
$L108799:

; 549  : 		cout << "---- SE(" << iSE << ") ----" <<endl;

  00d7d	8b 75 f8	 mov	 esi, DWORD PTR _iSE$[ebp]
  00d80	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06EEKMEKPC@?$CJ?5?9?9?9?9?$AA@
  00d85	56		 push	 esi
  00d86	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08COBGNJFP@?9?9?9?9?5SE?$CI?$AA@
  00d8b	68 00 00 00 00	 push	 OFFSET FLAT:?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  00d90	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00d95	59		 pop	 ecx
  00d96	59		 pop	 ecx
  00d97	50		 push	 eax
  00d98	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
  00d9d	50		 push	 eax
  00d9e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00da3	50		 push	 eax
  00da4	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl

; 550  : 		ptcSE[iSE]->TickCount(this);				//JEeBOAsvR}h`FbN

  00da9	89 75 f4	 mov	 DWORD PTR $T107759[ebp], esi
  00dac	83 c4 0c	 add	 esp, 12			; 0000000cH
  00daf	8d 75 f4	 lea	 esi, DWORD PTR $T107759[ebp]
  00db2	e8 00 00 00 00	 call	 ??A?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAEAAPAVSE@@ABH@Z ; std::map<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> > >::operator[]
  00db7	53		 push	 ebx
  00db8	8b 18		 mov	 ebx, DWORD PTR [eax]
  00dba	e8 00 00 00 00	 call	 ?TickCount@TrackSet@@QAEXPAVMusicFile@@@Z ; TrackSet::TickCount

; 551  : 		ptcSE[iSE]->OptimizeDefineCheck(this);		//g``FbN

  00dbf	8b 45 f8	 mov	 eax, DWORD PTR _iSE$[ebp]
  00dc2	8d 75 f4	 lea	 esi, DWORD PTR $T107760[ebp]
  00dc5	89 45 f4	 mov	 DWORD PTR $T107760[ebp], eax
  00dc8	e8 00 00 00 00	 call	 ??A?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAEAAPAVSE@@ABH@Z ; std::map<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> > >::operator[]
  00dcd	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00dd0	8b 18		 mov	 ebx, DWORD PTR [eax]
  00dd2	56		 push	 esi
  00dd3	e8 00 00 00 00	 call	 ?OptimizeDefineCheck@TrackSet@@QAEXPAVMusicFile@@@Z ; TrackSet::OptimizeDefineCheck
  00dd8	0f b6 86 9f 00
	00 00		 movzx	 eax, BYTE PTR [esi+159]

; 552  : 		iSE++;

  00ddf	ff 45 f8	 inc	 DWORD PTR _iSE$[ebp]
  00de2	39 45 f8	 cmp	 DWORD PTR _iSE$[ebp], eax
  00de5	8b de		 mov	 ebx, esi
  00de7	72 94		 jb	 SHORT $L108799
$L25041:

; 553  : 	}
; 554  : 
; 555  : 	//----------------------
; 556  : 	//svR}h
; 557  : 
; 558  : 	if(cOptionSW->flag_OptSeq == true){		//R}hKAKB
; 559  : 
; 560  : 		//	to do		svR}hEIuWFNg	
; 561  : 
; 562  : 	}
; 563  : 
; 564  : 	//----------------------
; 565  : 	//g`
; 566  : 
; 567  : 	if(cOptionSW->flag_OptObj == true){		//`KAKB

  00de9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cOptionSW@@3PAVOPSW@@A ; cOptionSW
  00dee	80 78 05 01	 cmp	 BYTE PTR [eax+5], 1
  00df2	0f 85 78 01 00
	00		 jne	 $L25184

; 568  : 
; 569  : 		//Tu[`
; 570  : 		if(!ptcSub.empty()){

  00df8	33 f6		 xor	 esi, esi
  00dfa	39 b3 c8 01 00
	00		 cmp	 DWORD PTR [ebx+456], esi
  00e00	74 47		 je	 SHORT $L25053

; 571  : 			itSub = ptcSub.begin();

  00e02	8b 83 c4 01 00
	00		 mov	 eax, DWORD PTR [ebx+452]
  00e08	8b 08		 mov	 ecx, DWORD PTR [eax]

; 572  : 			while(itSub != ptcSub.end()){

  00e0a	3b c8		 cmp	 ecx, eax
  00e0c	89 4d f8	 mov	 DWORD PTR _itSub$[ebp], ecx
  00e0f	74 38		 je	 SHORT $L25053
$L25052:

; 573  : 				if(itSub->second->chkUse() == true){

  00e11	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00e14	80 78 38 01	 cmp	 BYTE PTR [eax+56], 1
  00e18	75 0d		 jne	 SHORT $L25073

; 574  : 					//gTu[`Ag``FbN
; 575  : 					itSub->second->OptimizeDefineCheck(this);

  00e1a	53		 push	 ebx
  00e1b	8b d8		 mov	 ebx, eax
  00e1d	e8 00 00 00 00	 call	 ?OptimizeDefineCheck@TrackSet@@QAEXPAVMusicFile@@@Z ; TrackSet::OptimizeDefineCheck

; 576  : 				} else {

  00e22	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00e25	eb 0d		 jmp	 SHORT $L107999
$L25073:

; 577  : 					//gTu[`AIuWFNgB
; 578  : 					itSub->second->clear(itSub->first);

  00e27	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00e2a	83 48 58 ff	 or	 DWORD PTR [eax+88], -1
  00e2e	51		 push	 ecx
  00e2f	e8 00 00 00 00	 call	 ?clear@MusicItem@@QAEXH@Z ; MusicItem::clear
$L107999:

; 579  : 				}
; 580  : 				itSub++;

  00e34	8d 55 f8	 lea	 edx, DWORD PTR _itSub$[ebp]
  00e37	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::const_iterator::_Inc
  00e3c	8b 4d f8	 mov	 ecx, DWORD PTR _itSub$[ebp]
  00e3f	3b 8b c4 01 00
	00		 cmp	 ecx, DWORD PTR [ebx+452]
  00e45	75 ca		 jne	 SHORT $L25052

; 572  : 			while(itSub != ptcSub.end()){

  00e47	33 f6		 xor	 esi, esi
$L25053:

; 581  : 			}
; 582  : 		}
; 583  : 
; 584  : 		//Gx[v
; 585  : 		if(!ptcEnv.empty()){

  00e49	39 b3 a4 01 00
	00		 cmp	 DWORD PTR [ebx+420], esi
  00e4f	74 33		 je	 SHORT $L25080

; 586  : 			itEnv = ptcEnv.begin();

  00e51	8b 83 a0 01 00
	00		 mov	 eax, DWORD PTR [ebx+416]
  00e57	8b 08		 mov	 ecx, DWORD PTR [eax]

; 587  : 			while(itEnv != ptcEnv.end()){

  00e59	3b c8		 cmp	 ecx, eax
  00e5b	89 4d 08	 mov	 DWORD PTR _itEnv$[ebp], ecx
  00e5e	74 24		 je	 SHORT $L25080
$L25079:

; 588  : 				if(itEnv->second->chkUse() == false){

  00e60	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00e63	80 78 38 00	 cmp	 BYTE PTR [eax+56], 0
  00e67	75 08		 jne	 SHORT $L25100

; 589  : 					//gTu[`AIuWFNgB
; 590  : 					itEnv->second->clear(itEnv->first);

  00e69	ff 71 0c	 push	 DWORD PTR [ecx+12]
  00e6c	e8 00 00 00 00	 call	 ?clear@MusicItem@@QAEXH@Z ; MusicItem::clear
$L25100:

; 591  : 				}
; 592  : 				itEnv++;

  00e71	8d 55 08	 lea	 edx, DWORD PTR _itEnv$[ebp]
  00e74	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::const_iterator::_Inc
  00e79	8b 4d 08	 mov	 ecx, DWORD PTR _itEnv$[ebp]
  00e7c	3b 8b a0 01 00
	00		 cmp	 ecx, DWORD PTR [ebx+416]
  00e82	75 dc		 jne	 SHORT $L25079
$L25080:

; 593  : 			}
; 594  : 		}
; 595  : 
; 596  : 		//FDSC
; 597  : 		if(!ptcFDSC.empty()){

  00e84	39 b3 74 01 00
	00		 cmp	 DWORD PTR [ebx+372], esi
  00e8a	74 33		 je	 SHORT $L25106

; 598  : 			itFDSC = ptcFDSC.begin();

  00e8c	8b 83 70 01 00
	00		 mov	 eax, DWORD PTR [ebx+368]
  00e92	8b 08		 mov	 ecx, DWORD PTR [eax]

; 599  : 			while(itFDSC != ptcFDSC.end()){

  00e94	3b c8		 cmp	 ecx, eax
  00e96	89 4d 08	 mov	 DWORD PTR _itFDSC$[ebp], ecx
  00e99	74 24		 je	 SHORT $L25106
$L25105:

; 600  : 				if(itFDSC->second->chkUse() == false){

  00e9b	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00e9e	80 78 38 00	 cmp	 BYTE PTR [eax+56], 0
  00ea2	75 08		 jne	 SHORT $L25126

; 601  : 					//gTu[`AIuWFNgB
; 602  : 					itFDSC->second->clear(itFDSC->first);

  00ea4	ff 71 0c	 push	 DWORD PTR [ecx+12]
  00ea7	e8 00 00 00 00	 call	 ?clear@MusicItem@@QAEXH@Z ; MusicItem::clear
$L25126:

; 603  : 				}
; 604  : 				itFDSC++;

  00eac	8d 55 08	 lea	 edx, DWORD PTR _itFDSC$[ebp]
  00eaf	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::const_iterator::_Inc
  00eb4	8b 4d 08	 mov	 ecx, DWORD PTR _itFDSC$[ebp]
  00eb7	3b 8b 70 01 00
	00		 cmp	 ecx, DWORD PTR [ebx+368]
  00ebd	75 dc		 jne	 SHORT $L25105
$L25106:

; 605  : 			}
; 606  : 		}
; 607  : 
; 608  : 		//FDSM
; 609  : 		if(!ptcFDSM.empty()){

  00ebf	39 b3 80 01 00
	00		 cmp	 DWORD PTR [ebx+384], esi
  00ec5	74 33		 je	 SHORT $L25132

; 610  : 			itFDSM = ptcFDSM.begin();

  00ec7	8b 83 7c 01 00
	00		 mov	 eax, DWORD PTR [ebx+380]
  00ecd	8b 08		 mov	 ecx, DWORD PTR [eax]

; 611  : 			while(itFDSM != ptcFDSM.end()){

  00ecf	3b c8		 cmp	 ecx, eax
  00ed1	89 4d 08	 mov	 DWORD PTR _itFDSM$[ebp], ecx
  00ed4	74 24		 je	 SHORT $L25132
$L25131:

; 612  : 				if(itFDSM->second->chkUse() == false){

  00ed6	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00ed9	80 78 38 00	 cmp	 BYTE PTR [eax+56], 0
  00edd	75 08		 jne	 SHORT $L25152

; 613  : 					//gTu[`AIuWFNgB
; 614  : 					itFDSM->second->clear(itFDSM->first);

  00edf	ff 71 0c	 push	 DWORD PTR [ecx+12]
  00ee2	e8 00 00 00 00	 call	 ?clear@MusicItem@@QAEXH@Z ; MusicItem::clear
$L25152:

; 615  : 				}
; 616  : 				itFDSM++;

  00ee7	8d 55 08	 lea	 edx, DWORD PTR _itFDSM$[ebp]
  00eea	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::const_iterator::_Inc
  00eef	8b 4d 08	 mov	 ecx, DWORD PTR _itFDSM$[ebp]
  00ef2	3b 8b 7c 01 00
	00		 cmp	 ecx, DWORD PTR [ebx+380]
  00ef8	75 dc		 jne	 SHORT $L25131
$L25132:

; 617  : 			}
; 618  : 		}
; 619  : 
; 620  : 		//VRC7
; 621  : 		if(!ptcVRC7.empty()){

  00efa	39 b3 8c 01 00
	00		 cmp	 DWORD PTR [ebx+396], esi
  00f00	74 33		 je	 SHORT $L25158

; 622  : 			itVRC7 = ptcVRC7.begin();

  00f02	8b 83 88 01 00
	00		 mov	 eax, DWORD PTR [ebx+392]
  00f08	8b 08		 mov	 ecx, DWORD PTR [eax]

; 623  : 			while(itVRC7 != ptcVRC7.end()){

  00f0a	3b c8		 cmp	 ecx, eax
  00f0c	89 4d 08	 mov	 DWORD PTR _itVRC7$[ebp], ecx
  00f0f	74 24		 je	 SHORT $L25158
$L25157:

; 624  : 				if(itVRC7->second->chkUse() == false){

  00f11	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00f14	80 78 38 00	 cmp	 BYTE PTR [eax+56], 0
  00f18	75 08		 jne	 SHORT $L25178

; 625  : 					//gTu[`AIuWFNgB
; 626  : 					itVRC7->second->clear(itVRC7->first);

  00f1a	ff 71 0c	 push	 DWORD PTR [ecx+12]
  00f1d	e8 00 00 00 00	 call	 ?clear@MusicItem@@QAEXH@Z ; MusicItem::clear
$L25178:

; 627  : 				}
; 628  : 				itVRC7++;

  00f22	8d 55 08	 lea	 edx, DWORD PTR _itVRC7$[ebp]
  00f25	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::const_iterator::_Inc
  00f2a	8b 4d 08	 mov	 ecx, DWORD PTR _itVRC7$[ebp]
  00f2d	3b 8b 88 01 00
	00		 cmp	 ecx, DWORD PTR [ebx+392]
  00f33	75 dc		 jne	 SHORT $L25157
$L25158:

; 629  : 			}
; 630  : 		}
; 631  : 
; 632  : 		//N163
; 633  : 		if(!ptcN163.empty()){

  00f35	39 b3 98 01 00
	00		 cmp	 DWORD PTR [ebx+408], esi
  00f3b	74 33		 je	 SHORT $L25184

; 634  : 			itN163 = ptcN163.begin();

  00f3d	8b 83 94 01 00
	00		 mov	 eax, DWORD PTR [ebx+404]
  00f43	8b 08		 mov	 ecx, DWORD PTR [eax]

; 635  : 			while(itN163 != ptcN163.end()){

  00f45	3b c8		 cmp	 ecx, eax
  00f47	89 4d 08	 mov	 DWORD PTR _itN163$[ebp], ecx
  00f4a	74 24		 je	 SHORT $L25184
$L25183:

; 636  : 				if(itN163->second->chkUse() == false){

  00f4c	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00f4f	80 78 38 00	 cmp	 BYTE PTR [eax+56], 0
  00f53	75 08		 jne	 SHORT $L25204

; 637  : 					//gTu[`AIuWFNgB
; 638  : 					itN163->second->clear(itN163->first);

  00f55	ff 71 0c	 push	 DWORD PTR [ecx+12]
  00f58	e8 00 00 00 00	 call	 ?clear@MusicItem@@QAEXH@Z ; MusicItem::clear
$L25204:

; 639  : 				}
; 640  : 				itN163++;

  00f5d	8d 55 08	 lea	 edx, DWORD PTR _itN163$[ebp]
  00f60	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::const_iterator::_Inc
  00f65	8b 4d 08	 mov	 ecx, DWORD PTR _itN163$[ebp]
  00f68	3b 8b 94 01 00
	00		 cmp	 ecx, DWORD PTR [ebx+404]
  00f6e	75 dc		 jne	 SHORT $L25183
$L25184:
  00f70	5f		 pop	 edi
  00f71	5e		 pop	 esi
  00f72	5b		 pop	 ebx

; 641  : 			}
; 642  : 		}
; 643  : 	}
; 644  : }

  00f73	c9		 leave
  00f74	c2 04 00	 ret	 4
?TickCount@MusicFile@@QAEXXZ ENDP			; MusicFile::TickCount
PUBLIC	??0MusicFile@@QAE@PAVMMLfile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBG@Z ; MusicFile::MusicFile
$T111934 DD	0ffffffffH
	DD	FLAT:$L110371
	DD	00H
	DD	FLAT:$L110373
	DD	01H
	DD	FLAT:$L110375
	DD	02H
	DD	FLAT:$L110376
	DD	03H
	DD	FLAT:$L110378
	DD	04H
	DD	FLAT:$L110379
	DD	05H
	DD	FLAT:$L110380
	DD	06H
	DD	FLAT:$L110381
	DD	07H
	DD	FLAT:$L110382
	DD	08H
	DD	FLAT:$L110383
	DD	09H
	DD	FLAT:$L110384
	DD	0aH
	DD	FLAT:$L110385
	DD	0bH
	DD	FLAT:$L110386
	DD	0cH
	DD	FLAT:$L110387
	DD	0dH
	DD	FLAT:$L110388
	DD	0eH
	DD	FLAT:$L110389
	DD	0eH
	DD	FLAT:$L110390
	DD	0eH
	DD	FLAT:$L110391
	DD	0eH
	DD	FLAT:$L110392
	DD	0eH
	DD	FLAT:$L110393
	DD	0eH
	DD	FLAT:$L110394
	DD	0eH
	DD	FLAT:$L110395
	DD	0eH
	DD	FLAT:$L110396
	DD	0eH
	DD	FLAT:$L110397
	DD	0eH
	DD	FLAT:$L110398
$T111896 DD	019930520H
	DD	019H
	DD	FLAT:$T111934
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T110372 = -56						; size = 4
$T110367 = -52						; size = 4
$T110364 = -52						; size = 4
$T110360 = -52						; size = 4
$T110357 = -52						; size = 4
$T110353 = -52						; size = 4
$T110350 = -52						; size = 4
$T110346 = -52						; size = 4
$T110343 = -52						; size = 4
$T110336 = -52						; size = 4
$T110332 = -52						; size = 4
$T110329 = -52						; size = 4
$T110325 = -52						; size = 4
$T110322 = -52						; size = 4
$T110318 = -52						; size = 4
$T110315 = -52						; size = 4
$T110311 = -52						; size = 4
$T110308 = -52						; size = 4
$T110302 = -52						; size = 4
$T110300 = -52						; size = 4
$T110363 = -48						; size = 4
$T110356 = -48						; size = 4
$T110349 = -48						; size = 4
$T110342 = -48						; size = 4
$T110335 = -48						; size = 4
$T110328 = -48						; size = 4
$T110321 = -48						; size = 4
$T110314 = -48						; size = 4
$T110307 = -48						; size = 4
$T110305 = -48						; size = 4
_msg$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
$T110370 = 12						; size = 4
$T110369 = 12						; size = 4
_MML$ = 12						; size = 4
__code$ = 16						; size = 28
__strName$ = 44						; size = 4
$T110368 = 48						; size = 4
$T110362 = 48						; size = 4
$T110361 = 48						; size = 4
$T110355 = 48						; size = 4
$T110354 = 48						; size = 4
$T110348 = 48						; size = 4
$T110347 = 48						; size = 4
$T110341 = 48						; size = 4
$T110334 = 48						; size = 4
$T110333 = 48						; size = 4
$T110327 = 48						; size = 4
$T110326 = 48						; size = 4
$T110320 = 48						; size = 4
$T110319 = 48						; size = 4
$T110313 = 48						; size = 4
$T110312 = 48						; size = 4
$T110306 = 48						; size = 4
_$initVBases$ = 48					; size = 4
??0MusicFile@@QAE@PAVMMLfile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBG@Z PROC NEAR ; MusicFile::MusicFile

; 32   : {

  00f77	b8 00 00 00 00	 mov	 eax, __ehhandler$??0MusicFile@@QAE@PAVMMLfile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBG@Z
  00f7c	e8 00 00 00 00	 call	 __EH_prolog
  00f81	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00f84	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00f89	53		 push	 ebx
  00f8a	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00f8d	56		 push	 esi
  00f8e	57		 push	 edi
  00f8f	33 ff		 xor	 edi, edi
  00f91	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00f94	89 7d c8	 mov	 DWORD PTR $T110372[ebp], edi
  00f97	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00f9a	39 7d 30	 cmp	 DWORD PTR _$initVBases$[ebp], edi
  00f9d	74 1c		 je	 SHORT $L23924
  00f9f	c7 43 3c 00 00
	00 00		 mov	 DWORD PTR [ebx+60], OFFSET FLAT:??_8MusicFile@@7B@
  00fa6	c7 83 f0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+496], OFFSET FLAT:??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
  00fb0	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00fb4	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR $T110372[ebp], 1
$L23924:
  00fbb	57		 push	 edi
  00fbc	8d 73 3c	 lea	 esi, DWORD PTR [ebx+60]
  00fbf	56		 push	 esi
  00fc0	e8 00 00 00 00	 call	 ??0FileOutput@@QAE@XZ	; FileOutput::FileOutput
  00fc5	ff 75 2c	 push	 DWORD PTR __strName$[ebp]
  00fc8	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00fcf	53		 push	 ebx
  00fd0	e8 00 00 00 00	 call	 ??0MusicItem@@QAE@QBG@Z	; MusicItem::MusicItem
  00fd5	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00fd9	8b 06		 mov	 eax, DWORD PTR [esi]
  00fdb	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7MusicFile@@6BMusicItem@@@
  00fe1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00fe4	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00fe7	c7 44 18 3c 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+60], OFFSET FLAT:??_7MusicFile@@6BFileOutput@@@
  00fef	8d 45 10	 lea	 eax, DWORD PTR __code$[ebp]
  00ff2	8b cc		 mov	 ecx, esp
  00ff4	89 65 cc	 mov	 DWORD PTR $T110300[ebp], esp
  00ff7	50		 push	 eax
  00ff8	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00ffd	8d 83 9c 00 00
	00		 lea	 eax, DWORD PTR [ebx+156]
  01003	50		 push	 eax
  01004	e8 00 00 00 00	 call	 ??0MusicHeader@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; MusicHeader::MusicHeader
  01009	8d b3 6c 01 00
	00		 lea	 esi, DWORD PTR [ebx+364]
  0100f	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  01013	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::_Init
  01018	8d b3 78 01 00
	00		 lea	 esi, DWORD PTR [ebx+376]
  0101e	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  01022	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::_Init
  01027	8d b3 84 01 00
	00		 lea	 esi, DWORD PTR [ebx+388]
  0102d	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  01031	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::_Init
  01036	8d b3 90 01 00
	00		 lea	 esi, DWORD PTR [ebx+400]
  0103c	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  01040	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::_Init
  01045	8d b3 9c 01 00
	00		 lea	 esi, DWORD PTR [ebx+412]
  0104b	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  0104f	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::_Init
  01054	8d b3 a8 01 00
	00		 lea	 esi, DWORD PTR [ebx+424]
  0105a	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  0105e	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::_Init
  01063	8d b3 b4 01 00
	00		 lea	 esi, DWORD PTR [ebx+436]
  01069	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  0106d	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::_Init
  01072	8d b3 c0 01 00
	00		 lea	 esi, DWORD PTR [ebx+448]
  01078	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  0107c	e8 00 00 00 00	 call	 ?_Init@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::_Init
  01081	8d 8b d0 01 00
	00		 lea	 ecx, DWORD PTR [ebx+464]
  01087	89 bb cc 01 00
	00		 mov	 DWORD PTR [ebx+460], edi
  0108d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 33   : 	//----------------------
; 34   : 	//Local
; 35   : 
; 36   : 
; 37   : //	`
; 38   : enum	Command_ID_MusicFile {
; 39   : 	//for NSF output
; 40   : 	id_Title,
; 41   : 	id_Composer,
; 42   : 	id_Copyright,
; 43   : 	id_OffsetPCM,
; 44   : 	id_Code,
; 45   : 	id_External,
; 46   : 	id_Bank,
; 47   : 
; 48   : 	//for ASM output
; 49   : 	id_SegmentSEQ,
; 50   : 	id_SegmentPCM,
; 51   : 	id_Label,
; 52   : 	id_Priority,
; 53   : 
; 54   : 	//General
; 55   : 	id_include,
; 56   : 	id_timebase,
; 57   : 	id_OctaveReverse,
; 58   : 	id_QReverse,
; 59   : 	id_bgm_num,
; 60   : 	id_se_num,
; 61   : 	id_releaseVolume,
; 62   : 	id_repeatMode,
; 63   : 	id_TieMode,
; 64   : 	id_offset_Ei,
; 65   : 	id_offset_Ev,
; 66   : 	id_offset_En,
; 67   : 	id_offset_Em,
; 68   : 	id_QMax,
; 69   : 	id_rest,
; 70   : 	id_wait,
; 71   : 
; 72   : 	//Block
; 73   : 	id_DPCM,
; 74   : 	id_FDSC,
; 75   : 	id_FDSM,
; 76   : 	id_VRC7,
; 77   : 	id_N163,
; 78   : 	id_Envelop,
; 79   : 	id_Vibrato,
; 80   : 	id_Macro,
; 81   : 	id_Sub,
; 82   : 	id_BGM,
; 83   : 	id_SE,
; 84   : 	id_Patch,
; 85   : 
; 86   : 	id_Null
; 87   : };
; 88   : 
; 89   : //	AMML\gR}hB
; 90   : const	static	Command_Info	Command[] = {
; 91   : 		//for NSF output
; 92   : 		{	"#Title",			id_Title		},
; 93   : 		{	"#title",			id_Title		},
; 94   : 		{	"",				id_Title		},
; 95   : 		{	"#Composer",		id_Composer		},
; 96   : 		{	"#composer",		id_Composer		},
; 97   : 		{	"",			id_Composer		},
; 98   : 		{	"",				id_Composer		},
; 99   : 		{	"#Copyright",		id_Copyright	},
; 100  : 		{	"#copyright",		id_Copyright	},
; 101  : 		{	"",				id_Copyright	},
; 102  : 		{	"",			id_Copyright	},
; 103  : 		{	"#OffsetPCM",		id_OffsetPCM	},	//Offset Address of PCM
; 104  : 		{	"#offsetPCM",		id_OffsetPCM	},	//Offset Address of PCM
; 105  : 		{	"#offsetPCM",		id_OffsetPCM	},	//Offset Address of PCM
; 106  : 		{	"#Code",			id_Code			},
; 107  : 		{	"#code",			id_Code			},
; 108  : 		{	"R[h",			id_Code			},
; 109  : 		{	"#External",		id_External		},
; 110  : 		{	"#external",		id_External		},
; 111  : 		{	"#Bank",			id_Bank			},
; 112  : 		{	"#bank",			id_Bank			},
; 113  : 		{	"oN",			id_Bank			},
; 114  : 		//for ASM output
; 115  : 		{	"#SegmentPCM",		id_SegmentPCM	},	//Segment name for PCM
; 116  : 		{	"#segmentPCM",		id_SegmentPCM	},
; 117  : 		{	"#SegmentSEQ",		id_SegmentSEQ	},	//Segment name for Sequence
; 118  : 		{	"#segmentSEQ",		id_SegmentSEQ	},
; 119  : 		{	"#Segment",			id_SegmentSEQ	},	//Segment name for Sequence
; 120  : 		{	"#segment",			id_SegmentSEQ	},
; 121  : 		{	"#Label",			id_Label		},
; 122  : 		{	"#label",			id_Label		},
; 123  : 
; 124  : 		//General
; 125  : 		{	"#Include",			id_include		},
; 126  : 		{	"#include",			id_include		},
; 127  : 		{	"",				id_include		},
; 128  : 		{	"#Timebase",		id_timebase		},
; 129  : 		{	"#timebase",		id_timebase		},
; 130  : 		{	"#OctaveReverse",	id_OctaveReverse},
; 131  : 		{	"#octaveReverse",	id_OctaveReverse},
; 132  : 		{	"#QReverse",		id_QReverse		},
; 133  : 		{	"#qReverse",		id_QReverse		},
; 134  : 		{	"#BGM",				id_bgm_num		},
; 135  : 		{	"#bgm",				id_bgm_num		},
; 136  : 		{	"y",			id_bgm_num		},
; 137  : 		{	"#SE",				id_se_num		},
; 138  : 		{	"#se",				id_se_num		},
; 139  : 		{	"",			id_se_num		},
; 140  : 		{	"#releaseVolume",	id_releaseVolume},
; 141  : 		{	"#ReleaseVolume",	id_releaseVolume},
; 142  : 		{	"#repeatMode",		id_repeatMode	},
; 143  : 		{	"#RepeatMode",		id_repeatMode	},
; 144  : 		{	"#TieMode",			id_TieMode		},
; 145  : 		{	"#tieMode",			id_TieMode		},	
; 146  : 		{	"#OffsetE@",		id_offset_Ei	},
; 147  : 		{	"#offsetE@",		id_offset_Ei	},
; 148  : 		{	"#OffsetEv",		id_offset_Ev	},
; 149  : 		{	"#offsetEv",		id_offset_Ev	},
; 150  : 		{	"#OffsetEm",		id_offset_Em	},
; 151  : 		{	"#offsetEm",		id_offset_Em	},
; 152  : 		{	"#OffsetEn",		id_offset_En	},
; 153  : 		{	"#offsetEn",		id_offset_En	},
; 154  : 		{	"#Priority",		id_Priority		},
; 155  : 		{	"#priority",		id_Priority		},
; 156  : 		{	"#QMax",			id_QMax			},
; 157  : 		{	"#Qmax",			id_QMax			},
; 158  : 		{	"#Rest",			id_rest			},
; 159  : 		{	"#rest",			id_rest			},
; 160  : 		{	"#Wait",			id_wait			},
; 161  : 		{	"#wait",			id_wait			},
; 162  : 		//Block
; 163  : 		{	"DPCM",				id_DPCM			},
; 164  : 		{	"FDSC",				id_FDSC			},
; 165  : 		{	"FDSM",				id_FDSM			},
; 166  : 		{	"VRC7",				id_VRC7			},
; 167  : 		{	"N163",				id_N163			},
; 168  : 		{	"Envelope",			id_Envelop		},
; 169  : 		{	"envelope",			id_Envelop		},
; 170  : 		{	"Envelop",			id_Envelop		},
; 171  : 		{	"envelop",			id_Envelop		},
; 172  : 		{	"Gx[v",		id_Envelop		},
; 173  : 		{	"ru[g",		id_Vibrato		},
; 174  : 		{	"Sub",				id_Sub			},
; 175  : 		{	"sub",				id_Sub			},
; 176  : 		{	"BGM",				id_BGM			},
; 177  : 		{	"bgm",				id_BGM			},
; 178  : 		{	"y",				id_BGM			},
; 179  : 		{	"SE",				id_SE			},
; 180  : 		{	"se",				id_SE			},
; 181  : 		{	"",			id_SE			},
; 182  : 		{	"Patch",			id_Patch		},
; 183  : 
; 184  : 		//for 1 command
; 185  : 		{	"D",				id_DPCM			},
; 186  : 		{	"FC",				id_FDSC			},
; 187  : 		{	"FM",				id_FDSM			},
; 188  : 		{	"O",				id_VRC7			},
; 189  : 		{	"V",				id_VRC7			},
; 190  : 		{	"N",				id_N163			},
; 191  : 		{	"E",				id_Envelop		},
; 192  : 		{	"S",				id_Sub			},
; 193  : 		{	"P",				id_Patch		},
; 194  : 		{	"$",				id_Macro		},
; 195  : 
; 196  : 		//for mck/ppmck
; 197  : 		{	"@DPCM",			id_DPCM			},
; 198  : 		{	"@FM",				id_FDSC			},
; 199  : 		{	"@MW",				id_FDSM			},
; 200  : 		{	"@OP",				id_VRC7			},
; 201  : 		{	"@N",				id_N163			},
; 202  : 		{	"@E",				id_Envelop		},
; 203  : 
; 204  : 		{	"@",				id_Null			},
; 205  : 	};
; 206  : 
; 207  : 	unsigned	int			i;
; 208  : 	unsigned	char		cData;
; 209  : 				FDSC*		_fdsc;
; 210  : 				FDSM*		_fdsm;
; 211  : 				VRC7*		_vrc7;
; 212  : 				N163*		_n163;
; 213  : 				Envelop*	_env;
; 214  : 				BGM*		_bgm;
; 215  : 				SE*			_se;
; 216  : 				Sub*		_sub;
; 217  : 	string		msg;

  01092	57		 push	 edi
  01093	8d 4d d4	 lea	 ecx, DWORD PTR _msg$[ebp]
  01096	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _msg$[ebp+24], 15 ; 0000000fH
  0109d	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
  010a2	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH

; 218  : 
; 219  : 	map<	int,	Envelop*	>::iterator	itEnvelop;
; 220  : 	map<	int,	BGM*		>::iterator	itBGM;
; 221  : 	map<	int,	SE*			>::iterator	itSE;
; 222  : 	map<	int,	Sub*		>::iterator	itSub;
; 223  : 
; 224  : 	iSize = 0;

  010a6	8b 75 0c	 mov	 esi, DWORD PTR _MML$[ebp]
  010a9	89 7b 30	 mov	 DWORD PTR [ebx+48], edi
$L24415:

; 225  : 
; 226  : 	do{
; 227  : 		
; 228  : 		//PiRg`FbNAincludet@CI[`FbNj
; 229  : 		cData = MML->GetChar();

  010ac	8b fe		 mov	 edi, esi
  010ae	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 230  : 
; 231  : 		//[EOF]`FbN
; 232  : 		if( MML->eom() ){

  010b3	8b c6		 mov	 eax, esi
  010b5	e8 00 00 00 00	 call	 ?eom@MMLfile@@QAE_NXZ	; MMLfile::eom
  010ba	84 c0		 test	 al, al
  010bc	0f 85 6a 07 00
	00		 jne	 $L24417

; 233  : 			break;
; 234  : 		}
; 235  : 
; 236  : 		//P
; 237  : 		MML->Back();

  010c2	8b c6		 mov	 eax, esi
  010c4	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back

; 238  : 
; 239  : 		//R}h`FbN
; 240  : 		switch(MML->GetCommandID(Command, sizeof(Command)/sizeof(Command_Info))){

  010c9	6a 68		 push	 104			; 00000068H
  010cb	68 00 00 00 00	 push	 OFFSET FLAT:?Command@?1???0MusicFile@@QAE@PAVMMLfile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBG@Z@4QBUCommand_Info@@B
  010d0	8b c6		 mov	 eax, esi
  010d2	e8 00 00 00 00	 call	 ?GetCommandID@MMLfile@@QAEHQBUCommand_Info@@I@Z ; MMLfile::GetCommandID
  010d7	83 f8 27	 cmp	 eax, 39			; 00000027H
  010da	0f 87 8b 08 00
	00		 ja	 $L24587
  010e0	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L111933[eax*4]
$L24424:

; 241  : 			//for NSF output
; 242  : 			case(id_Code):
; 243  : 				Header.Set_RomCode(MML);

  010e7	ff 75 0c	 push	 DWORD PTR _MML$[ebp]
  010ea	8d b3 9c 00 00
	00		 lea	 esi, DWORD PTR [ebx+156]
  010f0	e8 00 00 00 00	 call	 ?Set_RomCode@MusicHeader@@QAEXPAVMMLfile@@@Z ; MusicHeader::Set_RomCode

; 244  : 				break;

  010f5	e9 20 07 00 00	 jmp	 $L111928
$L24425:

; 245  : 			case(id_Title):
; 246  : 				Header.Set_Title(MML);

  010fa	8d 83 9c 00 00
	00		 lea	 eax, DWORD PTR [ebx+156]
  01100	50		 push	 eax
  01101	8b ce		 mov	 ecx, esi
  01103	e8 00 00 00 00	 call	 ?Set_Title@MusicHeader@@QAEXPAVMMLfile@@@Z ; MusicHeader::Set_Title

; 247  : 				break;

  01108	e9 10 07 00 00	 jmp	 $L24416
$L24426:

; 248  : 			case(id_Composer):
; 249  : 				Header.Set_Composer(MML);

  0110d	8d 83 9c 00 00
	00		 lea	 eax, DWORD PTR [ebx+156]
  01113	50		 push	 eax
  01114	8b ce		 mov	 ecx, esi
  01116	e8 00 00 00 00	 call	 ?Set_Composer@MusicHeader@@QAEXPAVMMLfile@@@Z ; MusicHeader::Set_Composer

; 250  : 				break;

  0111b	e9 fd 06 00 00	 jmp	 $L24416
$L24427:

; 251  : 			case(id_Copyright):
; 252  : 				Header.Set_Copyright(MML);

  01120	8d 83 9c 00 00
	00		 lea	 eax, DWORD PTR [ebx+156]
  01126	50		 push	 eax
  01127	8b ce		 mov	 ecx, esi
  01129	e8 00 00 00 00	 call	 ?Set_Copyright@MusicHeader@@QAEXPAVMMLfile@@@Z ; MusicHeader::Set_Copyright

; 253  : 				break;

  0112e	e9 ea 06 00 00	 jmp	 $L24416
$L24428:

; 254  : 			case(id_OffsetPCM):
; 255  : 				Header.Set_OffsetPCM(MML);

  01133	8b 7d 0c	 mov	 edi, DWORD PTR _MML$[ebp]
  01136	8d b3 9c 00 00
	00		 lea	 esi, DWORD PTR [ebx+156]
  0113c	e8 00 00 00 00	 call	 ?Set_OffsetPCM@MusicHeader@@QAEXPAVMMLfile@@@Z ; MusicHeader::Set_OffsetPCM

; 256  : 				break;

  01141	e9 d4 06 00 00	 jmp	 $L111928
$L24429:

; 257  : 			case(id_External):
; 258  : 				Header.Set_External(MML);

  01146	56		 push	 esi
  01147	8d 83 9c 00 00
	00		 lea	 eax, DWORD PTR [ebx+156]
  0114d	50		 push	 eax
  0114e	e8 00 00 00 00	 call	 ?Set_External@MusicHeader@@QAEXPAVMMLfile@@@Z ; MusicHeader::Set_External

; 259  : 				break;

  01153	e9 c5 06 00 00	 jmp	 $L24416
$L24430:

; 260  : 			case(id_Bank):
; 261  : 				Header.Set_Bank();

  01158	8d 83 9c 00 00
	00		 lea	 eax, DWORD PTR [ebx+156]
  0115e	c6 00 01	 mov	 BYTE PTR [eax], 1
  01161	c7 40 04 00 c0
	00 00		 mov	 DWORD PTR [eax+4], 49152 ; 0000c000H

; 262  : 				break;

  01168	e9 b0 06 00 00	 jmp	 $L24416
$L24431:

; 263  : 			//for ASM output
; 264  : 			case(id_SegmentSEQ):
; 265  : 				Header.Set_SegmentSEQ(MML);

  0116d	8d 83 9c 00 00
	00		 lea	 eax, DWORD PTR [ebx+156]
  01173	50		 push	 eax
  01174	8b ce		 mov	 ecx, esi
  01176	e8 00 00 00 00	 call	 ?Set_SegmentSEQ@MusicHeader@@QAEXPAVMMLfile@@@Z ; MusicHeader::Set_SegmentSEQ

; 266  : 				break;

  0117b	e9 9d 06 00 00	 jmp	 $L24416
$L24432:

; 267  : 			case(id_SegmentPCM):
; 268  : 				Header.Set_SegmentPCM(MML);

  01180	8d 83 9c 00 00
	00		 lea	 eax, DWORD PTR [ebx+156]
  01186	50		 push	 eax
  01187	8b ce		 mov	 ecx, esi
  01189	e8 00 00 00 00	 call	 ?Set_SegmentPCM@MusicHeader@@QAEXPAVMMLfile@@@Z ; MusicHeader::Set_SegmentPCM

; 269  : 				break;

  0118e	e9 8a 06 00 00	 jmp	 $L24416
$L24433:

; 270  : 			case(id_Label):
; 271  : 				Header.Set_Label(MML);

  01193	8d 83 9c 00 00
	00		 lea	 eax, DWORD PTR [ebx+156]
  01199	50		 push	 eax
  0119a	8b ce		 mov	 ecx, esi
  0119c	e8 00 00 00 00	 call	 ?Set_Label@MusicHeader@@QAEXPAVMMLfile@@@Z ; MusicHeader::Set_Label

; 272  : 				break;

  011a1	e9 77 06 00 00	 jmp	 $L24416
$L24434:

; 273  : 			//General
; 274  : 			case(id_include):
; 275  : 				MML->include();

  011a6	8b fe		 mov	 edi, esi
  011a8	e8 00 00 00 00	 call	 ?include@MMLfile@@QAEXXZ ; MMLfile::include

; 276  : 				break;

  011ad	e9 6b 06 00 00	 jmp	 $L24416
$L24435:

; 277  : 			case(id_bgm_num):
; 278  : 				Header.Set_Number_BGM(MML);

  011b2	56		 push	 esi
  011b3	8d 83 9c 00 00
	00		 lea	 eax, DWORD PTR [ebx+156]
  011b9	50		 push	 eax
  011ba	e8 00 00 00 00	 call	 ?Set_Number_BGM@MusicHeader@@QAEXPAVMMLfile@@@Z ; MusicHeader::Set_Number_BGM

; 279  : 				break;

  011bf	e9 59 06 00 00	 jmp	 $L24416
$L24436:

; 280  : 			case(id_se_num):
; 281  : 				Header.Set_Number_SE(MML);

  011c4	56		 push	 esi
  011c5	8d 83 9c 00 00
	00		 lea	 eax, DWORD PTR [ebx+156]
  011cb	50		 push	 eax
  011cc	e8 00 00 00 00	 call	 ?Set_Number_SE@MusicHeader@@QAEXPAVMMLfile@@@Z ; MusicHeader::Set_Number_SE

; 282  : 				break;

  011d1	e9 47 06 00 00	 jmp	 $L24416
$L24437:

; 283  : 			case(id_timebase):
; 284  : 				MML->timebase = MML->GetInt();	//AMMLt@CB

  011d6	8b c6		 mov	 eax, esi
  011d8	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  011dd	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax

; 285  : 				break;

  011e3	e9 35 06 00 00	 jmp	 $L24416
$L24438:

; 286  : 			case(id_OctaveReverse):
; 287  : 				MML->octave_reverse = true;		//AMMLt@CB

  011e8	c6 86 94 00 00
	00 01		 mov	 BYTE PTR [esi+148], 1

; 288  : 				break;

  011ef	e9 29 06 00 00	 jmp	 $L24416
$L24439:

; 289  : 			case(id_QReverse):
; 290  : 				MML->q_reverse = true;			//AMMLt@CB

  011f4	c6 86 95 00 00
	00 01		 mov	 BYTE PTR [esi+149], 1

; 291  : 				break;

  011fb	e9 1d 06 00 00	 jmp	 $L24416
$L24440:

; 292  : 			case(id_releaseVolume):
; 293  : 				MML->iReleaseVolume	=  MML->GetInt();

  01200	8b c6		 mov	 eax, esi
  01202	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 294  : 				if((MML->iReleaseVolume<0) || (MML->iReleaseVolume>15)){

  01207	85 c0		 test	 eax, eax
  01209	89 86 84 00 00
	00		 mov	 DWORD PTR [esi+132], eax
  0120f	7c 09		 jl	 SHORT $L111901
  01211	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  01214	0f 8e 03 06 00
	00		 jle	 $L24416
$L111901:

; 295  : 					MML->Err(_T("#ReleaseVolumeR}hA0`15wB"));

  0121a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1EM@BEGGFCCM@?$AA?$CD?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe0?$LD0?$NO0?s0?I0o0?$AB@
  0121f	e9 4c 07 00 00	 jmp	 $L111930
$L24444:

; 296  : 				}
; 297  : 				break;
; 298  : 			case(id_repeatMode):
; 299  : 				MML->iRepeatMode	=  MML->GetInt();

  01224	8b c6		 mov	 eax, esi
  01226	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 300  : 				if((MML->iRepeatMode<0) || (MML->iRepeatMode>2)){

  0122b	85 c0		 test	 eax, eax
  0122d	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  01233	7c 09		 jl	 SHORT $L111902
  01235	83 f8 02	 cmp	 eax, 2
  01238	0f 8e df 05 00
	00		 jle	 $L24416
$L111902:

; 301  : 					MML->Err(_T("#RepeatModeR}hA0`2wB"));

  0123e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1EE@MOLGAENM@?$AA?$CD?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AAM?$AAo?$AAd?$AAe0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA2@
  01243	e9 28 07 00 00	 jmp	 $L111930
$L24448:

; 302  : 				}
; 303  : 				break;
; 304  : 			case(id_TieMode):
; 305  : 				MML->iTieMode	=  MML->GetInt();

  01248	8b c6		 mov	 eax, esi
  0124a	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 306  : 				if((MML->iTieMode<0) || (MML->iTieMode>1)){

  0124f	85 c0		 test	 eax, eax
  01251	89 86 8c 00 00
	00		 mov	 DWORD PTR [esi+140], eax
  01257	7c 09		 jl	 SHORT $L111903
  01259	83 f8 01	 cmp	 eax, 1
  0125c	0f 8e bb 05 00
	00		 jle	 $L24416
$L111903:

; 307  : 					MML->Err(_T("#TieModeR}hA0`1wB"));

  01262	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DO@PDNFGBGE@?$AA?$CD?$AAT?$AAi?$AAe?$AAM?$AAo?$AAd?$AAe0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA10n?$HL?DV?r@
  01267	e9 04 07 00 00	 jmp	 $L111930
$L24452:

; 308  : 				}
; 309  : 				break;
; 310  : 			case(id_offset_Ei):
; 311  : 				MML->offset_Ei = MML->GetInt();

  0126c	8b c6		 mov	 eax, esi
  0126e	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  01273	89 46 74	 mov	 DWORD PTR [esi+116], eax

; 312  : 				break;

  01276	e9 a2 05 00 00	 jmp	 $L24416
$L24453:

; 313  : 			case(id_offset_Ev):
; 314  : 				MML->offset_Ev = MML->GetInt();

  0127b	8b c6		 mov	 eax, esi
  0127d	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  01282	89 46 78	 mov	 DWORD PTR [esi+120], eax

; 315  : 				break;

  01285	e9 93 05 00 00	 jmp	 $L24416
$L24454:

; 316  : 			case(id_offset_En):
; 317  : 				MML->offset_En = MML->GetInt();

  0128a	8b c6		 mov	 eax, esi
  0128c	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  01291	89 46 7c	 mov	 DWORD PTR [esi+124], eax

; 318  : 				break;

  01294	e9 84 05 00 00	 jmp	 $L24416
$L24455:

; 319  : 			case(id_offset_Em):
; 320  : 				MML->offset_Em = MML->GetInt();

  01299	8b c6		 mov	 eax, esi
  0129b	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  012a0	89 86 80 00 00
	00		 mov	 DWORD PTR [esi+128], eax

; 321  : 				break;

  012a6	e9 72 05 00 00	 jmp	 $L24416
$L24456:

; 322  : 			case(id_Priority):
; 323  : 				i = MML->GetInt();

  012ab	8b c6		 mov	 eax, esi
  012ad	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 324  : 				if((i<0) || (i>3)){

  012b2	83 f8 03	 cmp	 eax, 3
  012b5	0f 87 98 05 00
	00		 ja	 $L111904

; 326  : 				} else {
; 327  : 					MML->priority = (unsigned char)i;

  012bb	88 86 a4 00 00
	00		 mov	 BYTE PTR [esi+164], al

; 328  : 				}
; 329  : 				break;

  012c1	e9 57 05 00 00	 jmp	 $L24416
$L24462:

; 330  : 			case(id_QMax):
; 331  : 				MML->QMax = MML->GetInt();

  012c6	8b c6		 mov	 eax, esi
  012c8	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  012cd	89 86 a0 00 00
	00		 mov	 DWORD PTR [esi+160], eax

; 332  : 				break;

  012d3	e9 45 05 00 00	 jmp	 $L24416
$L24463:

; 333  : 			case(id_rest):
; 334  : 				MML->rest = MML->GetInt();

  012d8	8b c6		 mov	 eax, esi
  012da	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 335  : 				if((MML->rest<0) || (MML->rest>3)){

  012df	85 c0		 test	 eax, eax
  012e1	89 86 98 00 00
	00		 mov	 DWORD PTR [esi+152], eax
  012e7	7c 09		 jl	 SHORT $L111905
  012e9	83 f8 03	 cmp	 eax, 3
  012ec	0f 8e 2b 05 00
	00		 jle	 $L24416
$L111905:

; 336  : 					MML->Err(_T("#RestR}hA0`3wB"));

  012f2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DI@LBEELOIE@?$AA?$CD?$AAR?$AAe?$AAs?$AAt0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA30n?$HL?DV?r0gc?$AH?$FL?$JK@
  012f7	e9 74 06 00 00	 jmp	 $L111930
$L24467:

; 337  : 				}
; 338  : 				break;
; 339  : 			case(id_wait):
; 340  : 				MML->wait = MML->GetInt();

  012fc	8b c6		 mov	 eax, esi
  012fe	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  01303	89 86 9c 00 00
	00		 mov	 DWORD PTR [esi+156], eax

; 341  : 				if((MML->rest<0) || (MML->rest>3)){

  01309	8b 86 98 00 00
	00		 mov	 eax, DWORD PTR [esi+152]
  0130f	85 c0		 test	 eax, eax
  01311	7c 09		 jl	 SHORT $L111906
  01313	83 f8 03	 cmp	 eax, 3
  01316	0f 8e 01 05 00
	00		 jle	 $L24416
$L111906:

; 342  : 					MML->Err(_T("#WaitR}hA0`3wB"));

  0131c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DI@MNKEBKGP@?$AA?$CD?$AAW?$AAa?$AAi?$AAt0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA30n?$HL?DV?r0gc?$AH?$FL?$JK@
  01321	e9 4a 06 00 00	 jmp	 $L111930
$L24471:

; 343  : 				}
; 344  : 				break;
; 345  : 			case(id_Macro):
; 346  : 				MML->SetMacro(0);

  01326	6a 00		 push	 0
  01328	8b ce		 mov	 ecx, esi
  0132a	e8 00 00 00 00	 call	 ?SetMacro@MMLfile@@QAEXH@Z ; MMLfile::SetMacro

; 347  : 				break;

  0132f	e9 e9 04 00 00	 jmp	 $L24416
$L24472:

; 348  : 			case(id_Patch):
; 349  : 				MML->SetPatch();

  01334	8b ce		 mov	 ecx, esi
  01336	e8 00 00 00 00	 call	 ?SetPatch@MMLfile@@QAEXXZ ; MMLfile::SetPatch

; 350  : 				break;

  0133b	e9 dd 04 00 00	 jmp	 $L24416
$L24473:

; 351  : 			//MML
; 352  : 			case(id_DPCM):
; 353  : 				if(cDPCMinfo != NULL){

  01340	83 bb cc 01 00
	00 00		 cmp	 DWORD PTR [ebx+460], 0
  01347	0f 85 10 05 00
	00		 jne	 $L111907

; 355  : 				}
; 356  : 				cDPCMinfo = new DPCMinfo(MML, Header.bank);

  0134d	68 4c 24 00 00	 push	 9292			; 0000244cH
  01352	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01357	59		 pop	 ecx
  01358	89 45 cc	 mov	 DWORD PTR $T110302[ebp], eax
  0135b	85 c0		 test	 eax, eax
  0135d	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  01361	74 18		 je	 SHORT $L110303
  01363	33 c9		 xor	 ecx, ecx
  01365	8a 8b 9c 00 00
	00		 mov	 cl, BYTE PTR [ebx+156]
  0136b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CM@EIOCHGHI@?$AA?$DN?$AA?$DN?$AA?$DN?$AA?$DN?$AA?5?$AA?$FL?$AA?5?$AAD?$AAP?$AAC?$AAM?$AAi?$AAn?$AAf?$AAo?$AA?5?$AA?$FN?$AA?$DN?$AA?$DN?$AA?$DN@
  01370	51		 push	 ecx
  01371	50		 push	 eax
  01372	8b ce		 mov	 ecx, esi
  01374	e8 00 00 00 00	 call	 ??0DPCMinfo@@QAE@PAVMMLfile@@_NQBG@Z ; DPCMinfo::DPCMinfo
  01379	eb 02		 jmp	 SHORT $L110304
$L110303:
  0137b	33 c0		 xor	 eax, eax
$L110304:
  0137d	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  01381	89 83 cc 01 00
	00		 mov	 DWORD PTR [ebx+460], eax

; 357  : 				ptcItem.push_back(cDPCMinfo);

  01387	89 45 d0	 mov	 DWORD PTR $T110305[ebp], eax
  0138a	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  0138d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01390	8d 55 d0	 lea	 edx, DWORD PTR $T110305[ebp]
  01393	52		 push	 edx
  01394	51		 push	 ecx
  01395	50		 push	 eax
  01396	e8 00 00 00 00	 call	 ?_Insert@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEXViterator@12@ABQAVMusicItem@@@Z ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Insert

; 358  : 				iSize += cDPCMinfo->getSize();	//BGMTCYXV

  0139b	8b 83 cc 01 00
	00		 mov	 eax, DWORD PTR [ebx+460]
  013a1	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  013a4	01 43 30	 add	 DWORD PTR [ebx+48], eax

; 359  : 				break;

  013a7	e9 71 04 00 00	 jmp	 $L24416
$L24482:

; 360  : 			case(id_FDSC):
; 361  : 				i = MML->GetNum();

  013ac	8b c6		 mov	 eax, esi
  013ae	e8 00 00 00 00	 call	 ?GetNum@MMLfile@@QAEHXZ	; MMLfile::GetNum
  013b3	8b f8		 mov	 edi, eax

; 362  : 
; 363  : 				//d`FbN
; 364  : 				if(ptcFDSC.count(i) != 0){

  013b5	8d 45 30	 lea	 eax, DWORD PTR $T110306[ebp]
  013b8	50		 push	 eax
  013b9	8d 83 6c 01 00
	00		 lea	 eax, DWORD PTR [ebx+364]
  013bf	50		 push	 eax
  013c0	89 7d 30	 mov	 DWORD PTR $T110306[ebp], edi
  013c3	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::count
  013c8	85 c0		 test	 eax, eax
  013ca	0f 85 97 04 00
	00		 jne	 $L111908

; 366  : 				}
; 367  : 				_fdsc = new FDSC(MML, i);

  013d0	6a 40		 push	 64			; 00000040H
  013d2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  013d7	59		 pop	 ecx
  013d8	89 45 cc	 mov	 DWORD PTR $T110308[ebp], eax
  013db	85 c0		 test	 eax, eax
  013dd	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  013e1	74 14		 je	 SHORT $L110309
  013e3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_19CBLNKBPD@?$AAF?$AAD?$AAS?$AAC?$AA?$AA@
  013e8	50		 push	 eax
  013e9	8b cf		 mov	 ecx, edi
  013eb	8b d6		 mov	 edx, esi
  013ed	e8 00 00 00 00	 call	 ??0FDSC@@QAE@PAVMMLfile@@IQBG@Z ; FDSC::FDSC
  013f2	89 45 d0	 mov	 DWORD PTR $T110307[ebp], eax
  013f5	eb 04		 jmp	 SHORT $L110310
$L110309:
  013f7	83 65 d0 00	 and	 DWORD PTR $T110307[ebp], 0
$L110310:
  013fb	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH

; 368  : 				ptcItem.push_back(_fdsc);

  013ff	8b 45 d0	 mov	 eax, DWORD PTR $T110307[ebp]
  01402	89 45 cc	 mov	 DWORD PTR $T110311[ebp], eax
  01405	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  01408	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0140b	8d 55 cc	 lea	 edx, DWORD PTR $T110311[ebp]
  0140e	52		 push	 edx
  0140f	51		 push	 ecx
  01410	50		 push	 eax
  01411	e8 00 00 00 00	 call	 ?_Insert@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEXViterator@12@ABQAVMusicItem@@@Z ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Insert

; 369  : 				ptcFDSC[i] = _fdsc;

  01416	89 7d 30	 mov	 DWORD PTR $T110312[ebp], edi
  01419	8d 75 30	 lea	 esi, DWORD PTR $T110312[ebp]
  0141c	8d bb 6c 01 00
	00		 lea	 edi, DWORD PTR [ebx+364]
  01422	e8 00 00 00 00	 call	 ??A?$map@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@@std@@QAEAAPAVFDSC@@ABH@Z ; std::map<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> > >::operator[]

; 370  : 				iSize += _fdsc->getSize();	//BGMTCYXV
; 371  : 				break;

  01427	e9 e3 03 00 00	 jmp	 $L111929
$L24493:

; 372  : 			case(id_FDSM):
; 373  : 				i = MML->GetNum();

  0142c	8b c6		 mov	 eax, esi
  0142e	e8 00 00 00 00	 call	 ?GetNum@MMLfile@@QAEHXZ	; MMLfile::GetNum
  01433	8b f8		 mov	 edi, eax

; 374  : 
; 375  : 				//d`FbN
; 376  : 				if(ptcFDSM.count(i) != 0){

  01435	8d 45 30	 lea	 eax, DWORD PTR $T110313[ebp]
  01438	50		 push	 eax
  01439	8d 83 78 01 00
	00		 lea	 eax, DWORD PTR [ebx+376]
  0143f	50		 push	 eax
  01440	89 7d 30	 mov	 DWORD PTR $T110313[ebp], edi
  01443	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::count
  01448	85 c0		 test	 eax, eax
  0144a	0f 85 21 04 00
	00		 jne	 $L111909

; 378  : 				}
; 379  : 				_fdsm = new FDSM(MML, i);

  01450	6a 40		 push	 64			; 00000040H
  01452	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01457	59		 pop	 ecx
  01458	89 45 cc	 mov	 DWORD PTR $T110315[ebp], eax
  0145b	85 c0		 test	 eax, eax
  0145d	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+8], 17 ; 00000011H
  01461	74 14		 je	 SHORT $L110316
  01463	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_19MBGCNGMA@?$AAF?$AAD?$AAS?$AAM?$AA?$AA@
  01468	50		 push	 eax
  01469	8b cf		 mov	 ecx, edi
  0146b	8b d6		 mov	 edx, esi
  0146d	e8 00 00 00 00	 call	 ??0FDSM@@QAE@PAVMMLfile@@IQBG@Z ; FDSM::FDSM
  01472	89 45 d0	 mov	 DWORD PTR $T110314[ebp], eax
  01475	eb 04		 jmp	 SHORT $L110317
$L110316:
  01477	83 65 d0 00	 and	 DWORD PTR $T110314[ebp], 0
$L110317:
  0147b	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH

; 380  : 				ptcItem.push_back(_fdsm);

  0147f	8b 45 d0	 mov	 eax, DWORD PTR $T110314[ebp]
  01482	89 45 cc	 mov	 DWORD PTR $T110318[ebp], eax
  01485	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  01488	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0148b	8d 55 cc	 lea	 edx, DWORD PTR $T110318[ebp]
  0148e	52		 push	 edx
  0148f	51		 push	 ecx
  01490	50		 push	 eax
  01491	e8 00 00 00 00	 call	 ?_Insert@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEXViterator@12@ABQAVMusicItem@@@Z ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Insert

; 381  : 				ptcFDSM[i] = _fdsm;

  01496	89 7d 30	 mov	 DWORD PTR $T110319[ebp], edi
  01499	8d 75 30	 lea	 esi, DWORD PTR $T110319[ebp]
  0149c	8d bb 78 01 00
	00		 lea	 edi, DWORD PTR [ebx+376]
  014a2	e8 00 00 00 00	 call	 ??A?$map@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@@std@@QAEAAPAVFDSM@@ABH@Z ; std::map<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> > >::operator[]

; 382  : 				iSize += _fdsm->getSize();	//BGMTCYXV
; 383  : 				break;

  014a7	e9 63 03 00 00	 jmp	 $L111929
$L24504:

; 384  : 			case(id_VRC7):
; 385  : 				i = MML->GetNum();

  014ac	8b c6		 mov	 eax, esi
  014ae	e8 00 00 00 00	 call	 ?GetNum@MMLfile@@QAEHXZ	; MMLfile::GetNum
  014b3	8b f8		 mov	 edi, eax

; 386  : 
; 387  : 				//d`FbN
; 388  : 				if(ptcVRC7.count(i) != 0){

  014b5	8d 45 30	 lea	 eax, DWORD PTR $T110320[ebp]
  014b8	50		 push	 eax
  014b9	8d 83 84 01 00
	00		 lea	 eax, DWORD PTR [ebx+388]
  014bf	50		 push	 eax
  014c0	89 7d 30	 mov	 DWORD PTR $T110320[ebp], edi
  014c3	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::count
  014c8	85 c0		 test	 eax, eax
  014ca	0f 85 ab 03 00
	00		 jne	 $L111910

; 390  : 				}
; 391  : 				_vrc7 = new VRC7(MML, i);

  014d0	6a 40		 push	 64			; 00000040H
  014d2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  014d7	59		 pop	 ecx
  014d8	89 45 cc	 mov	 DWORD PTR $T110322[ebp], eax
  014db	85 c0		 test	 eax, eax
  014dd	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
  014e1	74 14		 je	 SHORT $L110323
  014e3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_19FLEMCNOH@?$AAV?$AAR?$AAC?$AA7?$AA?$AA@
  014e8	50		 push	 eax
  014e9	8b cf		 mov	 ecx, edi
  014eb	8b d6		 mov	 edx, esi
  014ed	e8 00 00 00 00	 call	 ??0VRC7@@QAE@PAVMMLfile@@IQBG@Z ; VRC7::VRC7
  014f2	89 45 d0	 mov	 DWORD PTR $T110321[ebp], eax
  014f5	eb 04		 jmp	 SHORT $L110324
$L110323:
  014f7	83 65 d0 00	 and	 DWORD PTR $T110321[ebp], 0
$L110324:
  014fb	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH

; 392  : 				ptcItem.push_back(_vrc7);

  014ff	8b 45 d0	 mov	 eax, DWORD PTR $T110321[ebp]
  01502	89 45 cc	 mov	 DWORD PTR $T110325[ebp], eax
  01505	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  01508	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0150b	8d 55 cc	 lea	 edx, DWORD PTR $T110325[ebp]
  0150e	52		 push	 edx
  0150f	51		 push	 ecx
  01510	50		 push	 eax
  01511	e8 00 00 00 00	 call	 ?_Insert@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEXViterator@12@ABQAVMusicItem@@@Z ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Insert

; 393  : 				ptcVRC7[i] = _vrc7;

  01516	89 7d 30	 mov	 DWORD PTR $T110326[ebp], edi
  01519	8d 75 30	 lea	 esi, DWORD PTR $T110326[ebp]
  0151c	8d bb 84 01 00
	00		 lea	 edi, DWORD PTR [ebx+388]
  01522	e8 00 00 00 00	 call	 ??A?$map@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@@std@@QAEAAPAVVRC7@@ABH@Z ; std::map<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> > >::operator[]

; 394  : 				iSize += _vrc7->getSize();	//BGMTCYXV
; 395  : 				break;

  01527	e9 e3 02 00 00	 jmp	 $L111929
$L24515:

; 396  : 			case(id_N163):
; 397  : 				i = MML->GetNum();

  0152c	8b c6		 mov	 eax, esi
  0152e	e8 00 00 00 00	 call	 ?GetNum@MMLfile@@QAEHXZ	; MMLfile::GetNum
  01533	8b f8		 mov	 edi, eax

; 398  : 
; 399  : 				//d`FbN
; 400  : 				if(ptcN163.count(i) != 0){

  01535	8d 45 30	 lea	 eax, DWORD PTR $T110327[ebp]
  01538	50		 push	 eax
  01539	8d 83 90 01 00
	00		 lea	 eax, DWORD PTR [ebx+400]
  0153f	50		 push	 eax
  01540	89 7d 30	 mov	 DWORD PTR $T110327[ebp], edi
  01543	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::count
  01548	85 c0		 test	 eax, eax
  0154a	0f 85 35 03 00
	00		 jne	 $L111911

; 402  : 				}
; 403  : 				_n163 = new N163(MML, i);

  01550	6a 40		 push	 64			; 00000040H
  01552	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01557	59		 pop	 ecx
  01558	89 45 cc	 mov	 DWORD PTR $T110329[ebp], eax
  0155b	85 c0		 test	 eax, eax
  0155d	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+8], 19 ; 00000013H
  01561	74 14		 je	 SHORT $L110330
  01563	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_19OFNMEAIG@?$AAN?$AA1?$AA6?$AA3?$AA?$AA@
  01568	50		 push	 eax
  01569	8b cf		 mov	 ecx, edi
  0156b	8b d6		 mov	 edx, esi
  0156d	e8 00 00 00 00	 call	 ??0N163@@QAE@PAVMMLfile@@IQBG@Z ; N163::N163
  01572	89 45 d0	 mov	 DWORD PTR $T110328[ebp], eax
  01575	eb 04		 jmp	 SHORT $L110331
$L110330:
  01577	83 65 d0 00	 and	 DWORD PTR $T110328[ebp], 0
$L110331:
  0157b	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH

; 404  : 				ptcItem.push_back(_n163);

  0157f	8b 45 d0	 mov	 eax, DWORD PTR $T110328[ebp]
  01582	89 45 cc	 mov	 DWORD PTR $T110332[ebp], eax
  01585	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  01588	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0158b	8d 55 cc	 lea	 edx, DWORD PTR $T110332[ebp]
  0158e	52		 push	 edx
  0158f	51		 push	 ecx
  01590	50		 push	 eax
  01591	e8 00 00 00 00	 call	 ?_Insert@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEXViterator@12@ABQAVMusicItem@@@Z ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Insert

; 405  : 				ptcN163[i] = _n163;

  01596	89 7d 30	 mov	 DWORD PTR $T110333[ebp], edi
  01599	8d 75 30	 lea	 esi, DWORD PTR $T110333[ebp]
  0159c	8d bb 90 01 00
	00		 lea	 edi, DWORD PTR [ebx+400]
  015a2	e8 00 00 00 00	 call	 ??A?$map@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@@std@@QAEAAPAVN163@@ABH@Z ; std::map<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> > >::operator[]

; 406  : 				iSize += _n163->getSize();	//BGMTCYXV
; 407  : 				break;

  015a7	e9 63 02 00 00	 jmp	 $L111929
$L24526:

; 408  : 			case(id_Envelop):
; 409  : 				i = MML->GetNum();

  015ac	8b c6		 mov	 eax, esi
  015ae	e8 00 00 00 00	 call	 ?GetNum@MMLfile@@QAEHXZ	; MMLfile::GetNum
  015b3	8b f8		 mov	 edi, eax

; 410  : 				//d`FbN
; 411  : 				if(ptcEnv.count(i) != 0){

  015b5	8d 45 30	 lea	 eax, DWORD PTR $T110334[ebp]
  015b8	50		 push	 eax
  015b9	8d 83 9c 01 00
	00		 lea	 eax, DWORD PTR [ebx+412]
  015bf	50		 push	 eax
  015c0	89 7d 30	 mov	 DWORD PTR $T110334[ebp], edi
  015c3	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::count
  015c8	85 c0		 test	 eax, eax
  015ca	0f 85 bf 02 00
	00		 jne	 $L111912

; 413  : 				}
; 414  : 				_env = new Envelop(MML, i);

  015d0	6a 50		 push	 80			; 00000050H
  015d2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  015d7	59		 pop	 ecx
  015d8	89 45 cc	 mov	 DWORD PTR $T110336[ebp], eax
  015db	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
$L111932:
  015df	85 c0		 test	 eax, eax
  015e1	74 58		 je	 SHORT $L110344
  015e3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BC@LIMGOFOL@?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@
  015e8	56		 push	 esi
  015e9	50		 push	 eax
  015ea	8b cf		 mov	 ecx, edi
  015ec	e8 00 00 00 00	 call	 ??0Envelop@@QAE@PAVMMLfile@@IQBG@Z ; Envelop::Envelop
  015f1	89 45 d0	 mov	 DWORD PTR $T110335[ebp], eax
  015f4	eb 49		 jmp	 SHORT $L110345
$L24537:

; 415  : 				ptcItem.push_back(_env);
; 416  : 				ptcEnv[i] = _env;
; 417  : 				iSize += _env->getSize();	//BGMTCYXV
; 418  : 				break;
; 419  : 			case(id_Vibrato):
; 420  : 				MML->offset_Em = 1000000;
; 421  : 				i = MML->GetNum() + MML->offset_Em;

  015f6	8b c6		 mov	 eax, esi
  015f8	c7 86 80 00 00
	00 40 42 0f 00	 mov	 DWORD PTR [esi+128], 1000000 ; 000f4240H
  01602	e8 00 00 00 00	 call	 ?GetNum@MMLfile@@QAEHXZ	; MMLfile::GetNum
  01607	8b f8		 mov	 edi, eax
  01609	03 be 80 00 00
	00		 add	 edi, DWORD PTR [esi+128]

; 422  : 				//d`FbN
; 423  : 				if(ptcEnv.count(i) != 0){

  0160f	8d 45 30	 lea	 eax, DWORD PTR $T110341[ebp]
  01612	50		 push	 eax
  01613	8d 83 9c 01 00
	00		 lea	 eax, DWORD PTR [ebx+412]
  01619	50		 push	 eax
  0161a	89 7d 30	 mov	 DWORD PTR $T110341[ebp], edi
  0161d	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::count
  01622	85 c0		 test	 eax, eax
  01624	0f 85 6f 02 00
	00		 jne	 $L111913

; 425  : 				}
; 426  : 				_env = new Envelop(MML, i);

  0162a	6a 50		 push	 80			; 00000050H
  0162c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01631	59		 pop	 ecx
  01632	89 45 cc	 mov	 DWORD PTR $T110343[ebp], eax
  01635	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+8], 21 ; 00000015H
  01639	eb a4		 jmp	 SHORT $L111932
$L110344:
  0163b	83 65 d0 00	 and	 DWORD PTR $T110342[ebp], 0
$L110345:
  0163f	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH

; 427  : 				ptcItem.push_back(_env);

  01643	8b 45 d0	 mov	 eax, DWORD PTR $T110342[ebp]
  01646	89 45 cc	 mov	 DWORD PTR $T110346[ebp], eax
  01649	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  0164c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0164f	8d 55 cc	 lea	 edx, DWORD PTR $T110346[ebp]
  01652	52		 push	 edx
  01653	51		 push	 ecx
  01654	50		 push	 eax
  01655	e8 00 00 00 00	 call	 ?_Insert@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEXViterator@12@ABQAVMusicItem@@@Z ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Insert

; 428  : 				ptcEnv[i] = _env;

  0165a	89 7d 30	 mov	 DWORD PTR $T110347[ebp], edi
  0165d	8d 75 30	 lea	 esi, DWORD PTR $T110347[ebp]
  01660	8d bb 9c 01 00
	00		 lea	 edi, DWORD PTR [ebx+412]
  01666	e8 00 00 00 00	 call	 ??A?$map@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@@std@@QAEAAPAVEnvelop@@ABH@Z ; std::map<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> > >::operator[]

; 429  : 				iSize += _env->getSize();	//BGMTCYXV
; 430  : 				break;

  0166b	e9 9f 01 00 00	 jmp	 $L111929
$L24547:

; 431  : 			case(id_Sub):
; 432  : 				i = MML->GetNum();

  01670	8b c6		 mov	 eax, esi
  01672	e8 00 00 00 00	 call	 ?GetNum@MMLfile@@QAEHXZ	; MMLfile::GetNum
  01677	8b f8		 mov	 edi, eax

; 433  : 				//d`FbN
; 434  : 				if(ptcSub.count(i) != 0){

  01679	8d 45 30	 lea	 eax, DWORD PTR $T110348[ebp]
  0167c	50		 push	 eax
  0167d	8d 83 c0 01 00
	00		 lea	 eax, DWORD PTR [ebx+448]
  01683	50		 push	 eax
  01684	89 7d 30	 mov	 DWORD PTR $T110348[ebp], edi
  01687	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::count
  0168c	85 c0		 test	 eax, eax
  0168e	0f 85 0f 02 00
	00		 jne	 $L111914

; 436  : 				}
; 437  : 				//`FbN
; 438  : 				_sub = new Sub(MML, i);

  01694	6a 6c		 push	 108			; 0000006cH
  01696	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0169b	59		 pop	 ecx
  0169c	89 45 cc	 mov	 DWORD PTR $T110350[ebp], eax
  0169f	85 c0		 test	 eax, eax
  016a1	c6 45 fc 16	 mov	 BYTE PTR __$EHRec$[ebp+8], 22 ; 00000016H
  016a5	74 16		 je	 SHORT $L110351
  016a7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_17ILLEHHEJ@?$AAS?$AAu?$AAb?$AA?$AA@
  016ac	ff 75 0c	 push	 DWORD PTR _MML$[ebp]
  016af	8b cf		 mov	 ecx, edi
  016b1	8b f0		 mov	 esi, eax
  016b3	e8 00 00 00 00	 call	 ??0Sub@@QAE@PAVMMLfile@@IQAG@Z ; Sub::Sub
  016b8	89 45 d0	 mov	 DWORD PTR $T110349[ebp], eax
  016bb	eb 04		 jmp	 SHORT $L110352
$L110351:
  016bd	83 65 d0 00	 and	 DWORD PTR $T110349[ebp], 0
$L110352:
  016c1	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH

; 439  : 				ptcItem.push_back(_sub);

  016c5	8b 45 d0	 mov	 eax, DWORD PTR $T110349[ebp]
  016c8	89 45 cc	 mov	 DWORD PTR $T110353[ebp], eax
  016cb	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  016ce	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  016d1	8d 55 cc	 lea	 edx, DWORD PTR $T110353[ebp]
  016d4	52		 push	 edx
  016d5	51		 push	 ecx
  016d6	50		 push	 eax
  016d7	e8 00 00 00 00	 call	 ?_Insert@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEXViterator@12@ABQAVMusicItem@@@Z ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Insert

; 440  : 				ptcSub[i] = _sub;

  016dc	89 7d 30	 mov	 DWORD PTR $T110354[ebp], edi
  016df	8d 75 30	 lea	 esi, DWORD PTR $T110354[ebp]
  016e2	8d bb c0 01 00
	00		 lea	 edi, DWORD PTR [ebx+448]
  016e8	e8 00 00 00 00	 call	 ??A?$map@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@@std@@QAEAAPAVSub@@ABH@Z ; std::map<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> > >::operator[]

; 441  : 				iSize += _sub->getSize();	//BGMTCYXV
; 442  : 				break;

  016ed	e9 1d 01 00 00	 jmp	 $L111929
$L24558:

; 443  : 			case(id_BGM):
; 444  : 				i = MML->GetNum();

  016f2	8b c6		 mov	 eax, esi
  016f4	e8 00 00 00 00	 call	 ?GetNum@MMLfile@@QAEHXZ	; MMLfile::GetNum
  016f9	8b f8		 mov	 edi, eax

; 445  : 				//d`FbN
; 446  : 				if(ptcBGM.count(i) != 0){

  016fb	8d 45 30	 lea	 eax, DWORD PTR $T110355[ebp]
  016fe	50		 push	 eax
  016ff	8d 83 a8 01 00
	00		 lea	 eax, DWORD PTR [ebx+424]
  01705	50		 push	 eax
  01706	89 7d 30	 mov	 DWORD PTR $T110355[ebp], edi
  01709	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::count
  0170e	85 c0		 test	 eax, eax
  01710	0f 85 97 01 00
	00		 jne	 $L111915

; 448  : 				}
; 449  : 				//`FbN
; 450  : 				if((Header.iBGM <= i) || (i<0)){

  01716	0f b6 83 9e 00
	00 00		 movzx	 eax, BYTE PTR [ebx+158]
  0171d	3b c7		 cmp	 eax, edi
  0171f	0f 86 92 01 00
	00		 jbe	 $L111916

; 452  : 				}
; 453  : 				_bgm = new BGM(MML, i);

  01725	6a 6c		 push	 108			; 0000006cH
  01727	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0172c	59		 pop	 ecx
  0172d	89 45 cc	 mov	 DWORD PTR $T110357[ebp], eax
  01730	85 c0		 test	 eax, eax
  01732	c6 45 fc 17	 mov	 BYTE PTR __$EHRec$[ebp+8], 23 ; 00000017H
  01736	74 16		 je	 SHORT $L110358
  01738	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_17IKEGFPDC@?$AAB?$AAG?$AAM?$AA?$AA@
  0173d	ff 75 0c	 push	 DWORD PTR _MML$[ebp]
  01740	8b cf		 mov	 ecx, edi
  01742	8b f0		 mov	 esi, eax
  01744	e8 00 00 00 00	 call	 ??0BGM@@QAE@PAVMMLfile@@IQBG@Z ; BGM::BGM
  01749	89 45 d0	 mov	 DWORD PTR $T110356[ebp], eax
  0174c	eb 04		 jmp	 SHORT $L110359
$L110358:
  0174e	83 65 d0 00	 and	 DWORD PTR $T110356[ebp], 0
$L110359:
  01752	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH

; 454  : 				ptcItem.push_back(_bgm);

  01756	8b 45 d0	 mov	 eax, DWORD PTR $T110356[ebp]
  01759	89 45 cc	 mov	 DWORD PTR $T110360[ebp], eax
  0175c	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  0175f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01762	8d 55 cc	 lea	 edx, DWORD PTR $T110360[ebp]
  01765	52		 push	 edx
  01766	51		 push	 ecx
  01767	50		 push	 eax
  01768	e8 00 00 00 00	 call	 ?_Insert@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEXViterator@12@ABQAVMusicItem@@@Z ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Insert

; 455  : 				ptcBGM[i] = _bgm;

  0176d	89 7d 30	 mov	 DWORD PTR $T110361[ebp], edi
  01770	8d 75 30	 lea	 esi, DWORD PTR $T110361[ebp]
  01773	8d bb a8 01 00
	00		 lea	 edi, DWORD PTR [ebx+424]
  01779	e8 00 00 00 00	 call	 ??A?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAEAAPAVBGM@@ABH@Z ; std::map<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> > >::operator[]

; 456  : 				iSize += _bgm->getSize();	//BGMTCYXV
; 457  : 				break;

  0177e	e9 8c 00 00 00	 jmp	 $L111929
$L24572:

; 458  : 			case(id_SE):
; 459  : 				i = MML->GetNum();

  01783	8b c6		 mov	 eax, esi
  01785	e8 00 00 00 00	 call	 ?GetNum@MMLfile@@QAEHXZ	; MMLfile::GetNum
  0178a	8b f8		 mov	 edi, eax

; 460  : 				//d`FbN
; 461  : 				if(ptcSE.count(i) != 0){

  0178c	8d 45 30	 lea	 eax, DWORD PTR $T110362[ebp]
  0178f	50		 push	 eax
  01790	8d 83 b4 01 00
	00		 lea	 eax, DWORD PTR [ebx+436]
  01796	50		 push	 eax
  01797	89 7d 30	 mov	 DWORD PTR $T110362[ebp], edi
  0179a	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::count
  0179f	85 c0		 test	 eax, eax
  017a1	0f 85 1a 01 00
	00		 jne	 $L111917

; 463  : 				}
; 464  : 				//`FbN
; 465  : 				if((Header.iSE <= i) || (i<0)){

  017a7	0f b6 83 9f 00
	00 00		 movzx	 eax, BYTE PTR [ebx+159]
  017ae	3b c7		 cmp	 eax, edi
  017b0	0f 86 15 01 00
	00		 jbe	 $L111918

; 467  : 				}
; 468  : 				_se = new SE(MML, i);

  017b6	6a 6c		 push	 108			; 0000006cH
  017b8	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  017bd	59		 pop	 ecx
  017be	89 45 cc	 mov	 DWORD PTR $T110364[ebp], eax
  017c1	85 c0		 test	 eax, eax
  017c3	c6 45 fc 18	 mov	 BYTE PTR __$EHRec$[ebp+8], 24 ; 00000018H
  017c7	74 16		 je	 SHORT $L110365
  017c9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_15GIONIMAK@?$AAS?$AAE?$AA?$AA@
  017ce	ff 75 0c	 push	 DWORD PTR _MML$[ebp]
  017d1	8b cf		 mov	 ecx, edi
  017d3	8b f0		 mov	 esi, eax
  017d5	e8 00 00 00 00	 call	 ??0SE@@QAE@PAVMMLfile@@IQAG@Z ; SE::SE
  017da	89 45 d0	 mov	 DWORD PTR $T110363[ebp], eax
  017dd	eb 04		 jmp	 SHORT $L110366
$L110365:
  017df	83 65 d0 00	 and	 DWORD PTR $T110363[ebp], 0
$L110366:
  017e3	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH

; 469  : 				ptcItem.push_back(_se);

  017e7	8b 45 d0	 mov	 eax, DWORD PTR $T110363[ebp]
  017ea	89 45 cc	 mov	 DWORD PTR $T110367[ebp], eax
  017ed	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  017f0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  017f3	8d 55 cc	 lea	 edx, DWORD PTR $T110367[ebp]
  017f6	52		 push	 edx
  017f7	51		 push	 ecx
  017f8	50		 push	 eax
  017f9	e8 00 00 00 00	 call	 ?_Insert@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEXViterator@12@ABQAVMusicItem@@@Z ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Insert

; 470  : 				ptcSE[i] = _se;

  017fe	89 7d 30	 mov	 DWORD PTR $T110368[ebp], edi
  01801	8d 75 30	 lea	 esi, DWORD PTR $T110368[ebp]
  01804	8d bb b4 01 00
	00		 lea	 edi, DWORD PTR [ebx+436]
  0180a	e8 00 00 00 00	 call	 ??A?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAEAAPAVSE@@ABH@Z ; std::map<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> > >::operator[]
$L111929:
  0180f	8b 4d d0	 mov	 ecx, DWORD PTR $T110363[ebp]
  01812	89 08		 mov	 DWORD PTR [eax], ecx

; 471  : 				iSize += _se->getSize();	//BGMTCYXV

  01814	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  01817	01 43 30	 add	 DWORD PTR [ebx+48], eax
$L111928:
  0181a	8b 75 0c	 mov	 esi, DWORD PTR _MML$[ebp]
$L24416:

; 477  : 				break;
; 478  : 		}
; 479  : 		
; 480  : 	} while( !MML->eom() );

  0181d	8b c6		 mov	 eax, esi
  0181f	e8 00 00 00 00	 call	 ?eom@MMLfile@@QAE_NXZ	; MMLfile::eom
  01824	84 c0		 test	 al, al
  01826	0f 84 80 f8 ff
	ff		 je	 $L24415
$L24417:

; 481  : 
; 482  : 	//Check
; 483  : 	if( Header.iBGM + Header.iSE > 255){

  0182c	0f b6 b3 9f 00
	00 00		 movzx	 esi, BYTE PTR [ebx+159]
  01833	0f b6 83 9e 00
	00 00		 movzx	 eax, BYTE PTR [ebx+158]
  0183a	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0183d	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  01843	0f 8e 8c 00 00
	00		 jle	 $L24589

; 484  : 		Err(_T("BGMSEv255zB"));

  01849	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CO@LFJBLHAK@?$AAB?$AAG?$AAM0h?$AAS?$AAE0nep0LT?$AI?$IK?$AI0g?$AA2?$AA5?$AA50?$JC?$IN?$IK0H0?$HO0W@
  0184e	e9 13 01 00 00	 jmp	 $L111931
$L111904:

; 325  : 					MML->Err(_T("#priorityR}hA0`3wB"));

  01853	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1EA@EIGBEKHF@?$AA?$CD?$AAp?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy0?$LD0?$NO0?s0?I0o0?$AB?$AA0?$PP?$FO?$AA30n?$HL?D@
  01858	e9 13 01 00 00	 jmp	 $L111930
$L111907:

; 354  : 					MML->Err(_T("DPCMubNPB"));

  0185d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CC@JGHEFCII@?$AAD?$AAP?$AAC?$AAM0?V0?m0?C0?$KP0o?$PP?$BB0d0?$HO0g0g0Y0?$AC?$AA?$AA@
  01862	e9 09 01 00 00	 jmp	 $L111930
$L111908:

; 365  : 					MML->Err(_T("FDSC()ubNwB"));

  01867	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DC@HNHPBHDM@?$AAF?$AAD?$AAS?$AAC?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM@
  0186c	e9 ff 00 00 00	 jmp	 $L111930
$L111909:

; 377  : 					MML->Err(_T("FDSM()ubNwB"));

  01871	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DC@LLPEDCB@?$AAF?$AAD?$AAS?$AAM?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM@
  01876	e9 f5 00 00 00	 jmp	 $L111930
$L111910:

; 389  : 					MML->Err(_T("VRC7()ubNwB"));

  0187b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DC@IKBGODDN@?$AAV?$AAR?$AAC?$AA7?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM@
  01880	e9 eb 00 00 00	 jmp	 $L111930
$L111911:

; 401  : 					MML->Err(_T("N163()ubNwB"));

  01885	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DC@BMHBEBNP@?$AAN?$AA1?$AA6?$AA3?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM@
  0188a	e9 e1 00 00 00	 jmp	 $L111930
$L111912:

; 412  : 					MML->Err(_T("Envelope()ubNwB"));

  0188f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DK@BHJCAEG@?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0L@
  01894	e9 d7 00 00 00	 jmp	 $L111930
$L111913:

; 424  : 					MML->Err(_T("ru[g()ubNwB"));

  01899	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DE@FKOKODHI@0?S0?V0?i0?$PM0?H?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U@
  0189e	e9 cd 00 00 00	 jmp	 $L111930
$L111914:

; 435  : 					MML->Err(_T("Sub()ubNwB"));

  018a3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DA@BGBJDANG@?$AAS?$AAu?$AAb?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM0?$HO@
  018a8	e9 c3 00 00 00	 jmp	 $L111930
$L111915:

; 447  : 					MML->Err(_T("BGM()ubNwB"));

  018ad	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DA@MIOILPIL@?$AAB?$AAG?$AAM?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM0?$HO@
  018b2	e9 b9 00 00 00	 jmp	 $L111930
$L111916:

; 451  : 					MML->Err(_T("BGM()ubNwB\n#BGMlmFB"));

  018b7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1FI@OKDKOODI@?$AAB?$AAG?$AAM?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gc?$AH?$FL?$JK0g0M0?$IL?$HL?DV?r0?$JC?$IN?$IF0H@
  018bc	e9 af 00 00 00	 jmp	 $L111930
$L111917:

; 462  : 					MML->Err(_T("SE()ubNwB"));

  018c1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CO@BBMENDGM@?$AAS?$AAE?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gT?$AM0XujS?w0Lc?$AH?$FL?$JK0U0?$IM0?$HO0W@
  018c6	e9 a5 00 00 00	 jmp	 $L111930
$L111918:

; 466  : 					MML->Err(_T("SE()ubNwB\n#SElmFB"));

  018cb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1FE@JACJBOFE@?$AAS?$AAE?$AA?$CI?$AA?$CJ0?V0?m0?C0?$KP0gc?$AH?$FL?$JK0g0M0?$IL?$HL?DV?r0?$JC?$IN?$IF0H0f@
  018d0	e9 9b 00 00 00	 jmp	 $L111930
$L24589:

; 485  : 	}
; 486  : 
; 487  : 	i = 0;

  018d5	33 ff		 xor	 edi, edi

; 488  : 	while(i < Header.iBGM){

  018d7	85 c0		 test	 eax, eax
  018d9	76 23		 jbe	 SHORT $L24593
$L24592:

; 489  : 		if(ptcBGM.count(i) == 0){

  018db	8d 45 0c	 lea	 eax, DWORD PTR $T110369[ebp]
  018de	50		 push	 eax
  018df	8d 83 a8 01 00
	00		 lea	 eax, DWORD PTR [ebx+424]
  018e5	50		 push	 eax
  018e6	89 7d 0c	 mov	 DWORD PTR $T110369[ebp], edi
  018e9	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,BGM *,std::less<int>,std::allocator<std::pair<int const ,BGM *> >,0> >::count
  018ee	85 c0		 test	 eax, eax
  018f0	74 68		 je	 SHORT $L111919
  018f2	0f b6 83 9e 00
	00 00		 movzx	 eax, BYTE PTR [ebx+158]

; 491  : 		};
; 492  : 		i++;

  018f9	47		 inc	 edi
  018fa	3b f8		 cmp	 edi, eax
  018fc	72 dd		 jb	 SHORT $L24592
$L24593:

; 493  : 	}
; 494  : 
; 495  : 	i = 0;

  018fe	33 ff		 xor	 edi, edi

; 496  : 	while(i < Header.iSE){

  01900	85 f6		 test	 esi, esi
  01902	76 23		 jbe	 SHORT $L24599
$L24598:

; 497  : 		if(ptcSE.count(i) == 0){

  01904	8d 45 0c	 lea	 eax, DWORD PTR $T110370[ebp]
  01907	50		 push	 eax
  01908	8d 83 b4 01 00
	00		 lea	 eax, DWORD PTR [ebx+436]
  0190e	50		 push	 eax
  0190f	89 7d 0c	 mov	 DWORD PTR $T110370[ebp], edi
  01912	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::count
  01917	85 c0		 test	 eax, eax
  01919	74 46		 je	 SHORT $L111920
  0191b	0f b6 83 9f 00
	00 00		 movzx	 eax, BYTE PTR [ebx+159]

; 499  : 		};
; 500  : 		i++;

  01922	47		 inc	 edi
  01923	3b f8		 cmp	 edi, eax
  01925	72 dd		 jb	 SHORT $L24598
$L24599:

; 501  : 	}
; 502  : 
; 503  : }

  01927	6a 00		 push	 0
  01929	6a 01		 push	 1
  0192b	8d 4d d4	 lea	 ecx, DWORD PTR _msg$[ebp]
  0192e	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  01933	6a 00		 push	 0
  01935	6a 01		 push	 1
  01937	8d 4d 10	 lea	 ecx, DWORD PTR __code$[ebp]
  0193a	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  0193f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01942	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01949	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0194c	8b c3		 mov	 eax, ebx
  0194e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01953	5f		 pop	 edi
  01954	5e		 pop	 esi
  01955	5b		 pop	 ebx
  01956	c9		 leave
  01957	c2 2c 00	 ret	 44			; 0000002cH
$L111919:

; 490  : 			Err(_T("BGMf[^B"));

  0195a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BM@PLCKFEBA@?$AAB?$AAG?$AAM0?G0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
  0195f	eb 05		 jmp	 SHORT $L111931
$L111920:

; 498  : 			Err(_T("SE f[^B"));

  01961	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BM@BGKOPALL@?$AAS?$AAE?$AA?50?G0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
$L111931:
  01966	e8 00 00 00 00	 call	 ?Err@MusicFile@@QAEXQBG@Z ; MusicFile::Err
$L111935:
$L24587:

; 472  : 				break;
; 473  : 			case(id_Null):
; 474  : 				break;
; 475  : 			default:
; 476  : 				MML->Err(_T("unknown command"));

  0196b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CA@BFMKMMBP@?$AAu?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAc?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?$AA@
$L111930:
  01970	8b c6		 mov	 eax, esi
  01972	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L111936:
$L111927:
$L111933:

; 501  : 	}
; 502  : 
; 503  : }

  01977	00 00 00 00	 DD	 $L24425
  0197b	00 00 00 00	 DD	 $L24426
  0197f	00 00 00 00	 DD	 $L24427
  01983	00 00 00 00	 DD	 $L24428
  01987	00 00 00 00	 DD	 $L24424
  0198b	00 00 00 00	 DD	 $L24429
  0198f	00 00 00 00	 DD	 $L24430
  01993	00 00 00 00	 DD	 $L24431
  01997	00 00 00 00	 DD	 $L24432
  0199b	00 00 00 00	 DD	 $L24433
  0199f	00 00 00 00	 DD	 $L24456
  019a3	00 00 00 00	 DD	 $L24434
  019a7	00 00 00 00	 DD	 $L24437
  019ab	00 00 00 00	 DD	 $L24438
  019af	00 00 00 00	 DD	 $L24439
  019b3	00 00 00 00	 DD	 $L24435
  019b7	00 00 00 00	 DD	 $L24436
  019bb	00 00 00 00	 DD	 $L24440
  019bf	00 00 00 00	 DD	 $L24444
  019c3	00 00 00 00	 DD	 $L24448
  019c7	00 00 00 00	 DD	 $L24452
  019cb	00 00 00 00	 DD	 $L24453
  019cf	00 00 00 00	 DD	 $L24454
  019d3	00 00 00 00	 DD	 $L24455
  019d7	00 00 00 00	 DD	 $L24462
  019db	00 00 00 00	 DD	 $L24463
  019df	00 00 00 00	 DD	 $L24467
  019e3	00 00 00 00	 DD	 $L24473
  019e7	00 00 00 00	 DD	 $L24482
  019eb	00 00 00 00	 DD	 $L24493
  019ef	00 00 00 00	 DD	 $L24504
  019f3	00 00 00 00	 DD	 $L24515
  019f7	00 00 00 00	 DD	 $L24526
  019fb	00 00 00 00	 DD	 $L24537
  019ff	00 00 00 00	 DD	 $L24471
  01a03	00 00 00 00	 DD	 $L24547
  01a07	00 00 00 00	 DD	 $L24558
  01a0b	00 00 00 00	 DD	 $L24572
  01a0f	00 00 00 00	 DD	 $L24472
  01a13	00 00 00 00	 DD	 $L24416
$L110371:
  00dea	8d 4d 10	 lea	 ecx, DWORD PTR __code$[ebp]
  00ded	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L110373:
  00df2	8b 45 c8	 mov	 eax, DWORD PTR $T110372[ebp]
  00df5	83 e0 01	 and	 eax, 1
  00df8	0f 84 12 00 00
	00		 je	 $L110374
  00dfe	83 65 c8 fe	 and	 DWORD PTR $T110372[ebp], -2 ; fffffffeH
  00e02	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00e05	81 c1 f0 01 00
	00		 add	 ecx, 496		; 000001f0H
  00e0b	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$L110374:
  00e10	c3		 ret	 0
$L110375:
  00e11	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00e14	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  00e1a	e9 00 00 00 00	 jmp	 ??1FileOutput@@UAE@XZ	; FileOutput::~FileOutput
$L110376:
  00e1f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00e22	e9 00 00 00 00	 jmp	 ??1MusicItem@@QAE@XZ	; MusicItem::~MusicItem
$L110378:
  00e27	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00e2a	81 c6 9c 00 00
	00		 add	 esi, 156		; 0000009cH
  00e30	e9 00 00 00 00	 jmp	 ??1MusicHeader@@QAE@XZ	; MusicHeader::~MusicHeader
$L110379:
  00e35	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00e38	81 c6 6c 01 00
	00		 add	 esi, 364		; 0000016cH
  00e3e	e9 00 00 00 00	 jmp	 ??1?$map@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@@std@@QAE@XZ
$L110380:
  00e43	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00e46	81 c6 78 01 00
	00		 add	 esi, 376		; 00000178H
  00e4c	e9 00 00 00 00	 jmp	 ??1?$map@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@@std@@QAE@XZ
$L110381:
  00e51	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00e54	81 c6 84 01 00
	00		 add	 esi, 388		; 00000184H
  00e5a	e9 00 00 00 00	 jmp	 ??1?$map@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@@std@@QAE@XZ
$L110382:
  00e5f	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00e62	81 c6 90 01 00
	00		 add	 esi, 400		; 00000190H
  00e68	e9 00 00 00 00	 jmp	 ??1?$map@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@@std@@QAE@XZ
$L110383:
  00e6d	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00e70	81 c6 9c 01 00
	00		 add	 esi, 412		; 0000019cH
  00e76	e9 00 00 00 00	 jmp	 ??1?$map@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@@std@@QAE@XZ
$L110384:
  00e7b	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00e7e	81 c6 a8 01 00
	00		 add	 esi, 424		; 000001a8H
  00e84	e9 00 00 00 00	 jmp	 ??1?$map@HPAVBGM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVBGM@@@std@@@3@@std@@QAE@XZ
$L110385:
  00e89	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00e8c	81 c6 b4 01 00
	00		 add	 esi, 436		; 000001b4H
  00e92	e9 00 00 00 00	 jmp	 ??1?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAE@XZ
$L110386:
  00e97	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00e9a	81 c6 c0 01 00
	00		 add	 esi, 448		; 000001c0H
  00ea0	e9 00 00 00 00	 jmp	 ??1?$map@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@@std@@QAE@XZ
$L110387:
  00ea5	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00ea8	81 c1 d0 01 00
	00		 add	 ecx, 464		; 000001d0H
  00eae	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L110388:
  00eb3	8d 4d d4	 lea	 ecx, DWORD PTR _msg$[ebp]
  00eb6	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L110389:
  00ebb	ff 75 cc	 push	 DWORD PTR $T110302[ebp]
  00ebe	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00ec3	59		 pop	 ecx
  00ec4	c3		 ret	 0
$L110390:
  00ec5	ff 75 cc	 push	 DWORD PTR $T110308[ebp]
  00ec8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00ecd	59		 pop	 ecx
  00ece	c3		 ret	 0
$L110391:
  00ecf	ff 75 cc	 push	 DWORD PTR $T110315[ebp]
  00ed2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00ed7	59		 pop	 ecx
  00ed8	c3		 ret	 0
$L110392:
  00ed9	ff 75 cc	 push	 DWORD PTR $T110322[ebp]
  00edc	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00ee1	59		 pop	 ecx
  00ee2	c3		 ret	 0
$L110393:
  00ee3	ff 75 cc	 push	 DWORD PTR $T110329[ebp]
  00ee6	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00eeb	59		 pop	 ecx
  00eec	c3		 ret	 0
$L110394:
  00eed	ff 75 cc	 push	 DWORD PTR $T110336[ebp]
  00ef0	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00ef5	59		 pop	 ecx
  00ef6	c3		 ret	 0
$L110395:
  00ef7	ff 75 cc	 push	 DWORD PTR $T110343[ebp]
  00efa	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00eff	59		 pop	 ecx
  00f00	c3		 ret	 0
$L110396:
  00f01	ff 75 cc	 push	 DWORD PTR $T110350[ebp]
  00f04	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00f09	59		 pop	 ecx
  00f0a	c3		 ret	 0
$L110397:
  00f0b	ff 75 cc	 push	 DWORD PTR $T110357[ebp]
  00f0e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00f13	59		 pop	 ecx
  00f14	c3		 ret	 0
$L110398:
  00f15	ff 75 cc	 push	 DWORD PTR $T110364[ebp]
  00f18	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00f1d	59		 pop	 ecx
  00f1e	c3		 ret	 0
__ehhandler$??0MusicFile@@QAE@PAVMMLfile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBG@Z:
  00f1f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T111896
  00f24	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
??0MusicFile@@QAE@PAVMMLfile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBG@Z ENDP ; MusicFile::MusicFile
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocnum
;	COMDAT _$E3
text$yc	SEGMENT
_$E3	PROC NEAR					; COMDAT

; 806  : 		{	// initialize from _Locinfo object

  00000	83 25 00 00 00
	00 00		 and	 DWORD PTR ?id@?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@2V0locale@2@A, 0 ; std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short> > >::id
  00007	c3		 ret	 0
_$E3	ENDP
END
