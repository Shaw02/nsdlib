PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
EXTRN	?wcerr@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A:BYTE ; std::wcerr
EXTRN	_getenv:NEAR
EXTRN	_sscanf:NEAR
; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\Option.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
;	COMDAT ??_C@_15JGEKKPOB@?$AA?9?$AAo?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04CLONAGJF@?9D?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_15OBHJIHNO@?$AA?9?$AAD?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GKHLBAIJ@?4bin?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DE@EPPPAIBF@?$AA?9?$AAl?$AA?5?$AAC?$AAo?$AAd?$AAe?$AA?50?U0?$KB0?$KE0?k0L?$AA2V?$NON?eN?6c?$AH?$FL?$JK0U@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CG@DFOJALGM@?$AA?1?$AAF?$AA?50?U0?$KB0?$KE0?kT?$AN0Lf?x0D0f0B0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DGHPGHDC@?4s?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DE@PJEMIKMA@?$AA?9?$AAf?$AAa?$AA?5?$AAA?$AAS?$AAM?$AA?50?U0?$KB0?$KE0?k0L?$AA2V?$NON?eN?6c?$AH?$FL?$JK0U@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04PJMFADJP@?4nsf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DE@HDIADBHN@?$AA?9?$AAf?$AAn?$AA?5?$AAN?$AAS?$AAF?$AA?50?U0?$KB0?$KE0?k0L?$AA2V?$NON?eN?6c?$AH?$FL?$JK0U@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_15OLECOAGL@?$AA?9?$AAf?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04HCHMKIB@?4mml?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CK@HMJGEGAD@?$AAM?$AAM?$AAL0?U0?$KB0?$KE0?k0L?$AA2V?$NON?eN?6c?$AH?$FL?$JK0U0?$IM0?$HO0W0_0?$AC@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04HBHDLLBA@PATH?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@ECJCKIFH@DMC_INCLUDE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1FGA@BOEDPMCK@?$AAM?$AAM?$AAL?$AA?5?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAr?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAN?$AAE?$AAS@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BK@PLCOPKCK@0?$KK0?W0?$LH0?g0?s0LN?$ANkc0g0Y0?$AC?$PP?$BK?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E1
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_15JGEKKPOB@?$AA?9?$AAo?$AA?$AA@		; `string'
PUBLIC	??_C@_04CLONAGJF@?9D?$CFd?$AA@			; `string'
PUBLIC	??_C@_15OBHJIHNO@?$AA?9?$AAD?$AA?$AA@		; `string'
PUBLIC	??_C@_04GKHLBAIJ@?4bin?$AA@			; `string'
PUBLIC	??_C@_1DE@EPPPAIBF@?$AA?9?$AAl?$AA?5?$AAC?$AAo?$AAd?$AAe?$AA?50?U0?$KB0?$KE0?k0L?$AA2V?$NON?eN?6c?$AH?$FL?$JK0U@ ; `string'
PUBLIC	??_C@_1CG@DFOJALGM@?$AA?1?$AAF?$AA?50?U0?$KB0?$KE0?kT?$AN0Lf?x0D0f0B0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@ ; `string'
PUBLIC	??_C@_02DGHPGHDC@?4s?$AA@			; `string'
PUBLIC	??_C@_1DE@PJEMIKMA@?$AA?9?$AAf?$AAa?$AA?5?$AAA?$AAS?$AAM?$AA?50?U0?$KB0?$KE0?k0L?$AA2V?$NON?eN?6c?$AH?$FL?$JK0U@ ; `string'
PUBLIC	??_C@_04PJMFADJP@?4nsf?$AA@			; `string'
PUBLIC	??_C@_1DE@HDIADBHN@?$AA?9?$AAf?$AAn?$AA?5?$AAN?$AAS?$AAF?$AA?50?U0?$KB0?$KE0?k0L?$AA2V?$NON?eN?6c?$AH?$FL?$JK0U@ ; `string'
PUBLIC	??_C@_15OLECOAGL@?$AA?9?$AAf?$AA?$AA@		; `string'
PUBLIC	??_C@_11LOCGONAA@?$AA?$AA@			; `string'
PUBLIC	??_C@_04HCHMKIB@?4mml?$AA@			; `string'
PUBLIC	??_C@_1CK@HMJGEGAD@?$AAM?$AAM?$AAL0?U0?$KB0?$KE0?k0L?$AA2V?$NON?eN?6c?$AH?$FL?$JK0U0?$IM0?$HO0W0_0?$AC@ ; `string'
PUBLIC	??_C@_04HBHDLLBA@PATH?$AA@			; `string'
PUBLIC	??_C@_0M@ECJCKIFH@DMC_INCLUDE?$AA@		; `string'
PUBLIC	??_C@_1FGA@BOEDPMCK@?$AAM?$AAM?$AAL?$AA?5?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAr?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAN?$AAE?$AAS@ ; `string'
PUBLIC	??_C@_1BK@PLCOPKCK@0?$KK0?W0?$LH0?g0?s0LN?$ANkc0g0Y0?$AC?$PP?$BK?$AA?$AA@ ; `string'
;	COMDAT ??_C@_15JGEKKPOB@?$AA?9?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_15JGEKKPOB@?$AA?9?$AAo?$AA?$AA@ DB '-', 00H, 'o', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04CLONAGJF@?9D?$CFd?$AA@
CONST	SEGMENT
??_C@_04CLONAGJF@?9D?$CFd?$AA@ DB '-D%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_15OBHJIHNO@?$AA?9?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_15OBHJIHNO@?$AA?9?$AAD?$AA?$AA@ DB '-', 00H, 'D', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04GKHLBAIJ@?4bin?$AA@
CONST	SEGMENT
??_C@_04GKHLBAIJ@?4bin?$AA@ DB '.bin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@EPPPAIBF@?$AA?9?$AAl?$AA?5?$AAC?$AAo?$AAd?$AAe?$AA?50?U0?$KB0?$KE0?k0L?$AA2V?$NON?eN?6c?$AH?$FL?$JK0U@
CONST	SEGMENT
??_C@_1DE@EPPPAIBF@?$AA?9?$AAl?$AA?5?$AAC?$AAo?$AAd?$AAe?$AA?50?U0?$KB0?$KE0?k0L?$AA2V?$NON?eN?6c?$AH?$FL?$JK0U@ DB '-'
	DB	00H, 'l', 00H, ' ', 00H, 'C', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	' ', 00H, 0d5H, '0', 0a1H, '0', 0a4H, '0', 0ebH, '0L02', 00H, 0deH
	DB	'V', 0e5H, 'N', 0aH, 'N', 07H, 'c', 09aH, '[U0', 08cH, '0~0W0_'
	DB	'0', 02H, '0', 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@DFOJALGM@?$AA?1?$AAF?$AA?50?U0?$KB0?$KE0?kT?$AN0Lf?x0D0f0B0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@DFOJALGM@?$AA?1?$AAF?$AA?50?U0?$KB0?$KE0?kT?$AN0Lf?x0D0f0B0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@ DB '/'
	DB	00H, 'F', 00H, ' ', 00H, 0d5H, '0', 0a1H, '0', 0a4H, '0', 0ebH
	DB	'0', 0dH, 'TL0', 0f8H, 'fD0f0B0', 08aH, '0~0[0', 093H, '0', 02H
	DB	'0', 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DGHPGHDC@?4s?$AA@
CONST	SEGMENT
??_C@_02DGHPGHDC@?4s?$AA@ DB '.s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@PJEMIKMA@?$AA?9?$AAf?$AAa?$AA?5?$AAA?$AAS?$AAM?$AA?50?U0?$KB0?$KE0?k0L?$AA2V?$NON?eN?6c?$AH?$FL?$JK0U@
CONST	SEGMENT
??_C@_1DE@PJEMIKMA@?$AA?9?$AAf?$AAa?$AA?5?$AAA?$AAS?$AAM?$AA?50?U0?$KB0?$KE0?k0L?$AA2V?$NON?eN?6c?$AH?$FL?$JK0U@ DB '-'
	DB	00H, 'f', 00H, 'a', 00H, ' ', 00H, 'A', 00H, 'S', 00H, 'M', 00H
	DB	' ', 00H, 0d5H, '0', 0a1H, '0', 0a4H, '0', 0ebH, '0L02', 00H, 0deH
	DB	'V', 0e5H, 'N', 0aH, 'N', 07H, 'c', 09aH, '[U0', 08cH, '0~0W0_'
	DB	'0', 02H, '0', 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PJMFADJP@?4nsf?$AA@
CONST	SEGMENT
??_C@_04PJMFADJP@?4nsf?$AA@ DB '.nsf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@HDIADBHN@?$AA?9?$AAf?$AAn?$AA?5?$AAN?$AAS?$AAF?$AA?50?U0?$KB0?$KE0?k0L?$AA2V?$NON?eN?6c?$AH?$FL?$JK0U@
CONST	SEGMENT
??_C@_1DE@HDIADBHN@?$AA?9?$AAf?$AAn?$AA?5?$AAN?$AAS?$AAF?$AA?50?U0?$KB0?$KE0?k0L?$AA2V?$NON?eN?6c?$AH?$FL?$JK0U@ DB '-'
	DB	00H, 'f', 00H, 'n', 00H, ' ', 00H, 'N', 00H, 'S', 00H, 'F', 00H
	DB	' ', 00H, 0d5H, '0', 0a1H, '0', 0a4H, '0', 0ebH, '0L02', 00H, 0deH
	DB	'V', 0e5H, 'N', 0aH, 'N', 07H, 'c', 09aH, '[U0', 08cH, '0~0W0_'
	DB	'0', 02H, '0', 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_15OLECOAGL@?$AA?9?$AAf?$AA?$AA@
CONST	SEGMENT
??_C@_15OLECOAGL@?$AA?9?$AAf?$AA?$AA@ DB '-', 00H, 'f', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@?$AA?$AA@
CONST	SEGMENT
??_C@_11LOCGONAA@?$AA?$AA@ DB 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HCHMKIB@?4mml?$AA@
CONST	SEGMENT
??_C@_04HCHMKIB@?4mml?$AA@ DB '.mml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@HMJGEGAD@?$AAM?$AAM?$AAL0?U0?$KB0?$KE0?k0L?$AA2V?$NON?eN?6c?$AH?$FL?$JK0U0?$IM0?$HO0W0_0?$AC@
CONST	SEGMENT
??_C@_1CK@HMJGEGAD@?$AAM?$AAM?$AAL0?U0?$KB0?$KE0?k0L?$AA2V?$NON?eN?6c?$AH?$FL?$JK0U0?$IM0?$HO0W0_0?$AC@ DB 'M'
	DB	00H, 'M', 00H, 'L', 00H, 0d5H, '0', 0a1H, '0', 0a4H, '0', 0ebH
	DB	'0L02', 00H, 0deH, 'V', 0e5H, 'N', 0aH, 'N', 07H, 'c', 09aH, '['
	DB	'U0', 08cH, '0~0W0_0', 02H, '0', 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HBHDLLBA@PATH?$AA@
CONST	SEGMENT
??_C@_04HBHDLLBA@PATH?$AA@ DB 'PATH', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ECJCKIFH@DMC_INCLUDE?$AA@
CONST	SEGMENT
??_C@_0M@ECJCKIFH@DMC_INCLUDE?$AA@ DB 'DMC_INCLUDE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FGA@BOEDPMCK@?$AAM?$AAM?$AAL?$AA?5?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAr?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAN?$AAE?$AAS@
CONST	SEGMENT
??_C@_1FGA@BOEDPMCK@?$AAM?$AAM?$AAL?$AA?5?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAr?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAN?$AAE?$AAS@ DB 'M'
	DB	00H, 'M', 00H, 'L', 00H, ' ', 00H, 'C', 00H, 'o', 00H, 'm', 00H
	DB	'p', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'f'
	DB	00H, 'o', 00H, 'r', 00H, ' ', 00H, 'N', 00H, 'E', 00H, 'S', 00H
	DB	' ', 00H, 'S', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 'd', 00H, ' '
	DB	00H, 'D', 00H, 'r', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 'r', 00H
	DB	' ', 00H, '&', 00H, ' ', 00H, 'L', 00H, 'i', 00H, 'b', 00H, 'r'
	DB	00H, 'a', 00H, 'r', 00H, 'y', 00H, 0aH, 00H, 0aH, 00H, ' ', 00H
	DB	' ', 00H, 'U', 00H, 's', 00H, 'a', 00H, 'g', 00H, 'e', 00H, ' '
	DB	00H, ':', 00H, ' ', 00H, 'n', 00H, 's', 00H, 'c', 00H, ' ', 00H
	DB	'[', 00H, ' ', 00H, '-', 00H, 'o', 00H, 'p', 00H, 't', 00H, 'i'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, ' ', 00H, ']', 00H, ' ', 00H
	DB	'[', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, '(', 00H, '.'
	DB	00H, 'm', 00H, 'm', 00H, 'l', 00H, ')', 00H, ']', 00H, 0aH, 00H
	DB	0aH, 00H, ' ', 00H, ' ', 00H, '-', 00H, 'A', 00H, 09H, 00H, 09H
	DB	00H, 09H, 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, 'e', 00H, 'm', 00H, 'b', 00H, 'l', 00H
	DB	'y', 00H, ' ', 00H, 'l', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'a'
	DB	00H, 'g', 00H, 'e', 00H, '.', 00H, 0aH, 00H, ' ', 00H, ' ', 00H
	DB	'-', 00H, 'N', 00H, 09H, 00H, 09H, 00H, 09H, 00H, 'C', 00H, 'o'
	DB	00H, 'm', 00H, 'p', 00H, 'i', 00H, 'l', 00H, 'e', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 'N', 00H, 'S', 00H, 'F', 00H, ' '
	DB	00H, 'm', 00H, 'u', 00H, 's', 00H, 'i', 00H, 'c', 00H, ' ', 00H
	DB	'f', 00H, 'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H, 't', 00H, '.'
	DB	00H, 0aH, 00H, ' ', 00H, ' ', 00H, '-', 00H, 'E', 00H, 09H, 00H
	DB	09H, 00H, 09H, 00H, 'E', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r'
	DB	00H, '/', 00H, 'W', 00H, 'a', 00H, 'r', 00H, 'n', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, ' ', 00H, 'm', 00H, 'e', 00H, 's', 00H, 's'
	DB	00H, 'a', 00H, 'g', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'o', 00H
	DB	'u', 00H, 't', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 'd', 00H, 'a', 00H, 'r', 00H
	DB	'd', 00H, ' ', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r'
	DB	00H, '.', 00H, 0aH, 00H, ' ', 00H, ' ', 00H, '-', 00H, 'O', 00H
	DB	'd', 00H, '[', 00H, '+', 00H, '/', 00H, '-', 00H, ']', 00H, 09H
	DB	00H, 09H, 00H, 'O', 00H, 'p', 00H, 't', 00H, 'i', 00H, 'm', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e'
	DB	00H, ' ', 00H, 'N', 00H, 'S', 00H, 'F', 00H, ' ', 00H, 'b', 00H
	DB	'a', 00H, 'n', 00H, 'k', 00H, ' ', 00H, 's', 00H, 't', 00H, 'r'
	DB	00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, 'd', 00H, 'e'
	DB	00H, 'l', 00H, 't', 00H, 'a', 00H, '-', 00H, 'P', 00H, 'C', 00H
	DB	'M', 00H, '.', 00H, 0aH, 00H, ' ', 00H, ' ', 00H, '-', 00H, 'O'
	DB	00H, 'o', 00H, '[', 00H, '+', 00H, '/', 00H, '-', 00H, ']', 00H
	DB	09H, 00H, 09H, 00H, 'O', 00H, 'p', 00H, 't', 00H, 'i', 00H, 'm'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'h', 00H
	DB	'e', 00H, ' ', 00H, 'o', 00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, ' ', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'a', 00H
	DB	'.', 00H, 0aH, 00H, ' ', 00H, ' ', 00H, '-', 00H, 'S', 00H, 09H
	DB	00H, 09H, 00H, 09H, 00H, 'E', 00H, 'n', 00H, 'a', 00H, 'b', 00H
	DB	'l', 00H, 'e', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, 'o'
	DB	00H, 'u', 00H, 't', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H
	DB	' ', 00H, 's', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h'
	DB	00H, ' ', 00H, 'p', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H
	DB	'r', 00H, 'e', 00H, 's', 00H, 'u', 00H, 'l', 00H, 't', 00H, '.'
	DB	00H, 0aH, 00H, ' ', 00H, ' ', 00H, '-', 00H, 'L', 00H, '[', 00H
	DB	'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, '(', 00H, '.', 00H, 'b'
	DB	00H, 'i', 00H, 'n', 00H, ')', 00H, ']', 00H, 09H, 00H, 'F', 00H
	DB	'i', 00H, 'l', 00H, 'e', 00H, 'n', 00H, 'a', 00H, 'm', 00H, 'e'
	DB	00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 't', 00H, 'h', 00H
	DB	'e', 00H, ' ', 00H, 'r', 00H, 'o', 00H, 'm', 00H, ' ', 00H, 'c'
	DB	00H, 'o', 00H, 'd', 00H, 'e', 00H, ' ', 00H, 'f', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, 'N', 00H, 'S', 00H, 'F', 00H, '.', 00H, 0aH
	DB	00H, ' ', 00H, ' ', 00H, '-', 00H, 'F', 00H, 'A', 00H, '[', 00H
	DB	'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, '(', 00H, '.', 00H, 's'
	DB	00H, ' ', 00H, ' ', 00H, ')', 00H, ']', 00H, 09H, 00H, 'F', 00H
	DB	'i', 00H, 'l', 00H, 'e', 00H, 'n', 00H, 'a', 00H, 'm', 00H, 'e'
	DB	00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 't', 00H, 'h', 00H
	DB	'e', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, 'p', 00H, 'u'
	DB	00H, 't', 00H, ' ', 00H, 'a', 00H, 's', 00H, 's', 00H, 'e', 00H
	DB	'm', 00H, 'b', 00H, 'l', 00H, 'y', 00H, ' ', 00H, 'l', 00H, 'a'
	DB	00H, 'n', 00H, 'g', 00H, 'a', 00H, 'g', 00H, 'e', 00H, ' ', 00H
	DB	'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, '.', 00H, 0aH, 00H, ' '
	DB	00H, ' ', 00H, '-', 00H, 'F', 00H, 'N', 00H, '[', 00H, 'f', 00H
	DB	'i', 00H, 'l', 00H, 'e', 00H, '(', 00H, '.', 00H, 'n', 00H, 's'
	DB	00H, 'f', 00H, ')', 00H, ']', 00H, 09H, 00H, 'F', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, 'n', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' '
	DB	00H, 'o', 00H, 'f', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H
	DB	' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't'
	DB	00H, ' ', 00H, 'N', 00H, 'S', 00H, 'F', 00H, ' ', 00H, 'm', 00H
	DB	'u', 00H, 's', 00H, 'i', 00H, 'c', 00H, ' ', 00H, 'f', 00H, 'o'
	DB	00H, 'r', 00H, 'm', 00H, 'a', 00H, 't', 00H, '.', 00H, 0aH, 00H
	DB	' ', 00H, ' ', 00H, '-', 00H, 'C', 00H, '[', 00H, 'd', 00H, 'i'
	DB	00H, 'r', 00H, ']', 00H, 09H, 00H, 09H, 00H, 'S', 00H, 'e', 00H
	DB	'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, ' ', 00H, 'p', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H
	DB	't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, 'r', 00H, 'o', 00H, 'm'
	DB	00H, ' ', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, ' ', 00H
	DB	'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'N', 00H, 'S', 00H, 'F'
	DB	00H, '.', 00H, 0aH, 00H, ' ', 00H, ' ', 00H, '-', 00H, 'P', 00H
	DB	'[', 00H, 'd', 00H, 'i', 00H, 'r', 00H, ']', 00H, 09H, 00H, 09H
	DB	00H, 'S', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H
	DB	' ', 00H, 'p', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'o'
	DB	00H, 'f', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H
	DB	'd', 00H, 'e', 00H, 'l', 00H, 't', 00H, 'a', 00H, '-', 00H, 'p'
	DB	00H, 'c', 00H, 'm', 00H, '.', 00H, 0aH, 00H, ' ', 00H, ' ', 00H
	DB	'-', 00H, 'I', 00H, '[', 00H, 'd', 00H, 'i', 00H, 'r', 00H, ']'
	DB	00H, 09H, 00H, 09H, 00H, 'S', 00H, 'e', 00H, 'a', 00H, 'r', 00H
	DB	'c', 00H, 'h', 00H, ' ', 00H, 'p', 00H, 'a', 00H, 's', 00H, 's'
	DB	00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 't', 00H, 'h', 00H
	DB	'e', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H, 'u'
	DB	00H, 'd', 00H, 'e', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l', 00H
	DB	'e', 00H, '.', 00H, 0aH, 00H, ' ', 00H, ' ', 00H, '-', 00H, 'H'
	DB	00H, 09H, 00H, 09H, 00H, 09H, 00H, 'P', 00H, 'r', 00H, 'i', 00H
	DB	'n', 00H, 't', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' '
	DB	00H, 't', 00H, 'h', 00H, 'i', 00H, 's', 00H, ' ', 00H, 'h', 00H
	DB	'e', 00H, 'l', 00H, 'p', 00H, '.', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@PLCOPKCK@0?$KK0?W0?$LH0?g0?s0LN?$ANkc0g0Y0?$AC?$PP?$BK?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@PLCOPKCK@0?$KK0?W0?$LH0?g0?s0LN?$ANkc0g0Y0?$AC?$PP?$BK?$AA?$AA@ DB 0aaH
	DB	'0', 0d7H, '0', 0b7H, '0', 0e7H, '0', 0f3H, '0L0', 0dH, 'Nckg0'
	DB	'Y0', 02H, '0', 01aH, 0ffH, 00H, 00H		; `string'
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 1148 : 		return (_Mysize == 0);

  00000	33 c0		 xor	 eax, eax
  00002	39 41 14	 cmp	 DWORD PTR [ecx+20], eax
  00005	0f 94 c0	 sete	 al

; 1149 : 		}

  00008	c3		 ret	 0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
; Function compile flags: /Ogsy
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Ptr$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 538  : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00004	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
$L59524:
  00007	8a 10		 mov	 dl, BYTE PTR [eax]
  00009	40		 inc	 eax
  0000a	84 d2		 test	 dl, dl
  0000c	75 f9		 jne	 SHORT $L59524
  0000e	2b c1		 sub	 eax, ecx
  00010	8b 4c 24 04	 mov	 ecx, DWORD PTR _this$[esp-4]
  00014	50		 push	 eax
  00015	ff 74 24 0c	 push	 DWORD PTR __Ptr$[esp]
  00019	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 539  : 		}

  0001e	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT

; 487  : 		return (append(_Ptr));

  00000	e9 00 00 00 00	 jmp	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
; Function compile flags: /Ogsy
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 492  : 		return (append((size_type)1, _Ch));

  00000	ff 74 24 04	 push	 DWORD PTR __Ch$[esp-4]
  00004	6a 01		 push	 1
  00006	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 493  : 		}

  0000b	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?opError@OPSW@@AAEXPBG@Z			; OPSW::opError
; Function compile flags: /Ogsy
; File f:\nes\nsdl\src\nsc\option.cpp
_TEXT	SEGMENT
_stErrMsg$ = 8						; size = 4
?opError@OPSW@@AAEXPBG@Z PROC NEAR			; OPSW::opError
; _this$ = eax

; 446  : 
; 447  : 	if(fErr == true){

  00000	80 78 01 01	 cmp	 BYTE PTR [eax+1], 1

; 448  : 		_CERR << _T("オプションが不正です。：") << stErrMsg << endl;

  00004	ff 74 24 04	 push	 DWORD PTR _stErrMsg$[esp-4]
  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BK@PLCOPKCK@0?$KK0?W0?$LH0?g0?s0LN?$ANkc0g0Y0?$AC?$PP?$BK?$AA?$AA@
  0000d	75 07		 jne	 SHORT $L24251
  0000f	68 00 00 00 00	 push	 OFFSET FLAT:?wcerr@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A ; std::wcerr

; 449  : 	} else {

  00014	eb 05		 jmp	 SHORT $L79321
$L24251:

; 450  : 		_COUT << _T("オプションが不正です。：") << stErrMsg << endl;

  00016	68 00 00 00 00	 push	 OFFSET FLAT:?wcout@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A ; std::wcout
$L79321:
  0001b	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  00020	59		 pop	 ecx
  00021	59		 pop	 ecx
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl

; 451  : 	}
; 452  : 	nsc_exit(EXIT_FAILURE);

  0002e	33 c0		 xor	 eax, eax
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH
  00033	40		 inc	 eax
  00034	e8 00 00 00 00	 call	 ?nsc_exit@@YAXH@Z	; nsc_exit
$L79322:
$L79320:
  00039	cc		 int	 3
?opError@OPSW@@AAEXPBG@Z ENDP				; OPSW::opError
_TEXT	ENDS
PUBLIC	?print_help@OPSW@@AAEXXZ			; OPSW::print_help
; Function compile flags: /Ogsy
_TEXT	SEGMENT
?print_help@OPSW@@AAEXXZ PROC NEAR			; OPSW::print_help

; 401  : 
; 402  : 	_COUT	<<	_T("MML Compiler for NES Sound Driver & Library\n")
; 403  : 				_T("\n")
; 404  : 				_T("  Usage : nsc [ -options ] [file(.mml)]\n")
; 405  : 				_T("\n")
; 406  : 				_T("  -A			Compile to assembly langage.\n")
; 407  : 				_T("  -N			Compile to NSF music format.\n")
; 408  : 				_T("  -E			Error/Warning messages out the stadard error.\n")
; 409  : 			//	_T("  -T			Disable to output the tick counting result.\n")
; 410  : 				_T("  -Od[+/-]		Optimize the NSF bank struct of the delta-PCM.\n")
; 411  : 				_T("  -Oo[+/-]		Optimize the object data.\n")
; 412  : 			//	_T("  -Os[+/-]		Optimize the sequence data.\n")
; 413  : 				_T("  -S			Enable outout the search pass result.\n")
; 414  : 				_T("  -L[file(.bin)]	Filename of the rom code for NSF.\n")
; 415  : 				_T("  -FA[file(.s  )]	Filename of the output assembly langage file.\n")
; 416  : 				_T("  -FN[file(.nsf)]	Filename of the output NSF music format.\n")
; 417  : 				_T("  -C[dir]		Search pass of the rom code for NSF.\n")
; 418  : 				_T("  -P[dir]		Search pass of the delta-pcm.\n")
; 419  : 				_T("  -I[dir]		Search pass of the include file.\n")
; 420  : 				_T("  -H			Print the this help.")	<<	endl;

  0003a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1FGA@BOEDPMCK@?$AAM?$AAM?$AAL?$AA?5?$AAC?$AAo?$AAm?$AAp?$AAi?$AAl?$AAe?$AAr?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAN?$AAE?$AAS@
  0003f	68 00 00 00 00	 push	 OFFSET FLAT:?wcout@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A ; std::wcout
  00044	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 421  : 
; 422  : 	nsc_exit(EXIT_SUCCESS);

  00052	33 c0		 xor	 eax, eax
  00054	e9 00 00 00 00	 jmp	 ?nsc_exit@@YAXH@Z	; nsc_exit
?print_help@OPSW@@AAEXXZ ENDP				; OPSW::print_help
PUBLIC	??1OPSW@@QAE@XZ					; OPSW::~OPSW
$T100184 DD	0ffffffffH
	DD	FLAT:$L100162
	DD	00H
	DD	FLAT:$L100163
	DD	01H
	DD	FLAT:$L100164
	DD	02H
	DD	FLAT:$L100165
	DD	03H
	DD	FLAT:$L100166
	DD	04H
	DD	FLAT:$L100167
$T100182 DD	019930520H
	DD	06H
	DD	FLAT:$T100184
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1OPSW@@QAE@XZ PROC NEAR				; OPSW::~OPSW

; 433  : OPSW::~OPSW(){

  00059	b8 00 00 00 00	 mov	 eax, __ehhandler$??1OPSW@@QAE@XZ
  0005e	e8 00 00 00 00	 call	 __EH_prolog
  00063	56		 push	 esi
  00064	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]

; 434  : 
; 435  : 
; 436  : };

  00067	8d 86 9c 00 00
	00		 lea	 eax, DWORD PTR [esi+156]
  0006d	50		 push	 eax
  0006e	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
  00075	e8 00 00 00 00	 call	 ??1SearchPass@@QAE@XZ	; SearchPass::~SearchPass
  0007a	8d 86 8c 00 00
	00		 lea	 eax, DWORD PTR [esi+140]
  00080	50		 push	 eax
  00081	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00085	e8 00 00 00 00	 call	 ??1SearchPass@@QAE@XZ	; SearchPass::~SearchPass
  0008a	8d 46 7c	 lea	 eax, DWORD PTR [esi+124]
  0008d	50		 push	 eax
  0008e	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00092	e8 00 00 00 00	 call	 ??1SearchPass@@QAE@XZ	; SearchPass::~SearchPass
  00097	6a 00		 push	 0
  00099	6a 01		 push	 1
  0009b	8d 4e 60	 lea	 ecx, DWORD PTR [esi+96]
  0009e	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  000a3	6a 00		 push	 0
  000a5	6a 01		 push	 1
  000a7	8d 4e 44	 lea	 ecx, DWORD PTR [esi+68]
  000aa	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  000af	6a 00		 push	 0
  000b1	6a 01		 push	 1
  000b3	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  000b6	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  000bb	6a 00		 push	 0
  000bd	6a 01		 push	 1
  000bf	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  000c2	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  000c7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ca	5e		 pop	 esi
  000cb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000d2	c9		 leave
  000d3	c2 04 00	 ret	 4
$L100162:
  003e5	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  003e8	83 c1 0c	 add	 ecx, 12			; 0000000cH
  003eb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L100163:
  003f0	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  003f3	83 c1 28	 add	 ecx, 40			; 00000028H
  003f6	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L100164:
  003fb	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  003fe	83 c1 44	 add	 ecx, 68			; 00000044H
  00401	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L100165:
  00406	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00409	83 c1 60	 add	 ecx, 96			; 00000060H
  0040c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L100166:
  00411	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00414	83 c0 7c	 add	 eax, 124		; 0000007cH
  00417	50		 push	 eax
  00418	e8 00 00 00 00	 call	 ??1SearchPass@@QAE@XZ	; SearchPass::~SearchPass
  0041d	c3		 ret	 0
$L100167:
  0041e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00421	05 8c 00 00 00	 add	 eax, 140		; 0000008cH
  00426	50		 push	 eax
  00427	e8 00 00 00 00	 call	 ??1SearchPass@@QAE@XZ	; SearchPass::~SearchPass
  0042c	c3		 ret	 0
__ehhandler$??1OPSW@@QAE@XZ:
  0042d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T100182
  00432	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
??1OPSW@@QAE@XZ ENDP					; OPSW::~OPSW
PUBLIC	??0OPSW@@QAE@HQAPAD@Z				; OPSW::OPSW
	ORG $+4
$T100405 DD	0ffffffffH
	DD	FLAT:$L100187
	DD	00H
	DD	FLAT:$L100188
	DD	01H
	DD	FLAT:$L100189
	DD	02H
	DD	FLAT:$L100190
	DD	03H
	DD	FLAT:$L100191
	DD	04H
	DD	FLAT:$L100192
	DD	05H
	DD	FLAT:$L100193
	DD	06H
	DD	FLAT:$L100194
	DD	07H
	DD	FLAT:$L100195
	DD	08H
	DD	FLAT:$L100196
	DD	09H
	DD	FLAT:$L100197
$T100363 DD	019930520H
	DD	0bH
	DD	FLAT:$T100405
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_i$23963 = -148						; size = 4
_iCount$ = -144						; size = 4
tv1004 = -140						; size = 4
_cOption$ = -136					; size = 1
_iOptionChk$ = -132					; size = 4
_str_dmc$ = -128					; size = 28
_str_inc$ = -100					; size = 28
_str_code$ = -72					; size = 28
_str_mmldir$24039 = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_iResult$ = 12						; size = 4
_argc$ = 12						; size = 4
$T100349 = 16						; size = 1
_argv$ = 16						; size = 4
_iFlagFilnameExt$ = 19					; size = 1
??0OPSW@@QAE@HQAPAD@Z PROC NEAR				; OPSW::OPSW

; 44   : {

  000d6	b8 00 00 00 00	 mov	 eax, __ehhandler$??0OPSW@@QAE@HQAPAD@Z
  000db	e8 00 00 00 00	 call	 __EH_prolog
  000e0	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  000e6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  000eb	53		 push	 ebx
  000ec	33 db		 xor	 ebx, ebx
  000ee	56		 push	 esi
  000ef	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  000f2	57		 push	 edi
  000f3	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  000f6	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  000f9	88 1e		 mov	 BYTE PTR [esi], bl
  000fb	88 5e 01	 mov	 BYTE PTR [esi+1], bl
  000fe	88 5e 02	 mov	 BYTE PTR [esi+2], bl
  00101	88 5e 03	 mov	 BYTE PTR [esi+3], bl
  00104	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  00107	c6 46 05 01	 mov	 BYTE PTR [esi+5], 1
  0010b	c6 46 06 01	 mov	 BYTE PTR [esi+6], 1
  0010f	88 5e 07	 mov	 BYTE PTR [esi+7], bl
  00112	88 5e 08	 mov	 BYTE PTR [esi+8], bl
  00115	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0011a	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  0011d	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00120	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00125	8d 4e 44	 lea	 ecx, DWORD PTR [esi+68]
  00128	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0012d	8d 4e 60	 lea	 ecx, DWORD PTR [esi+96]
  00130	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00135	8d 7e 7c	 lea	 edi, DWORD PTR [esi+124]
  00138	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0013c	e8 00 00 00 00	 call	 ??0SearchPass@@QAE@XZ	; SearchPass::SearchPass
  00141	8d be 8c 00 00
	00		 lea	 edi, DWORD PTR [esi+140]
  00147	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0014b	e8 00 00 00 00	 call	 ??0SearchPass@@QAE@XZ	; SearchPass::SearchPass
  00150	8d be 9c 00 00
	00		 lea	 edi, DWORD PTR [esi+156]
  00156	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0015a	e8 00 00 00 00	 call	 ??0SearchPass@@QAE@XZ	; SearchPass::SearchPass

; 45   : 
; 46   : 	//----------------------------------
; 47   : 	//■Local 変数
; 48   : 	
; 49   : 	int		iCount;				//whileのカウント用
; 50   : 	int		iResult;			//汎用
; 51   : 
; 52   : 	//Option処理用
; 53   : 	int		iOptionChk;			//オプションチェック用　ポインタ
; 54   : 	char	cOption;			//オプションチェック用　文字
; 55   : 	char	iFlagFilnameExt;	//拡張子あったかのフラグ
; 56   : 
; 57   : 	//検索パス
; 58   : 	string	str_code	= "";

  0015f	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00164	57		 push	 edi
  00165	8d 4d b8	 lea	 ecx, DWORD PTR _str_code$[ebp]
  00168	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0016c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 59   : 	string	str_dmc		= "";

  00171	57		 push	 edi
  00172	8d 4d 80	 lea	 ecx, DWORD PTR _str_dmc$[ebp]
  00175	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00179	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 60   : 	string	str_inc		= "";

  0017e	57		 push	 edi
  0017f	8d 4d 9c	 lea	 ecx, DWORD PTR _str_inc$[ebp]
  00182	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00186	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 61   : 
; 62   : 	//----------------------------------
; 63   : 	//■オプション処理
; 64   : 	iCount=1;	//コマンド名は飛ばす

  0018b	33 c0		 xor	 eax, eax
  0018d	40		 inc	 eax

; 65   : 	while(iCount!=argc)

  0018e	39 45 0c	 cmp	 DWORD PTR _argc$[ebp], eax
  00191	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00195	89 85 70 ff ff
	ff		 mov	 DWORD PTR _iCount$[ebp], eax
  0019b	0f 84 29 03 00
	00		 je	 $L100395
  001a1	8b 45 10	 mov	 eax, DWORD PTR _argv$[ebp]
  001a4	83 c0 04	 add	 eax, 4
  001a7	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv1004[ebp], eax
$L23931:

; 66   : 	{
; 67   : 		//--------------
; 68   : 		//オプションスイッチにハイフン(orスラッシュ)があるか確認
; 69   : 		if(OPTCHK){

  001ad	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv1004[ebp]
  001b3	8b 00		 mov	 eax, DWORD PTR [eax]
  001b5	8a 08		 mov	 cl, BYTE PTR [eax]
  001b7	80 f9 2f	 cmp	 cl, 47			; 0000002fH
  001ba	74 75		 je	 SHORT $L23934
  001bc	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  001bf	74 70		 je	 SHORT $L23934

; 269  : 					break;
; 270  : 			};
; 271  : 
; 272  : 		} else{
; 273  : 
; 274  : 			//--------------
; 275  : 			//◆ファイル名	（スラッシュが無かった場合の処理）
; 276  : 			//既に指定されている？
; 277  : 			if(strMMLname.empty()){

  001c1	39 5e 20	 cmp	 DWORD PTR [esi+32], ebx
  001c4	0f 85 2d 03 00
	00		 jne	 $L24014

; 278  : 				iFlagFilnameExt=0;		//拡張子の有無　Reset
; 279  : 				iOptionChk=0;		
; 280  : 				while((cOption=argv[iCount][iOptionChk])!=0)

  001ca	3a cb		 cmp	 cl, bl
  001cc	88 5d 13	 mov	 BYTE PTR _iFlagFilnameExt$[ebp], bl
  001cf	89 9d 7c ff ff
	ff		 mov	 DWORD PTR _iOptionChk$[ebp], ebx
  001d5	88 8d 78 ff ff
	ff		 mov	 BYTE PTR _cOption$[ebp], cl
  001db	74 47		 je	 SHORT $L100384
$L24016:

; 281  : 				{
; 282  : 					strMMLname+=cOption;

  001dd	ff b5 78 ff ff
	ff		 push	 DWORD PTR _cOption$[ebp]
  001e3	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  001e6	6a 01		 push	 1
  001e8	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 283  : 					if(cOption=='.'){iFlagFilnameExt=1;};

  001ed	80 bd 78 ff ff
	ff 2e		 cmp	 BYTE PTR _cOption$[ebp], 46 ; 0000002eH
  001f4	75 04		 jne	 SHORT $L100391
  001f6	c6 45 13 01	 mov	 BYTE PTR _iFlagFilnameExt$[ebp], 1
$L100391:

; 284  : 					iOptionChk++;

  001fa	ff 85 7c ff ff
	ff		 inc	 DWORD PTR _iOptionChk$[ebp]
  00200	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv1004[ebp]
  00206	8b 00		 mov	 eax, DWORD PTR [eax]
  00208	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _iOptionChk$[ebp]
  0020e	8a 04 01	 mov	 al, BYTE PTR [ecx+eax]
  00211	3a c3		 cmp	 al, bl
  00213	88 85 78 ff ff
	ff		 mov	 BYTE PTR _cOption$[ebp], al
  00219	75 c2		 jne	 SHORT $L24016

; 285  : 				};
; 286  : 				if(iFlagFilnameExt==0){

  0021b	38 5d 13	 cmp	 BYTE PTR _iFlagFilnameExt$[ebp], bl
  0021e	0f 85 8a 02 00
	00		 jne	 $L100396
$L100384:

; 287  : 					strMMLname+=".mml";

  00224	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04HCHMKIB@?4mml?$AA@
  00229	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]

; 288  : 				};
; 289  : 			} else {

  0022c	e9 77 02 00 00	 jmp	 $L100400
$L23934:

; 70   : 
; 71   : 			//--------------
; 72   : 			//◆Option Switch	（スラッシュがあった場合の処理）
; 73   : 			switch(argv[iCount][1]){

  00231	0f be 48 01	 movsx	 ecx, BYTE PTR [eax+1]
  00235	83 c1 c1	 add	 ecx, -63		; ffffffc1H
  00238	83 f9 34	 cmp	 ecx, 52			; 00000034H
  0023b	0f 87 e7 02 00
	00		 ja	 $L24011
  00241	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $L100388[ecx]
  00248	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L100404[ecx*4]
$L23939:

; 74   : 				//--------
; 75   : 				//Help表示
; 76   : 				case 'h' :
; 77   : 				case 'H' :
; 78   : 				case '?' :
; 79   : 					fHelp=1;

  0024f	c6 46 08 01	 mov	 BYTE PTR [esi+8], 1

; 80   : 					break;

  00253	e9 56 02 00 00	 jmp	 $L100396
$L23940:

; 81   : 				//--------
; 82   : 				//アセンブリ言語へ
; 83   : 				case 'o' :
; 84   : 				case 'O' :
; 85   : 					{
; 86   : 						bool fTemp;
; 87   : 						switch(argv[iCount][3]){

  00258	0f be 48 03	 movsx	 ecx, BYTE PTR [eax+3]
  0025c	83 e9 2b	 sub	 ecx, 43			; 0000002bH
  0025f	74 14		 je	 SHORT $L23946
  00261	49		 dec	 ecx
  00262	49		 dec	 ecx
  00263	74 0c		 je	 SHORT $L23947
  00265	83 e9 03	 sub	 ecx, 3
  00268	74 0b		 je	 SHORT $L23946
  0026a	49		 dec	 ecx
  0026b	0f 85 8d 02 00
	00		 jne	 $L23948
$L23947:

; 91   : 								break;
; 92   : 							case '1' :
; 93   : 							case '-' :
; 94   : 								fTemp = false;

  00271	32 c9		 xor	 cl, cl

; 95   : 								break;

  00273	eb 02		 jmp	 SHORT $L23943
$L23946:

; 88   : 							case '0' :
; 89   : 							case '+' :
; 90   : 								fTemp = true;

  00275	b1 01		 mov	 cl, 1
$L23943:

; 98   : 								break;
; 99   : 						}
; 100  : 						switch(argv[iCount][2]){

  00277	8a 40 02	 mov	 al, BYTE PTR [eax+2]
  0027a	3c 44		 cmp	 al, 68			; 00000044H
  0027c	74 28		 je	 SHORT $L23954
  0027e	3c 4f		 cmp	 al, 79			; 0000004fH
  00280	74 1c		 je	 SHORT $L23955
  00282	3c 53		 cmp	 al, 83			; 00000053H
  00284	74 10		 je	 SHORT $L23956
  00286	3c 64		 cmp	 al, 100			; 00000064H
  00288	74 1c		 je	 SHORT $L23954
  0028a	3c 6f		 cmp	 al, 111			; 0000006fH
  0028c	74 10		 je	 SHORT $L23955
  0028e	3c 73		 cmp	 al, 115			; 00000073H
  00290	0f 85 68 02 00
	00		 jne	 $L23948
$L23956:

; 109  : 							case 's' :
; 110  : 							case 'S' :
; 111  : 								flag_OptSeq = fTemp;

  00296	88 4e 06	 mov	 BYTE PTR [esi+6], cl

; 112  : 								break;

  00299	e9 10 02 00 00	 jmp	 $L100396
$L23955:

; 104  : 								break;
; 105  : 							case 'o' :
; 106  : 							case 'O' :
; 107  : 								flag_OptObj = fTemp;

  0029e	88 4e 05	 mov	 BYTE PTR [esi+5], cl

; 108  : 								break;

  002a1	e9 08 02 00 00	 jmp	 $L100396
$L23954:

; 101  : 							case 'd' :
; 102  : 							case 'D' :
; 103  : 								flag_Optimize = fTemp;

  002a6	88 4e 04	 mov	 BYTE PTR [esi+4], cl

; 113  : 							default :
; 114  : 								opError(_T("-o"));
; 115  : 								break;
; 116  : 						}
; 117  : 						break;

  002a9	e9 00 02 00 00	 jmp	 $L100396
$L23958:

; 118  : 					}
; 119  : 				//--------
; 120  : 				//アセンブリ言語へ
; 121  : 				case 'a' :
; 122  : 				case 'A' :
; 123  : 					saveASM = true;

  002ae	c6 46 03 01	 mov	 BYTE PTR [esi+3], 1

; 124  : 					break;

  002b2	e9 f7 01 00 00	 jmp	 $L100396
$L23959:

; 125  : 				//--------
; 126  : 				//ＮＳＦへ
; 127  : 				case 'n' :
; 128  : 				case 'N' :
; 129  : 					saveNSF = true;

  002b7	c6 46 02 01	 mov	 BYTE PTR [esi+2], 1

; 130  : 					break;

  002bb	e9 ee 01 00 00	 jmp	 $L100396
$L23960:

; 131  : 				//--------
; 132  : 				//標準エラー出力へ
; 133  : 				case 'e' :
; 134  : 				case 'E' :
; 135  : 					fErr = true;

  002c0	c6 46 01 01	 mov	 BYTE PTR [esi+1], 1

; 136  : 					break;

  002c4	e9 e5 01 00 00	 jmp	 $L100396
$L23961:

; 137  : 				//--------
; 138  : 				//Tick Count
; 139  : 		//		case 't' :
; 140  : 		//		case 'T' :
; 141  : 		//			flag_TickCount = false;
; 142  : 		//			break;
; 143  : 				//--------
; 144  : 				//Search Pass
; 145  : 				case 's' :
; 146  : 				case 'S' :
; 147  : 					flag_SearchPass = true;

  002c9	c6 46 07 01	 mov	 BYTE PTR [esi+7], 1

; 148  : 					break;

  002cd	e9 dc 01 00 00	 jmp	 $L100396
$L23962:

; 149  : 				//--------
; 150  : 				//Debugの指定
; 151  : 				case 'D' :
; 152  : 					//0x01:	Class Object Creat
; 153  : 					//0x02:	Address settlement
; 154  : 					//0x04:	Music File Outputing
; 155  : 					//0x40:	Class Object Clear	
; 156  : 					//0x80:	Class Object Delete
; 157  : 					int	i;
; 158  : 					iResult=sscanf(argv[iCount],"-D%d",&i);

  002d2	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _i$23963[ebp]
  002d8	51		 push	 ecx
  002d9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04CLONAGJF@?9D?$CFd?$AA@
  002de	50		 push	 eax
  002df	e8 00 00 00 00	 call	 _sscanf

; 159  : 					cDebug = (char)i;

  002e4	8a 8d 6c ff ff
	ff		 mov	 cl, BYTE PTR _i$23963[ebp]
  002ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 160  : 					if((iResult==NULL)||(iResult==EOF)){

  002ed	3b c3		 cmp	 eax, ebx
  002ef	88 0e		 mov	 BYTE PTR [esi], cl
  002f1	74 09		 je	 SHORT $L100374
  002f3	83 f8 ff	 cmp	 eax, -1
  002f6	0f 85 b2 01 00
	00		 jne	 $L100396
$L100374:

; 161  : 						opError(_T("-D"));

  002fc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_15OBHJIHNO@?$AA?9?$AAD?$AA?$AA@
  00301	e9 27 02 00 00	 jmp	 $L100402
$L23969:

; 162  : 						break;
; 163  : 					};
; 164  : 					break;
; 165  : 				//--------
; 166  : 				//Debugの指定
; 167  : 				case 'l' :
; 168  : 				case 'L' :
; 169  : 					//既に指定されている？
; 170  : 					if(strCodeName.empty()){

  00306	39 5e 74	 cmp	 DWORD PTR [esi+116], ebx
  00309	0f 85 f6 01 00
	00		 jne	 $L23970

; 171  : 						iFlagFilnameExt=0;		//拡張子の有無　Reset
; 172  : 						iOptionChk=0;
; 173  : 						while((cOption=argv[iCount][iOptionChk+2])!=0)

  0030f	8a 40 02	 mov	 al, BYTE PTR [eax+2]
  00312	3a c3		 cmp	 al, bl
  00314	88 5d 13	 mov	 BYTE PTR _iFlagFilnameExt$[ebp], bl
  00317	89 9d 7c ff ff
	ff		 mov	 DWORD PTR _iOptionChk$[ebp], ebx
  0031d	88 85 78 ff ff
	ff		 mov	 BYTE PTR _cOption$[ebp], al
  00323	74 48		 je	 SHORT $L100385
$L23972:

; 174  : 						{
; 175  : 							strCodeName+=cOption;

  00325	ff b5 78 ff ff
	ff		 push	 DWORD PTR _cOption$[ebp]
  0032b	8d 4e 60	 lea	 ecx, DWORD PTR [esi+96]
  0032e	6a 01		 push	 1
  00330	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 176  : 							if(cOption=='.'){iFlagFilnameExt=1;};

  00335	80 bd 78 ff ff
	ff 2e		 cmp	 BYTE PTR _cOption$[ebp], 46 ; 0000002eH
  0033c	75 04		 jne	 SHORT $L100392
  0033e	c6 45 13 01	 mov	 BYTE PTR _iFlagFilnameExt$[ebp], 1
$L100392:

; 177  : 							iOptionChk++;

  00342	ff 85 7c ff ff
	ff		 inc	 DWORD PTR _iOptionChk$[ebp]
  00348	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv1004[ebp]
  0034e	8b 00		 mov	 eax, DWORD PTR [eax]
  00350	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _iOptionChk$[ebp]
  00356	8a 44 01 02	 mov	 al, BYTE PTR [ecx+eax+2]
  0035a	3a c3		 cmp	 al, bl
  0035c	88 85 78 ff ff
	ff		 mov	 BYTE PTR _cOption$[ebp], al
  00362	75 c1		 jne	 SHORT $L23972

; 178  : 						};
; 179  : 						if(iFlagFilnameExt==0){

  00364	38 5d 13	 cmp	 BYTE PTR _iFlagFilnameExt$[ebp], bl
  00367	0f 85 41 01 00
	00		 jne	 $L100396
$L100385:

; 180  : 							strCodeName+=".bin";

  0036d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04GKHLBAIJ@?4bin?$AA@
  00372	8d 46 60	 lea	 eax, DWORD PTR [esi+96]

; 184  : 						break;
; 185  : 					};
; 186  : 					break;

  00375	e9 2e 01 00 00	 jmp	 $L100400
$L23979:

; 187  : 				//--------
; 188  : 				//ROMコードの検索パス
; 189  : 				case 'c' :
; 190  : 				case 'C' :
; 191  : 					str_code += &argv[iCount][2];

  0037a	83 c0 02	 add	 eax, 2
  0037d	50		 push	 eax
  0037e	8d 45 b8	 lea	 eax, DWORD PTR _str_code$[ebp]
  00381	50		 push	 eax
  00382	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 192  : 					str_code.append(1, _PATH_SPLIT);

  00387	8d 4d b8	 lea	 ecx, DWORD PTR _str_code$[ebp]

; 193  : 					break;

  0038a	eb 22		 jmp	 SHORT $L100403
$L23980:

; 194  : 				//--------
; 195  : 				//⊿PCMの検索パス
; 196  : 				case 'p' :
; 197  : 				case 'P' :
; 198  : 					str_dmc += &argv[iCount][2];

  0038c	83 c0 02	 add	 eax, 2
  0038f	50		 push	 eax
  00390	8d 45 80	 lea	 eax, DWORD PTR _str_dmc$[ebp]
  00393	50		 push	 eax
  00394	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 199  : 					str_dmc.append(1, _PATH_SPLIT);

  00399	8d 4d 80	 lea	 ecx, DWORD PTR _str_dmc$[ebp]

; 200  : 					break;

  0039c	eb 10		 jmp	 SHORT $L100403
$L23981:

; 201  : 				//--------
; 202  : 				//インクルードファイルの検索パス
; 203  : 				case 'i' :
; 204  : 				case 'I' :
; 205  : 					str_inc += &argv[iCount][2];

  0039e	83 c0 02	 add	 eax, 2
  003a1	50		 push	 eax
  003a2	8d 45 9c	 lea	 eax, DWORD PTR _str_inc$[ebp]
  003a5	50		 push	 eax
  003a6	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 206  : 					str_inc.append(1, _PATH_SPLIT);

  003ab	8d 4d 9c	 lea	 ecx, DWORD PTR _str_inc$[ebp]
$L100403:
  003ae	6a 3b		 push	 59			; 0000003bH
  003b0	6a 01		 push	 1
  003b2	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 207  : 					break;

  003b7	e9 f2 00 00 00	 jmp	 $L100396
$L23982:

; 208  : 				//--------
; 209  : 				//ファイルの指定
; 210  : 				case 'f' :
; 211  : 				case 'F' :
; 212  : 					//先に、ファイル名が書いてあるかチェック。
; 213  : 					if(argv[iCount][3]==0){

  003bc	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  003bf	3a cb		 cmp	 cl, bl
  003c1	0f 84 45 01 00
	00		 je	 $L100375

; 215  : 						break;
; 216  : 					};
; 217  : 					switch(argv[iCount][2]){

  003c7	8a 40 02	 mov	 al, BYTE PTR [eax+2]
  003ca	3c 41		 cmp	 al, 65			; 00000041H
  003cc	74 76		 je	 SHORT $L23989
  003ce	3c 4e		 cmp	 al, 78			; 0000004eH
  003d0	74 0c		 je	 SHORT $L23999
  003d2	3c 61		 cmp	 al, 97			; 00000061H
  003d4	74 6e		 je	 SHORT $L23989
  003d6	3c 6e		 cmp	 al, 110			; 0000006eH
  003d8	0f 85 35 01 00
	00		 jne	 $L100376
$L23999:

; 237  : 							break;
; 238  : 						};
; 239  : 						break;
; 240  : 					case 'N' :
; 241  : 					case 'n' :
; 242  : 						//既に指定されている？
; 243  : 						if(strNSFname.empty()){

  003de	39 5e 3c	 cmp	 DWORD PTR [esi+60], ebx
  003e1	0f 85 33 01 00
	00		 jne	 $L24000

; 244  : 							iFlagFilnameExt=0;		//拡張子の有無　Reset

  003e7	88 5d 13	 mov	 BYTE PTR _iFlagFilnameExt$[ebp], bl

; 245  : 							iOptionChk=0;

  003ea	89 9d 7c ff ff
	ff		 mov	 DWORD PTR _iOptionChk$[ebp], ebx

; 246  : 							while((cOption=argv[iCount][iOptionChk+3])!=0)

  003f0	88 8d 78 ff ff
	ff		 mov	 BYTE PTR _cOption$[ebp], cl
$L24002:

; 247  : 							{
; 248  : 								strNSFname+=cOption;

  003f6	ff b5 78 ff ff
	ff		 push	 DWORD PTR _cOption$[ebp]
  003fc	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  003ff	6a 01		 push	 1
  00401	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 249  : 								if(cOption=='.'){iFlagFilnameExt=1;};

  00406	80 bd 78 ff ff
	ff 2e		 cmp	 BYTE PTR _cOption$[ebp], 46 ; 0000002eH
  0040d	75 04		 jne	 SHORT $L100393
  0040f	c6 45 13 01	 mov	 BYTE PTR _iFlagFilnameExt$[ebp], 1
$L100393:

; 250  : 								iOptionChk++;

  00413	ff 85 7c ff ff
	ff		 inc	 DWORD PTR _iOptionChk$[ebp]
  00419	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv1004[ebp]
  0041f	8b 00		 mov	 eax, DWORD PTR [eax]
  00421	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _iOptionChk$[ebp]
  00427	8a 44 01 03	 mov	 al, BYTE PTR [ecx+eax+3]
  0042b	3a c3		 cmp	 al, bl
  0042d	88 85 78 ff ff
	ff		 mov	 BYTE PTR _cOption$[ebp], al
  00433	75 c1		 jne	 SHORT $L24002

; 251  : 							};
; 252  : 							if(iFlagFilnameExt==0){

  00435	38 5d 13	 cmp	 BYTE PTR _iFlagFilnameExt$[ebp], bl
  00438	75 74		 jne	 SHORT $L100396

; 253  : 								strNSFname+=".nsf";

  0043a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04PJMFADJP@?4nsf?$AA@
  0043f	8d 46 28	 lea	 eax, DWORD PTR [esi+40]

; 257  : 							break;
; 258  : 						};
; 259  : 						break;

  00442	eb 64		 jmp	 SHORT $L100400
$L23989:

; 218  : 					//--------
; 219  : 					//MMLファイルの指定
; 220  : 					case 'A' :
; 221  : 					case 'a' :
; 222  : 						//既に指定されている？
; 223  : 						if(strASMname.empty()){

  00444	39 5e 58	 cmp	 DWORD PTR [esi+88], ebx
  00447	0f 85 d4 00 00
	00		 jne	 $L23990

; 224  : 							iFlagFilnameExt=0;		//拡張子の有無　Reset

  0044d	88 5d 13	 mov	 BYTE PTR _iFlagFilnameExt$[ebp], bl

; 225  : 							iOptionChk=0;

  00450	89 9d 7c ff ff
	ff		 mov	 DWORD PTR _iOptionChk$[ebp], ebx

; 226  : 							while((cOption=argv[iCount][iOptionChk+3])!=0)

  00456	88 8d 78 ff ff
	ff		 mov	 BYTE PTR _cOption$[ebp], cl
$L23992:

; 227  : 							{
; 228  : 								strASMname+=cOption;

  0045c	ff b5 78 ff ff
	ff		 push	 DWORD PTR _cOption$[ebp]
  00462	8d 4e 44	 lea	 ecx, DWORD PTR [esi+68]
  00465	6a 01		 push	 1
  00467	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 229  : 								if(cOption=='.'){iFlagFilnameExt=1;};

  0046c	80 bd 78 ff ff
	ff 2e		 cmp	 BYTE PTR _cOption$[ebp], 46 ; 0000002eH
  00473	75 04		 jne	 SHORT $L100394
  00475	c6 45 13 01	 mov	 BYTE PTR _iFlagFilnameExt$[ebp], 1
$L100394:

; 230  : 								iOptionChk++;

  00479	ff 85 7c ff ff
	ff		 inc	 DWORD PTR _iOptionChk$[ebp]
  0047f	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv1004[ebp]
  00485	8b 00		 mov	 eax, DWORD PTR [eax]
  00487	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _iOptionChk$[ebp]
  0048d	8a 44 01 03	 mov	 al, BYTE PTR [ecx+eax+3]
  00491	3a c3		 cmp	 al, bl
  00493	88 85 78 ff ff
	ff		 mov	 BYTE PTR _cOption$[ebp], al
  00499	75 c1		 jne	 SHORT $L23992

; 231  : 							};
; 232  : 							if(iFlagFilnameExt==0){

  0049b	38 5d 13	 cmp	 BYTE PTR _iFlagFilnameExt$[ebp], bl
  0049e	75 0e		 jne	 SHORT $L100396

; 233  : 								strASMname+=".s";

  004a0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DGHPGHDC@?4s?$AA@
  004a5	8d 46 44	 lea	 eax, DWORD PTR [esi+68]
$L100400:
  004a8	50		 push	 eax
  004a9	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$L100396:

; 291  : 				break;
; 292  : 			};
; 293  : 
; 294  : 		};
; 295  : 
; 296  : 		//--------------
; 297  : 		//◆次のオプション
; 298  : 		iCount++;

  004ae	ff 85 70 ff ff
	ff		 inc	 DWORD PTR _iCount$[ebp]
  004b4	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _iCount$[ebp]
  004ba	83 85 74 ff ff
	ff 04		 add	 DWORD PTR tv1004[ebp], 4
  004c1	3b 45 0c	 cmp	 eax, DWORD PTR _argc$[ebp]
  004c4	0f 85 e3 fc ff
	ff		 jne	 $L23931
$L100395:

; 299  : 	};
; 300  : 
; 301  : 	//----------------------------------
; 302  : 	//◆オプションで指定された事を処理する。
; 303  : 
; 304  : 	//--------------
; 305  : 	//ヘルプ表示
; 306  : 	//ファイル名が書かれなかった場合も、ヘルプを表示する。
; 307  : 	if((fHelp==1)||(strMMLname.empty())){print_help();};

  004ca	80 7e 08 01	 cmp	 BYTE PTR [esi+8], 1
  004ce	0f 84 34 02 00
	00		 je	 $L24024
  004d4	39 5e 20	 cmp	 DWORD PTR [esi+32], ebx
  004d7	0f 84 2b 02 00
	00		 je	 $L24024

; 308  : 
; 309  : 	if(strASMname.empty()){

  004dd	39 5e 58	 cmp	 DWORD PTR [esi+88], ebx
  004e0	0f 85 8a 00 00
	00		 jne	 $L100271

; 310  : 		iOptionChk=0;		

  004e6	89 9d 7c ff ff
	ff		 mov	 DWORD PTR _iOptionChk$[ebp], ebx
$L24027:

; 311  : 		while((cOption=strMMLname[iOptionChk])!='.')

  004ec	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
  004f0	72 42		 jb	 SHORT $L100263
  004f2	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  004f5	eb 40		 jmp	 SHORT $L100264
$L24014:

; 290  : 				opError(_T("MMLファイルが2回以上指定されました。"));

  004f7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CK@HMJGEGAD@?$AAM?$AAM?$AAL0?U0?$KB0?$KE0?k0L?$AA2V?$NON?eN?6c?$AH?$FL?$JK0U0?$IM0?$HO0W0_0?$AC@
  004fc	eb 2f		 jmp	 SHORT $L100402
$L23948:

; 96   : 							default :
; 97   : 								opError(_T("-o"));

  004fe	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_15JGEKKPOB@?$AA?9?$AAo?$AA?$AA@
  00503	eb 28		 jmp	 SHORT $L100402
$L23970:

; 181  : 						};
; 182  : 					} else {
; 183  : 						opError(_T("-l Code ファイルが2回以上指定されました。"));

  00505	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DE@EPPPAIBF@?$AA?9?$AAl?$AA?5?$AAC?$AAo?$AAd?$AAe?$AA?50?U0?$KB0?$KE0?k0L?$AA2V?$NON?eN?6c?$AH?$FL?$JK0U@
  0050a	eb 21		 jmp	 SHORT $L100402
$L100375:

; 214  : 						opError(_T("/F ファイル名が書いてありません。"));

  0050c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CG@DFOJALGM@?$AA?1?$AAF?$AA?50?U0?$KB0?$KE0?kT?$AN0Lf?x0D0f0B0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
  00511	eb 1a		 jmp	 SHORT $L100402
$L100376:

; 260  : 					default :
; 261  : 						opError(_T("-f"));

  00513	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_15OLECOAGL@?$AA?9?$AAf?$AA?$AA@
  00518	eb 13		 jmp	 SHORT $L100402
$L24000:

; 254  : 							};
; 255  : 						} else {
; 256  : 							opError(_T("-fn NSF ファイルが2回以上指定されました。"));

  0051a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DE@HDIADBHN@?$AA?9?$AAf?$AAn?$AA?5?$AAN?$AAS?$AAF?$AA?50?U0?$KB0?$KE0?k0L?$AA2V?$NON?eN?6c?$AH?$FL?$JK0U@
  0051f	eb 0c		 jmp	 SHORT $L100402
$L23990:

; 234  : 							};
; 235  : 						} else {
; 236  : 							opError(_T("-fa ASM ファイルが2回以上指定されました。"));

  00521	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DE@PJEMIKMA@?$AA?9?$AAf?$AAa?$AA?5?$AAA?$AAS?$AAM?$AA?50?U0?$KB0?$KE0?k0L?$AA2V?$NON?eN?6c?$AH?$FL?$JK0U@
  00526	eb 05		 jmp	 SHORT $L100402
$L24011:

; 262  : 						break;
; 263  : 					};
; 264  : 				break;
; 265  : 				//--------
; 266  : 				//デフォルト
; 267  : 				default :
; 268  : 					opError(_T(""));

  00528	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_11LOCGONAA@?$AA?$AA@
$L100402:
  0052d	8b c6		 mov	 eax, esi
  0052f	e8 00 00 00 00	 call	 ?opError@OPSW@@AAEXPBG@Z ; OPSW::opError
$L100406:

; 311  : 		while((cOption=strMMLname[iOptionChk])!='.')

$L100263:
  00534	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
$L100264:
  00537	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _iOptionChk$[ebp]
  0053d	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  00540	3c 2e		 cmp	 al, 46			; 0000002eH
  00542	88 85 78 ff ff
	ff		 mov	 BYTE PTR _cOption$[ebp], al
  00548	74 18		 je	 SHORT $L24028

; 312  : 		{
; 313  : 			strASMname+=cOption;

  0054a	ff b5 78 ff ff
	ff		 push	 DWORD PTR _cOption$[ebp]
  00550	8d 4e 44	 lea	 ecx, DWORD PTR [esi+68]
  00553	6a 01		 push	 1
  00555	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 314  : 			iOptionChk++;

  0055a	ff 85 7c ff ff
	ff		 inc	 DWORD PTR _iOptionChk$[ebp]

; 315  : 		};

  00560	eb 8a		 jmp	 SHORT $L24027
$L24028:

; 316  : 		strASMname+=".s";

  00562	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DGHPGHDC@?4s?$AA@
  00567	8d 46 44	 lea	 eax, DWORD PTR [esi+68]
  0056a	50		 push	 eax
  0056b	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$L100271:

; 317  : 	};
; 318  : 
; 319  : 	if(strNSFname.empty()){

  00570	39 5e 3c	 cmp	 DWORD PTR [esi+60], ebx
  00573	75 4d		 jne	 SHORT $L100295

; 320  : 		iOptionChk=0;		

  00575	89 9d 7c ff ff
	ff		 mov	 DWORD PTR _iOptionChk$[ebp], ebx
$L24031:

; 321  : 		while((cOption=strMMLname[iOptionChk])!='.')

  0057b	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
  0057f	72 05		 jb	 SHORT $L100287
  00581	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00584	eb 03		 jmp	 SHORT $L100288
$L100287:
  00586	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
$L100288:
  00589	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _iOptionChk$[ebp]
  0058f	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  00592	3c 2e		 cmp	 al, 46			; 0000002eH
  00594	88 85 78 ff ff
	ff		 mov	 BYTE PTR _cOption$[ebp], al
  0059a	74 18		 je	 SHORT $L24032

; 322  : 		{
; 323  : 			strNSFname+=cOption;

  0059c	ff b5 78 ff ff
	ff		 push	 DWORD PTR _cOption$[ebp]
  005a2	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  005a5	6a 01		 push	 1
  005a7	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 324  : 			iOptionChk++;

  005ac	ff 85 7c ff ff
	ff		 inc	 DWORD PTR _iOptionChk$[ebp]

; 325  : 		};

  005b2	eb c7		 jmp	 SHORT $L24031
$L24032:

; 326  : 		strNSFname+=".nsf";

  005b4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04PJMFADJP@?4nsf?$AA@
  005b9	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  005bc	50		 push	 eax
  005bd	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$L100295:

; 327  : 	};
; 328  : 
; 329  : 	//----------------------------------
; 330  : 	//◆検索パスの設定
; 331  : 
; 332  : 	//MMLのディレクトリを取得
; 333  : 	iCount	= 0;

  005c2	33 c9		 xor	 ecx, ecx

; 334  : 	iResult	= 0;
; 335  : 	while(iCount < strMMLname.size()){

  005c4	39 5e 20	 cmp	 DWORD PTR [esi+32], ebx
  005c7	89 5d 0c	 mov	 DWORD PTR _iResult$[ebp], ebx
  005ca	0f 86 a6 00 00
	00		 jbe	 $L100351
  005d0	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
$L24034:

; 336  : 		if((strMMLname[iCount] == '\\') || (strMMLname[iCount] == '/')){

  005d3	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
  005d7	72 05		 jb	 SHORT $L100313
  005d9	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  005dc	eb 03		 jmp	 SHORT $L100314
$L100313:
  005de	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
$L100314:
  005e1	80 3c 08 5c	 cmp	 BYTE PTR [eax+ecx], 92	; 0000005cH
  005e5	74 14		 je	 SHORT $L24037
  005e7	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
  005eb	72 05		 jb	 SHORT $L100328
  005ed	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  005f0	eb 03		 jmp	 SHORT $L100329
$L100328:
  005f2	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
$L100329:
  005f5	80 3c 08 2f	 cmp	 BYTE PTR [eax+ecx], 47	; 0000002fH
  005f9	75 03		 jne	 SHORT $L24036
$L24037:

; 337  : 			iResult = iCount;

  005fb	89 4d 0c	 mov	 DWORD PTR _iResult$[ebp], ecx
$L24036:

; 338  : 		}
; 339  : 		iCount++;

  005fe	41		 inc	 ecx
  005ff	3b ca		 cmp	 ecx, edx
  00601	72 d0		 jb	 SHORT $L24034

; 340  : 	}
; 341  : 
; 342  : 	//優先順位１　カレントパス
; 343  : 	//優先順位２　MMLファイルが存在するパス
; 344  : 	if(iResult > 0){

  00603	39 5d 0c	 cmp	 DWORD PTR _iResult$[ebp], ebx
  00606	7e 6e		 jle	 SHORT $L100351

; 345  : 		string	str_mmldir = "";

  00608	57		 push	 edi
  00609	8d 4d d4	 lea	 ecx, DWORD PTR _str_mmldir$24039[ebp]
  0060c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 346  : 		iCount	= 0;

  00611	33 ff		 xor	 edi, edi

; 347  : 		while(iCount < iResult){

  00613	39 5d 0c	 cmp	 DWORD PTR _iResult$[ebp], ebx
  00616	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  0061a	7e 27		 jle	 SHORT $L24042
$L24041:

; 348  : 			str_mmldir += strMMLname[iCount];

  0061c	83 7e 24 10	 cmp	 DWORD PTR [esi+36], 16	; 00000010H
  00620	72 05		 jb	 SHORT $L100343
  00622	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00625	eb 03		 jmp	 SHORT $L100344
$L100343:
  00627	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
$L100344:
  0062a	8a 04 38	 mov	 al, BYTE PTR [eax+edi]
  0062d	88 45 10	 mov	 BYTE PTR $T100349[ebp], al
  00630	ff 75 10	 push	 DWORD PTR $T100349[ebp]
  00633	8d 4d d4	 lea	 ecx, DWORD PTR _str_mmldir$24039[ebp]
  00636	6a 01		 push	 1
  00638	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 349  : 			iCount++;

  0063d	47		 inc	 edi
  0063e	3b 7d 0c	 cmp	 edi, DWORD PTR _iResult$[ebp]
  00641	7c d9		 jl	 SHORT $L24041
$L24042:

; 350  : 		}
; 351  : 		m_pass_code.add(&str_mmldir);

  00643	8d 46 7c	 lea	 eax, DWORD PTR [esi+124]
  00646	50		 push	 eax
  00647	8d 7d d4	 lea	 edi, DWORD PTR _str_mmldir$24039[ebp]
  0064a	e8 00 00 00 00	 call	 ?add@SearchPass@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; SearchPass::add

; 352  : 		m_pass_dmc.add(&str_mmldir);

  0064f	8d 86 8c 00 00
	00		 lea	 eax, DWORD PTR [esi+140]
  00655	50		 push	 eax
  00656	e8 00 00 00 00	 call	 ?add@SearchPass@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; SearchPass::add

; 353  : 		m_pass_inc.add(&str_mmldir);

  0065b	8d 86 9c 00 00
	00		 lea	 eax, DWORD PTR [esi+156]
  00661	50		 push	 eax
  00662	e8 00 00 00 00	 call	 ?add@SearchPass@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; SearchPass::add

; 354  : 	}

  00667	53		 push	 ebx
  00668	6a 01		 push	 1
  0066a	8d 4d d4	 lea	 ecx, DWORD PTR _str_mmldir$24039[ebp]
  0066d	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00671	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
$L100351:

; 355  : 
; 356  : 	//優先順位３　環境変数で指定のパス
; 357  : 	m_pass_code.add(getenv("PATH"));

  00676	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04HBHDLLBA@PATH?$AA@
  0067b	e8 00 00 00 00	 call	 _getenv
  00680	59		 pop	 ecx
  00681	8d 7e 7c	 lea	 edi, DWORD PTR [esi+124]
  00684	57		 push	 edi
  00685	8b c8		 mov	 ecx, eax
  00687	e8 00 00 00 00	 call	 ?add@SearchPass@@QAEXPAD@Z ; SearchPass::add

; 358  : 	m_pass_dmc.add(getenv("DMC_INCLUDE"));

  0068c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@ECJCKIFH@DMC_INCLUDE?$AA@
  00691	e8 00 00 00 00	 call	 _getenv
  00696	59		 pop	 ecx
  00697	8d 8e 8c 00 00
	00		 lea	 ecx, DWORD PTR [esi+140]
  0069d	51		 push	 ecx
  0069e	8b c8		 mov	 ecx, eax
  006a0	e8 00 00 00 00	 call	 ?add@SearchPass@@QAEXPAD@Z ; SearchPass::add

; 359  : 
; 360  : 	//優先順位４　オプションで指定のパス
; 361  : 	m_pass_code.add(&str_code);

  006a5	57		 push	 edi
  006a6	8d 7d b8	 lea	 edi, DWORD PTR _str_code$[ebp]
  006a9	e8 00 00 00 00	 call	 ?add@SearchPass@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; SearchPass::add

; 362  : 	m_pass_dmc.add(&str_dmc);

  006ae	8d 86 8c 00 00
	00		 lea	 eax, DWORD PTR [esi+140]
  006b4	50		 push	 eax
  006b5	8d 7d 80	 lea	 edi, DWORD PTR _str_dmc$[ebp]
  006b8	e8 00 00 00 00	 call	 ?add@SearchPass@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; SearchPass::add

; 363  : 	m_pass_inc.add(&str_inc);

  006bd	8d 86 9c 00 00
	00		 lea	 eax, DWORD PTR [esi+156]
  006c3	50		 push	 eax
  006c4	8d 7d 9c	 lea	 edi, DWORD PTR _str_inc$[ebp]
  006c7	e8 00 00 00 00	 call	 ?add@SearchPass@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; SearchPass::add

; 364  : 
; 365  : 
; 366  : 
; 367  : 	//----------------------------------
; 368  : 	//◆
; 369  : 
; 370  : 	//	to do	その他のオプションを追加したときは、この辺に追記する。
; 371  : 
; 372  : 	//----------
; 373  : 	//Debug用 表示
; 374  : //	cout << "MML = " << strMMLname << endl;
; 375  : //	cout << "NSF = " << strNSFname << endl;
; 376  : //	cout << "BIN = " << strBINname << endl;
; 377  : //	cout << "ASM = " << strASMname << endl;
; 378  : //	cout << "C   = " << strCname << endl;
; 379  : 
; 380  : /*
; 381  : 	cout << "code:" << endl;
; 382  : 	m_pass_code.debug();
; 383  : 
; 384  : 	cout << "dmc:" << endl;
; 385  : 	m_pass_dmc.debug();
; 386  : 
; 387  : 	cout << "inc:" << endl;
; 388  : 	m_pass_inc.debug();
; 389  : */
; 390  : 
; 391  : };

  006cc	53		 push	 ebx
  006cd	6a 01		 push	 1
  006cf	8d 4d 9c	 lea	 ecx, DWORD PTR _str_inc$[ebp]
  006d2	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  006d7	53		 push	 ebx
  006d8	6a 01		 push	 1
  006da	8d 4d 80	 lea	 ecx, DWORD PTR _str_dmc$[ebp]
  006dd	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  006e2	53		 push	 ebx
  006e3	6a 01		 push	 1
  006e5	8d 4d b8	 lea	 ecx, DWORD PTR _str_code$[ebp]
  006e8	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  006ed	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  006f0	5f		 pop	 edi
  006f1	8b c6		 mov	 eax, esi
  006f3	5e		 pop	 esi
  006f4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  006fb	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006fe	5b		 pop	 ebx
  006ff	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00704	c9		 leave
  00705	c2 0c 00	 ret	 12			; 0000000cH
$L24024:

; 299  : 	};
; 300  : 
; 301  : 	//----------------------------------
; 302  : 	//◆オプションで指定された事を処理する。
; 303  : 
; 304  : 	//--------------
; 305  : 	//ヘルプ表示
; 306  : 	//ファイル名が書かれなかった場合も、ヘルプを表示する。
; 307  : 	if((fHelp==1)||(strMMLname.empty())){print_help();};

  00708	e8 00 00 00 00	 call	 ?print_help@OPSW@@AAEXXZ ; OPSW::print_help
$L100407:
$L100399:
$L100404:

; 364  : 
; 365  : 
; 366  : 
; 367  : 	//----------------------------------
; 368  : 	//◆
; 369  : 
; 370  : 	//	to do	その他のオプションを追加したときは、この辺に追記する。
; 371  : 
; 372  : 	//----------
; 373  : 	//Debug用 表示
; 374  : //	cout << "MML = " << strMMLname << endl;
; 375  : //	cout << "NSF = " << strNSFname << endl;
; 376  : //	cout << "BIN = " << strBINname << endl;
; 377  : //	cout << "ASM = " << strASMname << endl;
; 378  : //	cout << "C   = " << strCname << endl;
; 379  : 
; 380  : /*
; 381  : 	cout << "code:" << endl;
; 382  : 	m_pass_code.debug();
; 383  : 
; 384  : 	cout << "dmc:" << endl;
; 385  : 	m_pass_dmc.debug();
; 386  : 
; 387  : 	cout << "inc:" << endl;
; 388  : 	m_pass_inc.debug();
; 389  : */
; 390  : 
; 391  : };

  0070d	00 00 00 00	 DD	 $L23939
  00711	00 00 00 00	 DD	 $L23958
  00715	00 00 00 00	 DD	 $L23979
  00719	00 00 00 00	 DD	 $L23962
  0071d	00 00 00 00	 DD	 $L23960
  00721	00 00 00 00	 DD	 $L23982
  00725	00 00 00 00	 DD	 $L23981
  00729	00 00 00 00	 DD	 $L23969
  0072d	00 00 00 00	 DD	 $L23959
  00731	00 00 00 00	 DD	 $L23940
  00735	00 00 00 00	 DD	 $L23980
  00739	00 00 00 00	 DD	 $L23961
  0073d	00 00 00 00	 DD	 $L24011
$L100388:
  00741	00		 DB	 0
  00742	0c		 DB	 12			; 0000000cH
  00743	01		 DB	 1
  00744	0c		 DB	 12			; 0000000cH
  00745	02		 DB	 2
  00746	03		 DB	 3
  00747	04		 DB	 4
  00748	05		 DB	 5
  00749	0c		 DB	 12			; 0000000cH
  0074a	00		 DB	 0
  0074b	06		 DB	 6
  0074c	0c		 DB	 12			; 0000000cH
  0074d	0c		 DB	 12			; 0000000cH
  0074e	07		 DB	 7
  0074f	0c		 DB	 12			; 0000000cH
  00750	08		 DB	 8
  00751	09		 DB	 9
  00752	0a		 DB	 10			; 0000000aH
  00753	0c		 DB	 12			; 0000000cH
  00754	0c		 DB	 12			; 0000000cH
  00755	0b		 DB	 11			; 0000000bH
  00756	0c		 DB	 12			; 0000000cH
  00757	0c		 DB	 12			; 0000000cH
  00758	0c		 DB	 12			; 0000000cH
  00759	0c		 DB	 12			; 0000000cH
  0075a	0c		 DB	 12			; 0000000cH
  0075b	0c		 DB	 12			; 0000000cH
  0075c	0c		 DB	 12			; 0000000cH
  0075d	0c		 DB	 12			; 0000000cH
  0075e	0c		 DB	 12			; 0000000cH
  0075f	0c		 DB	 12			; 0000000cH
  00760	0c		 DB	 12			; 0000000cH
  00761	0c		 DB	 12			; 0000000cH
  00762	0c		 DB	 12			; 0000000cH
  00763	01		 DB	 1
  00764	0c		 DB	 12			; 0000000cH
  00765	02		 DB	 2
  00766	0c		 DB	 12			; 0000000cH
  00767	04		 DB	 4
  00768	05		 DB	 5
  00769	0c		 DB	 12			; 0000000cH
  0076a	00		 DB	 0
  0076b	06		 DB	 6
  0076c	0c		 DB	 12			; 0000000cH
  0076d	0c		 DB	 12			; 0000000cH
  0076e	07		 DB	 7
  0076f	0c		 DB	 12			; 0000000cH
  00770	08		 DB	 8
  00771	09		 DB	 9
  00772	0a		 DB	 10			; 0000000aH
  00773	0c		 DB	 12			; 0000000cH
  00774	0c		 DB	 12			; 0000000cH
  00775	0b		 DB	 11			; 0000000bH
$L100187:
  00437	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0043a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0043d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L100188:
  00442	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00445	83 c1 28	 add	 ecx, 40			; 00000028H
  00448	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L100189:
  0044d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00450	83 c1 44	 add	 ecx, 68			; 00000044H
  00453	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L100190:
  00458	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0045b	83 c1 60	 add	 ecx, 96			; 00000060H
  0045e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L100191:
  00463	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00466	83 c0 7c	 add	 eax, 124		; 0000007cH
  00469	50		 push	 eax
  0046a	e8 00 00 00 00	 call	 ??1SearchPass@@QAE@XZ	; SearchPass::~SearchPass
  0046f	c3		 ret	 0
$L100192:
  00470	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00473	05 8c 00 00 00	 add	 eax, 140		; 0000008cH
  00478	50		 push	 eax
  00479	e8 00 00 00 00	 call	 ??1SearchPass@@QAE@XZ	; SearchPass::~SearchPass
  0047e	c3		 ret	 0
$L100193:
  0047f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00482	05 9c 00 00 00	 add	 eax, 156		; 0000009cH
  00487	50		 push	 eax
  00488	e8 00 00 00 00	 call	 ??1SearchPass@@QAE@XZ	; SearchPass::~SearchPass
  0048d	c3		 ret	 0
$L100194:
  0048e	8d 4d b8	 lea	 ecx, DWORD PTR _str_code$[ebp]
  00491	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L100195:
  00496	8d 4d 80	 lea	 ecx, DWORD PTR _str_dmc$[ebp]
  00499	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L100196:
  0049e	8d 4d 9c	 lea	 ecx, DWORD PTR _str_inc$[ebp]
  004a1	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L100197:
  004a6	8d 4d d4	 lea	 ecx, DWORD PTR _str_mmldir$24039[ebp]
  004a9	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0OPSW@@QAE@HQAPAD@Z:
  004ae	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T100363
  004b3	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
??0OPSW@@QAE@HQAPAD@Z ENDP				; OPSW::OPSW
END
