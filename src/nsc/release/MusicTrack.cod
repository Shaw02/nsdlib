PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::end
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
PUBLIC	?pop_back@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::pop_back
PUBLIC	??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::iterator::iterator
PUBLIC	??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::vector<int,std::allocator<int> >::iterator::operator*
PUBLIC	??Fiterator@?$vector@HV?$allocator@H@std@@@std@@QAE?AV012@H@Z ; std::vector<int,std::allocator<int> >::iterator::operator--
PUBLIC	??0?$list@IV?$allocator@I@std@@@std@@QAE@XZ	; std::list<unsigned int,std::allocator<unsigned int> >::list<unsigned int,std::allocator<unsigned int> >
PUBLIC	??1?$list@IV?$allocator@I@std@@@std@@QAE@XZ	; std::list<unsigned int,std::allocator<unsigned int> >::~list<unsigned int,std::allocator<unsigned int> >
PUBLIC	?end@?$list@IV?$allocator@I@std@@@std@@QAE?AViterator@12@XZ ; std::list<unsigned int,std::allocator<unsigned int> >::end
PUBLIC	?push_back@?$list@IV?$allocator@I@std@@@std@@QAEXABI@Z ; std::list<unsigned int,std::allocator<unsigned int> >::push_back
PUBLIC	?pop_back@?$list@IV?$allocator@I@std@@@std@@QAEXXZ ; std::list<unsigned int,std::allocator<unsigned int> >::pop_back
PUBLIC	??0?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >
PUBLIC	??1?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::~list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >
PUBLIC	?end@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE?AViterator@12@XZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::end
PUBLIC	?push_back@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXABViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::push_back
PUBLIC	?pop_back@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXXZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::pop_back
PUBLIC	??0iterator@?$list@IV?$allocator@I@std@@@std@@QAE@XZ ; std::list<unsigned int,std::allocator<unsigned int> >::iterator::iterator
PUBLIC	??Diterator@?$list@IV?$allocator@I@std@@@std@@QBEAAIXZ ; std::list<unsigned int,std::allocator<unsigned int> >::iterator::operator*
PUBLIC	??Fiterator@?$list@IV?$allocator@I@std@@@std@@QAE?AV012@H@Z ; std::list<unsigned int,std::allocator<unsigned int> >::iterator::operator--
PUBLIC	??0iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::iterator::iterator
PUBLIC	??Diterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QBEAAV0?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@XZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::iterator::operator*
PUBLIC	??Fiterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE?AV012@H@Z ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::iterator::operator--
PUBLIC	??0?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::vector<mml_Address *,std::allocator<mml_Address *> >
PUBLIC	??1?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::~vector<mml_Address *,std::allocator<mml_Address *> >
PUBLIC	?begin@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::begin
PUBLIC	?end@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::end
PUBLIC	?empty@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBE_NXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::empty
PUBLIC	?push_back@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEXABQAVmml_Address@@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::push_back
PUBLIC	??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
PUBLIC	??Fiterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE?AV012@H@Z ; std::list<MusicItem *,std::allocator<MusicItem *> >::iterator::operator--
PUBLIC	??0iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::iterator
PUBLIC	??Diterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEAAPAVmml_Address@@XZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::operator*
PUBLIC	??Eiterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE?AV012@H@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::operator++
PUBLIC	??9const_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBE_NABV012@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::const_iterator::operator!=
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
PUBLIC	??0?$allocator@I@std@@QAE@XZ			; std::allocator<unsigned int>::allocator<unsigned int>
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
PUBLIC	?empty@?$vector@HV?$allocator@H@std@@@std@@QBE_NXZ ; std::vector<int,std::allocator<int> >::empty
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z ; std::vector<int,std::allocator<int> >::insert
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
PUBLIC	??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::vector<int,std::allocator<int> >::iterator::iterator
PUBLIC	??Fiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ; std::vector<int,std::allocator<int> >::iterator::operator--
PUBLIC	??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator
PUBLIC	??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::vector<int,std::allocator<int> >::const_iterator::operator*
PUBLIC	?_Insert@?$list@IV?$allocator@I@std@@@std@@QAEXViterator@12@ABI@Z ; std::list<unsigned int,std::allocator<unsigned int> >::_Insert
PUBLIC	?erase@?$list@IV?$allocator@I@std@@@std@@QAE?AViterator@12@V312@@Z ; std::list<unsigned int,std::allocator<unsigned int> >::erase
PUBLIC	?_Buynode@?$list@IV?$allocator@I@std@@@std@@IAEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@XZ ; std::list<unsigned int,std::allocator<unsigned int> >::_Buynode
PUBLIC	?_Tidy@?$list@IV?$allocator@I@std@@@std@@IAEXXZ	; std::list<unsigned int,std::allocator<unsigned int> >::_Tidy
PUBLIC	??0?$_List_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_List_val<unsigned int,std::allocator<unsigned int> >::_List_val<unsigned int,std::allocator<unsigned int> >
PUBLIC	?_Insert@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXViterator@12@ABV3?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Insert
PUBLIC	?erase@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE?AViterator@12@V312@@Z ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::erase
PUBLIC	?_Buynode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@XZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Buynode
PUBLIC	?_Tidy@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEXXZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Tidy
PUBLIC	??0?$_List_val@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAE@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z ; std::_List_val<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_List_val<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >
PUBLIC	??0?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QAE@XZ ; std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator>::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator>
PUBLIC	??0iterator@?$list@IV?$allocator@I@std@@@std@@QAE@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z ; std::list<unsigned int,std::allocator<unsigned int> >::iterator::iterator
PUBLIC	??Fiterator@?$list@IV?$allocator@I@std@@@std@@QAEAAV012@XZ ; std::list<unsigned int,std::allocator<unsigned int> >::iterator::operator--
PUBLIC	??0const_iterator@?$list@IV?$allocator@I@std@@@std@@QAE@XZ ; std::list<unsigned int,std::allocator<unsigned int> >::const_iterator::const_iterator
PUBLIC	??Dconst_iterator@?$list@IV?$allocator@I@std@@@std@@QBEABIXZ ; std::list<unsigned int,std::allocator<unsigned int> >::const_iterator::operator*
PUBLIC	??0iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::iterator::iterator
PUBLIC	??Fiterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEAAV012@XZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::iterator::operator--
PUBLIC	??0const_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::const_iterator::const_iterator
PUBLIC	??Dconst_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QBEABViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@XZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::const_iterator::operator*
PUBLIC	?capacity@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::capacity
PUBLIC	?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
PUBLIC	?insert@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE?AViterator@12@V312@ABQAVmml_Address@@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::insert
PUBLIC	?_Buy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAE_NI@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Buy
PUBLIC	?_Tidy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Tidy
PUBLIC	?_Ufill@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEPAPAVmml_Address@@PAPAV3@IABQAV3@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Ufill
PUBLIC	??0?$_Vector_val@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAE@V?$allocator@PAVmml_Address@@@1@@Z ; std::_Vector_val<mml_Address *,std::allocator<mml_Address *> >::_Vector_val<mml_Address *,std::allocator<mml_Address *> >
PUBLIC	??0?$allocator@PAVmml_Address@@@std@@QAE@XZ	; std::allocator<mml_Address *>::allocator<mml_Address *>
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Key
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::end
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBIPAVPatch@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::insert
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::lower_bound
PUBLIC	??Fiterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEAAV012@XZ ; std::list<MusicItem *,std::allocator<MusicItem *> >::iterator::operator--
PUBLIC	??0iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@PAPAVmml_Address@@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::iterator
PUBLIC	??Eiterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEAAV012@XZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::operator++
PUBLIC	??0const_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::const_iterator::const_iterator
PUBLIC	??Dconst_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEABQAVmml_Address@@XZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::const_iterator::operator*
PUBLIC	??8const_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBE_NABV012@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::const_iterator::operator==
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBIPAVPatch@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::iterator::operator*
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::operator==
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::_Mynode
PUBLIC	??0?$pair@$$CBIPAVPatch@@@std@@QAE@ABIABQAVPatch@@@Z ; std::pair<unsigned int const ,Patch *>::pair<unsigned int const ,Patch *>
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
PUBLIC	??0?$allocator@I@std@@QAE@ABV01@@Z		; std::allocator<unsigned int>::allocator<unsigned int>
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ; std::vector<int,std::allocator<int> >::begin
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z ; std::vector<int,std::allocator<int> >::iterator::operator+
PUBLIC	??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<int,std::allocator<int> >::iterator::operator-
PUBLIC	??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator
PUBLIC	?_Nextnode@?$list@IV?$allocator@I@std@@@std@@KAAAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@PAU342@@Z ; std::list<unsigned int,std::allocator<unsigned int> >::_Nextnode
PUBLIC	?_Prevnode@?$list@IV?$allocator@I@std@@@std@@KAAAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@PAU342@@Z ; std::list<unsigned int,std::allocator<unsigned int> >::_Prevnode
PUBLIC	?_Myval@?$list@IV?$allocator@I@std@@@std@@KAAAIPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z ; std::list<unsigned int,std::allocator<unsigned int> >::_Myval
PUBLIC	?clear@?$list@IV?$allocator@I@std@@@std@@QAEXXZ	; std::list<unsigned int,std::allocator<unsigned int> >::clear
PUBLIC	?_Buynode@?$list@IV?$allocator@I@std@@@std@@IAEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@PAU342@0ABI@Z ; std::list<unsigned int,std::allocator<unsigned int> >::_Buynode
PUBLIC	?_Incsize@?$list@IV?$allocator@I@std@@@std@@IAEXI@Z ; std::list<unsigned int,std::allocator<unsigned int> >::_Incsize
PUBLIC	??0?$_List_ptr@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_List_ptr<unsigned int,std::allocator<unsigned int> >::_List_ptr<unsigned int,std::allocator<unsigned int> >
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@I@Z ; std::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node>::deallocate
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@I@Z ; std::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node>::allocate
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z ; std::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node>::destroy
PUBLIC	?construct@?$allocator@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node *>::construct
PUBLIC	?destroy@?$allocator@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z ; std::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node *>::destroy
PUBLIC	?_Nextnode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@KAAAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@PAU342@@Z ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Nextnode
PUBLIC	?_Prevnode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@KAAAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@PAU342@@Z ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Prevnode
PUBLIC	?_Myval@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@KAAAViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Myval
PUBLIC	?clear@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXXZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::clear
PUBLIC	?_Buynode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@PAU342@0ABViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Buynode
PUBLIC	?_Incsize@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEXI@Z ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Incsize
PUBLIC	??0?$_List_ptr@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAE@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z ; std::_List_ptr<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_List_ptr<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >
PUBLIC	??0?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator>::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator>
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEXPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@I@Z ; std::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node>::deallocate
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@I@Z ; std::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node>::allocate
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEXPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z ; std::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node>::destroy
PUBLIC	?construct@?$allocator@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node *>::construct
PUBLIC	?destroy@?$allocator@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z ; std::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node *>::destroy
PUBLIC	??Eiterator@?$list@IV?$allocator@I@std@@@std@@QAE?AV012@H@Z ; std::list<unsigned int,std::allocator<unsigned int> >::iterator::operator++
PUBLIC	??0const_iterator@?$list@IV?$allocator@I@std@@@std@@QAE@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z ; std::list<unsigned int,std::allocator<unsigned int> >::const_iterator::const_iterator
PUBLIC	??Fconst_iterator@?$list@IV?$allocator@I@std@@@std@@QAEAAV012@XZ ; std::list<unsigned int,std::allocator<unsigned int> >::const_iterator::operator--
PUBLIC	?_Mynode@const_iterator@?$list@IV?$allocator@I@std@@@std@@QBEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@3@XZ ; std::list<unsigned int,std::allocator<unsigned int> >::const_iterator::_Mynode
PUBLIC	??Eiterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE?AV012@H@Z ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::iterator::operator++
PUBLIC	??0const_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::const_iterator::const_iterator
PUBLIC	??Fconst_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEAAV012@XZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::const_iterator::operator--
PUBLIC	?_Mynode@const_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QBEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@3@XZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::const_iterator::_Mynode
PUBLIC	?max_size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::max_size
PUBLIC	?_Destroy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXPAPAVmml_Address@@0@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Destroy
PUBLIC	?_Insert_n@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXViterator@12@IABQAVmml_Address@@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Insert_n
PUBLIC	?_Xlen@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IBEXXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Xlen
PUBLIC	??0?$allocator@PAVmml_Address@@@std@@QAE@ABV01@@Z ; std::allocator<mml_Address *>::allocator<mml_Address *>
PUBLIC	?deallocate@?$allocator@PAVmml_Address@@@std@@QAEXPAPAVmml_Address@@I@Z ; std::allocator<mml_Address *>::deallocate
PUBLIC	?allocate@?$allocator@PAVmml_Address@@@std@@QAEPAPAVmml_Address@@I@Z ; std::allocator<mml_Address *>::allocate
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Isnil
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Right
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVPatch@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Myval
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::begin
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::size
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIPAVPatch@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::insert
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIPAVPatch@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Insert
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Lbound
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Rmost
PUBLIC	?_Kfn@?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@SAABIABU?$pair@$$CBIPAVPatch@@@2@@Z ; std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0>::_Kfn
PUBLIC	??Fconst_iterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEAAV012@XZ ; std::list<MusicItem *,std::allocator<MusicItem *> >::const_iterator::operator--
PUBLIC	??Hiterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBE?AV012@H@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::operator+
PUBLIC	??Giterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::operator-
PUBLIC	??0const_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@PAPAVmml_Address@@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::const_iterator::const_iterator
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::iterator::iterator
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::iterator::iterator
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::iterator::operator++
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::iterator::operator--
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBIPAVPatch@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::operator*
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
PUBLIC	??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z ; std::vector<int,std::allocator<int> >::iterator::operator+=
PUBLIC	??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z ; std::vector<int,std::allocator<int> >::const_iterator::operator-
PUBLIC	?max_size@?$list@IV?$allocator@I@std@@@std@@QBEIXZ ; std::list<unsigned int,std::allocator<unsigned int> >::max_size
PUBLIC	??0?$_List_nod@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_List_nod<unsigned int,std::allocator<unsigned int> >::_List_nod<unsigned int,std::allocator<unsigned int> >
PUBLIC	?max_size@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QBEIXZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::max_size
PUBLIC	??0?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAE@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z ; std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >
PUBLIC	??Eiterator@?$list@IV?$allocator@I@std@@@std@@QAEAAV012@XZ ; std::list<unsigned int,std::allocator<unsigned int> >::iterator::operator++
PUBLIC	??Eiterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEAAV012@XZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::iterator::operator++
PUBLIC	?max_size@?$allocator@PAVmml_Address@@@std@@QBEIXZ ; std::allocator<mml_Address *>::max_size
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Color
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Left
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Parent
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::max_size
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Lmost
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Lrotate
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Root
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Root
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Rrotate
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVPatch@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Buynode
PUBLIC	??Yiterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEAAV012@H@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::operator+=
PUBLIC	??Gconst_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEHABV012@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::const_iterator::operator-
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::const_iterator
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::const_iterator
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::operator++
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::operator--
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::iterator,bool>
PUBLIC	??0_Node@?$_List_nod@IV?$allocator@I@std@@@std@@QAE@PAU012@0ABI@Z ; std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node::_Node
PUBLIC	??0_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@PAU012@0ABViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z ; std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node::_Node
PUBLIC	?max_size@?$allocator@I@std@@QBEIXZ		; std::allocator<unsigned int>::max_size
PUBLIC	?max_size@?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QBEIXZ ; std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator>::max_size
PUBLIC	??Econst_iterator@?$list@IV?$allocator@I@std@@@std@@QAEAAV012@XZ ; std::list<unsigned int,std::allocator<unsigned int> >::const_iterator::operator++
PUBLIC	??Econst_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEAAV012@XZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::const_iterator::operator++
PUBLIC	?max_size@?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned int const ,Patch *> >::max_size
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Node>::deallocate
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Node>::allocate
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::_Dec
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::_Inc
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIPAVPatch@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Node::_Node
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Max
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Min
PUBLIC	??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<int,std::allocator<int> >
PUBLIC	??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z ; std::_Uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
PUBLIC	??$_Uninitialized_fill_n@PAPAVmml_Address@@IPAV1@V?$allocator@PAVmml_Address@@@std@@@std@@YAXPAPAVmml_Address@@IABQAV1@AAV?$allocator@PAVmml_Address@@@0@@Z ; std::_Uninitialized_fill_n<mml_Address * *,unsigned int,mml_Address *,std::allocator<mml_Address *> >
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
PUBLIC	??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
PUBLIC	??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z	; std::copy_backward<int *,int *>
PUBLIC	??$?0I@?$allocator@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node *>::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node *><unsigned int>
PUBLIC	??$_Allocate@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@YAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node>
PUBLIC	??$_Destroy@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@IV?$allocator@I@std@@@0@@Z ; std::_Destroy<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node>
PUBLIC	??$_Construct@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node *,std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node *>
PUBLIC	??$_Destroy@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@0@@Z ; std::_Destroy<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node *>
PUBLIC	??$?0Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@?$allocator@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAE@ABV?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z ; std::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node *>::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node *><std::list<MusicItem *,std::allocator<MusicItem *> >::iterator>
PUBLIC	??$_Allocate@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@YAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node>
PUBLIC	??$_Destroy@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@YAXPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@0@@Z ; std::_Destroy<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node>
PUBLIC	??$_Construct@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node *,std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node *>
PUBLIC	??$_Destroy@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@YAXPAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@0@@Z ; std::_Destroy<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node *>
PUBLIC	??$_Destroy_range@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@YAXPAPAVmml_Address@@0AAV?$allocator@PAVmml_Address@@@0@@Z ; std::_Destroy_range<mml_Address *,std::allocator<mml_Address *> >
PUBLIC	??$_Ucopy@PAPAVmml_Address@@@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEPAPAVmml_Address@@PAPAV2@00@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Ucopy<mml_Address * *>
PUBLIC	??$fill@PAPAVmml_Address@@PAV1@@std@@YAXPAPAVmml_Address@@0ABQAV1@@Z ; std::fill<mml_Address * *,mml_Address *>
PUBLIC	??$copy_backward@PAPAVmml_Address@@PAPAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00@Z ; std::copy_backward<mml_Address * *,mml_Address * *>
PUBLIC	??$_Allocate@PAVmml_Address@@@std@@YAPAPAVmml_Address@@IPAPAV1@@Z ; std::_Allocate<mml_Address *>
PUBLIC	??$?0I@?$allocator@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node>::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node><unsigned int>
PUBLIC	??$?0Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@?$allocator@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAE@ABV?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z ; std::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node>::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node><std::list<MusicItem *,std::allocator<MusicItem *> >::iterator>
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Node>
PUBLIC	??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<int,std::allocator<int> >
PUBLIC	??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<int,unsigned int,int>
PUBLIC	??$_Ptr_cat@Vmml_Address@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVmml_Address@@0@Z ; std::_Ptr_cat<mml_Address>
PUBLIC	??$_Uninit_fill_n@PAVmml_Address@@IPAV1@@std@@YAXPAPAVmml_Address@@IABQAV1@AAV?$allocator@PAVmml_Address@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<mml_Address *,unsigned int,mml_Address *>
PUBLIC	??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >
PUBLIC	??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *>
PUBLIC	??$_Destroy_range@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@YAXPAPAVmml_Address@@0AAV?$allocator@PAVmml_Address@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<mml_Address *,std::allocator<mml_Address *> >
PUBLIC	??$_Uninitialized_copy@PAPAVmml_Address@@PAPAV1@V?$allocator@PAVmml_Address@@@std@@@std@@YAPAPAVmml_Address@@PAPAV1@00AAV?$allocator@PAVmml_Address@@@0@@Z ; std::_Uninitialized_copy<mml_Address * *,mml_Address * *,std::allocator<mml_Address *> >
PUBLIC	??$_Copy_backward_opt@PAPAVmml_Address@@PAPAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<mml_Address * *,mml_Address * *>
PUBLIC	??$fill_n@PAHIH@std@@YAXPAHIABH@Z		; std::fill_n<int *,unsigned int,int>
PUBLIC	??$fill_n@PAPAVmml_Address@@IPAV1@@std@@YAXPAPAVmml_Address@@IABQAV1@@Z ; std::fill_n<mml_Address * *,unsigned int,mml_Address *>
PUBLIC	??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<int,int>
PUBLIC	??$_Uninit_copy@PAVmml_Address@@PAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00AAV?$allocator@PAVmml_Address@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<mml_Address *,mml_Address *>
PUBLIC	?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z ; std::_Ptr_cat
PUBLIC	?get_sw_Evoi@Patch@@QAE_NXZ			; Patch::get_sw_Evoi
PUBLIC	?setUse@MusicItem@@QAEXXZ			; MusicItem::setUse
PUBLIC	?get@NSD_WORK@@QAEXPAV1@@Z			; NSD_WORK::get
PUBLIC	?set@NSD_WORK@@QAEXPAV1@@Z			; NSD_WORK::set
PUBLIC	?Reset_opt@MusicTrack@@QAEXXZ			; MusicTrack::Reset_opt
PUBLIC	?init@NSD_WORK@@QAEXXZ				; NSD_WORK::init
PUBLIC	??1NSD_WORK@@QAE@XZ				; NSD_WORK::~NSD_WORK
PUBLIC	??0NSD_WORK@@QAE@XZ				; NSD_WORK::NSD_WORK
; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\MusicTrack.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
;	COMDAT ??_C@_19HGHALIPE@?$AAN?$AAu?$AAl?$AAl?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BG@DLEDEKK@?$AA?$CJuj0L?$FLXW?$CI0W0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_19IKFMBMLG@?$AAS?$AAu?$AAb?$AA?$CI?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BE@IGMADMH@?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$CI?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1M@PLMGIHGM@?$AAF?$AAD?$AAS?$AAC?$AA?$CI?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1M@MBMMOGBM@?$AAF?$AAD?$AAS?$AAM?$AA?$CI?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1M@DBGGOFMD@?$AAV?$AAR?$AAC?$AA7?$AA?$CI?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1M@HOIDBMFA@?$AAN?$AA1?$AA6?$AA3?$AA?$CI?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_17HLGHMILN@?$AAS?$AAE?$AA?$CI?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CE@JMOHEOPF@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJ0L?$HNB0?$IP0c0f0D0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CE@IJKNAFJK@0?j0?T0?$PM0?H?$AA?$CI?$AAC?$AA?$CJ0L?$HNB0?$IP0c0f0D0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BK@OCDBGHAP@?$AAE?$AAn?$AAd?$AA?5?$AAo?$AAf?$AA?5?$AAT?$AAr?$AAa?$AAc?$AAk?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CO@IIMELFGG@?$AAE?$AAn?$AAd?$AA?5?$AAo?$AAf?$AA?5?$AAT?$AAr?$AAa?$AAc?$AAk?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAL?$AAO@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CA@JPKIEODC@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAB?$AA?$CJ?$AA?5?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CC@KDMBBGBP@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAB?$AA?$CJ?$AA?5?$AAB?$AAr?$AAa?$AAn?$AAc?$AAh?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DE@EIMDGIFC@0?j0?T0?$PM0?H?$AA?$CI?$AAB?$AA?$CJQ?$IF0g?$AA?5?$AA?2?$AA?50?$LD0?$NO0?s0?I0L?$JB?M?$IJ?$AH0W@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DE@NPLPFED@0?j0?T0?$PM0?H?$AA?$CI?$AAB?$AA?$CJ0n?$JF?$ILY?K?$AA?5?$AA?$HM?$AA?3?$AA?50?$LD0?$NO0?s0?I0L0B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CC@DHDLBODE@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJ0nS?3?$JF?$JD0n?$JA?$BEN?90g0Y0?$AC?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BM@EDCBEBGE@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAB?$AA?$CJ?$AA?5?$AAE?$AAn?$AAd?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1FK@BKKHDBPB@0?j0?T0?$PM0?H?$AA?$CI?$AAB?$AA?$CJQ?$IF0g?$AA?5?$AA?2?$AA?50?$LD0?$NO0?s0?I0L0B0?$IK0?$HO@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DC@JAEEIEKF@0?j0?T0?$PM0?HV?$NOep0o?$AA2?$PP?$FO?$AA2?$AA5?$AA50n?$HL?DV?r0gc?$AH?$FL?$JK0W0f@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CG@DHEAMNDG@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJ0n0?M0?$LJ0?H0o0g0M0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CA@HFCOJDFA@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAA?$AA?$CJ?$AA?5?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CC@MGIFLNF@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAA?$AA?$CJ?$AA?5?$AAB?$AAr?$AAa?$AAn?$AAc?$AAh?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DE@HGGAJCGI@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJQ?$IF0g?$AA?5?$AA?3?$AA?50?$LD0?$NO0?s0?I0L?$JB?M?$IJ?$AH0W@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DC@IPGNKEJP@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJ0n?$JF?$ILY?K?$AA?5?$AA?$FL?$AA?50?$LD0?$NO0?s0?I0L0B0?$IK@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DE@OPGCJNPF@0?j0?T0?$PM0?H?$AA?$CI?$AAC?$AA?$CJQ?$IF0g?$AA?5?$AA?3?$AA?50?$LD0?$NO0?s0?I0L?$JB?M?$IJ?$AH0W@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DE@PIDIKAJB@0?j0?T0?$PM0?H?$AA?$CI?$AAC?$AA?$CJ0n?$JF?$ILY?K?$AA?5?$AA?$FL?$AA?3?$AA?50?$LD0?$NO0?s0?I0L0B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CE@PJCEBMDC@0?j0?T0?$PM0?H?$JF?$ILY?K0?$LD0?$NO0?s0?I0L0B0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CC@FCKGONLL@0?j0?T0?$PM0?HV?$NOep0n?$IK?$BI?$IP?p0L0B0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CI@IJNCMADK@0?j0?T0?$PM0?HV?$NOep0LN?$CBe?$LJ0k?$IK?$BI?$IP?p0U0?$IM0f0D0?$HO0Y0?$AC?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BM@DPEAGELP@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAA?$AA?$CJ?$AA?5?$AAE?$AAn?$AAd?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BA@GCDNCJOK@?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BA@LDPMAPOD@?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BA@DMAFONIK@?$AAC?$AAa?$AAl?$AAl?$AA?5?$AAS?$AAE?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BG@DLCGAOAF@?$AAS?$AAu?$AAb?$AAr?$AAo?$AAu?$AAt?$AAi?$AAn?$AAe?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CK@JNKNAIAA@?$AAS?$AAu?$AAb?$AAr?$AAo?$AAu?$AAt?$AAi?$AAn?$AAe?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAP?$AAa?$AAt?$AAc?$AAh@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BI@EHCLFFIH@?$FLXW?$CI0W0j0D0?Q0?C0?A0g0Y0?$AC?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BO@GFLIMKC@?$AAV?$AAo?$AAi?$AAc?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CA@BOAFBFBE@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CG@HDOLOCJJ@?$AAF?$AAr?$AAe?$AAq?$AAu?$AAe?$AAn?$AAc?$AAy?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BM@CBOHIOMD@?$AAN?$AAo?$AAt?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1M@DKLMFINE@?$AAV?$AAo?$AAi?$AAc?$AAe?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CI@DNAKKDOB@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?5?$AAO?$AAf?$AAf?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CO@BJABPOLD@?$AAF?$AAr?$AAe?$AAq?$AAu?$AAe?$AAn?$AAc?$AAy?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?5?$AAO@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CE@KEOAGLPM@?$AAN?$AAo?$AAt?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?5?$AAO?$AAf?$AAf?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1M@HAFHLPCH@?$AAS?$AAw?$AAe?$AAe?$AAp?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CM@GOJLGHKM@?$AAF?$AAD?$AAS?$AA?5?$AAc?$AAa?$AAr?$AAe?$AAe?$AAr?$AA?5?$AAw?$AAa?$AAv?$AAe?$AA?5?$AAt?$AAa?$AAb?$AAl@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DC@IBICFHPL@?$AAF?$AAD?$AAS?$AA?5?$AAm?$AAo?$AAd?$AAu?$AAl?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAw?$AAa?$AAv?$AAe?$AA?5?$AAt@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CM@FAPBPOGD@?$AAV?$AAR?$AAC?$AA7?$AA?5?$AAu?$AAs?$AAe?$AAr?$AA?5?$AAi?$AAn?$AAs?$AAt?$AAr?$AAu?$AAm?$AAe?$AAn?$AAt@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CA@NKOKHIPN@?$AAn?$AA1?$AA6?$AA3?$AA?5?$AAw?$AAa?$AAv?$AAe?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1EA@CPIKLJAL@?$AA?$EA?$AAN?$AA?50?$LD0?$NO0?s0?I0n0?Q0?i0?a0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CO@PCFIGAHG@?$AAJ0?$LD0?$NO0?s0?I0o?$AA0?$PP?$FO?$AA10n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O0?$GA0U@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CC@EMHPIIFB@?$AAG?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AA?$CI?$AAq?$AA?$CJ?$AA?5?$AAB?$AAy?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BI@DCFFOBJ@?$AAG?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AA?$CI?$AAq?$AA?$CJ?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BI@IPILGHHC@?$AAG?$AAa?$AAt?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DI@HCGIJCFJ@0?$LC0?$PM0?H0?$LP0?$KE0?$OA?$AAQ0o?$AA1?$PP?$FO?$AA?$CD?$AAQ?$AAM?$AAa?$AAx0n?$HL?DV?r0gc?$AH@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DE@DMILNHDF@0?$LC0?$PM0?H0?$LP0?$KE0?$OA?$AAq0o?$AA0?$PP?$FO?$AA2?$AA5?$AA50n?$HL?DV?r0gc?$AH?$FL?$JK0W@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BG@CIPPAIIN@?$AAG?$AAa?$AAt?$AAe?$AAM?$AAo?$AAd?$AAe?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BG@JAEDGPOI@?$AAG?$AAa?$AAt?$AAe?$AAM?$AAo?$AAd?$AAe?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BG@ICPGMAAG@?$AAG?$AAa?$AAt?$AAe?$AAM?$AAo?$AAd?$AAe?$AA?5?$AA2?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DC@NMCJFJGP@0?j0?j0?$PM0?$LJ0?b0?$PM0?I0o?$AA0?$PP?$FO?$AA20n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BM@LPHMCIPB@?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?5?$AAV?$AAo?$AAi?$AAc?$AAe?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DA@NPNLAEDI@0?j0?j0?$PM0?$LJ?$JH?s?$ICr0o?$AA0?$PP?$FO?$AA70n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O0?$GA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BO@IEEELBMO@?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?5?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CK@OMCJIBOF@?$JH?s?$JB?O0o?$AA0?$PP?$FO?$AA1?$AA50n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O0?$GA0U0D0?$AC@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05KFOFLDIO@C?9Dur?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06DNHFJLJE@Ds?9Dur?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BCGGFLM@Des?9Dur?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LIOAIDDG@D?9Dur?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06JLACJACA@Es?9Dur?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05HDLMFAJD@E?9Dur?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05PFCICCDN@F?9Dur?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07IEKDAILF@Fis?9Dur?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06MJNIBAJ@Gs?9Dur?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07IPKJGCFP@Ges?9Dur?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05DOHEPBJI@G?9Dur?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06GPENLEDD@As?9Dur?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05OICNBCIF@A?9Dur?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05GOLJGACL@B?9Dur?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FOKFKOKO@Bs?9Dur?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MPCCEDEN@H?9Dur?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06OJJNCCFH@c?9moll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08FPGMHDLI@cis?9moll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CMDKBMNJ@d?9moll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08DLANBOHB@dis?9moll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07OOAGBAFB@es?9moll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06IKENBHGN@e?9moll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06LLKFANPA@f?9moll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08BFPLDGPH@fis?9moll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06BNNCAGEE@g?9moll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08CIACCLE@gis?9moll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06HOACDDHO@a?9moll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06EPOKCJOD@b?9moll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07OEMDBJEI@bs?9moll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06OLJKHGKN@h?9moll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07CCKMBAMP@ds?9moll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08GMKCALDO@des?9moll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07KMCDBHCM@gs?9moll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08FFCPDHPL@ges?9moll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07GKEMBOKL@as?9moll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01MIFGBAGJ@?$CL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02CMICPHGH@?$IB?$HL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01IPJKGB@?$CD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02PFGEBIEE@?$IB?$JE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02GDMDGBKA@?$IB?$HM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02NPNIOFCE@?$IB?s?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01NEMOKFLO@?$DN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02MCNBPOFA@?$IB?$IB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02MHFCHKMG@?$IB?$JG?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02LJKBFKON@?$ID?$JD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02LEAGIKBB@?$IDb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02OPKIDJPP@?$IC?q?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DAOOAPAM@?$IC?A?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BILDMFBN@?$IDn?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02HMNPAABJ@?$IDj?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DGBNBCEI@?$IDz?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02IDLDGMAF@?$IDw?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02MJHBHOFE@?$IDg?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DIJJJPPC@?$IDC?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02GNOAGFDC@?$ID?$IN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DI@JCDDEPJK@?$IK?$LPS?w0?$LD0?$NO0?s0?I0?$PL0?V0?m0?C0?$KP0n?$JF?$ILY?K0?$JCy?30Y?$AA?$HL0L?$IJ?$IL@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DI@GALIBNKP@?$IK?$LPS?w0?$LD0?$NO0?s0?I0?$PL0?V0?m0?C0?$KP0n?$HNBz?o0?$JCy?30Y?$AA?$GA?$AA?$HN?$AA?8@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DM@KNFDIHJH@?$IK?$LPS?w?$AA?5?$AAK?$AA?$HL?$AA?$HN?$AA?50?$LD0?$NO0?s0?I0n_?$BFep0gg?$CKw?e0ne?$IH?$FLW@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BE@PDJGDLM@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA9?$AA6?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BE@LKFBJFJL@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA7?$AA2?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BE@FDHIAHFB@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA4?$AA8?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BE@KOKCEANK@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA3?$AA6?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BE@CBMANHIN@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA3?$AA2?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BE@MPPHFLPE@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA2?$AA4?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BE@DLFJGOC@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA1?$AA8?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BE@ODGKOBNB@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA1?$AA6?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BE@GMAIHGIG@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA1?$AA2?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BC@BACHBKJG@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA9?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BC@KIJLHNPD@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA8?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BC@EIEEAKMA@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA6?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BC@OCENMCEL@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA4?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BC@HPJKPKPC@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA3?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BC@MHCGJNJH@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA2?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BC@NFJDDCHJ@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1O@IONIPGKG@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1EE@FMLCMNNO@?$AAE?$AAC0?$LD0?$NO0?s0?I0n?$HL?0?$PP?$BB0?Q0?i0?a0?$PM0?$LP0o?$AA0?$PP?$FO?$AA2?$AA5?$AA5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1EA@ECJHFDDN@?$AAE?$AAC?$AA?50?$LD0?$NO0?s0?I0n0?Q0?i0?a0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1EE@OOLANPID@?$AAE?$AAC0?$LD0?$NO0?s0?I0n?$HL?0?$PP?$BC0?Q0?i0?a0?$PM0?$LP0o?$AA?9?$AA1?$PP?$FO?$AA1?$AA5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DK@PHOKHOEC@?$JH?sz?$AL0n?$HL?DV?r0L0?N0?$PM0?H0?J0?s0?P0?$PM?$AA0?$PP?$FO?$AA2?$AA5?$AA50n?$HL?D@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BI@EPMKAKFB@?$AAE?$AAc?$AAh?$AAo?$AA?5?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CK@JCJILIHF@?$AAO?$AAn?$AAe?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?5?$AAo?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAd?$AAo?$AAw?$AAn@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CG@IKGHOBJA@?$AAO?$AAn?$AAe?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?5?$AAo?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAu?$AAp?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BE@HOMMDOEE@?$AAE?$AAc?$AAh?$AAo?$AA?5?$AAN?$AAo?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1O@DMLCJFNF@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_19JIGFKGL@?$AAN?$AAo?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1GG@HBOGPEMM@?$AAM?$AAu?$AAs?$AAi?$AAc?$AAT?$AAr?$AAa?$AAc?$AAk?$AA?3?$AA?3?$AAS?$AAe?$AAt?$AAR?$AAe?$AAs?$AAt?$AA?$CI@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1GG@IPLHPKBL@?$AAM?$AAu?$AAs?$AAi?$AAc?$AAT?$AAr?$AAa?$AAc?$AAk?$AA?3?$AA?3?$AAS?$AAe?$AAt?$AAR?$AAe?$AAs?$AAt?$AA?$CI@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_19FAHECHIH@?$AAR?$AAe?$AAs?$AAt?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CK@DKBDHLKE@?$AAa?$AA?0?$AAb?$AA?0?$AAc?$PP?$FO?$AAg0n?$JH?sT?$AN0?$JC?$IK?$BI?$IP?p0W0f0O0?$GA0U0D0?$AC@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CM@GGEMPKPF@0?$NN0?k0?$LP0?a0?s0?H0?$LD0?$NO0?s0?I0o0?$AB?$AA?$HN0g?$JF?$IJ0X0fN?$AL0U0D@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DK@BBKDBEBK@0?$NN0?k0?$LP0?a0?s0?H0?$LD0?$NO0?s0?I0g0?$AB?$JH?s?$JFw0L?$AA2?$HL?$IHb?$EA0k?$IK?$BI@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1EC@HFJPNNCI@0?$NN0?k0?$LP0?a0?s0?H0?$LD0?$NO0?s0?I0g0?$AB0?$LC0?$PM0?H0?$LP0?$KE0?$OA0L?$AA2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BG@GGJHBHG@?$AAP?$AAo?$AAr?$AAt?$AAa?$AAm?$AAe?$AAn?$AAt?$AAo?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1EE@PLBKOKJL@0?$NN0?k0?$LP0?a0?s0?H0n?$HL?0?$AA10?Q0?i0?a0?$PM0?$LP0o?$AA0?$PP?$FO?$AA2?$AA5?$AA5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DO@OLCBIOJB@?$AAP?$AA?50?$LD0?$NO0?s0?I0n0?Q0?i0?a0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC?$PP?$BE@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1EE@IIGGDGHG@0?$NN0?k0?$LP0?a0?s0?H0n?$HL?0?$AA20?Q0?i0?a0?$PM0?$LP0o?$AA1?$PP?$FO?$AA2?$AA5?$AA6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1EK@HIFALIIE@0?$NN0?k0?$LP0?a0?s0?H0n?$HL?0?$AA30?Q0?i0?a0?$PM0?$LP0o?$AA?9?$AA1?$AA2?$AA8?$PP?$FO@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1EK@FHHEJADM@0?$NN0?k0?$LP0?a0?s0?H0n?$HL?0?$AA40?Q0?i0?a0?$PM0?$LP0o?$AA?9?$AA1?$AA2?$AA8?$PP?$FO@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DI@EBCJNIGK@0?$KN0?$PM0?$LH0?U0?H0o?$AA?9?$AA1?$AA2?$AA7?$PP?$FO?$AA1?$AA2?$AA80n?$HL?DV?r0gc?$AH?$FL?$JK@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DC@IEPABAMO@0?$KN0?$PM0?$LH0?U0?H0n?$HL?DV?r0L?$AA?9?$AA1?$AA2?$AA7?$PP?$FO?$AA1?$AA2?$AA80?$JC?$IN?$IF0H@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BE@FKDCKBLJ@?$AAT?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CG@MDOKKNHL@?$AAR?$AAe?$AAl?$AAa?$AAt?$AAi?$AAv?$AAe?$AA?5?$AAT?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1O@FEMFBHON@?$AAO?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1CO@KKLECMEI@0?$KK0?$KP0?$LP0?$PM0?V0o?$AA1?$PP?$FO?$AA80n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O0?$GA0U@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BE@JMDGIABI@?$AAO?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAU?$AAp?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BI@KEBEFOPC@?$AAO?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAD?$AAo?$AAw?$AAn?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BE@ILJOBKB@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAu?$AAp?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BI@MGACCNCM@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAd?$AAo?$AAw?$AAn?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$vector@HV?$allocator@H@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$list@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$list@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$list@IV?$allocator@I@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$list@IV?$allocator@I@std@@@std@@QAEXABI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$list@IV?$allocator@I@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXABViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$list@IV?$allocator@I@std@@@std@@QBEAAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$list@IV?$allocator@I@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QBEAAV0?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEXABQAVmml_Address@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEAAPAVmml_Address@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@I@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$vector@HV?$allocator@H@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$list@IV?$allocator@I@std@@@std@@QAEXViterator@12@ABI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$list@IV?$allocator@I@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@IV?$allocator@I@std@@@std@@IAEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$list@IV?$allocator@I@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXViterator@12@ABV3?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_val@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAE@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@IV?$allocator@I@std@@@std@@QAE@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$list@IV?$allocator@I@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$list@IV?$allocator@I@std@@@std@@QBEABIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QBEABViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE?AViterator@12@V312@ABQAVmml_Address@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEPAPAVmml_Address@@PAPAV3@IABQAV3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAE@V?$allocator@PAVmml_Address@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVmml_Address@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBIPAVPatch@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@PAPAVmml_Address@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEABQAVmml_Address@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBIPAVPatch@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBIPAVPatch@@@std@@QAE@ABIABQAVPatch@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@I@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@IV?$allocator@I@std@@@std@@KAAAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@IV?$allocator@I@std@@@std@@KAAAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@IV?$allocator@I@std@@@std@@KAAAIPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$list@IV?$allocator@I@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@IV?$allocator@I@std@@@std@@IAEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@PAU342@0ABI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Incsize@?$list@IV?$allocator@I@std@@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_ptr@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@KAAAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@KAAAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@KAAAViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@PAU342@0ABViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Incsize@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_ptr@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAE@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEXPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEXPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@IV?$allocator@I@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@IV?$allocator@I@std@@@std@@QAE@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$list@IV?$allocator@I@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$list@IV?$allocator@I@std@@@std@@QBEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QBEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXPAPAVmml_Address@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXViterator@12@IABQAVmml_Address@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVmml_Address@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVmml_Address@@@std@@QAEXPAPAVmml_Address@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAVmml_Address@@@std@@QAEPAPAVmml_Address@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVPatch@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIPAVPatch@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIPAVPatch@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@ABI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@SAABIABU?$pair@$$CBIPAVPatch@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@PAPAVmml_Address@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBIPAVPatch@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$list@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_nod@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAE@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@IV?$allocator@I@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVmml_Address@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVPatch@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_List_nod@IV?$allocator@I@std@@@std@@QAE@PAU012@0ABI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@PAU012@0ABViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@I@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$list@IV?$allocator@I@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIPAVPatch@@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E1
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAPAVmml_Address@@IPAV1@V?$allocator@PAVmml_Address@@@std@@@std@@YAXPAPAVmml_Address@@IABQAV1@AAV?$allocator@PAVmml_Address@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0I@?$allocator@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@YAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@IV?$allocator@I@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@?$allocator@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAE@ABV?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@YAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@YAXPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@YAXPAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@YAXPAPAVmml_Address@@0AAV?$allocator@PAVmml_Address@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAPAVmml_Address@@@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEPAPAVmml_Address@@PAPAV2@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAPAVmml_Address@@PAV1@@std@@YAXPAPAVmml_Address@@0ABQAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAPAVmml_Address@@PAPAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVmml_Address@@@std@@YAPAPAVmml_Address@@IPAPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0I@?$allocator@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@?$allocator@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAE@ABV?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E3
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Vmml_Address@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVmml_Address@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVmml_Address@@IPAV1@@std@@YAXPAPAVmml_Address@@IABQAV1@AAV?$allocator@PAVmml_Address@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E5
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@YAXPAPAVmml_Address@@0AAV?$allocator@PAVmml_Address@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAPAVmml_Address@@PAPAV1@V?$allocator@PAVmml_Address@@@std@@@std@@YAPAPAVmml_Address@@PAPAV1@00AAV?$allocator@PAVmml_Address@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAVmml_Address@@PAPAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAHIH@std@@YAXPAHIABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAPAVmml_Address@@IPAV1@@std@@YAXPAPAVmml_Address@@IABQAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAVmml_Address@@PAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00AAV?$allocator@PAVmml_Address@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?note_code@?1??calc_note@MusicTrack@@QAEDPAVMMLfile@@H@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?KS_Command@?1??SetKeySignature@MusicTrack@@QAEXPAVMMLfile@@@Z@4QBUCommand_Info@@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Key@?1??SetKey@MusicTrack@@QAEXHH@Z@4QAY06$$CBDA
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Scale@?1??SetKey@MusicTrack@@QAEXHH@Z@4QAY06$$CBDA
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Shift@?1??SetKey@MusicTrack@@QAEXHH@Z@4QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?get_sw_Evoi@Patch@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setUse@MusicItem@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get@NSD_WORK@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?set@NSD_WORK@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset_opt@MusicTrack@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?init@NSD_WORK@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NSD_WORK@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NSD_WORK@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7MusicTrack@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_19HGHALIPE@?$AAN?$AAu?$AAl?$AAl?$AA?$AA@	; `string'
PUBLIC	??_C@_1BG@DLEDEKK@?$AA?$CJuj0L?$FLXW?$CI0W0?$HO0?$FL0?$JD0?$AC?$AA?$AA@ ; `string'
PUBLIC	??_C@_19IKFMBMLG@?$AAS?$AAu?$AAb?$AA?$CI?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@IGMADMH@?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$CI?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PLMGIHGM@?$AAF?$AAD?$AAS?$AAC?$AA?$CI?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@MBMMOGBM@?$AAF?$AAD?$AAS?$AAM?$AA?$CI?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@DBGGOFMD@?$AAV?$AAR?$AAC?$AA7?$AA?$CI?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@HOIDBMFA@?$AAN?$AA1?$AA6?$AA3?$AA?$CI?$AA?$AA@ ; `string'
PUBLIC	??_C@_17HLGHMILN@?$AAS?$AAE?$AA?$CI?$AA?$AA@	; `string'
PUBLIC	??_C@_1CE@JMOHEOPF@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJ0L?$HNB0?$IP0c0f0D0?$HO0?$FL0?$JD0?$AC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CE@IJKNAFJK@0?j0?T0?$PM0?H?$AA?$CI?$AAC?$AA?$CJ0L?$HNB0?$IP0c0f0D0?$HO0?$FL0?$JD0?$AC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BK@OCDBGHAP@?$AAE?$AAn?$AAd?$AA?5?$AAo?$AAf?$AA?5?$AAT?$AAr?$AAa?$AAc?$AAk?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CO@IIMELFGG@?$AAE?$AAn?$AAd?$AA?5?$AAo?$AAf?$AA?5?$AAT?$AAr?$AAa?$AAc?$AAk?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAL?$AAO@ ; `string'
PUBLIC	??_C@_1CA@JPKIEODC@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAB?$AA?$CJ?$AA?5?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@KDMBBGBP@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAB?$AA?$CJ?$AA?5?$AAB?$AAr?$AAa?$AAn?$AAc?$AAh?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@EIMDGIFC@0?j0?T0?$PM0?H?$AA?$CI?$AAB?$AA?$CJQ?$IF0g?$AA?5?$AA?2?$AA?50?$LD0?$NO0?s0?I0L?$JB?M?$IJ?$AH0W@ ; `string'
PUBLIC	??_C@_1DE@NPLPFED@0?j0?T0?$PM0?H?$AA?$CI?$AAB?$AA?$CJ0n?$JF?$ILY?K?$AA?5?$AA?$HM?$AA?3?$AA?50?$LD0?$NO0?s0?I0L0B@ ; `string'
PUBLIC	??_C@_1CC@DHDLBODE@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJ0nS?3?$JF?$JD0n?$JA?$BEN?90g0Y0?$AC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BM@EDCBEBGE@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAB?$AA?$CJ?$AA?5?$AAE?$AAn?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FK@BKKHDBPB@0?j0?T0?$PM0?H?$AA?$CI?$AAB?$AA?$CJQ?$IF0g?$AA?5?$AA?2?$AA?50?$LD0?$NO0?s0?I0L0B0?$IK0?$HO@ ; `string'
PUBLIC	??_C@_1DC@JAEEIEKF@0?j0?T0?$PM0?HV?$NOep0o?$AA2?$PP?$FO?$AA2?$AA5?$AA50n?$HL?DV?r0gc?$AH?$FL?$JK0W0f@ ; `string'
PUBLIC	??_C@_1CG@DHEAMNDG@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJ0n0?M0?$LJ0?H0o0g0M0?$HO0?$FL0?$JD0?$AC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CA@HFCOJDFA@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAA?$AA?$CJ?$AA?5?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@MGIFLNF@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAA?$AA?$CJ?$AA?5?$AAB?$AAr?$AAa?$AAn?$AAc?$AAh?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@HGGAJCGI@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJQ?$IF0g?$AA?5?$AA?3?$AA?50?$LD0?$NO0?s0?I0L?$JB?M?$IJ?$AH0W@ ; `string'
PUBLIC	??_C@_1DC@IPGNKEJP@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJ0n?$JF?$ILY?K?$AA?5?$AA?$FL?$AA?50?$LD0?$NO0?s0?I0L0B0?$IK@ ; `string'
PUBLIC	??_C@_1DE@OPGCJNPF@0?j0?T0?$PM0?H?$AA?$CI?$AAC?$AA?$CJQ?$IF0g?$AA?5?$AA?3?$AA?50?$LD0?$NO0?s0?I0L?$JB?M?$IJ?$AH0W@ ; `string'
PUBLIC	??_C@_1DE@PIDIKAJB@0?j0?T0?$PM0?H?$AA?$CI?$AAC?$AA?$CJ0n?$JF?$ILY?K?$AA?5?$AA?$FL?$AA?3?$AA?50?$LD0?$NO0?s0?I0L0B@ ; `string'
PUBLIC	??_C@_1CE@PJCEBMDC@0?j0?T0?$PM0?H?$JF?$ILY?K0?$LD0?$NO0?s0?I0L0B0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@FCKGONLL@0?j0?T0?$PM0?HV?$NOep0n?$IK?$BI?$IP?p0L0B0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@IJNCMADK@0?j0?T0?$PM0?HV?$NOep0LN?$CBe?$LJ0k?$IK?$BI?$IP?p0U0?$IM0f0D0?$HO0Y0?$AC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BM@DPEAGELP@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAA?$AA?$CJ?$AA?5?$AAE?$AAn?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BA@GCDNCJOK@?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BA@LDPMAPOD@?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BA@DMAFONIK@?$AAC?$AAa?$AAl?$AAl?$AA?5?$AAS?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@DLCGAOAF@?$AAS?$AAu?$AAb?$AAr?$AAo?$AAu?$AAt?$AAi?$AAn?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@JNKNAIAA@?$AAS?$AAu?$AAb?$AAr?$AAo?$AAu?$AAt?$AAi?$AAn?$AAe?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAP?$AAa?$AAt?$AAc?$AAh@ ; `string'
PUBLIC	??_C@_1BI@EHCLFFIH@?$FLXW?$CI0W0j0D0?Q0?C0?A0g0Y0?$AC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BO@GFLIMKC@?$AAV?$AAo?$AAi?$AAc?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CA@BOAFBFBE@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@HDOLOCJJ@?$AAF?$AAr?$AAe?$AAq?$AAu?$AAe?$AAn?$AAc?$AAy?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BM@CBOHIOMD@?$AAN?$AAo?$AAt?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@DKLMFINE@?$AAV?$AAo?$AAi?$AAc?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@DNAKKDOB@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?5?$AAO?$AAf?$AAf?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CO@BJABPOLD@?$AAF?$AAr?$AAe?$AAq?$AAu?$AAe?$AAn?$AAc?$AAy?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?5?$AAO@ ; `string'
PUBLIC	??_C@_1CE@KEOAGLPM@?$AAN?$AAo?$AAt?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?5?$AAO?$AAf?$AAf?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@HAFHLPCH@?$AAS?$AAw?$AAe?$AAe?$AAp?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CM@GOJLGHKM@?$AAF?$AAD?$AAS?$AA?5?$AAc?$AAa?$AAr?$AAe?$AAe?$AAr?$AA?5?$AAw?$AAa?$AAv?$AAe?$AA?5?$AAt?$AAa?$AAb?$AAl@ ; `string'
PUBLIC	??_C@_1DC@IBICFHPL@?$AAF?$AAD?$AAS?$AA?5?$AAm?$AAo?$AAd?$AAu?$AAl?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAw?$AAa?$AAv?$AAe?$AA?5?$AAt@ ; `string'
PUBLIC	??_C@_1CM@FAPBPOGD@?$AAV?$AAR?$AAC?$AA7?$AA?5?$AAu?$AAs?$AAe?$AAr?$AA?5?$AAi?$AAn?$AAs?$AAt?$AAr?$AAu?$AAm?$AAe?$AAn?$AAt@ ; `string'
PUBLIC	??_C@_1CA@NKOKHIPN@?$AAn?$AA1?$AA6?$AA3?$AA?5?$AAw?$AAa?$AAv?$AAe?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EA@CPIKLJAL@?$AA?$EA?$AAN?$AA?50?$LD0?$NO0?s0?I0n0?Q0?i0?a0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC@ ; `string'
PUBLIC	??_C@_1CO@PCFIGAHG@?$AAJ0?$LD0?$NO0?s0?I0o?$AA0?$PP?$FO?$AA10n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O0?$GA0U@ ; `string'
PUBLIC	??_C@_1CC@EMHPIIFB@?$AAG?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AA?$CI?$AAq?$AA?$CJ?$AA?5?$AAB?$AAy?$AAt?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@DCFFOBJ@?$AAG?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AA?$CI?$AAq?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@IPILGHHC@?$AAG?$AAa?$AAt?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DI@HCGIJCFJ@0?$LC0?$PM0?H0?$LP0?$KE0?$OA?$AAQ0o?$AA1?$PP?$FO?$AA?$CD?$AAQ?$AAM?$AAa?$AAx0n?$HL?DV?r0gc?$AH@ ; `string'
PUBLIC	??_C@_1DE@DMILNHDF@0?$LC0?$PM0?H0?$LP0?$KE0?$OA?$AAq0o?$AA0?$PP?$FO?$AA2?$AA5?$AA50n?$HL?DV?r0gc?$AH?$FL?$JK0W@ ; `string'
PUBLIC	??_C@_1BG@CIPPAIIN@?$AAG?$AAa?$AAt?$AAe?$AAM?$AAo?$AAd?$AAe?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@JAEDGPOI@?$AAG?$AAa?$AAt?$AAe?$AAM?$AAo?$AAd?$AAe?$AA?5?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@ICPGMAAG@?$AAG?$AAa?$AAt?$AAe?$AAM?$AAo?$AAd?$AAe?$AA?5?$AA2?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DC@NMCJFJGP@0?j0?j0?$PM0?$LJ0?b0?$PM0?I0o?$AA0?$PP?$FO?$AA20n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O@ ; `string'
PUBLIC	??_C@_1BM@LPHMCIPB@?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?5?$AAV?$AAo?$AAi?$AAc?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@NPNLAEDI@0?j0?j0?$PM0?$LJ?$JH?s?$ICr0o?$AA0?$PP?$FO?$AA70n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O0?$GA@ ; `string'
PUBLIC	??_C@_1BO@IEEELBMO@?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?5?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@OMCJIBOF@?$JH?s?$JB?O0o?$AA0?$PP?$FO?$AA1?$AA50n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O0?$GA0U0D0?$AC@ ; `string'
PUBLIC	??_C@_05KFOFLDIO@C?9Dur?$AA@			; `string'
PUBLIC	??_C@_06DNHFJLJE@Ds?9Dur?$AA@			; `string'
PUBLIC	??_C@_07BCGGFLM@Des?9Dur?$AA@			; `string'
PUBLIC	??_C@_05LIOAIDDG@D?9Dur?$AA@			; `string'
PUBLIC	??_C@_06JLACJACA@Es?9Dur?$AA@			; `string'
PUBLIC	??_C@_05HDLMFAJD@E?9Dur?$AA@			; `string'
PUBLIC	??_C@_05PFCICCDN@F?9Dur?$AA@			; `string'
PUBLIC	??_C@_07IEKDAILF@Fis?9Dur?$AA@			; `string'
PUBLIC	??_C@_06MJNIBAJ@Gs?9Dur?$AA@			; `string'
PUBLIC	??_C@_07IPKJGCFP@Ges?9Dur?$AA@			; `string'
PUBLIC	??_C@_05DOHEPBJI@G?9Dur?$AA@			; `string'
PUBLIC	??_C@_06GPENLEDD@As?9Dur?$AA@			; `string'
PUBLIC	??_C@_05OICNBCIF@A?9Dur?$AA@			; `string'
PUBLIC	??_C@_05GOLJGACL@B?9Dur?$AA@			; `string'
PUBLIC	??_C@_06FOKFKOKO@Bs?9Dur?$AA@			; `string'
PUBLIC	??_C@_05MPCCEDEN@H?9Dur?$AA@			; `string'
PUBLIC	??_C@_06OJJNCCFH@c?9moll?$AA@			; `string'
PUBLIC	??_C@_08FPGMHDLI@cis?9moll?$AA@			; `string'
PUBLIC	??_C@_06CMDKBMNJ@d?9moll?$AA@			; `string'
PUBLIC	??_C@_08DLANBOHB@dis?9moll?$AA@			; `string'
PUBLIC	??_C@_07OOAGBAFB@es?9moll?$AA@			; `string'
PUBLIC	??_C@_06IKENBHGN@e?9moll?$AA@			; `string'
PUBLIC	??_C@_06LLKFANPA@f?9moll?$AA@			; `string'
PUBLIC	??_C@_08BFPLDGPH@fis?9moll?$AA@			; `string'
PUBLIC	??_C@_06BNNCAGEE@g?9moll?$AA@			; `string'
PUBLIC	??_C@_08CIACCLE@gis?9moll?$AA@			; `string'
PUBLIC	??_C@_06HOACDDHO@a?9moll?$AA@			; `string'
PUBLIC	??_C@_06EPOKCJOD@b?9moll?$AA@			; `string'
PUBLIC	??_C@_07OEMDBJEI@bs?9moll?$AA@			; `string'
PUBLIC	??_C@_06OLJKHGKN@h?9moll?$AA@			; `string'
PUBLIC	??_C@_07CCKMBAMP@ds?9moll?$AA@			; `string'
PUBLIC	??_C@_08GMKCALDO@des?9moll?$AA@			; `string'
PUBLIC	??_C@_07KMCDBHCM@gs?9moll?$AA@			; `string'
PUBLIC	??_C@_08FFCPDHPL@ges?9moll?$AA@			; `string'
PUBLIC	??_C@_07GKEMBOKL@as?9moll?$AA@			; `string'
PUBLIC	??_C@_01MIFGBAGJ@?$CL?$AA@			; `string'
PUBLIC	??_C@_02CMICPHGH@?$IB?$HL?$AA@			; `string'
PUBLIC	??_C@_01IPJKGB@?$CD?$AA@			; `string'
PUBLIC	??_C@_02PFGEBIEE@?$IB?$JE?$AA@			; `string'
PUBLIC	??_C@_02GDMDGBKA@?$IB?$HM?$AA@			; `string'
PUBLIC	??_C@_02NPNIOFCE@?$IB?s?$AA@			; `string'
PUBLIC	??_C@_01NEMOKFLO@?$DN?$AA@			; `string'
PUBLIC	??_C@_02MCNBPOFA@?$IB?$IB?$AA@			; `string'
PUBLIC	??_C@_01NBENCBCI@?$CK?$AA@			; `string'
PUBLIC	??_C@_02MHFCHKMG@?$IB?$JG?$AA@			; `string'
PUBLIC	??_C@_02LJKBFKON@?$ID?$JD?$AA@			; `string'
PUBLIC	??_C@_02LEAGIKBB@?$IDb?$AA@			; `string'
PUBLIC	??_C@_02OPKIDJPP@?$IC?q?$AA@			; `string'
PUBLIC	??_C@_02DAOOAPAM@?$IC?A?$AA@			; `string'
PUBLIC	??_C@_02BILDMFBN@?$IDn?$AA@			; `string'
PUBLIC	??_C@_02HMNPAABJ@?$IDj?$AA@			; `string'
PUBLIC	??_C@_02DGBNBCEI@?$IDz?$AA@			; `string'
PUBLIC	??_C@_02IDLDGMAF@?$IDw?$AA@			; `string'
PUBLIC	??_C@_02MJHBHOFE@?$IDg?$AA@			; `string'
PUBLIC	??_C@_02DIJJJPPC@?$IDC?$AA@			; `string'
PUBLIC	??_C@_02GNOAGFDC@?$ID?$IN?$AA@			; `string'
PUBLIC	??_C@_1DI@JCDDEPJK@?$IK?$LPS?w0?$LD0?$NO0?s0?I0?$PL0?V0?m0?C0?$KP0n?$JF?$ILY?K0?$JCy?30Y?$AA?$HL0L?$IJ?$IL@ ; `string'
PUBLIC	??_C@_1DI@GALIBNKP@?$IK?$LPS?w0?$LD0?$NO0?s0?I0?$PL0?V0?m0?C0?$KP0n?$HNBz?o0?$JCy?30Y?$AA?$GA?$AA?$HN?$AA?8@ ; `string'
PUBLIC	??_C@_1DM@KNFDIHJH@?$IK?$LPS?w?$AA?5?$AAK?$AA?$HL?$AA?$HN?$AA?50?$LD0?$NO0?s0?I0n_?$BFep0gg?$CKw?e0ne?$IH?$FLW@ ; `string'
PUBLIC	??_C@_1BE@PDJGDLM@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA9?$AA6?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@LKFBJFJL@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA7?$AA2?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@FDHIAHFB@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA4?$AA8?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@KOKCEANK@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA3?$AA6?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@CBMANHIN@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA3?$AA2?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@MPPHFLPE@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA2?$AA4?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@DLFJGOC@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA1?$AA8?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@ODGKOBNB@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA1?$AA6?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@GMAIHGIG@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA1?$AA2?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@BACHBKJG@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA9?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@KIJLHNPD@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA8?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@EIEEAKMA@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA6?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@OCENMCEL@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA4?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@HPJKPKPC@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA3?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@MHCGJNJH@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA2?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@NFJDDCHJ@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@IONIPGKG@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EE@FMLCMNNO@?$AAE?$AAC0?$LD0?$NO0?s0?I0n?$HL?0?$PP?$BB0?Q0?i0?a0?$PM0?$LP0o?$AA0?$PP?$FO?$AA2?$AA5?$AA5@ ; `string'
PUBLIC	??_C@_1EA@ECJHFDDN@?$AAE?$AAC?$AA?50?$LD0?$NO0?s0?I0n0?Q0?i0?a0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC@ ; `string'
PUBLIC	??_C@_1EE@OOLANPID@?$AAE?$AAC0?$LD0?$NO0?s0?I0n?$HL?0?$PP?$BC0?Q0?i0?a0?$PM0?$LP0o?$AA?9?$AA1?$PP?$FO?$AA1?$AA5@ ; `string'
PUBLIC	??_C@_1DK@PHOKHOEC@?$JH?sz?$AL0n?$HL?DV?r0L0?N0?$PM0?H0?J0?s0?P0?$PM?$AA0?$PP?$FO?$AA2?$AA5?$AA50n?$HL?D@ ; `string'
PUBLIC	??_C@_1BI@EPMKAKFB@?$AAE?$AAc?$AAh?$AAo?$AA?5?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@JCJILIHF@?$AAO?$AAn?$AAe?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?5?$AAo?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAd?$AAo?$AAw?$AAn@ ; `string'
PUBLIC	??_C@_1CG@IKGHOBJA@?$AAO?$AAn?$AAe?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?5?$AAo?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAu?$AAp?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@HOMMDOEE@?$AAE?$AAc?$AAh?$AAo?$AA?5?$AAN?$AAo?$AAt?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@DMLCJFNF@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_19JIGFKGL@?$AAN?$AAo?$AAt?$AAe?$AA?$AA@	; `string'
PUBLIC	??_C@_1GG@HBOGPEMM@?$AAM?$AAu?$AAs?$AAi?$AAc?$AAT?$AAr?$AAa?$AAc?$AAk?$AA?3?$AA?3?$AAS?$AAe?$AAt?$AAR?$AAe?$AAs?$AAt?$AA?$CI@ ; `string'
PUBLIC	??_C@_1GG@IPLHPKBL@?$AAM?$AAu?$AAs?$AAi?$AAc?$AAT?$AAr?$AAa?$AAc?$AAk?$AA?3?$AA?3?$AAS?$AAe?$AAt?$AAR?$AAe?$AAs?$AAt?$AA?$CI@ ; `string'
PUBLIC	??_C@_19FAHECHIH@?$AAR?$AAe?$AAs?$AAt?$AA?$AA@	; `string'
PUBLIC	??_C@_1CK@DKBDHLKE@?$AAa?$AA?0?$AAb?$AA?0?$AAc?$PP?$FO?$AAg0n?$JH?sT?$AN0?$JC?$IK?$BI?$IP?p0W0f0O0?$GA0U0D0?$AC@ ; `string'
PUBLIC	??_C@_1CM@GGEMPKPF@0?$NN0?k0?$LP0?a0?s0?H0?$LD0?$NO0?s0?I0o0?$AB?$AA?$HN0g?$JF?$IJ0X0fN?$AL0U0D@ ; `string'
PUBLIC	??_C@_1DK@BBKDBEBK@0?$NN0?k0?$LP0?a0?s0?H0?$LD0?$NO0?s0?I0g0?$AB?$JH?s?$JFw0L?$AA2?$HL?$IHb?$EA0k?$IK?$BI@ ; `string'
PUBLIC	??_C@_1EC@HFJPNNCI@0?$NN0?k0?$LP0?a0?s0?H0?$LD0?$NO0?s0?I0g0?$AB0?$LC0?$PM0?H0?$LP0?$KE0?$OA0L?$AA2@ ; `string'
PUBLIC	??_C@_1BG@GGJHBHG@?$AAP?$AAo?$AAr?$AAt?$AAa?$AAm?$AAe?$AAn?$AAt?$AAo?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EE@PLBKOKJL@0?$NN0?k0?$LP0?a0?s0?H0n?$HL?0?$AA10?Q0?i0?a0?$PM0?$LP0o?$AA0?$PP?$FO?$AA2?$AA5?$AA5@ ; `string'
PUBLIC	??_C@_1DO@OLCBIOJB@?$AAP?$AA?50?$LD0?$NO0?s0?I0n0?Q0?i0?a0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC?$PP?$BE@ ; `string'
PUBLIC	??_C@_1EE@IIGGDGHG@0?$NN0?k0?$LP0?a0?s0?H0n?$HL?0?$AA20?Q0?i0?a0?$PM0?$LP0o?$AA1?$PP?$FO?$AA2?$AA5?$AA6@ ; `string'
PUBLIC	??_C@_1EK@HIFALIIE@0?$NN0?k0?$LP0?a0?s0?H0n?$HL?0?$AA30?Q0?i0?a0?$PM0?$LP0o?$AA?9?$AA1?$AA2?$AA8?$PP?$FO@ ; `string'
PUBLIC	??_C@_1EK@FHHEJADM@0?$NN0?k0?$LP0?a0?s0?H0n?$HL?0?$AA40?Q0?i0?a0?$PM0?$LP0o?$AA?9?$AA1?$AA2?$AA8?$PP?$FO@ ; `string'
PUBLIC	??_C@_1DI@EBCJNIGK@0?$KN0?$PM0?$LH0?U0?H0o?$AA?9?$AA1?$AA2?$AA7?$PP?$FO?$AA1?$AA2?$AA80n?$HL?DV?r0gc?$AH?$FL?$JK@ ; `string'
PUBLIC	??_C@_1DC@IEPABAMO@0?$KN0?$PM0?$LH0?U0?H0n?$HL?DV?r0L?$AA?9?$AA1?$AA2?$AA7?$PP?$FO?$AA1?$AA2?$AA80?$JC?$IN?$IF0H@ ; `string'
PUBLIC	??_C@_1BE@FKDCKBLJ@?$AAT?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@MDOKKNHL@?$AAR?$AAe?$AAl?$AAa?$AAt?$AAi?$AAv?$AAe?$AA?5?$AAT?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@FEMFBHON@?$AAO?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CO@KKLECMEI@0?$KK0?$KP0?$LP0?$PM0?V0o?$AA1?$PP?$FO?$AA80n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O0?$GA0U@ ; `string'
PUBLIC	??_C@_1BE@JMDGIABI@?$AAO?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAU?$AAp?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@KEBEFOPC@?$AAO?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAD?$AAo?$AAw?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@ILJOBKB@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAu?$AAp?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@MGACCNCM@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAd?$AAo?$AAw?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_7MusicTrack@@6B@				; MusicTrack::`vftable'
;	COMDAT ??_C@_19HGHALIPE@?$AAN?$AAu?$AAl?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_19HGHALIPE@?$AAN?$AAu?$AAl?$AAl?$AA?$AA@ DB 'N', 00H, 'u', 00H, 'l', 00H
	DB	'l', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@DLEDEKK@?$AA?$CJuj0L?$FLXW?$CI0W0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@DLEDEKK@?$AA?$CJuj0L?$FLXW?$CI0W0?$HO0?$FL0?$JD0?$AC?$AA?$AA@ DB ')'
	DB	00H, 'juL0X[(WW0~0[0', 093H, '0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19IKFMBMLG@?$AAS?$AAu?$AAb?$AA?$CI?$AA?$AA@
CONST	SEGMENT
??_C@_19IKFMBMLG@?$AAS?$AAu?$AAb?$AA?$CI?$AA?$AA@ DB 'S', 00H, 'u', 00H, 'b'
	DB	00H, '(', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@IGMADMH@?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$CI?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@IGMADMH@?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$CI?$AA?$AA@ DB 'E'
	DB	00H, 'n', 00H, 'v', 00H, 'e', 00H, 'l', 00H, 'o', 00H, 'p', 00H
	DB	'e', 00H, '(', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PLMGIHGM@?$AAF?$AAD?$AAS?$AAC?$AA?$CI?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PLMGIHGM@?$AAF?$AAD?$AAS?$AAC?$AA?$CI?$AA?$AA@ DB 'F', 00H, 'D', 00H
	DB	'S', 00H, 'C', 00H, '(', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MBMMOGBM@?$AAF?$AAD?$AAS?$AAM?$AA?$CI?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MBMMOGBM@?$AAF?$AAD?$AAS?$AAM?$AA?$CI?$AA?$AA@ DB 'F', 00H, 'D', 00H
	DB	'S', 00H, 'M', 00H, '(', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@DBGGOFMD@?$AAV?$AAR?$AAC?$AA7?$AA?$CI?$AA?$AA@
CONST	SEGMENT
??_C@_1M@DBGGOFMD@?$AAV?$AAR?$AAC?$AA7?$AA?$CI?$AA?$AA@ DB 'V', 00H, 'R', 00H
	DB	'C', 00H, '7', 00H, '(', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@HOIDBMFA@?$AAN?$AA1?$AA6?$AA3?$AA?$CI?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HOIDBMFA@?$AAN?$AA1?$AA6?$AA3?$AA?$CI?$AA?$AA@ DB 'N', 00H, '1', 00H
	DB	'6', 00H, '3', 00H, '(', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_17HLGHMILN@?$AAS?$AAE?$AA?$CI?$AA?$AA@
CONST	SEGMENT
??_C@_17HLGHMILN@?$AAS?$AAE?$AA?$CI?$AA?$AA@ DB 'S', 00H, 'E', 00H, '(', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@JMOHEOPF@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJ0L?$HNB0?$IP0c0f0D0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@JMOHEOPF@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJ0L?$HNB0?$IP0c0f0D0?$HO0?$FL0?$JD0?$AC?$AA?$AA@ DB 0eaH
	DB	'0', 0d4H, '0', 0fcH, '0', 0c8H, '0(', 00H, 'A', 00H, ')', 00H
	DB	'L0B}', 08fH, '0c0f0D0~0[0', 093H, '0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@IJKNAFJK@0?j0?T0?$PM0?H?$AA?$CI?$AAC?$AA?$CJ0L?$HNB0?$IP0c0f0D0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@IJKNAFJK@0?j0?T0?$PM0?H?$AA?$CI?$AAC?$AA?$CJ0L?$HNB0?$IP0c0f0D0?$HO0?$FL0?$JD0?$AC?$AA?$AA@ DB 0eaH
	DB	'0', 0d4H, '0', 0fcH, '0', 0c8H, '0(', 00H, 'C', 00H, ')', 00H
	DB	'L0B}', 08fH, '0c0f0D0~0[0', 093H, '0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@OCDBGHAP@?$AAE?$AAn?$AAd?$AA?5?$AAo?$AAf?$AA?5?$AAT?$AAr?$AAa?$AAc?$AAk?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@OCDBGHAP@?$AAE?$AAn?$AAd?$AA?5?$AAo?$AAf?$AA?5?$AAT?$AAr?$AAa?$AAc?$AAk?$AA?$AA@ DB 'E'
	DB	00H, 'n', 00H, 'd', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H
	DB	'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H, 'k', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@IIMELFGG@?$AAE?$AAn?$AAd?$AA?5?$AAo?$AAf?$AA?5?$AAT?$AAr?$AAa?$AAc?$AAk?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAL?$AAO@
CONST	SEGMENT
??_C@_1CO@IIMELFGG@?$AAE?$AAn?$AAd?$AA?5?$AAo?$AAf?$AA?5?$AAT?$AAr?$AAa?$AAc?$AAk?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAL?$AAO@ DB 'E'
	DB	00H, 'n', 00H, 'd', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H
	DB	'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 'w'
	DB	00H, 'i', 00H, 't', 00H, 'h', 00H, ' ', 00H, 'L', 00H, 'O', 00H
	DB	'O', 00H, 'P', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@JPKIEODC@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAB?$AA?$CJ?$AA?5?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@JPKIEODC@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAB?$AA?$CJ?$AA?5?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@ DB 'R'
	DB	00H, 'e', 00H, 'p', 00H, 'e', 00H, 'a', 00H, 't', 00H, '(', 00H
	DB	'B', 00H, ')', 00H, ' ', 00H, 'S', 00H, 't', 00H, 'a', 00H, 'r'
	DB	00H, 't', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@KDMBBGBP@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAB?$AA?$CJ?$AA?5?$AAB?$AAr?$AAa?$AAn?$AAc?$AAh?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@KDMBBGBP@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAB?$AA?$CJ?$AA?5?$AAB?$AAr?$AAa?$AAn?$AAc?$AAh?$AA?$AA@ DB 'R'
	DB	00H, 'e', 00H, 'p', 00H, 'e', 00H, 'a', 00H, 't', 00H, '(', 00H
	DB	'B', 00H, ')', 00H, ' ', 00H, 'B', 00H, 'r', 00H, 'a', 00H, 'n'
	DB	00H, 'c', 00H, 'h', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@EIMDGIFC@0?j0?T0?$PM0?H?$AA?$CI?$AAB?$AA?$CJQ?$IF0g?$AA?5?$AA?2?$AA?50?$LD0?$NO0?s0?I0L?$JB?M?$IJ?$AH0W@
CONST	SEGMENT
??_C@_1DE@EIMDGIFC@0?j0?T0?$PM0?H?$AA?$CI?$AAB?$AA?$CJQ?$IF0g?$AA?5?$AA?2?$AA?50?$LD0?$NO0?s0?I0L?$JB?M?$IJ?$AH0W@ DB 0eaH
	DB	'0', 0d4H, '0', 0fcH, '0', 0c8H, '0(', 00H, 'B', 00H, ')', 00H
	DB	085H, 'Qg0 ', 00H, '\', 00H, ' ', 00H, 0b3H, '0', 0deH, '0', 0f3H
	DB	'0', 0c9H, '0L0', 0cdH, 091H, 07H, 089H, 'W0f0D0~0Y0', 02H, '0'
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@NPLPFED@0?j0?T0?$PM0?H?$AA?$CI?$AAB?$AA?$CJ0n?$JF?$ILY?K?$AA?5?$AA?$HM?$AA?3?$AA?50?$LD0?$NO0?s0?I0L0B@
CONST	SEGMENT
??_C@_1DE@NPLPFED@0?j0?T0?$PM0?H?$AA?$CI?$AAB?$AA?$CJ0n?$JF?$ILY?K?$AA?5?$AA?$HM?$AA?3?$AA?50?$LD0?$NO0?s0?I0L0B@ DB 0eaH
	DB	'0', 0d4H, '0', 0fcH, '0', 0c8H, '0(', 00H, 'B', 00H, ')', 00H
	DB	'n0', 08bH, 095H, 0cbH, 'Y ', 00H, '|', 00H, ':', 00H, ' ', 00H
	DB	0b3H, '0', 0deH, '0', 0f3H, '0', 0c9H, '0L0B0', 08aH, '0~0[0', 093H
	DB	'0', 02H, '0', 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@DHDLBODE@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJ0nS?3?$JF?$JD0n?$JA?$BEN?90g0Y0?$AC?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@DHDLBODE@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJ0nS?3?$JF?$JD0n?$JA?$BEN?90g0Y0?$AC?$AA?$AA@ DB 0eaH
	DB	'0', 0d4H, '0', 0fcH, '0', 0c8H, '0(', 00H, 'A', 00H, ')', 00H
	DB	'n0:S', 093H, 095H, 'n0', 014H, 090H, '-Ng0Y0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@EDCBEBGE@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAB?$AA?$CJ?$AA?5?$AAE?$AAn?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@EDCBEBGE@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAB?$AA?$CJ?$AA?5?$AAE?$AAn?$AAd?$AA?$AA@ DB 'R'
	DB	00H, 'e', 00H, 'p', 00H, 'e', 00H, 'a', 00H, 't', 00H, '(', 00H
	DB	'B', 00H, ')', 00H, ' ', 00H, 'E', 00H, 'n', 00H, 'd', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1FK@BKKHDBPB@0?j0?T0?$PM0?H?$AA?$CI?$AAB?$AA?$CJQ?$IF0g?$AA?5?$AA?2?$AA?50?$LD0?$NO0?s0?I0L0B0?$IK0?$HO@
CONST	SEGMENT
??_C@_1FK@BKKHDBPB@0?j0?T0?$PM0?H?$AA?$CI?$AAB?$AA?$CJQ?$IF0g?$AA?5?$AA?2?$AA?50?$LD0?$NO0?s0?I0L0B0?$IK0?$HO@ DB 0eaH
	DB	'0', 0d4H, '0', 0fcH, '0', 0c8H, '0(', 00H, 'B', 00H, ')', 00H
	DB	085H, 'Qg0 ', 00H, '\', 00H, ' ', 00H, 0b3H, '0', 0deH, '0', 0f3H
	DB	'0', 0c9H, '0L0B0', 08aH, '0~0[0', 093H, '0g0W0_0', 02H, '0', 0c5H
	DB	'_Z0', 06H, 'R', 090H, '\', 0b9H, 'p ', 00H, '\', 00H, ' ', 00H
	DB	'o0', 07H, 'c', 09aH, '[W0f0O0`0U0D0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@JAEEIEKF@0?j0?T0?$PM0?HV?$NOep0o?$AA2?$PP?$FO?$AA2?$AA5?$AA50n?$HL?DV?r0gc?$AH?$FL?$JK0W0f@
CONST	SEGMENT
??_C@_1DC@JAEEIEKF@0?j0?T0?$PM0?HV?$NOep0o?$AA2?$PP?$FO?$AA2?$AA5?$AA50n?$HL?DV?r0gc?$AH?$FL?$JK0W0f@ DB 0eaH
	DB	'0', 0d4H, '0', 0fcH, '0', 0c8H, '0', 0deH, 'Vpeo02', 00H, '^', 0ffH
	DB	'2', 00H, '5', 00H, '5', 00H, 'n0', 0c4H, '{', 0f2H, 'Vg0', 07H
	DB	'c', 09aH, '[W0f0', 0bH, 'NU0D0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@DHEAMNDG@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJ0n0?M0?$LJ0?H0o0g0M0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@DHEAMNDG@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJ0n0?M0?$LJ0?H0o0g0M0?$HO0?$FL0?$JD0?$AC?$AA?$AA@ DB 0eaH
	DB	'0', 0d4H, '0', 0fcH, '0', 0c8H, '0(', 00H, 'A', 00H, ')', 00H
	DB	'n0', 0cdH, '0', 0b9H, '0', 0c8H, '0o0g0M0~0[0', 093H, '0', 02H
	DB	'0', 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@HFCOJDFA@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAA?$AA?$CJ?$AA?5?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@HFCOJDFA@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAA?$AA?$CJ?$AA?5?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@ DB 'R'
	DB	00H, 'e', 00H, 'p', 00H, 'e', 00H, 'a', 00H, 't', 00H, '(', 00H
	DB	'A', 00H, ')', 00H, ' ', 00H, 'S', 00H, 't', 00H, 'a', 00H, 'r'
	DB	00H, 't', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@MGIFLNF@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAA?$AA?$CJ?$AA?5?$AAB?$AAr?$AAa?$AAn?$AAc?$AAh?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@MGIFLNF@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAA?$AA?$CJ?$AA?5?$AAB?$AAr?$AAa?$AAn?$AAc?$AAh?$AA?$AA@ DB 'R'
	DB	00H, 'e', 00H, 'p', 00H, 'e', 00H, 'a', 00H, 't', 00H, '(', 00H
	DB	'A', 00H, ')', 00H, ' ', 00H, 'B', 00H, 'r', 00H, 'a', 00H, 'n'
	DB	00H, 'c', 00H, 'h', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@HGGAJCGI@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJQ?$IF0g?$AA?5?$AA?3?$AA?50?$LD0?$NO0?s0?I0L?$JB?M?$IJ?$AH0W@
CONST	SEGMENT
??_C@_1DE@HGGAJCGI@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJQ?$IF0g?$AA?5?$AA?3?$AA?50?$LD0?$NO0?s0?I0L?$JB?M?$IJ?$AH0W@ DB 0eaH
	DB	'0', 0d4H, '0', 0fcH, '0', 0c8H, '0(', 00H, 'A', 00H, ')', 00H
	DB	085H, 'Qg0 ', 00H, ':', 00H, ' ', 00H, 0b3H, '0', 0deH, '0', 0f3H
	DB	'0', 0c9H, '0L0', 0cdH, 091H, 07H, 089H, 'W0f0D0~0Y0', 02H, '0'
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@IPGNKEJP@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJ0n?$JF?$ILY?K?$AA?5?$AA?$FL?$AA?50?$LD0?$NO0?s0?I0L0B0?$IK@
CONST	SEGMENT
??_C@_1DC@IPGNKEJP@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJ0n?$JF?$ILY?K?$AA?5?$AA?$FL?$AA?50?$LD0?$NO0?s0?I0L0B0?$IK@ DB 0eaH
	DB	'0', 0d4H, '0', 0fcH, '0', 0c8H, '0(', 00H, 'A', 00H, ')', 00H
	DB	'n0', 08bH, 095H, 0cbH, 'Y ', 00H, '[', 00H, ' ', 00H, 0b3H, '0'
	DB	0deH, '0', 0f3H, '0', 0c9H, '0L0B0', 08aH, '0~0[0', 093H, '0', 02H
	DB	'0', 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@OPGCJNPF@0?j0?T0?$PM0?H?$AA?$CI?$AAC?$AA?$CJQ?$IF0g?$AA?5?$AA?3?$AA?50?$LD0?$NO0?s0?I0L?$JB?M?$IJ?$AH0W@
CONST	SEGMENT
??_C@_1DE@OPGCJNPF@0?j0?T0?$PM0?H?$AA?$CI?$AAC?$AA?$CJQ?$IF0g?$AA?5?$AA?3?$AA?50?$LD0?$NO0?s0?I0L?$JB?M?$IJ?$AH0W@ DB 0eaH
	DB	'0', 0d4H, '0', 0fcH, '0', 0c8H, '0(', 00H, 'C', 00H, ')', 00H
	DB	085H, 'Qg0 ', 00H, ':', 00H, ' ', 00H, 0b3H, '0', 0deH, '0', 0f3H
	DB	'0', 0c9H, '0L0', 0cdH, 091H, 07H, 089H, 'W0f0D0~0Y0', 02H, '0'
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@PIDIKAJB@0?j0?T0?$PM0?H?$AA?$CI?$AAC?$AA?$CJ0n?$JF?$ILY?K?$AA?5?$AA?$FL?$AA?3?$AA?50?$LD0?$NO0?s0?I0L0B@
CONST	SEGMENT
??_C@_1DE@PIDIKAJB@0?j0?T0?$PM0?H?$AA?$CI?$AAC?$AA?$CJ0n?$JF?$ILY?K?$AA?5?$AA?$FL?$AA?3?$AA?50?$LD0?$NO0?s0?I0L0B@ DB 0eaH
	DB	'0', 0d4H, '0', 0fcH, '0', 0c8H, '0(', 00H, 'C', 00H, ')', 00H
	DB	'n0', 08bH, 095H, 0cbH, 'Y ', 00H, '[', 00H, ':', 00H, ' ', 00H
	DB	0b3H, '0', 0deH, '0', 0f3H, '0', 0c9H, '0L0B0', 08aH, '0~0[0', 093H
	DB	'0', 02H, '0', 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@PJCEBMDC@0?j0?T0?$PM0?H?$JF?$ILY?K0?$LD0?$NO0?s0?I0L0B0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@PJCEBMDC@0?j0?T0?$PM0?H?$JF?$ILY?K0?$LD0?$NO0?s0?I0L0B0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@ DB 0eaH
	DB	'0', 0d4H, '0', 0fcH, '0', 0c8H, '0', 08bH, 095H, 0cbH, 'Y', 0b3H
	DB	'0', 0deH, '0', 0f3H, '0', 0c9H, '0L0B0', 08aH, '0~0[0', 093H, '0'
	DB	02H, '0', 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@FCKGONLL@0?j0?T0?$PM0?HV?$NOep0n?$IK?$BI?$IP?p0L0B0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@FCKGONLL@0?j0?T0?$PM0?HV?$NOep0n?$IK?$BI?$IP?p0L0B0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@ DB 0eaH
	DB	'0', 0d4H, '0', 0fcH, '0', 0c8H, '0', 0deH, 'Vpen0', 018H, 08aH
	DB	0f0H, 08fH, 'L0B0', 08aH, '0~0[0', 093H, '0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@IJNCMADK@0?j0?T0?$PM0?HV?$NOep0LN?$CBe?$LJ0k?$IK?$BI?$IP?p0U0?$IM0f0D0?$HO0Y0?$AC?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@IJNCMADK@0?j0?T0?$PM0?HV?$NOep0LN?$CBe?$LJ0k?$IK?$BI?$IP?p0U0?$IM0f0D0?$HO0Y0?$AC?$AA?$AA@ DB 0eaH
	DB	'0', 0d4H, '0', 0fcH, '0', 0c8H, '0', 0deH, 'VpeL0!N', 0b9H, 'e'
	DB	'k0', 018H, 08aH, 0f0H, 08fH, 'U0', 08cH, '0f0D0~0Y0', 02H, '0'
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@DPEAGELP@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAA?$AA?$CJ?$AA?5?$AAE?$AAn?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@DPEAGELP@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAA?$AA?$CJ?$AA?5?$AAE?$AAn?$AAd?$AA?$AA@ DB 'R'
	DB	00H, 'e', 00H, 'p', 00H, 'e', 00H, 'a', 00H, 't', 00H, '(', 00H
	DB	'A', 00H, ')', 00H, ' ', 00H, 'E', 00H, 'n', 00H, 'd', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@GCDNCJOK@?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@GCDNCJOK@?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl?$AA?$AA@ DB 'G', 00H
	DB	'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 'l', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@LDPMAPOD@?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@LDPMAPOD@?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?$AA@ DB 'A', 00H
	DB	'd', 00H, 'd', 00H, 'r', 00H, 'e', 00H, 's', 00H, 's', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@DMAFONIK@?$AAC?$AAa?$AAl?$AAl?$AA?5?$AAS?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@DMAFONIK@?$AAC?$AAa?$AAl?$AAl?$AA?5?$AAS?$AAE?$AA?$AA@ DB 'C', 00H
	DB	'a', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'S', 00H, 'E', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@DLCGAOAF@?$AAS?$AAu?$AAb?$AAr?$AAo?$AAu?$AAt?$AAi?$AAn?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@DLCGAOAF@?$AAS?$AAu?$AAb?$AAr?$AAo?$AAu?$AAt?$AAi?$AAn?$AAe?$AA?$AA@ DB 'S'
	DB	00H, 'u', 00H, 'b', 00H, 'r', 00H, 'o', 00H, 'u', 00H, 't', 00H
	DB	'i', 00H, 'n', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@JNKNAIAA@?$AAS?$AAu?$AAb?$AAr?$AAo?$AAu?$AAt?$AAi?$AAn?$AAe?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAP?$AAa?$AAt?$AAc?$AAh@
CONST	SEGMENT
??_C@_1CK@JNKNAIAA@?$AAS?$AAu?$AAb?$AAr?$AAo?$AAu?$AAt?$AAi?$AAn?$AAe?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAP?$AAa?$AAt?$AAc?$AAh@ DB 'S'
	DB	00H, 'u', 00H, 'b', 00H, 'r', 00H, 'o', 00H, 'u', 00H, 't', 00H
	DB	'i', 00H, 'n', 00H, 'e', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, 'P', 00H, 'a', 00H, 't', 00H, 'c', 00H, 'h', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@EHCLFFIH@?$FLXW?$CI0W0j0D0?Q0?C0?A0g0Y0?$AC?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@EHCLFFIH@?$FLXW?$CI0W0j0D0?Q0?C0?A0g0Y0?$AC?$AA?$AA@ DB 'X[(WW0'
	DB	'j0D0', 0d1H, '0', 0c3H, '0', 0c1H, '0g0Y0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@GFLIMKC@?$AAV?$AAo?$AAi?$AAc?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@GFLIMKC@?$AAV?$AAo?$AAi?$AAc?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@ DB 'V'
	DB	00H, 'o', 00H, 'i', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 'E', 00H
	DB	'n', 00H, 'v', 00H, 'e', 00H, 'l', 00H, 'o', 00H, 'p', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@BOAFBFBE@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@BOAFBFBE@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@ DB 'V'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'e', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'v', 00H, 'e', 00H, 'l', 00H, 'o', 00H, 'p'
	DB	00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@HDOLOCJJ@?$AAF?$AAr?$AAe?$AAq?$AAu?$AAe?$AAn?$AAc?$AAy?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@HDOLOCJJ@?$AAF?$AAr?$AAe?$AAq?$AAu?$AAe?$AAn?$AAc?$AAy?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@ DB 'F'
	DB	00H, 'r', 00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, 'n', 00H
	DB	'c', 00H, 'y', 00H, ' ', 00H, 'E', 00H, 'n', 00H, 'v', 00H, 'e'
	DB	00H, 'l', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@CBOHIOMD@?$AAN?$AAo?$AAt?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@CBOHIOMD@?$AAN?$AAo?$AAt?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@ DB 'N'
	DB	00H, 'o', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'E', 00H, 'n', 00H
	DB	'v', 00H, 'e', 00H, 'l', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@DKLMFINE@?$AAV?$AAo?$AAi?$AAc?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1M@DKLMFINE@?$AAV?$AAo?$AAi?$AAc?$AAe?$AA?$AA@ DB 'V', 00H, 'o', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@DNAKKDOB@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?5?$AAO?$AAf?$AAf?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@DNAKKDOB@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?5?$AAO?$AAf?$AAf?$AA?$AA@ DB 'V'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'e', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'v', 00H, 'e', 00H, 'l', 00H, 'o', 00H, 'p'
	DB	00H, 'e', 00H, ' ', 00H, 'O', 00H, 'f', 00H, 'f', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@BJABPOLD@?$AAF?$AAr?$AAe?$AAq?$AAu?$AAe?$AAn?$AAc?$AAy?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?5?$AAO@
CONST	SEGMENT
??_C@_1CO@BJABPOLD@?$AAF?$AAr?$AAe?$AAq?$AAu?$AAe?$AAn?$AAc?$AAy?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?5?$AAO@ DB 'F'
	DB	00H, 'r', 00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, 'n', 00H
	DB	'c', 00H, 'y', 00H, ' ', 00H, 'E', 00H, 'n', 00H, 'v', 00H, 'e'
	DB	00H, 'l', 00H, 'o', 00H, 'p', 00H, 'e', 00H, ' ', 00H, 'O', 00H
	DB	'f', 00H, 'f', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@KEOAGLPM@?$AAN?$AAo?$AAt?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?5?$AAO?$AAf?$AAf?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@KEOAGLPM@?$AAN?$AAo?$AAt?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?5?$AAO?$AAf?$AAf?$AA?$AA@ DB 'N'
	DB	00H, 'o', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'E', 00H, 'n', 00H
	DB	'v', 00H, 'e', 00H, 'l', 00H, 'o', 00H, 'p', 00H, 'e', 00H, ' '
	DB	00H, 'O', 00H, 'f', 00H, 'f', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@HAFHLPCH@?$AAS?$AAw?$AAe?$AAe?$AAp?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HAFHLPCH@?$AAS?$AAw?$AAe?$AAe?$AAp?$AA?$AA@ DB 'S', 00H, 'w', 00H
	DB	'e', 00H, 'e', 00H, 'p', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@GOJLGHKM@?$AAF?$AAD?$AAS?$AA?5?$AAc?$AAa?$AAr?$AAe?$AAe?$AAr?$AA?5?$AAw?$AAa?$AAv?$AAe?$AA?5?$AAt?$AAa?$AAb?$AAl@
CONST	SEGMENT
??_C@_1CM@GOJLGHKM@?$AAF?$AAD?$AAS?$AA?5?$AAc?$AAa?$AAr?$AAe?$AAe?$AAr?$AA?5?$AAw?$AAa?$AAv?$AAe?$AA?5?$AAt?$AAa?$AAb?$AAl@ DB 'F'
	DB	00H, 'D', 00H, 'S', 00H, ' ', 00H, 'c', 00H, 'a', 00H, 'r', 00H
	DB	'e', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'w', 00H, 'a', 00H, 'v'
	DB	00H, 'e', 00H, ' ', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@IBICFHPL@?$AAF?$AAD?$AAS?$AA?5?$AAm?$AAo?$AAd?$AAu?$AAl?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAw?$AAa?$AAv?$AAe?$AA?5?$AAt@
CONST	SEGMENT
??_C@_1DC@IBICFHPL@?$AAF?$AAD?$AAS?$AA?5?$AAm?$AAo?$AAd?$AAu?$AAl?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAw?$AAa?$AAv?$AAe?$AA?5?$AAt@ DB 'F'
	DB	00H, 'D', 00H, 'S', 00H, ' ', 00H, 'm', 00H, 'o', 00H, 'd', 00H
	DB	'u', 00H, 'l', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' '
	DB	00H, 'w', 00H, 'a', 00H, 'v', 00H, 'e', 00H, ' ', 00H, 't', 00H
	DB	'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@FAPBPOGD@?$AAV?$AAR?$AAC?$AA7?$AA?5?$AAu?$AAs?$AAe?$AAr?$AA?5?$AAi?$AAn?$AAs?$AAt?$AAr?$AAu?$AAm?$AAe?$AAn?$AAt@
CONST	SEGMENT
??_C@_1CM@FAPBPOGD@?$AAV?$AAR?$AAC?$AA7?$AA?5?$AAu?$AAs?$AAe?$AAr?$AA?5?$AAi?$AAn?$AAs?$AAt?$AAr?$AAu?$AAm?$AAe?$AAn?$AAt@ DB 'V'
	DB	00H, 'R', 00H, 'C', 00H, '7', 00H, ' ', 00H, 'u', 00H, 's', 00H
	DB	'e', 00H, 'r', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H
	DB	's', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@NKOKHIPN@?$AAn?$AA1?$AA6?$AA3?$AA?5?$AAw?$AAa?$AAv?$AAe?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@NKOKHIPN@?$AAn?$AA1?$AA6?$AA3?$AA?5?$AAw?$AAa?$AAv?$AAe?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$AA@ DB 'n'
	DB	00H, '1', 00H, '6', 00H, '3', 00H, ' ', 00H, 'w', 00H, 'a', 00H
	DB	'v', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l'
	DB	00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@CPIKLJAL@?$AA?$EA?$AAN?$AA?50?$LD0?$NO0?s0?I0n0?Q0?i0?a0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC@
CONST	SEGMENT
??_C@_1EA@CPIKLJAL@?$AA?$EA?$AAN?$AA?50?$LD0?$NO0?s0?I0n0?Q0?i0?a0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC@ DB '@'
	DB	00H, 'N', 00H, ' ', 00H, 0b3H, '0', 0deH, '0', 0f3H, '0', 0c9H
	DB	'0n0', 0d1H, '0', 0e9H, '0', 0e1H, '0', 0fcH, '0', 0bfH, '0L0', 0b3H
	DB	08dH, 08aH, '0~0[0', 093H, '0', 02H, '0', 012H, 0ffH, 'd0', 07H
	DB	'c', 09aH, '[W0f0O0`0U0D0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@PCFIGAHG@?$AAJ0?$LD0?$NO0?s0?I0o?$AA0?$PP?$FO?$AA10n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O0?$GA0U@
CONST	SEGMENT
??_C@_1CO@PCFIGAHG@?$AAJ0?$LD0?$NO0?s0?I0o?$AA0?$PP?$FO?$AA10n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O0?$GA0U@ DB 'J'
	DB	00H, 0b3H, '0', 0deH, '0', 0f3H, '0', 0c9H, '0o00', 00H, '^', 0ffH
	DB	'1', 00H, 'n0', 0c4H, '{', 0f2H, 'Vg0', 07H, 'c', 09aH, '[W0f0'
	DB	'O0`0U0D0', 02H, '0', 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@EMHPIIFB@?$AAG?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AA?$CI?$AAq?$AA?$CJ?$AA?5?$AAB?$AAy?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@EMHPIIFB@?$AAG?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AA?$CI?$AAq?$AA?$CJ?$AA?5?$AAB?$AAy?$AAt?$AAe?$AA?$AA@ DB 'G'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, 't', 00H, 'i', 00H, 'm', 00H
	DB	'e', 00H, '(', 00H, 'q', 00H, ')', 00H, ' ', 00H, 'B', 00H, 'y'
	DB	00H, 't', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@DCFFOBJ@?$AAG?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AA?$CI?$AAq?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@DCFFOBJ@?$AAG?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AA?$CI?$AAq?$AA?$CJ?$AA?$AA@ DB 'G'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, 't', 00H, 'i', 00H, 'm', 00H
	DB	'e', 00H, '(', 00H, 'q', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@IPILGHHC@?$AAG?$AAa?$AAt?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@IPILGHHC@?$AAG?$AAa?$AAt?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@ DB 'G'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H
	DB	'e', 00H, '(', 00H, 'u', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@HCGIJCFJ@0?$LC0?$PM0?H0?$LP0?$KE0?$OA?$AAQ0o?$AA1?$PP?$FO?$AA?$CD?$AAQ?$AAM?$AAa?$AAx0n?$HL?DV?r0gc?$AH@
CONST	SEGMENT
??_C@_1DI@HCGIJCFJ@0?$LC0?$PM0?H0?$LP0?$KE0?$OA?$AAQ0o?$AA1?$PP?$FO?$AA?$CD?$AAQ?$AAM?$AAa?$AAx0n?$HL?DV?r0gc?$AH@ DB 0b2H
	DB	'0', 0fcH, '0', 0c8H, '0', 0bfH, '0', 0a4H, '0', 0e0H, '0Q', 00H
	DB	'o01', 00H, '^', 0ffH, '#', 00H, 'Q', 00H, 'M', 00H, 'a', 00H, 'x'
	DB	00H, 'n0', 0c4H, '{', 0f2H, 'Vg0', 07H, 'c', 09aH, '[W0f0', 0bH
	DB	'NU0D0', 02H, '0', 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@DMILNHDF@0?$LC0?$PM0?H0?$LP0?$KE0?$OA?$AAq0o?$AA0?$PP?$FO?$AA2?$AA5?$AA50n?$HL?DV?r0gc?$AH?$FL?$JK0W@
CONST	SEGMENT
??_C@_1DE@DMILNHDF@0?$LC0?$PM0?H0?$LP0?$KE0?$OA?$AAq0o?$AA0?$PP?$FO?$AA2?$AA5?$AA50n?$HL?DV?r0gc?$AH?$FL?$JK0W@ DB 0b2H
	DB	'0', 0fcH, '0', 0c8H, '0', 0bfH, '0', 0a4H, '0', 0e0H, '0q', 00H
	DB	'o00', 00H, '^', 0ffH, '2', 00H, '5', 00H, '5', 00H, 'n0', 0c4H
	DB	'{', 0f2H, 'Vg0', 07H, 'c', 09aH, '[W0f0', 0bH, 'NU0D0', 02H, '0'
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@CIPPAIIN@?$AAG?$AAa?$AAt?$AAe?$AAM?$AAo?$AAd?$AAe?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@CIPPAIIN@?$AAG?$AAa?$AAt?$AAe?$AAM?$AAo?$AAd?$AAe?$AA?5?$AA0?$AA?$AA@ DB 'G'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, 'M', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@JAEDGPOI@?$AAG?$AAa?$AAt?$AAe?$AAM?$AAo?$AAd?$AAe?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@JAEDGPOI@?$AAG?$AAa?$AAt?$AAe?$AAM?$AAo?$AAd?$AAe?$AA?5?$AA1?$AA?$AA@ DB 'G'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, 'M', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, ' ', 00H, '1', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@ICPGMAAG@?$AAG?$AAa?$AAt?$AAe?$AAM?$AAo?$AAd?$AAe?$AA?5?$AA2?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@ICPGMAAG@?$AAG?$AAa?$AAt?$AAe?$AAM?$AAo?$AAd?$AAe?$AA?5?$AA2?$AA?$AA@ DB 'G'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, 'M', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, ' ', 00H, '2', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@NMCJFJGP@0?j0?j0?$PM0?$LJ0?b0?$PM0?I0o?$AA0?$PP?$FO?$AA20n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O@
CONST	SEGMENT
??_C@_1DC@NMCJFJGP@0?j0?j0?$PM0?$LJ0?b0?$PM0?I0o?$AA0?$PP?$FO?$AA20n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O@ DB 0eaH
	DB	'0', 0eaH, '0', 0fcH, '0', 0b9H, '0', 0e2H, '0', 0fcH, '0', 0c9H
	DB	'0o00', 00H, '^', 0ffH, '2', 00H, 'n0', 0c4H, '{', 0f2H, 'Vg0', 07H
	DB	'c', 09aH, '[W0f0O0`0U0D0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@LPHMCIPB@?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?5?$AAV?$AAo?$AAi?$AAc?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@LPHMCIPB@?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?5?$AAV?$AAo?$AAi?$AAc?$AAe?$AA?$AA@ DB 'R'
	DB	00H, 'e', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 's', 00H, 'e', 00H
	DB	' ', 00H, 'V', 00H, 'o', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@NPNLAEDI@0?j0?j0?$PM0?$LJ?$JH?s?$ICr0o?$AA0?$PP?$FO?$AA70n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O0?$GA@
CONST	SEGMENT
??_C@_1DA@NPNLAEDI@0?j0?j0?$PM0?$LJ?$JH?s?$ICr0o?$AA0?$PP?$FO?$AA70n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O0?$GA@ DB 0eaH
	DB	'0', 0eaH, '0', 0fcH, '0', 0b9H, '0', 0f3H, 097H, 'r', 082H, 'o'
	DB	'00', 00H, '^', 0ffH, '7', 00H, 'n0', 0c4H, '{', 0f2H, 'Vg0', 07H
	DB	'c', 09aH, '[W0f0O0`0U0D0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@IEEELBMO@?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?5?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@IEEELBMO@?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?5?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@ DB 'R'
	DB	00H, 'e', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 's', 00H, 'e', 00H
	DB	' ', 00H, 'V', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@OMCJIBOF@?$JH?s?$JB?O0o?$AA0?$PP?$FO?$AA1?$AA50n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O0?$GA0U0D0?$AC@
CONST	SEGMENT
??_C@_1CK@OMCJIBOF@?$JH?s?$JB?O0o?$AA0?$PP?$FO?$AA1?$AA50n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O0?$GA0U0D0?$AC@ DB 0f3H
	DB	097H, 0cfH, 091H, 'o00', 00H, '^', 0ffH, '1', 00H, '5', 00H, 'n'
	DB	'0', 0c4H, '{', 0f2H, 'Vg0', 07H, 'c', 09aH, '[W0f0O0`0U0D0', 02H
	DB	'0', 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?Shift@?1??SetKey@MusicTrack@@QAEXHH@Z@4QBDB
CONST	SEGMENT
?Shift@?1??SetKey@MusicTrack@@QAEXHH@Z@4QBDB DB 03H	; `MusicTrack::SetKey'::`2'::Shift
	DB	06H
	DB	02H
	DB	05H
	DB	01H
	DB	04H
	DB	00H
	DB	03H
	DB	06H
	DB	02H
	DB	05H
	DB	01H
	DB	04H
	DB	00H
	DB	03H
	DB	06H
CONST	ENDS
;	COMDAT ?Key@?1??SetKey@MusicTrack@@QAEXHH@Z@4QAY06$$CBDA
CONST	SEGMENT
?Key@?1??SetKey@MusicTrack@@QAEXHH@Z@4QAY06$$CBDA DB 0ffH ; `MusicTrack::SetKey'::`2'::Key
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	02H
	DB	01H
	DB	01H
	DB	01H
	DB	02H
	DB	01H
	DB	01H
	DB	02H
	DB	01H
	DB	01H
	DB	01H
CONST	ENDS
;	COMDAT ?Scale@?1??SetKey@MusicTrack@@QAEXHH@Z@4QAY06$$CBDA
CONST	SEGMENT
?Scale@?1??SetKey@MusicTrack@@QAEXHH@Z@4QAY06$$CBDA DB 00H ; `MusicTrack::SetKey'::`2'::Scale
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	01H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0feH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0feH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0feH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	01H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0feH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0feH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0feH
	DB	00H
	DB	00H
	DB	0ffH
	DB	01H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0feH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0feH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0feH
	DB	0feH
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	01H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT ??_C@_05KFOFLDIO@C?9Dur?$AA@
CONST	SEGMENT
??_C@_05KFOFLDIO@C?9Dur?$AA@ DB 'C-Dur', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DNHFJLJE@Ds?9Dur?$AA@
CONST	SEGMENT
??_C@_06DNHFJLJE@Ds?9Dur?$AA@ DB 'Ds-Dur', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BCGGFLM@Des?9Dur?$AA@
CONST	SEGMENT
??_C@_07BCGGFLM@Des?9Dur?$AA@ DB 'Des-Dur', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LIOAIDDG@D?9Dur?$AA@
CONST	SEGMENT
??_C@_05LIOAIDDG@D?9Dur?$AA@ DB 'D-Dur', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JLACJACA@Es?9Dur?$AA@
CONST	SEGMENT
??_C@_06JLACJACA@Es?9Dur?$AA@ DB 'Es-Dur', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HDLMFAJD@E?9Dur?$AA@
CONST	SEGMENT
??_C@_05HDLMFAJD@E?9Dur?$AA@ DB 'E-Dur', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PFCICCDN@F?9Dur?$AA@
CONST	SEGMENT
??_C@_05PFCICCDN@F?9Dur?$AA@ DB 'F-Dur', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IEKDAILF@Fis?9Dur?$AA@
CONST	SEGMENT
??_C@_07IEKDAILF@Fis?9Dur?$AA@ DB 'Fis-Dur', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MJNIBAJ@Gs?9Dur?$AA@
CONST	SEGMENT
??_C@_06MJNIBAJ@Gs?9Dur?$AA@ DB 'Gs-Dur', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IPKJGCFP@Ges?9Dur?$AA@
CONST	SEGMENT
??_C@_07IPKJGCFP@Ges?9Dur?$AA@ DB 'Ges-Dur', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DOHEPBJI@G?9Dur?$AA@
CONST	SEGMENT
??_C@_05DOHEPBJI@G?9Dur?$AA@ DB 'G-Dur', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GPENLEDD@As?9Dur?$AA@
CONST	SEGMENT
??_C@_06GPENLEDD@As?9Dur?$AA@ DB 'As-Dur', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OICNBCIF@A?9Dur?$AA@
CONST	SEGMENT
??_C@_05OICNBCIF@A?9Dur?$AA@ DB 'A-Dur', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GOLJGACL@B?9Dur?$AA@
CONST	SEGMENT
??_C@_05GOLJGACL@B?9Dur?$AA@ DB 'B-Dur', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FOKFKOKO@Bs?9Dur?$AA@
CONST	SEGMENT
??_C@_06FOKFKOKO@Bs?9Dur?$AA@ DB 'Bs-Dur', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MPCCEDEN@H?9Dur?$AA@
CONST	SEGMENT
??_C@_05MPCCEDEN@H?9Dur?$AA@ DB 'H-Dur', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OJJNCCFH@c?9moll?$AA@
CONST	SEGMENT
??_C@_06OJJNCCFH@c?9moll?$AA@ DB 'c-moll', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FPGMHDLI@cis?9moll?$AA@
CONST	SEGMENT
??_C@_08FPGMHDLI@cis?9moll?$AA@ DB 'cis-moll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06CMDKBMNJ@d?9moll?$AA@
CONST	SEGMENT
??_C@_06CMDKBMNJ@d?9moll?$AA@ DB 'd-moll', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DLANBOHB@dis?9moll?$AA@
CONST	SEGMENT
??_C@_08DLANBOHB@dis?9moll?$AA@ DB 'dis-moll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07OOAGBAFB@es?9moll?$AA@
CONST	SEGMENT
??_C@_07OOAGBAFB@es?9moll?$AA@ DB 'es-moll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKENBHGN@e?9moll?$AA@
CONST	SEGMENT
??_C@_06IKENBHGN@e?9moll?$AA@ DB 'e-moll', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LLKFANPA@f?9moll?$AA@
CONST	SEGMENT
??_C@_06LLKFANPA@f?9moll?$AA@ DB 'f-moll', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BFPLDGPH@fis?9moll?$AA@
CONST	SEGMENT
??_C@_08BFPLDGPH@fis?9moll?$AA@ DB 'fis-moll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06BNNCAGEE@g?9moll?$AA@
CONST	SEGMENT
??_C@_06BNNCAGEE@g?9moll?$AA@ DB 'g-moll', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CIACCLE@gis?9moll?$AA@
CONST	SEGMENT
??_C@_08CIACCLE@gis?9moll?$AA@ DB 'gis-moll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HOACDDHO@a?9moll?$AA@
CONST	SEGMENT
??_C@_06HOACDDHO@a?9moll?$AA@ DB 'a-moll', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EPOKCJOD@b?9moll?$AA@
CONST	SEGMENT
??_C@_06EPOKCJOD@b?9moll?$AA@ DB 'b-moll', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OEMDBJEI@bs?9moll?$AA@
CONST	SEGMENT
??_C@_07OEMDBJEI@bs?9moll?$AA@ DB 'bs-moll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OLJKHGKN@h?9moll?$AA@
CONST	SEGMENT
??_C@_06OLJKHGKN@h?9moll?$AA@ DB 'h-moll', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CCKMBAMP@ds?9moll?$AA@
CONST	SEGMENT
??_C@_07CCKMBAMP@ds?9moll?$AA@ DB 'ds-moll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GMKCALDO@des?9moll?$AA@
CONST	SEGMENT
??_C@_08GMKCALDO@des?9moll?$AA@ DB 'des-moll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KMCDBHCM@gs?9moll?$AA@
CONST	SEGMENT
??_C@_07KMCDBHCM@gs?9moll?$AA@ DB 'gs-moll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FFCPDHPL@ges?9moll?$AA@
CONST	SEGMENT
??_C@_08FFCPDHPL@ges?9moll?$AA@ DB 'ges-moll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GKEMBOKL@as?9moll?$AA@
CONST	SEGMENT
??_C@_07GKEMBOKL@as?9moll?$AA@ DB 'as-moll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01MIFGBAGJ@?$CL?$AA@
CONST	SEGMENT
??_C@_01MIFGBAGJ@?$CL?$AA@ DB '+', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CMICPHGH@?$IB?$HL?$AA@
CONST	SEGMENT
??_C@_02CMICPHGH@?$IB?$HL?$AA@ DB 081H, '{', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01IPJKGB@?$CD?$AA@
CONST	SEGMENT
??_C@_01IPJKGB@?$CD?$AA@ DB '#', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PFGEBIEE@?$IB?$JE?$AA@
CONST	SEGMENT
??_C@_02PFGEBIEE@?$IB?$JE?$AA@ DB 081H, 094H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02GDMDGBKA@?$IB?$HM?$AA@
CONST	SEGMENT
??_C@_02GDMDGBKA@?$IB?$HM?$AA@ DB 081H, '|', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02NPNIOFCE@?$IB?s?$AA@
CONST	SEGMENT
??_C@_02NPNIOFCE@?$IB?s?$AA@ DB 081H, 0f3H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01NEMOKFLO@?$DN?$AA@
CONST	SEGMENT
??_C@_01NEMOKFLO@?$DN?$AA@ DB '=', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MCNBPOFA@?$IB?$IB?$AA@
CONST	SEGMENT
??_C@_02MCNBPOFA@?$IB?$IB?$AA@ DB 081H, 081H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK?$AA@
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK?$AA@ DB '*', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MHFCHKMG@?$IB?$JG?$AA@
CONST	SEGMENT
??_C@_02MHFCHKMG@?$IB?$JG?$AA@ DB 081H, 096H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02LJKBFKON@?$ID?$JD?$AA@
CONST	SEGMENT
??_C@_02LJKBFKON@?$ID?$JD?$AA@ DB 083H, 093H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02LEAGIKBB@?$IDb?$AA@
CONST	SEGMENT
??_C@_02LEAGIKBB@?$IDb?$AA@ DB 083H, 'b', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02OPKIDJPP@?$IC?q?$AA@
CONST	SEGMENT
??_C@_02OPKIDJPP@?$IC?q?$AA@ DB 082H, 0f1H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DAOOAPAM@?$IC?A?$AA@
CONST	SEGMENT
??_C@_02DAOOAPAM@?$IC?A?$AA@ DB 082H, 0c1H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02BILDMFBN@?$IDn?$AA@
CONST	SEGMENT
??_C@_02BILDMFBN@?$IDn?$AA@ DB 083H, 'n', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02HMNPAABJ@?$IDj?$AA@
CONST	SEGMENT
??_C@_02HMNPAABJ@?$IDj?$AA@ DB 083H, 'j', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DGBNBCEI@?$IDz?$AA@
CONST	SEGMENT
??_C@_02DGBNBCEI@?$IDz?$AA@ DB 083H, 'z', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02IDLDGMAF@?$IDw?$AA@
CONST	SEGMENT
??_C@_02IDLDGMAF@?$IDw?$AA@ DB 083H, 'w', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02MJHBHOFE@?$IDg?$AA@
CONST	SEGMENT
??_C@_02MJHBHOFE@?$IDg?$AA@ DB 083H, 'g', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DIJJJPPC@?$IDC?$AA@
CONST	SEGMENT
??_C@_02DIJJJPPC@?$IDC?$AA@ DB 083H, 'C', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GNOAGFDC@?$ID?$IN?$AA@
CONST	SEGMENT
??_C@_02GNOAGFDC@?$ID?$IN?$AA@ DB 083H, 08dH, 00H	; `string'
CONST	ENDS
;	COMDAT ?KS_Command@?1??SetKeySignature@MusicTrack@@QAEXPAVMMLfile@@@Z@4QBUCommand_Info@@B
CONST	SEGMENT
?KS_Command@?1??SetKeySignature@MusicTrack@@QAEXPAVMMLfile@@@Z@4QBUCommand_Info@@B DD FLAT:??_C@_05KFOFLDIO@C?9Dur?$AA@ ; `MusicTrack::SetKeySignature'::`2'::KS_Command
	DD	0bH
	DD	FLAT:??_C@_06DNHFJLJE@Ds?9Dur?$AA@
	DD	017H
	DD	FLAT:??_C@_07BCGGFLM@Des?9Dur?$AA@
	DD	017H
	DD	FLAT:??_C@_05LIOAIDDG@D?9Dur?$AA@
	DD	0dH
	DD	FLAT:??_C@_06JLACJACA@Es?9Dur?$AA@
	DD	015H
	DD	FLAT:??_C@_05HDLMFAJD@E?9Dur?$AA@
	DD	0fH
	DD	FLAT:??_C@_05PFCICCDN@F?9Dur?$AA@
	DD	013H
	DD	FLAT:??_C@_07IEKDAILF@Fis?9Dur?$AA@
	DD	011H
	DD	FLAT:??_C@_06MJNIBAJ@Gs?9Dur?$AA@
	DD	018H
	DD	FLAT:??_C@_07IPKJGCFP@Ges?9Dur?$AA@
	DD	018H
	DD	FLAT:??_C@_05DOHEPBJI@G?9Dur?$AA@
	DD	0cH
	DD	FLAT:??_C@_06GPENLEDD@As?9Dur?$AA@
	DD	016H
	DD	FLAT:??_C@_05OICNBCIF@A?9Dur?$AA@
	DD	0eH
	DD	FLAT:??_C@_05GOLJGACL@B?9Dur?$AA@
	DD	014H
	DD	FLAT:??_C@_06FOKFKOKO@Bs?9Dur?$AA@
	DD	014H
	DD	FLAT:??_C@_05MPCCEDEN@H?9Dur?$AA@
	DD	010H
	DD	FLAT:??_C@_06OJJNCCFH@c?9moll?$AA@
	DD	01aH
	DD	FLAT:??_C@_08FPGMHDLI@cis?9moll?$AA@
	DD	021H
	DD	FLAT:??_C@_06CMDKBMNJ@d?9moll?$AA@
	DD	01cH
	DD	FLAT:??_C@_08DLANBOHB@dis?9moll?$AA@
	DD	023H
	DD	FLAT:??_C@_07OOAGBAFB@es?9moll?$AA@
	DD	026H
	DD	FLAT:??_C@_06IKENBHGN@e?9moll?$AA@
	DD	01eH
	DD	FLAT:??_C@_06LLKFANPA@f?9moll?$AA@
	DD	024H
	DD	FLAT:??_C@_08BFPLDGPH@fis?9moll?$AA@
	DD	020H
	DD	FLAT:??_C@_06BNNCAGEE@g?9moll?$AA@
	DD	01bH
	DD	FLAT:??_C@_08CIACCLE@gis?9moll?$AA@
	DD	022H
	DD	FLAT:??_C@_06HOACDDHO@a?9moll?$AA@
	DD	01dH
	DD	FLAT:??_C@_06EPOKCJOD@b?9moll?$AA@
	DD	025H
	DD	FLAT:??_C@_07OEMDBJEI@bs?9moll?$AA@
	DD	025H
	DD	FLAT:??_C@_06OLJKHGKN@h?9moll?$AA@
	DD	01fH
	DD	FLAT:??_C@_07CCKMBAMP@ds?9moll?$AA@
	DD	028H
	DD	FLAT:??_C@_08GMKCALDO@des?9moll?$AA@
	DD	028H
	DD	FLAT:??_C@_07KMCDBHCM@gs?9moll?$AA@
	DD	029H
	DD	FLAT:??_C@_08FFCPDHPL@ges?9moll?$AA@
	DD	029H
	DD	FLAT:??_C@_07GKEMBOKL@as?9moll?$AA@
	DD	027H
	DD	FLAT:??_C@_01MIFGBAGJ@?$CL?$AA@
	DD	00H
	DD	FLAT:??_C@_02CMICPHGH@?$IB?$HL?$AA@
	DD	00H
	DD	FLAT:??_C@_01IPJKGB@?$CD?$AA@
	DD	00H
	DD	FLAT:??_C@_02PFGEBIEE@?$IB?$JE?$AA@
	DD	00H
	DD	FLAT:??_C@_01JOAMLHOP@?9?$AA@
	DD	01H
	DD	FLAT:??_C@_02GDMDGBKA@?$IB?$HM?$AA@
	DD	01H
	DD	FLAT:??_C@_02NPNIOFCE@?$IB?s?$AA@
	DD	01H
	DD	FLAT:??_C@_01NEMOKFLO@?$DN?$AA@
	DD	02H
	DD	FLAT:??_C@_02MCNBPOFA@?$IB?$IB?$AA@
	DD	02H
	DD	FLAT:??_C@_01NBENCBCI@?$CK?$AA@
	DD	02H
	DD	FLAT:??_C@_02MHFCHKMG@?$IB?$JG?$AA@
	DD	02H
	DD	FLAT:??_C@_01PAPGNFGE@c?$AA@
	DD	03H
	DD	FLAT:??_C@_01LPLHEDKD@d?$AA@
	DD	04H
	DD	FLAT:??_C@_01KGKMHCOC@e?$AA@
	DD	05H
	DD	FLAT:??_C@_01INIBCBCB@f?$AA@
	DD	06H
	DD	FLAT:??_C@_01JEJKBAGA@g?$AA@
	DD	07H
	DD	FLAT:??_C@_01MCMALHOG@a?$AA@
	DD	08H
	DD	FLAT:??_C@_01OJONOECF@b?$AA@
	DD	09H
	DD	FLAT:??_C@_01KDCPPGHE@r?$AA@
	DD	0aH
	DD	FLAT:??_C@_02EOOJGCJL@?$IDh?$AA@
	DD	03H
	DD	FLAT:??_C@_02HEPLFEHD@?$ID?$IM?$AA@
	DD	04H
	DD	FLAT:??_C@_02FCHBNHEM@?$ID?$HO?$AA@
	DD	05H
	DD	FLAT:??_C@_04DIMMBPLH@?$IDt?$ID?$EA?$AA@
	DD	06H
	DD	FLAT:??_C@_02KIJODPMG@?$IDt?$AA@
	DD	06H
	DD	FLAT:??_C@_02PFMDJBGM@?$ID?2?$AA@
	DD	07H
	DD	FLAT:??_C@_02JIMKADG@?$ID?$IJ?$AA@
	DD	08H
	DD	FLAT:??_C@_02PCMHJOG@?$IDV?$AA@
	DD	09H
	DD	FLAT:??_C@_02LJKBFKON@?$ID?$JD?$AA@
	DD	0aH
	DD	FLAT:??_C@_02LEAGIKBB@?$IDb?$AA@
	DD	0aH
	DD	FLAT:??_C@_02GGLEKIIK@?$IC?G?$AA@
	DD	03H
	DD	FLAT:??_C@_02EGJOPCGF@?$IC?j?$AA@
	DD	04H
	DD	FLAT:??_C@_02NGJJFCFB@?$IC?$NN?$AA@
	DD	05H
	DD	FLAT:??_C@_04NCHCKEFM@?$IC?S?$IC?$JP?$AA@
	DD	06H
	DD	FLAT:??_C@_02EIBKHPNP@?$IC?S?$AA@
	DD	06H
	DD	FLAT:??_C@_02OFDOJOHA@?$IC?$LL?$AA@
	DD	07H
	DD	FLAT:??_C@_02PDDAIMCI@?$IC?g?$AA@
	DD	08H
	DD	FLAT:??_C@_02HLLNLDPO@?$IC?$LF?$AA@
	DD	09H
	DD	FLAT:??_C@_02OPKIDJPP@?$IC?q?$AA@
	DD	0aH
	DD	FLAT:??_C@_02DAOOAPAM@?$IC?A?$AA@
	DD	0aH
	DD	FLAT:??_C@_02BILDMFBN@?$IDn?$AA@
	DD	03H
	DD	FLAT:??_C@_02HMNPAABJ@?$IDj?$AA@
	DD	04H
	DD	FLAT:??_C@_02DGBNBCEI@?$IDz?$AA@
	DD	05H
	DD	FLAT:??_C@_02IDLDGMAF@?$IDw?$AA@
	DD	06H
	DD	FLAT:??_C@_02MJHBHOFE@?$IDg?$AA@
	DD	07H
	DD	FLAT:??_C@_02DIJJJPPC@?$IDC?$AA@
	DD	08H
	DD	FLAT:??_C@_02GNOAGFDC@?$ID?$IN?$AA@
	DD	09H
CONST	ENDS
;	COMDAT ??_C@_1DI@JCDDEPJK@?$IK?$LPS?w0?$LD0?$NO0?s0?I0?$PL0?V0?m0?C0?$KP0n?$JF?$ILY?K0?$JCy?30Y?$AA?$HL0L?$IJ?$IL@
CONST	SEGMENT
??_C@_1DI@JCDDEPJK@?$IK?$LPS?w0?$LD0?$NO0?s0?I0?$PL0?V0?m0?C0?$KP0n?$JF?$ILY?K0?$JCy?30Y?$AA?$HL0L?$IJ?$IL@ DB 0bfH
	DB	08aH, 0f7H, 'S', 0b3H, '0', 0deH, '0', 0f3H, '0', 0c9H, '0', 0fbH
	DB	'0', 0d6H, '0', 0edH, '0', 0c3H, '0', 0afH, '0n0', 08bH, 095H, 0cbH
	DB	'Y', 092H, '0:yY0{', 00H, 'L0', 08bH, 089H, 'd0K0', 08aH, '0~0'
	DB	'[0', 093H, '0', 02H, '0', 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@GALIBNKP@?$IK?$LPS?w0?$LD0?$NO0?s0?I0?$PL0?V0?m0?C0?$KP0n?$HNBz?o0?$JCy?30Y?$AA?$GA?$AA?$HN?$AA?8@
CONST	SEGMENT
??_C@_1DI@GALIBNKP@?$IK?$LPS?w0?$LD0?$NO0?s0?I0?$PL0?V0?m0?C0?$KP0n?$HNBz?o0?$JCy?30Y?$AA?$GA?$AA?$HN?$AA?8@ DB 0bfH
	DB	08aH, 0f7H, 'S', 0b3H, '0', 0deH, '0', 0f3H, '0', 0c9H, '0', 0fbH
	DB	'0', 0d6H, '0', 0edH, '0', 0c3H, '0', 0afH, '0n0B}', 0efH, 'z', 092H
	DB	'0:yY0`', 00H, '}', 00H, '''', 00H, 'L0B0', 08aH, '0~0[0', 093H
	DB	'0', 02H, '0', 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@KNFDIHJH@?$IK?$LPS?w?$AA?5?$AAK?$AA?$HL?$AA?$HN?$AA?50?$LD0?$NO0?s0?I0n_?$BFep0gg?$CKw?e0ne?$IH?$FLW@
CONST	SEGMENT
??_C@_1DM@KNFDIHJH@?$IK?$LPS?w?$AA?5?$AAK?$AA?$HL?$AA?$HN?$AA?50?$LD0?$NO0?s0?I0n_?$BFep0gg?$CKw?e0ne?$IH?$FLW@ DB 0bfH
	DB	08aH, 0f7H, 'S ', 00H, 'K', 00H, '{', 00H, '}', 00H, ' ', 00H, 0b3H
	DB	'0', 0deH, '0', 0f3H, '0', 0c9H, '0n0', 015H, '_peg0*g', 0e5H, 'w'
	DB	'n0', 087H, 'eW[L0', 07H, 'c', 09aH, '[U0', 08cH, '0~0W0_0', 02H
	DB	'0', 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@PDJGDLM@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA9?$AA6?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@PDJGDLM@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA9?$AA6?$AA?$AA@ DB 'L'
	DB	00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'9', 00H, '6', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@LKFBJFJL@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA7?$AA2?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@LKFBJFJL@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA7?$AA2?$AA?$AA@ DB 'L'
	DB	00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'7', 00H, '2', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@FDHIAHFB@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA4?$AA8?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@FDHIAHFB@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA4?$AA8?$AA?$AA@ DB 'L'
	DB	00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'4', 00H, '8', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@KOKCEANK@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA3?$AA6?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@KOKCEANK@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA3?$AA6?$AA?$AA@ DB 'L'
	DB	00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'3', 00H, '6', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@CBMANHIN@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA3?$AA2?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@CBMANHIN@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA3?$AA2?$AA?$AA@ DB 'L'
	DB	00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'3', 00H, '2', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@MPPHFLPE@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA2?$AA4?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@MPPHFLPE@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA2?$AA4?$AA?$AA@ DB 'L'
	DB	00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'2', 00H, '4', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@DLFJGOC@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA1?$AA8?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@DLFJGOC@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA1?$AA8?$AA?$AA@ DB 'L'
	DB	00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'1', 00H, '8', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@ODGKOBNB@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA1?$AA6?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@ODGKOBNB@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA1?$AA6?$AA?$AA@ DB 'L'
	DB	00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'1', 00H, '6', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@GMAIHGIG@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA1?$AA2?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@GMAIHGIG@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA1?$AA2?$AA?$AA@ DB 'L'
	DB	00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'1', 00H, '2', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@BACHBKJG@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA9?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@BACHBKJG@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA9?$AA?$AA@ DB 'L'
	DB	00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'9', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@KIJLHNPD@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA8?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@KIJLHNPD@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA8?$AA?$AA@ DB 'L'
	DB	00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'8', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@EIEEAKMA@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA6?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@EIEEAKMA@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA6?$AA?$AA@ DB 'L'
	DB	00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'6', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@OCENMCEL@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA4?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@OCENMCEL@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA4?$AA?$AA@ DB 'L'
	DB	00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'4', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@HPJKPKPC@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA3?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@HPJKPKPC@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA3?$AA?$AA@ DB 'L'
	DB	00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'3', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@MHCGJNJH@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA2?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@MHCGJNJH@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA2?$AA?$AA@ DB 'L'
	DB	00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'2', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@NFJDDCHJ@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@NFJDDCHJ@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA1?$AA?$AA@ DB 'L'
	DB	00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'1', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@IONIPGKG@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$AA@
CONST	SEGMENT
??_C@_1O@IONIPGKG@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$AA@ DB 'L', 00H, 'e'
	DB	00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?note_code@?1??calc_note@MusicTrack@@QAEDPAVMMLfile@@H@Z@4QBDB
CONST	SEGMENT
?note_code@?1??calc_note@MusicTrack@@QAEDPAVMMLfile@@H@Z@4QBDB DB 00H ; `MusicTrack::calc_note'::`2'::note_code
	DB	02H
	DB	04H
	DB	05H
	DB	07H
	DB	09H
	DB	0bH
CONST	ENDS
;	COMDAT ??_C@_1EE@FMLCMNNO@?$AAE?$AAC0?$LD0?$NO0?s0?I0n?$HL?0?$PP?$BB0?Q0?i0?a0?$PM0?$LP0o?$AA0?$PP?$FO?$AA2?$AA5?$AA5@
CONST	SEGMENT
??_C@_1EE@FMLCMNNO@?$AAE?$AAC0?$LD0?$NO0?s0?I0n?$HL?0?$PP?$BB0?Q0?i0?a0?$PM0?$LP0o?$AA0?$PP?$FO?$AA2?$AA5?$AA5@ DB 'E'
	DB	00H, 'C', 00H, 0b3H, '0', 0deH, '0', 0f3H, '0', 0c9H, '0n0,{', 011H
	DB	0ffH, 0d1H, '0', 0e9H, '0', 0e1H, '0', 0fcH, '0', 0bfH, '0o00', 00H
	DB	'^', 0ffH, '2', 00H, '5', 00H, '5', 00H, 'n0', 0c4H, '{', 0f2H
	DB	'Vg0', 07H, 'c', 09aH, '[W0f0O0`0U0D0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@ECJHFDDN@?$AAE?$AAC?$AA?50?$LD0?$NO0?s0?I0n0?Q0?i0?a0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC@
CONST	SEGMENT
??_C@_1EA@ECJHFDDN@?$AAE?$AAC?$AA?50?$LD0?$NO0?s0?I0n0?Q0?i0?a0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC@ DB 'E'
	DB	00H, 'C', 00H, ' ', 00H, 0b3H, '0', 0deH, '0', 0f3H, '0', 0c9H
	DB	'0n0', 0d1H, '0', 0e9H, '0', 0e1H, '0', 0fcH, '0', 0bfH, '0L0', 0b3H
	DB	08dH, 08aH, '0~0[0', 093H, '0', 02H, '0', 012H, 0ffH, 'd0', 07H
	DB	'c', 09aH, '[W0f0O0`0U0D0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@OOLANPID@?$AAE?$AAC0?$LD0?$NO0?s0?I0n?$HL?0?$PP?$BC0?Q0?i0?a0?$PM0?$LP0o?$AA?9?$AA1?$PP?$FO?$AA1?$AA5@
CONST	SEGMENT
??_C@_1EE@OOLANPID@?$AAE?$AAC0?$LD0?$NO0?s0?I0n?$HL?0?$PP?$BC0?Q0?i0?a0?$PM0?$LP0o?$AA?9?$AA1?$PP?$FO?$AA1?$AA5@ DB 'E'
	DB	00H, 'C', 00H, 0b3H, '0', 0deH, '0', 0f3H, '0', 0c9H, '0n0,{', 012H
	DB	0ffH, 0d1H, '0', 0e9H, '0', 0e1H, '0', 0fcH, '0', 0bfH, '0o0-', 00H
	DB	'1', 00H, '^', 0ffH, '1', 00H, '5', 00H, 'n0', 0c4H, '{', 0f2H
	DB	'Vg0', 07H, 'c', 09aH, '[W0f0O0`0U0D0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@PHOKHOEC@?$JH?sz?$AL0n?$HL?DV?r0L0?N0?$PM0?H0?J0?s0?P0?$PM?$AA0?$PP?$FO?$AA2?$AA5?$AA50n?$HL?D@
CONST	SEGMENT
??_C@_1DK@PHOKHOEC@?$JH?sz?$AL0n?$HL?DV?r0L0?N0?$PM0?H0?J0?s0?P0?$PM?$AA0?$PP?$FO?$AA2?$AA5?$AA50n?$HL?D@ DB 0f3H
	DB	097H, 0bH, 'zn0', 0c4H, '{', 0f2H, 'VL0', 0ceH, '0', 0fcH, '0', 0c8H
	DB	'0', 0caH, '0', 0f3H, '0', 0d0H, '0', 0fcH, '00', 00H, '^', 0ffH
	DB	'2', 00H, '5', 00H, '5', 00H, 'n0', 0c4H, '{', 0f2H, 'V', 092H
	DB	'0', 085H, 08dH, 'H0~0W0_0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@EPMKAKFB@?$AAE?$AAc?$AAh?$AAo?$AA?5?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@EPMKAKFB@?$AAE?$AAc?$AAh?$AAo?$AA?5?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@ DB 'E'
	DB	00H, 'c', 00H, 'h', 00H, 'o', 00H, ' ', 00H, 'V', 00H, 'o', 00H
	DB	'l', 00H, 'u', 00H, 'm', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@JCJILIHF@?$AAO?$AAn?$AAe?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?5?$AAo?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAd?$AAo?$AAw?$AAn@
CONST	SEGMENT
??_C@_1CK@JCJILIHF@?$AAO?$AAn?$AAe?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?5?$AAo?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAd?$AAo?$AAw?$AAn@ DB 'O'
	DB	00H, 'n', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'i', 00H, 'm', 00H
	DB	'e', 00H, ' ', 00H, 'o', 00H, 'c', 00H, 't', 00H, 'a', 00H, 'v'
	DB	00H, 'e', 00H, ' ', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@IKGHOBJA@?$AAO?$AAn?$AAe?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?5?$AAo?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAu?$AAp?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@IKGHOBJA@?$AAO?$AAn?$AAe?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?5?$AAo?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAu?$AAp?$AA?$AA@ DB 'O'
	DB	00H, 'n', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'i', 00H, 'm', 00H
	DB	'e', 00H, ' ', 00H, 'o', 00H, 'c', 00H, 't', 00H, 'a', 00H, 'v'
	DB	00H, 'e', 00H, ' ', 00H, 'u', 00H, 'p', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@HOMMDOEE@?$AAE?$AAc?$AAh?$AAo?$AA?5?$AAN?$AAo?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@HOMMDOEE@?$AAE?$AAc?$AAh?$AAo?$AA?5?$AAN?$AAo?$AAt?$AAe?$AA?$AA@ DB 'E'
	DB	00H, 'c', 00H, 'h', 00H, 'o', 00H, ' ', 00H, 'N', 00H, 'o', 00H
	DB	't', 00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@DMLCJFNF@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1O@DMLCJFNF@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@ DB 'V', 00H, 'o'
	DB	00H, 'l', 00H, 'u', 00H, 'm', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19JIGFKGL@?$AAN?$AAo?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_19JIGFKGL@?$AAN?$AAo?$AAt?$AAe?$AA?$AA@ DB 'N', 00H, 'o', 00H, 't', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GG@HBOGPEMM@?$AAM?$AAu?$AAs?$AAi?$AAc?$AAT?$AAr?$AAa?$AAc?$AAk?$AA?3?$AA?3?$AAS?$AAe?$AAt?$AAR?$AAe?$AAs?$AAt?$AA?$CI@
CONST	SEGMENT
??_C@_1GG@HBOGPEMM@?$AAM?$AAu?$AAs?$AAi?$AAc?$AAT?$AAr?$AAa?$AAc?$AAk?$AA?3?$AA?3?$AAS?$AAe?$AAt?$AAR?$AAe?$AAs?$AAt?$AA?$CI@ DB 'M'
	DB	00H, 'u', 00H, 's', 00H, 'i', 00H, 'c', 00H, 'T', 00H, 'r', 00H
	DB	'a', 00H, 'c', 00H, 'k', 00H, ':', 00H, ':', 00H, 'S', 00H, 'e'
	DB	00H, 't', 00H, 'R', 00H, 'e', 00H, 's', 00H, 't', 00H, '(', 00H
	DB	')', 00H, 0a2H, 095H, 'pe', 085H, 'Qg0', 01H, '0#', 00H, 'w', 00H
	DB	'a', 00H, 'i', 00H, 't', 00H, 0b3H, '0', 0deH, '0', 0f3H, '0', 0c9H
	DB	'0n0m', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'n0$PL0*g', 0e5H, 'w'
	DB	'n0$Pg0Y0', 02H, '0', 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1GG@IPLHPKBL@?$AAM?$AAu?$AAs?$AAi?$AAc?$AAT?$AAr?$AAa?$AAc?$AAk?$AA?3?$AA?3?$AAS?$AAe?$AAt?$AAR?$AAe?$AAs?$AAt?$AA?$CI@
CONST	SEGMENT
??_C@_1GG@IPLHPKBL@?$AAM?$AAu?$AAs?$AAi?$AAc?$AAT?$AAr?$AAa?$AAc?$AAk?$AA?3?$AA?3?$AAS?$AAe?$AAt?$AAR?$AAe?$AAs?$AAt?$AA?$CI@ DB 'M'
	DB	00H, 'u', 00H, 's', 00H, 'i', 00H, 'c', 00H, 'T', 00H, 'r', 00H
	DB	'a', 00H, 'c', 00H, 'k', 00H, ':', 00H, ':', 00H, 'S', 00H, 'e'
	DB	00H, 't', 00H, 'R', 00H, 'e', 00H, 's', 00H, 't', 00H, '(', 00H
	DB	')', 00H, 0a2H, 095H, 'pe', 085H, 'Qg0', 01H, '0#', 00H, 'r', 00H
	DB	'e', 00H, 's', 00H, 't', 00H, 0b3H, '0', 0deH, '0', 0f3H, '0', 0c9H
	DB	'0n0m', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'n0$PL0*g', 0e5H, 'w'
	DB	'n0$Pg0Y0', 02H, '0', 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_19FAHECHIH@?$AAR?$AAe?$AAs?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_19FAHECHIH@?$AAR?$AAe?$AAs?$AAt?$AA?$AA@ DB 'R', 00H, 'e', 00H, 's', 00H
	DB	't', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@DKBDHLKE@?$AAa?$AA?0?$AAb?$AA?0?$AAc?$PP?$FO?$AAg0n?$JH?sT?$AN0?$JC?$IK?$BI?$IP?p0W0f0O0?$GA0U0D0?$AC@
CONST	SEGMENT
??_C@_1CK@DKBDHLKE@?$AAa?$AA?0?$AAb?$AA?0?$AAc?$PP?$FO?$AAg0n?$JH?sT?$AN0?$JC?$IK?$BI?$IP?p0W0f0O0?$GA0U0D0?$AC@ DB 'a'
	DB	00H, ',', 00H, 'b', 00H, ',', 00H, 'c', 00H, '^', 0ffH, 'g', 00H
	DB	'n0', 0f3H, 097H, 0dH, 'T', 092H, '0', 018H, 08aH, 0f0H, 08fH, 'W'
	DB	'0f0O0`0U0D0', 02H, '0', 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@GGEMPKPF@0?$NN0?k0?$LP0?a0?s0?H0?$LD0?$NO0?s0?I0o0?$AB?$AA?$HN0g?$JF?$IJ0X0fN?$AL0U0D@
CONST	SEGMENT
??_C@_1CM@GGEMPKPF@0?$NN0?k0?$LP0?a0?s0?H0?$LD0?$NO0?s0?I0o0?$AB?$AA?$HN0g?$JF?$IJ0X0fN?$AL0U0D@ DB 0ddH
	DB	'0', 0ebH, '0', 0bfH, '0', 0e1H, '0', 0f3H, '0', 0c8H, '0', 0b3H
	DB	'0', 0deH, '0', 0f3H, '0', 0c9H, '0o0', 01H, '0}', 00H, 'g0', 089H
	DB	095H, 'X0f0', 0bH, 'NU0D0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@BBKDBEBK@0?$NN0?k0?$LP0?a0?s0?H0?$LD0?$NO0?s0?I0g0?$AB?$JH?s?$JFw0L?$AA2?$HL?$IHb?$EA0k?$IK?$BI@
CONST	SEGMENT
??_C@_1DK@BBKDBEBK@0?$NN0?k0?$LP0?a0?s0?H0?$LD0?$NO0?s0?I0g0?$AB?$JH?s?$JFw0L?$AA2?$HL?$IHb?$EA0k?$IK?$BI@ DB 0ddH
	DB	'0', 0ebH, '0', 0bfH, '0', 0e1H, '0', 0f3H, '0', 0c8H, '0', 0b3H
	DB	'0', 0deH, '0', 0f3H, '0', 0c9H, '0g0', 01H, '0', 0f3H, 097H, 'w'
	DB	095H, 'L02', 00H, 087H, '{@bk0', 018H, 08aH, 0f0H, 08fH, 'U0', 08cH
	DB	'0f0D0~0Y0', 02H, '0', 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@HFJPNNCI@0?$NN0?k0?$LP0?a0?s0?H0?$LD0?$NO0?s0?I0g0?$AB0?$LC0?$PM0?H0?$LP0?$KE0?$OA0L?$AA2@
CONST	SEGMENT
??_C@_1EC@HFJPNNCI@0?$NN0?k0?$LP0?a0?s0?H0?$LD0?$NO0?s0?I0g0?$AB0?$LC0?$PM0?H0?$LP0?$KE0?$OA0L?$AA2@ DB 0ddH
	DB	'0', 0ebH, '0', 0bfH, '0', 0e1H, '0', 0f3H, '0', 0c8H, '0', 0b3H
	DB	'0', 0deH, '0', 0f3H, '0', 0c9H, '0g0', 01H, '0', 0b2H, '0', 0fcH
	DB	'0', 0c8H, '0', 0bfH, '0', 0a4H, '0', 0e0H, '0L02', 00H, 087H, '{'
	DB	'@bk0', 018H, 08aH, 0f0H, 08fH, 'U0', 08cH, '0f0D0~0Y0', 02H, '0'
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@GGJHBHG@?$AAP?$AAo?$AAr?$AAt?$AAa?$AAm?$AAe?$AAn?$AAt?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@GGJHBHG@?$AAP?$AAo?$AAr?$AAt?$AAa?$AAm?$AAe?$AAn?$AAt?$AAo?$AA?$AA@ DB 'P'
	DB	00H, 'o', 00H, 'r', 00H, 't', 00H, 'a', 00H, 'm', 00H, 'e', 00H
	DB	'n', 00H, 't', 00H, 'o', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@PLBKOKJL@0?$NN0?k0?$LP0?a0?s0?H0n?$HL?0?$AA10?Q0?i0?a0?$PM0?$LP0o?$AA0?$PP?$FO?$AA2?$AA5?$AA5@
CONST	SEGMENT
??_C@_1EE@PLBKOKJL@0?$NN0?k0?$LP0?a0?s0?H0n?$HL?0?$AA10?Q0?i0?a0?$PM0?$LP0o?$AA0?$PP?$FO?$AA2?$AA5?$AA5@ DB 0ddH
	DB	'0', 0ebH, '0', 0bfH, '0', 0e1H, '0', 0f3H, '0', 0c8H, '0n0,{1'
	DB	00H, 0d1H, '0', 0e9H, '0', 0e1H, '0', 0fcH, '0', 0bfH, '0o00', 00H
	DB	'^', 0ffH, '2', 00H, '5', 00H, '5', 00H, 'n0', 0c4H, '{', 0f2H
	DB	'Vg0', 07H, 'c', 09aH, '[W0f0O0`0U0D0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@OLCBIOJB@?$AAP?$AA?50?$LD0?$NO0?s0?I0n0?Q0?i0?a0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC?$PP?$BE@
CONST	SEGMENT
??_C@_1DO@OLCBIOJB@?$AAP?$AA?50?$LD0?$NO0?s0?I0n0?Q0?i0?a0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC?$PP?$BE@ DB 'P'
	DB	00H, ' ', 00H, 0b3H, '0', 0deH, '0', 0f3H, '0', 0c9H, '0n0', 0d1H
	DB	'0', 0e9H, '0', 0e1H, '0', 0fcH, '0', 0bfH, '0L0', 0b3H, 08dH, 08aH
	DB	'0~0[0', 093H, '0', 02H, '0', 014H, 0ffH, 'd0', 07H, 'c', 09aH
	DB	'[W0f0O0`0U0D0', 02H, '0', 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@IIGGDGHG@0?$NN0?k0?$LP0?a0?s0?H0n?$HL?0?$AA20?Q0?i0?a0?$PM0?$LP0o?$AA1?$PP?$FO?$AA2?$AA5?$AA6@
CONST	SEGMENT
??_C@_1EE@IIGGDGHG@0?$NN0?k0?$LP0?a0?s0?H0n?$HL?0?$AA20?Q0?i0?a0?$PM0?$LP0o?$AA1?$PP?$FO?$AA2?$AA5?$AA6@ DB 0ddH
	DB	'0', 0ebH, '0', 0bfH, '0', 0e1H, '0', 0f3H, '0', 0c8H, '0n0,{2'
	DB	00H, 0d1H, '0', 0e9H, '0', 0e1H, '0', 0fcH, '0', 0bfH, '0o01', 00H
	DB	'^', 0ffH, '2', 00H, '5', 00H, '6', 00H, 'n0', 0c4H, '{', 0f2H
	DB	'Vg0', 07H, 'c', 09aH, '[W0f0O0`0U0D0', 02H, '0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@HIFALIIE@0?$NN0?k0?$LP0?a0?s0?H0n?$HL?0?$AA30?Q0?i0?a0?$PM0?$LP0o?$AA?9?$AA1?$AA2?$AA8?$PP?$FO@
CONST	SEGMENT
??_C@_1EK@HIFALIIE@0?$NN0?k0?$LP0?a0?s0?H0n?$HL?0?$AA30?Q0?i0?a0?$PM0?$LP0o?$AA?9?$AA1?$AA2?$AA8?$PP?$FO@ DB 0ddH
	DB	'0', 0ebH, '0', 0bfH, '0', 0e1H, '0', 0f3H, '0', 0c8H, '0n0,{3'
	DB	00H, 0d1H, '0', 0e9H, '0', 0e1H, '0', 0fcH, '0', 0bfH, '0o0-', 00H
	DB	'1', 00H, '2', 00H, '8', 00H, '^', 0ffH, '1', 00H, '2', 00H, '7'
	DB	00H, 'n0', 0c4H, '{', 0f2H, 'Vg0', 07H, 'c', 09aH, '[W0f0O0`0U'
	DB	'0D0', 02H, '0', 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@FHHEJADM@0?$NN0?k0?$LP0?a0?s0?H0n?$HL?0?$AA40?Q0?i0?a0?$PM0?$LP0o?$AA?9?$AA1?$AA2?$AA8?$PP?$FO@
CONST	SEGMENT
??_C@_1EK@FHHEJADM@0?$NN0?k0?$LP0?a0?s0?H0n?$HL?0?$AA40?Q0?i0?a0?$PM0?$LP0o?$AA?9?$AA1?$AA2?$AA8?$PP?$FO@ DB 0ddH
	DB	'0', 0ebH, '0', 0bfH, '0', 0e1H, '0', 0f3H, '0', 0c8H, '0n0,{4'
	DB	00H, 0d1H, '0', 0e9H, '0', 0e1H, '0', 0fcH, '0', 0bfH, '0o0-', 00H
	DB	'1', 00H, '2', 00H, '8', 00H, '^', 0ffH, '1', 00H, '2', 00H, '7'
	DB	00H, 'n0', 0c4H, '{', 0f2H, 'Vg0', 07H, 'c', 09aH, '[W0f0O0`0U'
	DB	'0D0', 02H, '0', 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@EBCJNIGK@0?$KN0?$PM0?$LH0?U0?H0o?$AA?9?$AA1?$AA2?$AA7?$PP?$FO?$AA1?$AA2?$AA80n?$HL?DV?r0gc?$AH?$FL?$JK@
CONST	SEGMENT
??_C@_1DI@EBCJNIGK@0?$KN0?$PM0?$LH0?U0?H0o?$AA?9?$AA1?$AA2?$AA7?$PP?$FO?$AA1?$AA2?$AA80n?$HL?DV?r0gc?$AH?$FL?$JK@ DB 0adH
	DB	'0', 0fcH, '0', 0b7H, '0', 0d5H, '0', 0c8H, '0o0-', 00H, '1', 00H
	DB	'2', 00H, '7', 00H, '^', 0ffH, '1', 00H, '2', 00H, '8', 00H, 'n'
	DB	'0', 0c4H, '{', 0f2H, 'Vg0', 07H, 'c', 09aH, '[W0f0O0`0U0D0', 02H
	DB	'0', 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@IEPABAMO@0?$KN0?$PM0?$LH0?U0?H0n?$HL?DV?r0L?$AA?9?$AA1?$AA2?$AA7?$PP?$FO?$AA1?$AA2?$AA80?$JC?$IN?$IF0H@
CONST	SEGMENT
??_C@_1DC@IEPABAMO@0?$KN0?$PM0?$LH0?U0?H0n?$HL?DV?r0L?$AA?9?$AA1?$AA2?$AA7?$PP?$FO?$AA1?$AA2?$AA80?$JC?$IN?$IF0H@ DB 0adH
	DB	'0', 0fcH, '0', 0b7H, '0', 0d5H, '0', 0c8H, '0n0', 0c4H, '{', 0f2H
	DB	'VL0-', 00H, '1', 00H, '2', 00H, '7', 00H, '^', 0ffH, '1', 00H
	DB	'2', 00H, '8', 00H, 092H, '0', 085H, 08dH, 'H0~0W0_0', 02H, '0'
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@FKDCKBLJ@?$AAT?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@FKDCKBLJ@?$AAT?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AA?$AA@ DB 'T'
	DB	00H, 'r', 00H, 'a', 00H, 'n', 00H, 's', 00H, 'p', 00H, 'o', 00H
	DB	's', 00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@MDOKKNHL@?$AAR?$AAe?$AAl?$AAa?$AAt?$AAi?$AAv?$AAe?$AA?5?$AAT?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@MDOKKNHL@?$AAR?$AAe?$AAl?$AAa?$AAt?$AAi?$AAv?$AAe?$AA?5?$AAT?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AA?$AA@ DB 'R'
	DB	00H, 'e', 00H, 'l', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'v', 00H
	DB	'e', 00H, ' ', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 's'
	DB	00H, 'p', 00H, 'o', 00H, 's', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@FEMFBHON@?$AAO?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1O@FEMFBHON@?$AAO?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?$AA@ DB 'O', 00H, 'c'
	DB	00H, 't', 00H, 'a', 00H, 'v', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@KKLECMEI@0?$KK0?$KP0?$LP0?$PM0?V0o?$AA1?$PP?$FO?$AA80n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O0?$GA0U@
CONST	SEGMENT
??_C@_1CO@KKLECMEI@0?$KK0?$KP0?$LP0?$PM0?V0o?$AA1?$PP?$FO?$AA80n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O0?$GA0U@ DB 0aaH
	DB	'0', 0afH, '0', 0bfH, '0', 0fcH, '0', 0d6H, '0o01', 00H, '^', 0ffH
	DB	'8', 00H, 'n0', 0c4H, '{', 0f2H, 'Vg0', 07H, 'c', 09aH, '[W0f0'
	DB	'O0`0U0D0', 02H, '0', 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@JMDGIABI@?$AAO?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAU?$AAp?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@JMDGIABI@?$AAO?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAU?$AAp?$AA?$AA@ DB 'O'
	DB	00H, 'c', 00H, 't', 00H, 'a', 00H, 'v', 00H, 'e', 00H, ' ', 00H
	DB	'U', 00H, 'p', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@KEBEFOPC@?$AAO?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAD?$AAo?$AAw?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@KEBEFOPC@?$AAO?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAD?$AAo?$AAw?$AAn?$AA?$AA@ DB 'O'
	DB	00H, 'c', 00H, 't', 00H, 'a', 00H, 'v', 00H, 'e', 00H, ' ', 00H
	DB	'D', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@ILJOBKB@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAu?$AAp?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@ILJOBKB@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAu?$AAp?$AA?$AA@ DB 'V'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'e', 00H, ' ', 00H
	DB	'u', 00H, 'p', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@MGACCNCM@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAd?$AAo?$AAw?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@MGACCNCM@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAd?$AAo?$AAw?$AAn?$AA?$AA@ DB 'V'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'e', 00H, ' ', 00H
	DB	'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_7MusicTrack@@6B@
CONST	SEGMENT
??_7MusicTrack@@6B@ DD FLAT:?getCode@MusicItem@@UAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; MusicTrack::`vftable'
	DD	FLAT:?setCode@MusicItem@@UAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getAsm@MusicItem@@UAEXPAVMusicFile@@@Z
; Function compile flags: /Ogsy
; File f:\nes\nsdl\src\nsc\musictrack.h
;	COMDAT ??0NSD_WORK@@QAE@XZ
_TEXT	SEGMENT
??0NSD_WORK@@QAE@XZ PROC NEAR				; NSD_WORK::NSD_WORK, COMDAT
; _this$ = eax

; 55   : 			NSD_WORK(void){};

  00000	c3		 ret	 0
??0NSD_WORK@@QAE@XZ ENDP				; NSD_WORK::NSD_WORK
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??1NSD_WORK@@QAE@XZ
_TEXT	SEGMENT
??1NSD_WORK@@QAE@XZ PROC NEAR				; NSD_WORK::~NSD_WORK, COMDAT

; 56   : 			~NSD_WORK(void){};

  00000	c3		 ret	 0
??1NSD_WORK@@QAE@XZ ENDP				; NSD_WORK::~NSD_WORK
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?init@NSD_WORK@@QAEXXZ
_TEXT	SEGMENT
?init@NSD_WORK@@QAEXXZ PROC NEAR			; NSD_WORK::init, COMDAT
; _this$ = eax

; 59   : 		//hCol
; 60   : 		gatemode		= -1;

  00000	83 c9 ff	 or	 ecx, -1

; 61   : 		length			= 24;
; 62   : 		gate_q			= 0;

  00003	33 d2		 xor	 edx, edx
  00005	89 08		 mov	 DWORD PTR [eax], ecx
  00007	c7 40 04 18 00
	00 00		 mov	 DWORD PTR [eax+4], 24	; 00000018H
  0000e	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 63   : 		gate_u			= 0;

  00011	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 64   : 		octave			= 3;

  00014	c7 40 10 03 00
	00 00		 mov	 DWORD PTR [eax+16], 3

; 65   : 		octave1			= 0;

  0001b	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 66   : 		detune_cent		= 0;

  0001e	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 67   : 		detune_fine		= 0;

  00021	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 68   : 		trans			= 0;

  00024	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 69   : 		voice			= -1;

  00027	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 70   : 		volume			= 15;

  0002a	c7 40 28 0f 00
	00 00		 mov	 DWORD PTR [eax+40], 15	; 0000000fH

; 71   : 		env_volume		= -1;

  00031	89 48 2c	 mov	 DWORD PTR [eax+44], ecx

; 72   : 		env_voice		= -1;

  00034	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 73   : 		env_frequency	= -1;

  00037	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 74   : 		env_note		= -1;

  0003a	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 75   : 		sweep			= -1;

  0003d	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 76   : 		apu_tri_time	= -1;

  00040	89 48 40	 mov	 DWORD PTR [eax+64], ecx

; 77   : 		fds_frequency	= -1;

  00043	89 48 44	 mov	 DWORD PTR [eax+68], ecx

; 78   : 		fds_sweepbias	= -1;

  00046	89 48 48	 mov	 DWORD PTR [eax+72], ecx

; 79   : 		n163_num		= -1;

  00049	89 48 4c	 mov	 DWORD PTR [eax+76], ecx

; 80   : 		n163_frequency	= -1;

  0004c	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 81   : 		psg_switch		= -1;

  0004f	89 48 54	 mov	 DWORD PTR [eax+84], ecx

; 82   : 	}

  00052	c3		 ret	 0
?init@NSD_WORK@@QAEXXZ ENDP				; NSD_WORK::init
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?Reset_opt@MusicTrack@@QAEXXZ
_TEXT	SEGMENT
?Reset_opt@MusicTrack@@QAEXXZ PROC NEAR			; MusicTrack::Reset_opt, COMDAT
; _this$ = eax

; 386  : 					opt_octave			= -1;

  00000	83 c9 ff	 or	 ecx, -1
  00003	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx

; 387  : 					opt_volume			= -1;

  00009	89 88 bc 00 00
	00		 mov	 DWORD PTR [eax+188], ecx

; 388  : 					opt_gatetime_q		= -1;

  0000f	89 88 b4 00 00
	00		 mov	 DWORD PTR [eax+180], ecx

; 389  : 					opt_gatetime_u		= -1;

  00015	89 88 b8 00 00
	00		 mov	 DWORD PTR [eax+184], ecx

; 390  : 					opt_DefaultLength	= -1;

  0001b	89 88 a4 00 00
	00		 mov	 DWORD PTR [eax+164], ecx

; 391  : 					f_opt_Voi			= false;	//

  00021	32 c9		 xor	 cl, cl
  00023	88 88 f4 01 00
	00		 mov	 BYTE PTR [eax+500], cl

; 392  : 					f_opt_Evoi			= false;	//

  00029	88 88 f5 01 00
	00		 mov	 BYTE PTR [eax+501], cl

; 393  : 					f_opt_Evol			= false;	//

  0002f	88 88 f6 01 00
	00		 mov	 BYTE PTR [eax+502], cl

; 394  : 					f_opt_Em			= false;	//

  00035	88 88 f7 01 00
	00		 mov	 BYTE PTR [eax+503], cl

; 395  : 					f_opt_En			= false;	//

  0003b	88 88 f8 01 00
	00		 mov	 BYTE PTR [eax+504], cl

; 396  : 					f_opt_Key			= false;	//

  00041	88 88 f9 01 00
	00		 mov	 BYTE PTR [eax+505], cl

; 397  : 					f_opt_Sweep			= false;	//

  00047	88 88 fa 01 00
	00		 mov	 BYTE PTR [eax+506], cl

; 398  : 					f_opt_Sub			= false;	//

  0004d	88 88 fb 01 00
	00		 mov	 BYTE PTR [eax+507], cl

; 399  : 			//		if((echo_flag == true) && (echo_slur == false)){
; 400  : 			//			echo_vol_ret	= true;		//
; 401  : 			//		}
; 402  : 				}

  00053	c3		 ret	 0
?Reset_opt@MusicTrack@@QAEXXZ ENDP			; MusicTrack::Reset_opt
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?set@NSD_WORK@@QAEXPAV1@@Z
_TEXT	SEGMENT
?set@NSD_WORK@@QAEXPAV1@@Z PROC NEAR			; NSD_WORK::set, COMDAT
; _this$ = ecx
; _work$ = eax

; 85   : 		gatemode		=	work->gatemode;

  00000	8b 10		 mov	 edx, DWORD PTR [eax]
  00002	89 11		 mov	 DWORD PTR [ecx], edx

; 86   : 		length			=	work->length;

  00004	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00007	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 87   : 		gate_q			=	work->gate_q;

  0000a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000d	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 88   : 		gate_u			=	work->gate_u;

  00010	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00013	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 89   : 		octave			=	work->octave;

  00016	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00019	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 90   : 		octave1			=	work->octave1;

  0001c	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0001f	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 91   : 		detune_cent		=	work->detune_cent;

  00022	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00025	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 92   : 		detune_fine		=	work->detune_fine;

  00028	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0002b	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 93   : 		trans			=	work->trans;

  0002e	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  00031	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 94   : 		voice			=	work->voice;

  00034	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00037	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 95   : 		volume			=	work->volume;

  0003a	8b 50 28	 mov	 edx, DWORD PTR [eax+40]
  0003d	89 51 28	 mov	 DWORD PTR [ecx+40], edx

; 96   : 		env_volume		=	work->env_volume;

  00040	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  00043	89 51 2c	 mov	 DWORD PTR [ecx+44], edx

; 97   : 		env_voice		=	work->env_voice;

  00046	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  00049	89 51 30	 mov	 DWORD PTR [ecx+48], edx

; 98   : 		env_frequency	=	work->env_frequency;

  0004c	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  0004f	89 51 34	 mov	 DWORD PTR [ecx+52], edx

; 99   : 		env_note		=	work->env_note;

  00052	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  00055	89 51 38	 mov	 DWORD PTR [ecx+56], edx

; 100  : 		sweep			=	work->sweep;

  00058	8b 50 3c	 mov	 edx, DWORD PTR [eax+60]
  0005b	89 51 3c	 mov	 DWORD PTR [ecx+60], edx

; 101  : 		apu_tri_time	=	work->apu_tri_time;

  0005e	8b 50 40	 mov	 edx, DWORD PTR [eax+64]
  00061	89 51 40	 mov	 DWORD PTR [ecx+64], edx

; 102  : 		fds_frequency	=	work->fds_frequency;

  00064	8b 50 44	 mov	 edx, DWORD PTR [eax+68]
  00067	89 51 44	 mov	 DWORD PTR [ecx+68], edx

; 103  : 		fds_sweepbias	=	work->fds_sweepbias;

  0006a	8b 50 48	 mov	 edx, DWORD PTR [eax+72]
  0006d	89 51 48	 mov	 DWORD PTR [ecx+72], edx

; 104  : 		n163_num		=	work->n163_num;

  00070	8b 50 4c	 mov	 edx, DWORD PTR [eax+76]
  00073	89 51 4c	 mov	 DWORD PTR [ecx+76], edx

; 105  : 		n163_frequency	=	work->n163_frequency;

  00076	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  00079	89 51 50	 mov	 DWORD PTR [ecx+80], edx

; 106  : 		psg_switch		=	work->psg_switch;

  0007c	8b 40 54	 mov	 eax, DWORD PTR [eax+84]
  0007f	89 41 54	 mov	 DWORD PTR [ecx+84], eax

; 107  : 	}

  00082	c3		 ret	 0
?set@NSD_WORK@@QAEXPAV1@@Z ENDP				; NSD_WORK::set
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?get@NSD_WORK@@QAEXPAV1@@Z
_TEXT	SEGMENT
?get@NSD_WORK@@QAEXPAV1@@Z PROC NEAR			; NSD_WORK::get, COMDAT
; _this$ = eax
; _work$ = ecx

; 109  : 	void	get(NSD_WORK* work){work->set(this);};

  00000	e9 00 00 00 00	 jmp	 ?set@NSD_WORK@@QAEXPAV1@@Z ; NSD_WORK::set
?get@NSD_WORK@@QAEXPAV1@@Z ENDP				; NSD_WORK::get
; Function compile flags: /Ogsy
; File f:\nes\nsdl\src\nsc\musicitem.h
_TEXT	ENDS
;	COMDAT ?setUse@MusicItem@@QAEXXZ
_TEXT	SEGMENT
?setUse@MusicItem@@QAEXXZ PROC NEAR			; MusicItem::setUse, COMDAT
; _this$ = eax

; 52   : 				void	setUse(void){f_Optimize = true;};	//KFs

  00000	c6 40 38 01	 mov	 BYTE PTR [eax+56], 1
  00004	c3		 ret	 0
?setUse@MusicItem@@QAEXXZ ENDP				; MusicItem::setUse
; Function compile flags: /Ogsy
; File f:\nes\nsdl\src\nsc\patch.h
_TEXT	ENDS
;	COMDAT ?get_sw_Evoi@Patch@@QAE_NXZ
_TEXT	SEGMENT
?get_sw_Evoi@Patch@@QAE_NXZ PROC NEAR			; Patch::get_sw_Evoi, COMDAT
; _this$ = eax

; 107  : 				bool	get_sw_Evoi(void){	return(m_now_Patch->sw_Evoi);};

  00000	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00003	8a 40 33	 mov	 al, BYTE PTR [eax+51]
  00006	c3		 ret	 0
?get_sw_Evoi@Patch@@QAE_NXZ ENDP			; Patch::get_sw_Evoi
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z PROC NEAR ; std::_Ptr_cat, COMDAT

; 335  : 	{	// return pointer category from pointer to int arguments

  00000	51		 push	 ecx

; 336  : 	_Scalar_ptr_iterator_tag _Cat;
; 337  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 338  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAH0@Z ENDP ; std::_Ptr_cat
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAVmml_Address@@PAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00AAV?$allocator@PAVmml_Address@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Dest$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Uninit_copy@PAVmml_Address@@PAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00AAV?$allocator@PAVmml_Address@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<mml_Address *,mml_Address *>, COMDAT
; __Last$ = eax

; 106  : 	size_t _Count = (size_t)(_Last - _First);

  00000	2b 44 24 04	 sub	 eax, DWORD PTR __First$[esp-4]
  00004	56		 push	 esi
  00005	c1 f8 02	 sar	 eax, 2

; 107  : 	return ((_Ty2 *)memmove(&*_Dest, &*_First,
; 108  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00008	8b f0		 mov	 esi, eax
  0000a	c1 e6 02	 shl	 esi, 2
  0000d	56		 push	 esi
  0000e	ff 74 24 0c	 push	 DWORD PTR __First$[esp+4]
  00012	ff 74 24 14	 push	 DWORD PTR __Dest$[esp+8]
  00016	e8 00 00 00 00	 call	 _memmove
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001e	03 c6		 add	 eax, esi
  00020	5e		 pop	 esi

; 109  : 	}

  00021	c3		 ret	 0
??$_Uninit_copy@PAVmml_Address@@PAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00AAV?$allocator@PAVmml_Address@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<mml_Address *,mml_Address *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Dest$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<int,int>, COMDAT
; __Last$ = eax

; 106  : 	size_t _Count = (size_t)(_Last - _First);

  00000	2b 44 24 04	 sub	 eax, DWORD PTR __First$[esp-4]
  00004	56		 push	 esi
  00005	c1 f8 02	 sar	 eax, 2

; 107  : 	return ((_Ty2 *)memmove(&*_Dest, &*_First,
; 108  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00008	8b f0		 mov	 esi, eax
  0000a	c1 e6 02	 shl	 esi, 2
  0000d	56		 push	 esi
  0000e	ff 74 24 0c	 push	 DWORD PTR __First$[esp+4]
  00012	ff 74 24 14	 push	 DWORD PTR __Dest$[esp+8]
  00016	e8 00 00 00 00	 call	 _memmove
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001e	03 c6		 add	 eax, esi
  00020	5e		 pop	 esi

; 109  : 	}

  00021	c3		 ret	 0
??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int,int>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill_n@PAPAVmml_Address@@IPAV1@@std@@YAXPAPAVmml_Address@@IABQAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$fill_n@PAPAVmml_Address@@IPAV1@@std@@YAXPAPAVmml_Address@@IABQAV1@@Z PROC NEAR ; std::fill_n<mml_Address * *,unsigned int,mml_Address *>, COMDAT
; __First$ = eax
; __Count$ = ecx

; 1160 : 	for (; 0 < _Count; --_Count, ++_First)

  00000	85 c9		 test	 ecx, ecx
  00002	76 0e		 jbe	 SHORT $L33267
$L33265:

; 1161 : 		*_First = _Val;

  00004	8b 54 24 04	 mov	 edx, DWORD PTR __Val$[esp-4]
  00008	8b 12		 mov	 edx, DWORD PTR [edx]
  0000a	89 10		 mov	 DWORD PTR [eax], edx
  0000c	83 c0 04	 add	 eax, 4
  0000f	49		 dec	 ecx
  00010	75 f2		 jne	 SHORT $L33265
$L33267:

; 1162 : 	}

  00012	c3		 ret	 0
??$fill_n@PAPAVmml_Address@@IPAV1@@std@@YAXPAPAVmml_Address@@IABQAV1@@Z ENDP ; std::fill_n<mml_Address * *,unsigned int,mml_Address *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$fill_n@PAHIH@std@@YAXPAHIABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$fill_n@PAHIH@std@@YAXPAHIABH@Z PROC NEAR		; std::fill_n<int *,unsigned int,int>, COMDAT
; __First$ = eax
; __Count$ = ecx

; 1160 : 	for (; 0 < _Count; --_Count, ++_First)

  00000	85 c9		 test	 ecx, ecx
  00002	76 0e		 jbe	 SHORT $L33263
$L33261:

; 1161 : 		*_First = _Val;

  00004	8b 54 24 04	 mov	 edx, DWORD PTR __Val$[esp-4]
  00008	8b 12		 mov	 edx, DWORD PTR [edx]
  0000a	89 10		 mov	 DWORD PTR [eax], edx
  0000c	83 c0 04	 add	 eax, 4
  0000f	49		 dec	 ecx
  00010	75 f2		 jne	 SHORT $L33261
$L33263:

; 1162 : 	}

  00012	c3		 ret	 0
??$fill_n@PAHIH@std@@YAXPAHIABH@Z ENDP			; std::fill_n<int *,unsigned int,int>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAVmml_Address@@PAPAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Copy_backward_opt@PAPAVmml_Address@@PAPAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<mml_Address * *,mml_Address * *>, COMDAT
; __Last$ = eax
; __Dest$ = ecx

; 1059 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

  00000	2b 44 24 04	 sub	 eax, DWORD PTR __First$[esp-4]
  00004	c1 f8 02	 sar	 eax, 2

; 1060 : 	return ((_OutIt)memmove(&*_Dest - _Off, &*_First,
; 1061 : 		_Off * sizeof (*_First)));

  00007	c1 e0 02	 shl	 eax, 2
  0000a	50		 push	 eax
  0000b	ff 74 24 08	 push	 DWORD PTR __First$[esp]
  0000f	2b c8		 sub	 ecx, eax
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 _memmove
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1062 : 	}

  0001a	c3		 ret	 0
??$_Copy_backward_opt@PAPAVmml_Address@@PAPAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<mml_Address * *,mml_Address * *>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@YAXPAPAVmml_Address@@0AAV?$allocator@PAVmml_Address@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@YAXPAPAVmml_Address@@0AAV?$allocator@PAVmml_Address@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<mml_Address *,std::allocator<mml_Address *> >, COMDAT

; 234  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@YAXPAPAVmml_Address@@0AAV?$allocator@PAVmml_Address@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<mml_Address *,std::allocator<mml_Address *> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<int *,int *>, COMDAT
; __Last$ = eax
; __Dest$ = ecx

; 1059 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

  00000	2b 44 24 04	 sub	 eax, DWORD PTR __First$[esp-4]
  00004	c1 f8 02	 sar	 eax, 2

; 1060 : 	return ((_OutIt)memmove(&*_Dest - _Off, &*_First,
; 1061 : 		_Off * sizeof (*_First)));

  00007	c1 e0 02	 shl	 eax, 2
  0000a	50		 push	 eax
  0000b	ff 74 24 08	 push	 DWORD PTR __First$[esp]
  0000f	2b c8		 sub	 ecx, eax
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 _memmove
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1062 : 	}

  0001a	c3		 ret	 0
??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__Cat$37005 = -4					; size = 1
__First$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z PROC NEAR ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT
; __Last$ = eax

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$37005[ebp]
  00007	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<int,int>
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 129  : 	}

  00015	c9		 leave
  00016	c3		 ret	 0
??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVmml_Address@@IPAV1@@std@@YAXPAPAVmml_Address@@IABQAV1@AAV?$allocator@PAVmml_Address@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Uninit_fill_n@PAVmml_Address@@IPAV1@@std@@YAXPAPAVmml_Address@@IABQAV1@AAV?$allocator@PAVmml_Address@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<mml_Address *,unsigned int,mml_Address *>, COMDAT
; __First$ = eax
; __Count$ = ecx

; 237  : 	fill_n(_First, _Count, _Val);

  00000	85 c9		 test	 ecx, ecx
  00002	76 0e		 jbe	 SHORT $L37013
$L37011:
  00004	8b 54 24 04	 mov	 edx, DWORD PTR __Val$[esp-4]
  00008	8b 12		 mov	 edx, DWORD PTR [edx]
  0000a	89 10		 mov	 DWORD PTR [eax], edx
  0000c	83 c0 04	 add	 eax, 4
  0000f	49		 dec	 ecx
  00010	75 f2		 jne	 SHORT $L37011
$L37013:

; 238  : 	}

  00012	c3		 ret	 0
??$_Uninit_fill_n@PAVmml_Address@@IPAV1@@std@@YAXPAPAVmml_Address@@IABQAV1@AAV?$allocator@PAVmml_Address@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<mml_Address *,unsigned int,mml_Address *>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Vmml_Address@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVmml_Address@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@Vmml_Address@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVmml_Address@@0@Z PROC NEAR ; std::_Ptr_cat<mml_Address>, COMDAT

; 218  : 	{	// return pointer category from pointer to pointer arguments

  00000	51		 push	 ecx

; 219  : 	_Scalar_ptr_iterator_tag _Cat;
; 220  : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 221  : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Ptr_cat@Vmml_Address@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVmml_Address@@0@Z ENDP ; std::_Ptr_cat<mml_Address>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<int,unsigned int,int>, COMDAT
; __First$ = eax
; __Count$ = ecx

; 237  : 	fill_n(_First, _Count, _Val);

  00000	85 c9		 test	 ecx, ecx
  00002	76 0e		 jbe	 SHORT $L37029
$L37027:
  00004	8b 54 24 04	 mov	 edx, DWORD PTR __Val$[esp-4]
  00008	8b 12		 mov	 edx, DWORD PTR [edx]
  0000a	89 10		 mov	 DWORD PTR [eax], edx
  0000c	83 c0 04	 add	 eax, 4
  0000f	49		 dec	 ecx
  00010	75 f2		 jne	 SHORT $L37027
$L37029:

; 238  : 	}

  00012	c3		 ret	 0
??$_Uninit_fill_n@HIH@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int,unsigned int,int>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<int,std::allocator<int> >, COMDAT

; 234  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<int,std::allocator<int> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Node>, COMDAT
; __Count$ = eax

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 03	 shl	 eax, 3
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 35   : 	}

  0000d	c3		 ret	 0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Node>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$?0Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@?$allocator@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAE@ABV?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@?$allocator@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAE@ABV?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node>::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node><std::list<MusicItem *,std::allocator<MusicItem *> >::iterator>, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00000	c3		 ret	 0
??$?0Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@?$allocator@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAE@ABV?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node>::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node><std::list<MusicItem *,std::allocator<MusicItem *> >::iterator>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$?0I@?$allocator@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z
_TEXT	SEGMENT
??$?0I@?$allocator@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z PROC NEAR ; std::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node>::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node><unsigned int>, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00000	c3		 ret	 0
??$?0I@?$allocator@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z ENDP ; std::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node>::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node><unsigned int>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVmml_Address@@@std@@YAPAPAVmml_Address@@IPAPAV1@@Z
_TEXT	SEGMENT
??$_Allocate@PAVmml_Address@@@std@@YAPAPAVmml_Address@@IPAPAV1@@Z PROC NEAR ; std::_Allocate<mml_Address *>, COMDAT
; __Count$ = eax

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	c1 e0 02	 shl	 eax, 2
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00009	59		 pop	 ecx

; 35   : 	}

  0000a	c3		 ret	 0
??$_Allocate@PAVmml_Address@@@std@@YAPAPAVmml_Address@@IPAPAV1@@Z ENDP ; std::_Allocate<mml_Address *>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAPAVmml_Address@@PAPAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00@Z
_TEXT	SEGMENT
__Cat$37056 = -4					; size = 1
__First$ = 8						; size = 4
??$copy_backward@PAPAVmml_Address@@PAPAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00@Z PROC NEAR ; std::copy_backward<mml_Address * *,mml_Address * *>, COMDAT
; __Last$ = eax
; __Dest$ = ecx

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$37056[ebp]
  00007	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAPAVmml_Address@@PAPAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<mml_Address * *,mml_Address * *>
  0000f	59		 pop	 ecx
  00010	59		 pop	 ecx

; 1070 : 	}

  00011	c9		 leave
  00012	c3		 ret	 0
??$copy_backward@PAPAVmml_Address@@PAPAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00@Z ENDP ; std::copy_backward<mml_Address * *,mml_Address * *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$fill@PAPAVmml_Address@@PAV1@@std@@YAXPAPAVmml_Address@@0ABQAV1@@Z
_TEXT	SEGMENT
__Last$ = 8						; size = 4
__Val$ = 12						; size = 4
??$fill@PAPAVmml_Address@@PAV1@@std@@YAXPAPAVmml_Address@@0ABQAV1@@Z PROC NEAR ; std::fill<mml_Address * *,mml_Address *>, COMDAT
; __First$ = eax

; 1135 : 	for (; _First != _Last; ++_First)

  00000	eb 0b		 jmp	 SHORT $L37061
$L32965:

; 1136 : 		*_First = _Val;

  00002	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx
  0000a	83 c0 04	 add	 eax, 4
$L37061:

; 1135 : 	for (; _First != _Last; ++_First)

  0000d	3b 44 24 04	 cmp	 eax, DWORD PTR __Last$[esp-4]
  00011	75 ef		 jne	 SHORT $L32965

; 1137 : 	}

  00013	c3		 ret	 0
??$fill@PAPAVmml_Address@@PAV1@@std@@YAXPAPAVmml_Address@@0ABQAV1@@Z ENDP ; std::fill<mml_Address * *,mml_Address *>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@YAXPAPAVmml_Address@@0AAV?$allocator@PAVmml_Address@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@YAXPAPAVmml_Address@@0AAV?$allocator@PAVmml_Address@@@0@@Z PROC NEAR ; std::_Destroy_range<mml_Address *,std::allocator<mml_Address *> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@YAXPAPAVmml_Address@@0AAV?$allocator@PAVmml_Address@@@0@@Z ENDP ; std::_Destroy_range<mml_Address *,std::allocator<mml_Address *> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@YAXPAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@0@@Z
_TEXT	SEGMENT
??$_Destroy@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@YAXPAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node *>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@YAXPAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@0@@Z ENDP ; std::_Destroy<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@YAXPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@0@@Z
_TEXT	SEGMENT
??$_Destroy@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@YAXPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@YAXPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@0@@Z ENDP ; std::_Destroy<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@YAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@0@IPAU120@@Z
_TEXT	SEGMENT
??$_Allocate@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@YAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node>, COMDAT
; __Count$ = eax

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 02	 shl	 eax, 2
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 35   : 	}

  0000d	c3		 ret	 0
??$_Allocate@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@YAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$?0Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@?$allocator@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAE@ABV?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@?$allocator@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAE@ABV?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z PROC NEAR ; std::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node *>::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node *><std::list<MusicItem *,std::allocator<MusicItem *> >::iterator>, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00000	c3		 ret	 0
??$?0Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@?$allocator@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAE@ABV?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node *>::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node *><std::list<MusicItem *,std::allocator<MusicItem *> >::iterator>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node *>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@IV?$allocator@I@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@IV?$allocator@I@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@IV?$allocator@I@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@YAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
??$_Allocate@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@YAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node>, COMDAT
; __Count$ = eax

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 02	 shl	 eax, 2
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 35   : 	}

  0000d	c3		 ret	 0
??$_Allocate@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@YAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$?0I@?$allocator@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z
_TEXT	SEGMENT
??$?0I@?$allocator@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z PROC NEAR ; std::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node *>::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node *><unsigned int>, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

  00000	c3		 ret	 0
??$?0I@?$allocator@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z ENDP ; std::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node *>::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node *><unsigned int>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__Cat$37104 = -4					; size = 1
__First$ = 8						; size = 4
??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z PROC NEAR	; std::copy_backward<int *,int *>, COMDAT
; __Last$ = eax
; __Dest$ = ecx

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$37104[ebp]
  00007	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *>
  0000f	59		 pop	 ecx
  00010	59		 pop	 ecx

; 1070 : 	}

  00011	c9		 leave
  00012	c3		 ret	 0
??$copy_backward@PAHPAH@std@@YAPAHPAH00@Z ENDP		; std::copy_backward<int *,int *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__Last$ = 8						; size = 4
__Val$ = 12						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC NEAR		; std::fill<int *,int>, COMDAT
; __First$ = eax

; 1135 : 	for (; _First != _Last; ++_First)

  00000	eb 0b		 jmp	 SHORT $L37109
$L32892:

; 1136 : 		*_First = _Val;

  00002	8b 4c 24 08	 mov	 ecx, DWORD PTR __Val$[esp-4]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx
  0000a	83 c0 04	 add	 eax, 4
$L37109:

; 1135 : 	for (; _First != _Last; ++_First)

  0000d	3b 44 24 04	 cmp	 eax, DWORD PTR __Last$[esp-4]
  00011	75 ef		 jne	 SHORT $L32892

; 1137 : 	}

  00013	c3		 ret	 0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__First$ = 12						; size = 4
__Cat$37123 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Ucopy<int *>, COMDAT
; __Last$ = eax

; 801  : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00003	ff 75 10	 push	 DWORD PTR __Cat$37123[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __First$[ebp]
  0000c	e8 00 00 00 00	 call	 ??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<int,int>
  00011	83 c4 0c	 add	 esp, 12			; 0000000cH

; 805  : 		}

  00014	5d		 pop	 ebp
  00015	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
??$_Allocate@H@std@@YAPAHIPAH@Z PROC NEAR		; std::_Allocate<int>, COMDAT
; __Count$ = eax

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00000	c1 e0 02	 shl	 eax, 2
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00009	59		 pop	 ecx

; 35   : 	}

  0000a	c3		 ret	 0
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAPAVmml_Address@@IPAV1@V?$allocator@PAVmml_Address@@@std@@@std@@YAXPAPAVmml_Address@@IABQAV1@AAV?$allocator@PAVmml_Address@@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Uninitialized_fill_n@PAPAVmml_Address@@IPAV1@V?$allocator@PAVmml_Address@@@std@@@std@@YAXPAPAVmml_Address@@IABQAV1@AAV?$allocator@PAVmml_Address@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<mml_Address * *,unsigned int,mml_Address *,std::allocator<mml_Address *> >, COMDAT
; __First$ = eax
; __Count$ = ecx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00000	85 c9		 test	 ecx, ecx
  00002	76 0e		 jbe	 SHORT $L37149
$L37147:
  00004	8b 54 24 04	 mov	 edx, DWORD PTR __Val$[esp-4]
  00008	8b 12		 mov	 edx, DWORD PTR [edx]
  0000a	89 10		 mov	 DWORD PTR [eax], edx
  0000c	83 c0 04	 add	 eax, 4
  0000f	49		 dec	 ecx
  00010	75 f2		 jne	 SHORT $L37147
$L37149:

; 258  : 	}

  00012	c3		 ret	 0
??$_Uninitialized_fill_n@PAPAVmml_Address@@IPAV1@V?$allocator@PAVmml_Address@@@std@@@std@@YAXPAPAVmml_Address@@IABQAV1@AAV?$allocator@PAVmml_Address@@@0@@Z ENDP ; std::_Uninitialized_fill_n<mml_Address * *,unsigned int,mml_Address *,std::allocator<mml_Address *> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT
; __First$ = eax
; __Count$ = ecx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00000	85 c9		 test	 ecx, ecx
  00002	76 0e		 jbe	 SHORT $L37175
$L37173:
  00004	8b 54 24 04	 mov	 edx, DWORD PTR __Val$[esp-4]
  00008	8b 12		 mov	 edx, DWORD PTR [edx]
  0000a	89 10		 mov	 DWORD PTR [eax], edx
  0000c	83 c0 04	 add	 eax, 4
  0000f	49		 dec	 ecx
  00010	75 f2		 jne	 SHORT $L37173
$L37175:

; 258  : 	}

  00012	c3		 ret	 0
??$_Uninitialized_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC NEAR ; std::_Destroy_range<int,std::allocator<int> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<int,std::allocator<int> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIPAVPatch@@@2@D@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Rarg$ = 12						; size = 4
__Carg$ = 16						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIPAVPatch@@@2@D@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Node::_Node, COMDAT
; _this$ = eax
; __Larg$ = edx
; __Val$ = ecx

; 40   : 			{	// construct a node with value

  00000	89 10		 mov	 DWORD PTR [eax], edx
  00002	8b 54 24 04	 mov	 edx, DWORD PTR __Parg$[esp-4]
  00006	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00009	8b 54 24 08	 mov	 edx, DWORD PTR __Rarg$[esp-4]
  0000d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00015	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00018	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0001b	8a 4c 24 0c	 mov	 cl, BYTE PTR __Carg$[esp-4]
  0001f	88 48 14	 mov	 BYTE PTR [eax+20], cl
  00022	c6 40 15 00	 mov	 BYTE PTR [eax+21], 0

; 41   : 			}

  00026	c2 0c 00	 ret	 12			; 0000000cH
??0_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIPAVPatch@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Node::_Node
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Node>::allocate, COMDAT
; __Count$ = eax

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 03	 shl	 eax, 3
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 138  : 		}

  0000d	c3		 ret	 0
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Node>::allocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Node>::deallocate, COMDAT

; 132  : 		operator delete(_Ptr);

  00000	ff 74 24 04	 push	 DWORD PTR __Ptr$[esp-4]
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 133  : 		}

  0000a	c2 04 00	 ret	 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Node>::deallocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@std@@QBEIXZ PROC NEAR ; std::allocator<std::pair<unsigned int const ,Patch *> >::max_size, COMDAT

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned int const ,Patch *> >::max_size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QBEIXZ PROC NEAR ; std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator>::max_size, COMDAT

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator>::max_size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@I@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@I@std@@QBEIXZ PROC NEAR		; std::allocator<unsigned int>::max_size, COMDAT

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@I@std@@QBEIXZ ENDP		; std::allocator<unsigned int>::max_size
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??0_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@PAU012@0ABViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z
_TEXT	SEGMENT
__Prevarg$ = 8						; size = 4
__Myvalarg$ = 12					; size = 4
??0_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@PAU012@0ABViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z PROC NEAR ; std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node::_Node, COMDAT
; _this$ = eax
; __Nextarg$ = ecx

; 34   : 			{	// construct a node with value

  00000	89 08		 mov	 DWORD PTR [eax], ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Prevarg$[esp-4]
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	8b 4c 24 08	 mov	 ecx, DWORD PTR __Myvalarg$[esp-4]
  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 35   : 			}

  00012	c2 08 00	 ret	 8
??0_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@PAU012@0ABViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z ENDP ; std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node::_Node
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0_Node@?$_List_nod@IV?$allocator@I@std@@@std@@QAE@PAU012@0ABI@Z
_TEXT	SEGMENT
__Prevarg$ = 8						; size = 4
__Myvalarg$ = 12					; size = 4
??0_Node@?$_List_nod@IV?$allocator@I@std@@@std@@QAE@PAU012@0ABI@Z PROC NEAR ; std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node::_Node, COMDAT
; _this$ = eax
; __Nextarg$ = ecx

; 34   : 			{	// construct a node with value

  00000	89 08		 mov	 DWORD PTR [eax], ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR __Prevarg$[esp-4]
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	8b 4c 24 08	 mov	 ecx, DWORD PTR __Myvalarg$[esp-4]
  0000d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000f	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 35   : 			}

  00012	c2 08 00	 ret	 8
??0_Node@?$_List_nod@IV?$allocator@I@std@@@std@@QAE@PAU012@0ABI@Z ENDP ; std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node::_Node
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@1@AB_N@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::iterator,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8a 09		 mov	 cl, BYTE PTR [ecx]
  0000a	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::iterator,bool>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 			}

  00002	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax

; 193  : 			{	// construct with null node pointer

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 194  : 			}

  00003	c3		 ret	 0
??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
??Gconst_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::const_iterator::operator-, COMDAT
; _this$ = eax
; __Right$ = ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	2b 01		 sub	 eax, DWORD PTR [ecx]
  00004	c1 f8 02	 sar	 eax, 2

; 144  : 			}

  00007	c3		 ret	 0
??Gconst_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::const_iterator::operator-
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
??Yiterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::operator+=, COMDAT
; _this$ = eax
; __Off$ = ecx

; 256  : 			this->_Myptr += _Off;

  00000	c1 e1 02	 shl	 ecx, 2
  00003	01 08		 add	 DWORD PTR [eax], ecx

; 257  : 			return (*this);
; 258  : 			}

  00005	c3		 ret	 0
??Yiterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::operator+=
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::max_size, COMDAT

; 453  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 454  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::max_size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Parent, COMDAT
; __Pnode$ = eax

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	83 c0 04	 add	 eax, 4

; 153  : 		}

  00003	c3		 ret	 0
?_Parent@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Parent
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Left@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Left, COMDAT
; __Pnode$ = eax

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);
; 148  : 		}

  00000	c3		 ret	 0
?_Left@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Left
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Color, COMDAT
; __Pnode$ = eax

; 132  : 		return ((_Charref)(*_Pnode)._Color);

  00000	83 c0 14	 add	 eax, 20			; 00000014H

; 133  : 		}

  00003	c3		 ret	 0
?_Color@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Color
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVmml_Address@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVmml_Address@@@std@@QBEIXZ PROC NEAR ; std::allocator<mml_Address *>::max_size, COMDAT

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAVmml_Address@@@std@@QBEIXZ ENDP	; std::allocator<mml_Address *>::max_size
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??0?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAE@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAE@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z PROC NEAR ; std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >, COMDAT
; _this$ = eax

; 45   : 		}

  00000	c2 04 00	 ret	 4
??0?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAE@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z ENDP ; std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QBEIXZ PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::max_size, COMDAT

; 436  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 437  : 		}

  00005	c3		 ret	 0
?max_size@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QBEIXZ ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::max_size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_List_nod@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_nod@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z PROC NEAR ; std::_List_nod<unsigned int,std::allocator<unsigned int> >::_List_nod<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = eax

; 45   : 		}

  00000	c2 04 00	 ret	 4
??0?$_List_nod@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ENDP ; std::_List_nod<unsigned int,std::allocator<unsigned int> >::_List_nod<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$list@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@IV?$allocator@I@std@@@std@@QBEIXZ PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::max_size, COMDAT

; 436  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 437  : 		}

  00005	c3		 ret	 0
?max_size@?$list@IV?$allocator@I@std@@@std@@QBEIXZ ENDP	; std::list<unsigned int,std::allocator<unsigned int> >::max_size
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::operator-, COMDAT
; _this$ = eax
; __Right$ = ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	2b 01		 sub	 eax, DWORD PTR [ecx]
  00004	c1 f8 02	 sar	 eax, 2

; 144  : 			}

  00007	c3		 ret	 0
??Gconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<int,std::allocator<int> >::const_iterator::operator-
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator+=, COMDAT
; _this$ = eax
; __Off$ = ecx

; 256  : 			this->_Myptr += _Off;

  00000	c1 e1 02	 shl	 ecx, 2
  00003	01 08		 add	 DWORD PTR [eax], ecx

; 257  : 			return (*this);
; 258  : 			}

  00005	c3		 ret	 0
??Yiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::operator+=
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC NEAR		; std::allocator<int>::max_size, COMDAT

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 159  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::iterator::iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 313  : 			}

  00002	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::iterator::iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::iterator::iterator, COMDAT
; _this$ = eax

; 304  : 		iterator()

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 305  : 			{	// construct with null node pointer
; 306  : 			}

  00003	c3		 ret	 0
??0iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::iterator::iterator
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@PAPAVmml_Address@@@Z
_TEXT	SEGMENT
??0const_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@PAPAVmml_Address@@@Z PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::const_iterator::const_iterator, COMDAT
; _this$ = eax
; __Ptr$ = ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00002	c3		 ret	 0
??0const_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@PAPAVmml_Address@@@Z ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
??Giterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::operator-, COMDAT
; _this$ = eax
; __Right$ = ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	2b 01		 sub	 eax, DWORD PTR [ecx]
  00004	c1 f8 02	 sar	 eax, 2

; 280  : 			}

  00007	c3		 ret	 0
??Giterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::operator-
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
??Hiterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::operator+, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax
; __Off$ = edx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	8d 0c 91	 lea	 ecx, DWORD PTR [ecx+edx*4]
  00005	89 08		 mov	 DWORD PTR [eax], ecx

; 264  : 			}

  00007	c3		 ret	 0
??Hiterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::operator+
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@SAABIABU?$pair@$$CBIPAVPatch@@@2@@Z
_TEXT	SEGMENT
?_Kfn@?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@SAABIABU?$pair@$$CBIPAVPatch@@@2@@Z PROC NEAR ; std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0>::_Kfn, COMDAT
; __Val$ = eax

; 64   : 		return (_Val.first);
; 65   : 		}

  00000	c3		 ret	 0
?_Kfn@?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@SAABIABU?$pair@$$CBIPAVPatch@@@2@@Z ENDP ; std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0>::_Kfn
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::size, COMDAT
; _this$ = eax

; 448  : 		return (_Mysize);

  00000	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 449  : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVPatch@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVPatch@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Myval, COMDAT
; __Pnode$ = eax

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 163  : 		}

  00003	c3		 ret	 0
?_Myval@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVPatch@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Myval
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Right@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Right, COMDAT
; __Pnode$ = eax

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	83 c0 08	 add	 eax, 8

; 158  : 		}

  00003	c3		 ret	 0
?_Right@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Right
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Isnil, COMDAT
; __Pnode$ = eax

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

  00000	83 c0 15	 add	 eax, 21			; 00000015H

; 138  : 		}

  00003	c3		 ret	 0
?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Isnil
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAVmml_Address@@@std@@QAEPAPAVmml_Address@@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@PAVmml_Address@@@std@@QAEPAPAVmml_Address@@I@Z PROC NEAR ; std::allocator<mml_Address *>::allocate, COMDAT
; __Count$ = eax

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	c1 e0 02	 shl	 eax, 2
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00009	59		 pop	 ecx

; 138  : 		}

  0000a	c3		 ret	 0
?allocate@?$allocator@PAVmml_Address@@@std@@QAEPAPAVmml_Address@@I@Z ENDP ; std::allocator<mml_Address *>::allocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVmml_Address@@@std@@QAEXPAPAVmml_Address@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?deallocate@?$allocator@PAVmml_Address@@@std@@QAEXPAPAVmml_Address@@I@Z PROC NEAR ; std::allocator<mml_Address *>::deallocate, COMDAT

; 132  : 		operator delete(_Ptr);

  00000	ff 74 24 04	 push	 DWORD PTR __Ptr$[esp-4]
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 133  : 		}

  0000a	c2 04 00	 ret	 4
?deallocate@?$allocator@PAVmml_Address@@@std@@QAEXPAPAVmml_Address@@I@Z ENDP ; std::allocator<mml_Address *>::deallocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVmml_Address@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@PAVmml_Address@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<mml_Address *>::allocator<mml_Address *>, COMDAT
; _this$ = eax

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00000	c3		 ret	 0
??0?$allocator@PAVmml_Address@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<mml_Address *>::allocator<mml_Address *>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXPAPAVmml_Address@@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXPAPAVmml_Address@@0@Z PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Destroy, COMDAT

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);
; 788  : 		}

  00000	c3		 ret	 0
?_Destroy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXPAPAVmml_Address@@0@Z ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Destroy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::max_size, COMDAT

; 521  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 522  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::max_size
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QBEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QBEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@3@XZ PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::const_iterator::_Mynode, COMDAT
; _this$ = eax

; 207  : 			return (_Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 208  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QBEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@3@XZ ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::const_iterator::_Mynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z
_TEXT	SEGMENT
??0const_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::const_iterator::const_iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 156  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 157  : 			}

  00002	c3		 ret	 0
??0const_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$list@IV?$allocator@I@std@@@std@@QBEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$list@IV?$allocator@I@std@@@std@@QBEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@3@XZ PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::const_iterator::_Mynode, COMDAT
; _this$ = eax

; 207  : 			return (_Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 208  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$list@IV?$allocator@I@std@@@std@@QBEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@3@XZ ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::const_iterator::_Mynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@IV?$allocator@I@std@@@std@@QAE@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z
_TEXT	SEGMENT
??0const_iterator@?$list@IV?$allocator@I@std@@@std@@QAE@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::const_iterator::const_iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 156  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 157  : 			}

  00002	c3		 ret	 0
??0const_iterator@?$list@IV?$allocator@I@std@@@std@@QAE@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node *>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z ENDP ; std::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node *>::destroy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEXPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEXPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEXPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z ENDP ; std::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node>::destroy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node>::allocate, COMDAT
; __Count$ = eax

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 02	 shl	 eax, 2
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 138  : 		}

  0000d	c3		 ret	 0
?allocate@?$allocator@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@I@Z ENDP ; std::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node>::allocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEXPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEXPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node>::deallocate, COMDAT

; 132  : 		operator delete(_Ptr);

  00000	ff 74 24 04	 push	 DWORD PTR __Ptr$[esp-4]
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 133  : 		}

  0000a	c2 04 00	 ret	 4
?deallocate@?$allocator@U_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEXPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@I@Z ENDP ; std::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node>::deallocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator>::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator>, COMDAT
; _this$ = eax

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00000	c3		 ret	 0
??0?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator>::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??0?$_List_ptr@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAE@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_ptr@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAE@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z PROC NEAR ; std::_List_ptr<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_List_ptr<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >, COMDAT
; _this$ = eax

; 65   : 		}

  00000	c2 04 00	 ret	 4
??0?$_List_ptr@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAE@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z ENDP ; std::_List_ptr<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_List_ptr<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@KAAAViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z
_TEXT	SEGMENT
?_Myval@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@KAAAViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Myval, COMDAT
; __Pnode$ = eax

; 118  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	83 c0 08	 add	 eax, 8

; 119  : 		}

  00003	c3		 ret	 0
?_Myval@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@KAAAViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Myval
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@KAAAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@PAU342@@Z
_TEXT	SEGMENT
?_Prevnode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@KAAAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@PAU342@@Z PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Prevnode, COMDAT
; __Pnode$ = eax

; 113  : 		return ((_Nodepref)(*_Pnode)._Prev);

  00000	83 c0 04	 add	 eax, 4

; 114  : 		}

  00003	c3		 ret	 0
?_Prevnode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@KAAAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@PAU342@@Z ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Prevnode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@KAAAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@PAU342@@Z
_TEXT	SEGMENT
?_Nextnode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@KAAAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@PAU342@@Z PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Nextnode, COMDAT
; __Pnode$ = eax

; 108  : 		return ((_Nodepref)(*_Pnode)._Next);
; 109  : 		}

  00000	c3		 ret	 0
?_Nextnode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@KAAAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@PAU342@@Z ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Nextnode
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node *>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node *>::destroy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node>::destroy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node>::allocate, COMDAT
; __Count$ = eax

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00003	c1 e0 02	 shl	 eax, 2
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	59		 pop	 ecx

; 138  : 		}

  0000d	c3		 ret	 0
?allocate@?$allocator@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node>::allocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node>::deallocate, COMDAT

; 132  : 		operator delete(_Ptr);

  00000	ff 74 24 04	 push	 DWORD PTR __Ptr$[esp-4]
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 133  : 		}

  0000a	c2 04 00	 ret	 4
?deallocate@?$allocator@U_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node>::deallocate
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@IV?$allocator@I@std@@@std@@KAAAIPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z
_TEXT	SEGMENT
?_Myval@?$list@IV?$allocator@I@std@@@std@@KAAAIPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::_Myval, COMDAT
; __Pnode$ = eax

; 118  : 		return ((_Vref)(*_Pnode)._Myval);

  00000	83 c0 08	 add	 eax, 8

; 119  : 		}

  00003	c3		 ret	 0
?_Myval@?$list@IV?$allocator@I@std@@@std@@KAAAIPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::_Myval
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@IV?$allocator@I@std@@@std@@KAAAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Prevnode@?$list@IV?$allocator@I@std@@@std@@KAAAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@PAU342@@Z PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::_Prevnode, COMDAT
; __Pnode$ = eax

; 113  : 		return ((_Nodepref)(*_Pnode)._Prev);

  00000	83 c0 04	 add	 eax, 4

; 114  : 		}

  00003	c3		 ret	 0
?_Prevnode@?$list@IV?$allocator@I@std@@@std@@KAAAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@PAU342@@Z ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::_Prevnode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@IV?$allocator@I@std@@@std@@KAAAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Nextnode@?$list@IV?$allocator@I@std@@@std@@KAAAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@PAU342@@Z PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::_Nextnode, COMDAT
; __Pnode$ = eax

; 108  : 		return ((_Nodepref)(*_Pnode)._Next);
; 109  : 		}

  00000	c3		 ret	 0
?_Nextnode@?$list@IV?$allocator@I@std@@@std@@KAAAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@PAU342@@Z ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::_Nextnode
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator, COMDAT
; _this$ = eax
; __Ptr$ = ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00002	c3		 ret	 0
??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator-, COMDAT
; _this$ = eax
; __Right$ = ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	2b 01		 sub	 eax, DWORD PTR [ecx]
  00004	c1 f8 02	 sar	 eax, 2

; 280  : 			}

  00007	c3		 ret	 0
??Giterator@?$vector@HV?$allocator@H@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::operator-
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator+, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax
; __Off$ = edx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	8d 0c 91	 lea	 ecx, DWORD PTR [ecx+edx*4]
  00005	89 08		 mov	 DWORD PTR [eax], ecx

; 264  : 			}

  00007	c3		 ret	 0
??Hiterator@?$vector@HV?$allocator@H@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::operator+
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC NEAR ; std::vector<int,std::allocator<int> >::max_size, COMDAT

; 521  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 522  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@I@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@I@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<unsigned int>::allocator<unsigned int>, COMDAT
; _this$ = eax

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00000	c3		 ret	 0
??0?$allocator@I@std@@QAE@ABV01@@Z ENDP			; std::allocator<unsigned int>::allocator<unsigned int>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC NEAR	; std::allocator<int>::allocate, COMDAT
; __Count$ = eax

; 137  : 		return (_Allocate(_Count, (pointer)0));

  00000	c1 e0 02	 shl	 eax, 2
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00009	59		 pop	 ecx

; 138  : 		}

  0000a	c3		 ret	 0
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC NEAR	; std::allocator<int>::deallocate, COMDAT

; 132  : 		operator delete(_Ptr);

  00000	ff 74 24 04	 push	 DWORD PTR __Ptr$[esp-4]
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 133  : 		}

  0000a	c2 04 00	 ret	 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<int>::allocator<int>, COMDAT
; _this$ = eax

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  00000	c3		 ret	 0
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBIPAVPatch@@@std@@QAE@ABIABQAVPatch@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@$$CBIPAVPatch@@@std@@QAE@ABIABQAVPatch@@@Z PROC NEAR ; std::pair<unsigned int const ,Patch *>::pair<unsigned int const ,Patch *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Val2$[esp-4]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 35   : 		}

  0000d	c2 04 00	 ret	 4
??0?$pair@$$CBIPAVPatch@@@std@@QAE@ABIABQAVPatch@@@Z ENDP ; std::pair<unsigned int const ,Patch *>::pair<unsigned int const ,Patch *>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = eax

; 284  : 			return (_Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 285  : 			}

  00002	c3		 ret	 0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = eax
; __Right$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	2b 01		 sub	 eax, DWORD PTR [ecx]
  00004	f7 d8		 neg	 eax
  00006	1b c0		 sbb	 eax, eax
  00008	40		 inc	 eax

; 242  : 			}

  00009	c3		 ret	 0
??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::operator==
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8const_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::const_iterator::operator==, COMDAT
; _this$ = eax
; __Right$ = ecx

; 153  : 
; 154  : 
; 155  : 			return (_Myptr == _Right._Myptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	2b 01		 sub	 eax, DWORD PTR [ecx]
  00004	f7 d8		 neg	 eax
  00006	1b c0		 sbb	 eax, eax
  00008	40		 inc	 eax

; 156  : 			}

  00009	c3		 ret	 0
??8const_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::const_iterator::operator==
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEABQAVmml_Address@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEABQAVmml_Address@@XZ PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::const_iterator::operator*, COMDAT
; _this$ = eax

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEABQAVmml_Address@@XZ ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::const_iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::const_iterator::const_iterator, COMDAT
; _this$ = eax

; 69   : 			{	// construct with null pointer
; 70   : 			_Myptr = 0;

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 71   : 			}

  00003	c3		 ret	 0
??0const_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::operator++, COMDAT
; _this$ = eax

; 230  : 			++this->_Myptr;

  00000	83 00 04	 add	 DWORD PTR [eax], 4

; 231  : 			return (*this);
; 232  : 			}

  00003	c3		 ret	 0
??Eiterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEAAV012@XZ ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@PAPAVmml_Address@@@Z
_TEXT	SEGMENT
??0iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@PAPAVmml_Address@@@Z PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::iterator, COMDAT
; _this$ = eax
; __Ptr$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00002	c3		 ret	 0
??0iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@PAPAVmml_Address@@@Z ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::iterator
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 418  : 		return (_TREE_ITERATOR(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	89 08		 mov	 DWORD PTR [eax], ecx

; 419  : 		}

  00005	c3		 ret	 0
?end@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::end
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Key@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Key, COMDAT
; __Pnode$ = eax

; 142  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 143  : 		}

  00003	c3		 ret	 0
?_Key@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Key
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVmml_Address@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVmml_Address@@@std@@QAE@XZ PROC NEAR	; std::allocator<mml_Address *>::allocator<mml_Address *>, COMDAT
; _this$ = eax

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00000	c3		 ret	 0
??0?$allocator@PAVmml_Address@@@std@@QAE@XZ ENDP	; std::allocator<mml_Address *>::allocator<mml_Address *>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAE@V?$allocator@PAVmml_Address@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAE@V?$allocator@PAVmml_Address@@@1@@Z PROC NEAR ; std::_Vector_val<mml_Address *,std::allocator<mml_Address *> >::_Vector_val<mml_Address *,std::allocator<mml_Address *> >, COMDAT
; _this$ = eax

; 22   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Vector_val@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAE@V?$allocator@PAVmml_Address@@@1@@Z ENDP ; std::_Vector_val<mml_Address *,std::allocator<mml_Address *> >::_Vector_val<mml_Address *,std::allocator<mml_Address *> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEPAPAVmml_Address@@PAPAV3@IABQAV3@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Ufill@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEPAPAVmml_Address@@PAPAV3@IABQAV3@@Z PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Ufill, COMDAT
; __Ptr$ = esi
; __Count$ = ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00000	85 c9		 test	 ecx, ecx
  00002	8b c6		 mov	 eax, esi
  00004	76 12		 jbe	 SHORT $L37622
  00006	8b d1		 mov	 edx, ecx
  00008	57		 push	 edi
$L37620:
  00009	8b 7c 24 08	 mov	 edi, DWORD PTR __Val$[esp]
  0000d	8b 3f		 mov	 edi, DWORD PTR [edi]
  0000f	89 38		 mov	 DWORD PTR [eax], edi
  00011	83 c0 04	 add	 eax, 4
  00014	4a		 dec	 edx
  00015	75 f2		 jne	 SHORT $L37620
  00017	5f		 pop	 edi
$L37622:

; 879  : 		return (_Ptr + _Count);

  00018	8d 04 8e	 lea	 eax, DWORD PTR [esi+ecx*4]

; 880  : 		}

  0001b	c2 04 00	 ret	 4
?_Ufill@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEPAPAVmml_Address@@PAPAV3@IABQAV3@@Z ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Ufill
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Tidy, COMDAT
; _this$ = esi

; 792  : 		if (_Myfirst != 0)

  00000	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00003	85 c0		 test	 eax, eax
  00005	74 07		 je	 SHORT $L37659

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);
; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000d	59		 pop	 ecx
$L37659:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  0000e	83 66 04 00	 and	 DWORD PTR [esi+4], 0
  00012	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  00016	83 66 0c 00	 and	 DWORD PTR [esi+12], 0

; 798  : 		}

  0001a	c3		 ret	 0
?_Tidy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXXZ ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Tidy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size, COMDAT
; _this$ = eax

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	85 c9		 test	 ecx, ecx
  00005	75 03		 jne	 SHORT $L37666
  00007	33 c0		 xor	 eax, eax

; 517  : 		}

  00009	c3		 ret	 0
$L37666:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	2b c1		 sub	 eax, ecx
  0000f	c1 f8 02	 sar	 eax, 2

; 517  : 		}

  00012	c3		 ret	 0
?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::capacity, COMDAT
; _this$ = eax

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	85 c9		 test	 ecx, ecx
  00005	75 03		 jne	 SHORT $L37671
  00007	33 c0		 xor	 eax, eax

; 459  : 		}

  00009	c3		 ret	 0
$L37671:

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  0000a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0000d	2b c1		 sub	 eax, ecx
  0000f	c1 f8 02	 sar	 eax, 2

; 459  : 		}

  00012	c3		 ret	 0
?capacity@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::capacity
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QBEABViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QBEABViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@XZ PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::const_iterator::operator*, COMDAT
; _this$ = eax

; 161  : 			return (_Myval(_Ptr));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 08	 add	 eax, 8

; 162  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QBEABViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@XZ ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::const_iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::const_iterator::const_iterator, COMDAT
; _this$ = eax

; 151  : 			{	// construct with null node pointer

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 152  : 			}

  00003	c3		 ret	 0
??0const_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z
_TEXT	SEGMENT
??0iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::iterator::iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 235  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 236  : 			}

  00002	c3		 ret	 0
??0iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@@Z ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::iterator::iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$list@IV?$allocator@I@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
??Dconst_iterator@?$list@IV?$allocator@I@std@@@std@@QBEABIXZ PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::const_iterator::operator*, COMDAT
; _this$ = eax

; 161  : 			return (_Myval(_Ptr));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 08	 add	 eax, 8

; 162  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$list@IV?$allocator@I@std@@@std@@QBEABIXZ ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::const_iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$list@IV?$allocator@I@std@@@std@@QAE@XZ PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::const_iterator::const_iterator, COMDAT
; _this$ = eax

; 151  : 			{	// construct with null node pointer

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 152  : 			}

  00003	c3		 ret	 0
??0const_iterator@?$list@IV?$allocator@I@std@@@std@@QAE@XZ ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@IV?$allocator@I@std@@@std@@QAE@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z
_TEXT	SEGMENT
??0iterator@?$list@IV?$allocator@I@std@@@std@@QAE@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::iterator::iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 235  : 			{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 236  : 			}

  00002	c3		 ret	 0
??0iterator@?$list@IV?$allocator@I@std@@@std@@QAE@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@@Z ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::iterator::iterator
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QAE@XZ PROC NEAR ; std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator>::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator>, COMDAT
; _this$ = eax

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00000	c3		 ret	 0
??0?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator>::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??0?$_List_val@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAE@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_val@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAE@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z PROC NEAR ; std::_List_val<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_List_val<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >, COMDAT
; _this$ = eax

; 83   : 		}

  00000	c2 04 00	 ret	 4
??0?$_List_val@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAE@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@1@@Z ENDP ; std::_List_val<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_List_val<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::operator*, COMDAT
; _this$ = eax

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 83   : 			}

  00002	c3		 ret	 0
??Dconst_iterator@?$vector@HV?$allocator@H@std@@@std@@QBEABHXZ ENDP ; std::vector<int,std::allocator<int> >::const_iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC NEAR ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator, COMDAT
; _this$ = eax

; 69   : 			{	// construct with null pointer
; 70   : 			_Myptr = 0;

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 71   : 			}

  00003	c3		 ret	 0
??0const_iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP ; std::vector<int,std::allocator<int> >::const_iterator::const_iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Fiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator--, COMDAT
; _this$ = eax

; 243  : 			--this->_Myptr;

  00000	83 00 fc	 add	 DWORD PTR [eax], -4	; fffffffcH

; 244  : 			return (*this);
; 245  : 			}

  00003	c3		 ret	 0
??Fiterator@?$vector@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ENDP ; std::vector<int,std::allocator<int> >::iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::iterator, COMDAT
; _this$ = eax
; __Ptr$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 216  : 			}

  00002	c3		 ret	 0
??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC NEAR ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = eax

; 22   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; __Ptr$ = esi
; __Count$ = ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00000	85 c9		 test	 ecx, ecx
  00002	8b c6		 mov	 eax, esi
  00004	76 12		 jbe	 SHORT $L37802
  00006	8b d1		 mov	 edx, ecx
  00008	57		 push	 edi
$L37800:
  00009	8b 7c 24 08	 mov	 edi, DWORD PTR __Val$[esp]
  0000d	8b 3f		 mov	 edi, DWORD PTR [edi]
  0000f	89 38		 mov	 DWORD PTR [eax], edi
  00011	83 c0 04	 add	 eax, 4
  00014	4a		 dec	 edx
  00015	75 f2		 jne	 SHORT $L37800
  00017	5f		 pop	 edi
$L37802:

; 879  : 		return (_Ptr + _Count);

  00018	8d 04 8e	 lea	 eax, DWORD PTR [esi+ecx*4]

; 880  : 		}

  0001b	c2 04 00	 ret	 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);
; 788  : 		}

  00000	c3		 ret	 0
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC NEAR ; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = eax

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	85 c9		 test	 ecx, ecx
  00005	75 03		 jne	 SHORT $L37829
  00007	33 c0		 xor	 eax, eax

; 517  : 		}

  00009	c3		 ret	 0
$L37829:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	2b c1		 sub	 eax, ecx
  0000f	c1 f8 02	 sar	 eax, 2

; 517  : 		}

  00012	c3		 ret	 0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC NEAR ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = eax

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	85 c9		 test	 ecx, ecx
  00005	75 03		 jne	 SHORT $L37834
  00007	33 c0		 xor	 eax, eax

; 459  : 		}

  00009	c3		 ret	 0
$L37834:

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  0000a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0000d	2b c1		 sub	 eax, ecx
  0000f	c1 f8 02	 sar	 eax, 2

; 459  : 		}

  00012	c3		 ret	 0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@I@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@I@std@@QAE@XZ PROC NEAR			; std::allocator<unsigned int>::allocator<unsigned int>, COMDAT
; _this$ = eax

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00000	c3		 ret	 0
??0?$allocator@I@std@@QAE@XZ ENDP			; std::allocator<unsigned int>::allocator<unsigned int>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC NEAR			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = eax

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  00000	c3		 ret	 0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??9const_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::const_iterator::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 160  : 			return (!(*this == _Right));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	33 c9		 xor	 ecx, ecx
  00004	3b 02		 cmp	 eax, DWORD PTR [edx]
  00006	0f 95 c1	 setne	 cl
  00009	8a c1		 mov	 al, cl

; 161  : 			}

  0000b	c3		 ret	 0
??9const_iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::const_iterator::operator!=
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
??Eiterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::operator++, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax

; 236  : 			iterator _Tmp = *this;

  00000	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00002	56		 push	 esi

; 237  : 			++*this;

  00003	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00006	89 32		 mov	 DWORD PTR [edx], esi

; 238  : 			return (_Tmp);

  00008	89 08		 mov	 DWORD PTR [eax], ecx
  0000a	5e		 pop	 esi

; 239  : 			}

  0000b	c3		 ret	 0
??Eiterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE?AV012@H@Z ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEAAPAVmml_Address@@XZ
_TEXT	SEGMENT
??Diterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEAAPAVmml_Address@@XZ PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::operator*, COMDAT
; _this$ = eax

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEAAPAVmml_Address@@XZ ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::iterator, COMDAT
; _this$ = eax

; 209  : 		iterator()

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 210  : 			{	// construct with null vector pointer
; 211  : 			}

  00003	c3		 ret	 0
??0iterator@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::iterator::iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?empty@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBE_NXZ PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::empty, COMDAT
; _this$ = eax

; 526  : 		return (size() == 0);

  00000	e8 00 00 00 00	 call	 ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
  00005	f7 d8		 neg	 eax
  00007	1b c0		 sbb	 eax, eax
  00009	40		 inc	 eax

; 527  : 		}

  0000a	c3		 ret	 0
?empty@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBE_NXZ ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::empty
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 473  : 		return (iterator(_Mylast));

  00000	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00003	89 08		 mov	 DWORD PTR [eax], ecx

; 474  : 		}

  00005	c3		 ret	 0
?end@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::end
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?begin@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00005	c3		 ret	 0
?begin@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::begin
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??1?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::~vector<mml_Address *,std::allocator<mml_Address *> >, COMDAT
; _this$ = esi

; 388  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Tidy
??1?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::~vector<mml_Address *,std::allocator<mml_Address *> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??Diterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QBEAAV0?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QBEAAV0?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@XZ PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::iterator::operator*, COMDAT
; _this$ = eax

; 240  : 			return ((reference)**(const_iterator *)this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 08	 add	 eax, 8

; 241  : 			}

  00005	c3		 ret	 0
??Diterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QBEAAV0?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@XZ ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::iterator::iterator, COMDAT
; _this$ = eax

; 229  : 		iterator()

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 230  : 			{	// construct with null node
; 231  : 			}

  00003	c3		 ret	 0
??0iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::iterator::iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Diterator@?$list@IV?$allocator@I@std@@@std@@QBEAAIXZ
_TEXT	SEGMENT
??Diterator@?$list@IV?$allocator@I@std@@@std@@QBEAAIXZ PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::iterator::operator*, COMDAT
; _this$ = eax

; 240  : 			return ((reference)**(const_iterator *)this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 08	 add	 eax, 8

; 241  : 			}

  00005	c3		 ret	 0
??Diterator@?$list@IV?$allocator@I@std@@@std@@QBEAAIXZ ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$list@IV?$allocator@I@std@@@std@@QAE@XZ PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::iterator::iterator, COMDAT
; _this$ = eax

; 229  : 		iterator()

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 230  : 			{	// construct with null node
; 231  : 			}

  00003	c3		 ret	 0
??0iterator@?$list@IV?$allocator@I@std@@@std@@QAE@XZ ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::iterator::iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?end@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 387  : 		return (iterator(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	89 08		 mov	 DWORD PTR [eax], ecx

; 388  : 		}

  00005	c3		 ret	 0
?end@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE?AViterator@12@XZ ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::end
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?end@?$list@IV?$allocator@I@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$list@IV?$allocator@I@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 387  : 		return (iterator(_Myhead));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	89 08		 mov	 DWORD PTR [eax], ecx

; 388  : 		}

  00005	c3		 ret	 0
?end@?$list@IV?$allocator@I@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::end
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Fiterator@?$vector@HV?$allocator@H@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
??Fiterator@?$vector@HV?$allocator@H@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator--, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax

; 249  : 			iterator _Tmp = *this;

  00000	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00002	56		 push	 esi

; 250  : 			--*this;

  00003	8d 71 fc	 lea	 esi, DWORD PTR [ecx-4]
  00006	89 32		 mov	 DWORD PTR [edx], esi

; 251  : 			return (_Tmp);

  00008	89 08		 mov	 DWORD PTR [eax], ecx
  0000a	5e		 pop	 esi

; 252  : 			}

  0000b	c3		 ret	 0
??Fiterator@?$vector@HV?$allocator@H@std@@@std@@QAE?AV012@H@Z ENDP ; std::vector<int,std::allocator<int> >::iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT
??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::operator*, COMDAT
; _this$ = eax

; 220  : 			return ((reference)**(const_iterator *)this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 221  : 			}

  00002	c3		 ret	 0
??Diterator@?$vector@HV?$allocator@H@std@@@std@@QBEAAHXZ ENDP ; std::vector<int,std::allocator<int> >::iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC NEAR ; std::vector<int,std::allocator<int> >::iterator::iterator, COMDAT
; _this$ = eax

; 209  : 		iterator()

  00000	83 20 00	 and	 DWORD PTR [eax], 0

; 210  : 			{	// construct with null vector pointer
; 211  : 			}

  00003	c3		 ret	 0
??0iterator@?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP ; std::vector<int,std::allocator<int> >::iterator::iterator
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 473  : 		return (iterator(_Mylast));

  00000	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00003	89 08		 mov	 DWORD PTR [eax], ecx

; 474  : 		}

  00005	c3		 ret	 0
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	?ResetEcho@MusicTrack@@QAEXXZ			; MusicTrack::ResetEcho
; Function compile flags: /Ogsy
; File f:\nes\nsdl\src\nsc\musictrack.cpp
_TEXT	SEGMENT
?ResetEcho@MusicTrack@@QAEXXZ PROC NEAR			; MusicTrack::ResetEcho
; _this$ = edx

; 2811 : {

  00000	57		 push	 edi

; 2812 : 	unsigned	int	i = 0;
; 2813 : 
; 2814 : 	while(i < 256){
; 2815 : 		oldNote[i] = -1;

  00001	6a 40		 push	 64			; 00000040H
  00003	59		 pop	 ecx
  00004	8d ba e2 00 00
	00		 lea	 edi, DWORD PTR [edx+226]
  0000a	83 c8 ff	 or	 eax, -1
  0000d	f3 ab		 rep stosd

; 2816 : 		i++;
; 2817 : 	}
; 2818 : //	echo_flag	= false;
; 2819 : 	pt_oldNote	= 0;

  0000f	c6 82 e2 01 00
	00 00		 mov	 BYTE PTR [edx+482], 0
  00016	5f		 pop	 edi

; 2820 : }

  00017	c3		 ret	 0
?ResetEcho@MusicTrack@@QAEXXZ ENDP			; MusicTrack::ResetEcho
_TEXT	ENDS
PUBLIC	?SetKeyFlag@MusicTrack@@QAEXDDDDDDD@Z		; MusicTrack::SetKeyFlag
; Function compile flags: /Ogsy
_TEXT	SEGMENT
__d$ = 8						; size = 1
__e$ = 12						; size = 1
__f$ = 16						; size = 1
__g$ = 20						; size = 1
__a$ = 24						; size = 1
__b$ = 28						; size = 1
?SetKeyFlag@MusicTrack@@QAEXDDDDDDD@Z PROC NEAR		; MusicTrack::SetKeyFlag
; _this$ = eax
; __c$ = ecx

; 1916 : {

  00018	55		 push	 ebp
  00019	8b ec		 mov	 ebp, esp

; 1917 : 	KeySignature[0] = _c;	//c

  0001b	88 88 c8 00 00
	00		 mov	 BYTE PTR [eax+200], cl

; 1918 : 	KeySignature[1] = _d;	//d

  00021	8a 4d 08	 mov	 cl, BYTE PTR __d$[ebp]
  00024	88 88 c9 00 00
	00		 mov	 BYTE PTR [eax+201], cl

; 1919 : 	KeySignature[2] = _e;	//e

  0002a	8a 4d 0c	 mov	 cl, BYTE PTR __e$[ebp]
  0002d	88 88 ca 00 00
	00		 mov	 BYTE PTR [eax+202], cl

; 1920 : 	KeySignature[3] = _f;	//f

  00033	8a 4d 10	 mov	 cl, BYTE PTR __f$[ebp]
  00036	88 88 cb 00 00
	00		 mov	 BYTE PTR [eax+203], cl

; 1921 : 	KeySignature[4] = _g;	//g

  0003c	8a 4d 14	 mov	 cl, BYTE PTR __g$[ebp]
  0003f	88 88 cc 00 00
	00		 mov	 BYTE PTR [eax+204], cl

; 1922 : 	KeySignature[5] = _a;	//a

  00045	8a 4d 18	 mov	 cl, BYTE PTR __a$[ebp]
  00048	88 88 cd 00 00
	00		 mov	 BYTE PTR [eax+205], cl

; 1923 : 	KeySignature[6] = _b;	//b

  0004e	8a 4d 1c	 mov	 cl, BYTE PTR __b$[ebp]
  00051	88 88 ce 00 00
	00		 mov	 BYTE PTR [eax+206], cl

; 1924 : }

  00057	5d		 pop	 ebp
  00058	c2 18 00	 ret	 24			; 00000018H
?SetKeyFlag@MusicTrack@@QAEXDDDDDDD@Z ENDP		; MusicTrack::SetKeyFlag
_TEXT	ENDS
PUBLIC	?SetPatch@MusicTrack@@QAEXXZ			; MusicTrack::SetPatch
; Function compile flags: /Ogsy
_TEXT	SEGMENT
?SetPatch@MusicTrack@@QAEXXZ PROC NEAR			; MusicTrack::SetPatch
; _this$ = eax

; 1336 : 	f_Patch = false;

  0005b	c6 80 e3 01 00
	00 00		 mov	 BYTE PTR [eax+483], 0

; 1337 : }

  00062	c3		 ret	 0
?SetPatch@MusicTrack@@QAEXXZ ENDP			; MusicTrack::SetPatch
_TEXT	ENDS
PUBLIC	?SetLoop@MusicTrack@@QAEXXZ			; MusicTrack::SetLoop
; Function compile flags: /Ogsy
_TEXT	SEGMENT
?SetLoop@MusicTrack@@QAEXXZ PROC NEAR			; MusicTrack::SetLoop
; _this$ = eax

; 790  : 	offset_loop = offset_now;

  00063	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [eax+156]
  00069	89 88 00 02 00
	00		 mov	 DWORD PTR [eax+512], ecx

; 791  : 	loop_flag	= true;

  0006f	c6 80 fc 01 00
	00 01		 mov	 BYTE PTR [eax+508], 1

; 792  : 
; 793  : 	Reset_opt();

  00076	e9 00 00 00 00	 jmp	 ?Reset_opt@MusicTrack@@QAEXXZ ; MusicTrack::Reset_opt
?SetLoop@MusicTrack@@QAEXXZ ENDP			; MusicTrack::SetLoop
_TEXT	ENDS
PUBLIC	?TickCount@MusicTrack@@QAEIPAVMusicFile@@PAVNSD_WORK@@@Z ; MusicTrack::TickCount
PUBLIC	?TickCount@MusicTrack@@QAEIPAVMusicFile@@@Z	; MusicTrack::TickCount
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_MUS$ = 8						; size = 4
_work$ = 12						; size = 4
?TickCount@MusicTrack@@QAEIPAVMusicFile@@PAVNSD_WORK@@@Z PROC NEAR ; MusicTrack::TickCount
; _this$ = eax

; 112  : {

  0007b	56		 push	 esi
  0007c	57		 push	 edi
  0007d	8b f8		 mov	 edi, eax

; 113  : 	unsigned int	itick;
; 114  : 
; 115  : 	nsd.set(work);				//Tu[`Ap[^

  0007f	8b 44 24 10	 mov	 eax, DWORD PTR _work$[esp+4]
  00083	8d 77 3c	 lea	 esi, DWORD PTR [edi+60]
  00086	8b ce		 mov	 ecx, esi
  00088	e8 00 00 00 00	 call	 ?set@NSD_WORK@@QAEXPAV1@@Z ; NSD_WORK::set

; 116  : 	itick = TickCount(MUS);

  0008d	ff 74 24 0c	 push	 DWORD PTR _MUS$[esp+4]
  00091	8b cf		 mov	 ecx, edi
  00093	e8 00 00 00 00	 call	 ?TickCount@MusicTrack@@QAEIPAVMusicFile@@@Z ; MusicTrack::TickCount

; 117  : 	nsd.get(work);				//Tu[`Ap[^m

  00098	8b 4c 24 10	 mov	 ecx, DWORD PTR _work$[esp+4]
  0009c	8b f8		 mov	 edi, eax
  0009e	8b c6		 mov	 eax, esi
  000a0	e8 00 00 00 00	 call	 ?set@NSD_WORK@@QAEXPAV1@@Z ; NSD_WORK::set

; 118  : 
; 119  : 	return(itick);

  000a5	8b c7		 mov	 eax, edi
  000a7	5f		 pop	 edi
  000a8	5e		 pop	 esi

; 120  : }

  000a9	c2 08 00	 ret	 8
?TickCount@MusicTrack@@QAEIPAVMusicFile@@PAVNSD_WORK@@@Z ENDP ; MusicTrack::TickCount
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAPAVmml_Address@@PAPAV1@V?$allocator@PAVmml_Address@@@std@@@std@@YAPAPAVmml_Address@@PAPAV1@00AAV?$allocator@PAVmml_Address@@@0@@Z
_TEXT	SEGMENT
__Cat$44105 = -4					; size = 1
__First$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_copy@PAPAVmml_Address@@PAPAV1@V?$allocator@PAVmml_Address@@@std@@@std@@YAPAPAVmml_Address@@PAPAV1@00AAV?$allocator@PAVmml_Address@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<mml_Address * *,mml_Address * *,std::allocator<mml_Address *> >, COMDAT
; __Last$ = eax

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$44105[ebp]
  00007	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAVmml_Address@@PAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00AAV?$allocator@PAVmml_Address@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<mml_Address *,mml_Address *>
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 129  : 	}

  00015	c9		 leave
  00016	c3		 ret	 0
??$_Uninitialized_copy@PAPAVmml_Address@@PAPAV1@V?$allocator@PAVmml_Address@@@std@@@std@@YAPAPAVmml_Address@@PAPAV1@00AAV?$allocator@PAVmml_Address@@@0@@Z ENDP ; std::_Uninitialized_copy<mml_Address * *,mml_Address * *,std::allocator<mml_Address *> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAPAVmml_Address@@@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEPAPAVmml_Address@@PAPAV2@00@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__First$ = 12						; size = 4
__Cat$44118 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVmml_Address@@@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEPAPAVmml_Address@@PAPAV2@00@Z PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Ucopy<mml_Address * *>, COMDAT
; __Last$ = eax

; 801  : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  00003	ff 75 10	 push	 DWORD PTR __Cat$44118[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __First$[ebp]
  0000c	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAVmml_Address@@PAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00AAV?$allocator@PAVmml_Address@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<mml_Address *,mml_Address *>
  00011	83 c4 0c	 add	 esp, 12			; 0000000cH

; 805  : 		}

  00014	5d		 pop	 ebp
  00015	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAPAVmml_Address@@@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEPAPAVmml_Address@@PAPAV2@00@Z ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Ucopy<mml_Address * *>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@0@ABQAU120@@Z
_TEXT	SEGMENT
??$_Construct@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node *,std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node *>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $L44123
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
$L44123:

; 43   : 	}

  00008	c3		 ret	 0
??$_Construct@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node *,std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node *>
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
??$_Construct@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node *,std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node *>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $L44132
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
$L44132:

; 43   : 	}

  00008	c3		 ret	 0
??$_Construct@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node *,std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node *>
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Min@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Min, COMDAT
; __Pnode$ = eax

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00000	eb 02		 jmp	 SHORT $L44152
$L32082:

; 1043 : 			_Pnode = _Left(_Pnode);

  00002	8b c1		 mov	 eax, ecx
$L44152:

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	74 f6		 je	 SHORT $L32082

; 1044 : 		return (_Pnode);
; 1045 : 		}

  0000c	c3		 ret	 0
?_Min@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Min
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Max@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Max, COMDAT
; __Pnode$ = eax

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00000	eb 02		 jmp	 SHORT $L44168
$L32078:

; 1036 : 			_Pnode = _Right(_Pnode);

  00002	8b c1		 mov	 eax, ecx
$L44168:

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

  00004	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00007	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000b	74 f5		 je	 SHORT $L32078

; 1037 : 		return (_Pnode);
; 1038 : 		}

  0000d	c3		 ret	 0
?_Max@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Max
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = edx

; 268  : 			if (_Isnil(_Ptr))

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	53		 push	 ebx
  00003	32 db		 xor	 bl, bl
  00005	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00008	75 2a		 jne	 SHORT $L31851

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	38 59 15	 cmp	 BYTE PTR [ecx+21], bl
  00010	75 18		 jne	 SHORT $L44215

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

  00012	eb 02		 jmp	 SHORT $L44219
$L44202:
  00014	8b c8		 mov	 ecx, eax
$L44219:
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  0001b	74 f7		 je	 SHORT $L44202
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  00020	c3		 ret	 0
$L31854:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  00021	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00023	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00026	75 0a		 jne	 SHORT $L31855

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

  00028	89 02		 mov	 DWORD PTR [edx], eax
$L44215:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00030	74 ef		 je	 SHORT $L31854
$L31855:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

  00032	89 02		 mov	 DWORD PTR [edx], eax
$L31851:
  00034	5b		 pop	 ebx

; 279  : 				}
; 280  : 			}

  00035	c3		 ret	 0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 251  : 			if (_Isnil(_Ptr))

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	53		 push	 ebx
  00003	32 db		 xor	 bl, bl
  00005	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00008	74 05		 je	 SHORT $L31837

; 252  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 253  : 			else if (!_Isnil(_Left(_Ptr)))

  0000d	eb 2c		 jmp	 SHORT $L44278
$L31837:
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	38 5a 15	 cmp	 BYTE PTR [edx+21], bl
  00014	75 18		 jne	 SHORT $L44275

; 254  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

  00016	eb 02		 jmp	 SHORT $L44280
$L44259:
  00018	8b d0		 mov	 edx, eax
$L44280:
  0001a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001d	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00020	74 f6		 je	 SHORT $L44259
  00022	89 11		 mov	 DWORD PTR [ecx], edx
  00024	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  00025	c3		 ret	 0
$L31843:

; 255  : 			else
; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	3b 10		 cmp	 edx, DWORD PTR [eax]
  0002a	75 0a		 jne	 SHORT $L31844

; 260  : 					_Ptr = _Pnode;	// ==> parent while left subtree

  0002c	89 01		 mov	 DWORD PTR [ecx], eax
$L44275:

; 255  : 			else
; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

  0002e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00031	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00034	74 f0		 je	 SHORT $L31843
$L31844:

; 261  : 				if (!_Isnil(_Pnode))

  00036	38 58 15	 cmp	 BYTE PTR [eax+21], bl
  00039	75 02		 jne	 SHORT $L31845
$L44278:

; 262  : 					_Ptr = _Pnode;	// ==> parent if not head

  0003b	89 01		 mov	 DWORD PTR [ecx], eax
$L31845:
  0003d	5b		 pop	 ebx

; 263  : 				}
; 264  : 			}

  0003e	c3		 ret	 0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEAAV012@XZ PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::const_iterator::operator++, COMDAT
; _this$ = eax

; 171  : 			_Ptr = _Nextnode(_Ptr);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 172  : 			return (*this);
; 173  : 			}

  00006	c3		 ret	 0
??Econst_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEAAV012@XZ ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::const_iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$list@IV?$allocator@I@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$list@IV?$allocator@I@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::const_iterator::operator++, COMDAT
; _this$ = eax

; 171  : 			_Ptr = _Nextnode(_Ptr);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 172  : 			return (*this);
; 173  : 			}

  00006	c3		 ret	 0
??Econst_iterator@?$list@IV?$allocator@I@std@@@std@@QAEAAV012@XZ ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::const_iterator::operator++
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::operator--, COMDAT

; 228  : 			_Dec();

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::_Dec

; 229  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 230  : 			}

  0000d	c2 04 00	 ret	 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::operator++, COMDAT

; 215  : 			_Inc();

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 217  : 			}

  0000d	c2 04 00	 ret	 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVPatch@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVPatch@@@2@D@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Buynode, COMDAT

; 1130 : 		{	// allocate a node with pointers, value, and color

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1131 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00004	6a 18		 push	 24			; 00000018H
  00006	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000b	8b f0		 mov	 esi, eax

; 1132 : 		_TRY_BEGIN
; 1133 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

  0000d	85 f6		 test	 esi, esi
  0000f	59		 pop	 ecx
  00010	74 14		 je	 SHORT $L44307
  00012	ff 75 18	 push	 DWORD PTR __Carg$[ebp]
  00015	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  00018	ff 75 10	 push	 DWORD PTR __Rarg$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR __Larg$[ebp]
  0001e	ff 75 0c	 push	 DWORD PTR __Parg$[ebp]
  00021	e8 00 00 00 00	 call	 ??0_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIPAVPatch@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Node::_Node
$L44307:

; 1134 : 		_CATCH_ALL
; 1135 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1136 : 		_RERAISE;
; 1137 : 		_CATCH_END
; 1138 : 		return (_Wherenode);

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi

; 1139 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 14 00	 ret	 20			; 00000014H
?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVPatch@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Buynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Root, COMDAT
; _this$ = eax

; 1064 : 		return (_Parent(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 04	 add	 eax, 4

; 1065 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Root
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Root, COMDAT
; _this$ = eax

; 1059 : 		return (_Parent(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 04	 add	 eax, 4

; 1060 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Root
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Lrotate, COMDAT
; __Wherenode$ = ecx

; 1015 : 		_Nodeptr _Pnode = _Right(_Wherenode);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1016 : 		_Right(_Wherenode) = _Left(_Pnode);

  00003	8b 10		 mov	 edx, DWORD PTR [eax]
  00005	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 1017 : 
; 1018 : 		if (!_Isnil(_Left(_Pnode)))

  00008	8b 10		 mov	 edx, DWORD PTR [eax]
  0000a	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0000e	75 03		 jne	 SHORT $L31047

; 1019 : 			_Parent(_Left(_Pnode)) = _Wherenode;

  00010	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L31047:

; 1020 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1021 : 
; 1022 : 		if (_Wherenode == _Root())

  00019	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  0001d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00020	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00023	75 05		 jne	 SHORT $L31048

; 1023 : 			_Root() = _Pnode;

  00025	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1024 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

  00028	eb 0e		 jmp	 SHORT $L31051
$L31048:
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0002f	75 04		 jne	 SHORT $L31050

; 1025 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  00031	89 02		 mov	 DWORD PTR [edx], eax

; 1026 : 		else

  00033	eb 03		 jmp	 SHORT $L31051
$L31050:

; 1027 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00035	89 42 08	 mov	 DWORD PTR [edx+8], eax
$L31051:

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

  00038	89 08		 mov	 DWORD PTR [eax], ecx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

  0003a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1031 : 		}

  0003d	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Lrotate
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Lmost, COMDAT
; _this$ = eax

; 1005 : 		return (_Left(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1006 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Lmost
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEAAV012@XZ PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::iterator::operator++, COMDAT
; _this$ = eax

; 250  : 			++(*(const_iterator *)this);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 251  : 			return (*this);
; 252  : 			}

  00006	c3		 ret	 0
??Eiterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEAAV012@XZ ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@IV?$allocator@I@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$list@IV?$allocator@I@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::iterator::operator++, COMDAT
; _this$ = eax

; 250  : 			++(*(const_iterator *)this);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 251  : 			return (*this);
; 252  : 			}

  00006	c3		 ret	 0
??Eiterator@?$list@IV?$allocator@I@std@@@std@@QAEAAV012@XZ ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::iterator::operator++
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBIPAVPatch@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBIPAVPatch@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = eax

; 205  : 			return (_Myval(_Ptr));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 206  : 			}

  00005	c3		 ret	 0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@$$CBIPAVPatch@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::operator*
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Fiterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::iterator::operator--, COMDAT

; 340  : 			--(*(const_iterator *)this);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::_Dec

; 341  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 342  : 			}

  0000d	c2 04 00	 ret	 4
??Fiterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::iterator::operator++, COMDAT

; 327  : 			++(*(const_iterator *)this);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  00004	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::_Inc

; 328  : 			return (*this);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR _this$[esp-4]

; 329  : 			}

  0000d	c2 04 00	 ret	 4
??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::iterator::operator++
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<MusicItem *,std::allocator<MusicItem *> >::const_iterator::operator--, COMDAT
; _this$ = eax

; 184  : 			_Ptr = _Prevnode(_Ptr);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00005	89 08		 mov	 DWORD PTR [eax], ecx

; 185  : 			return (*this);
; 186  : 			}

  00007	c3		 ret	 0
??Fconst_iterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<MusicItem *,std::allocator<MusicItem *> >::const_iterator::operator--
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Rmost, COMDAT
; _this$ = eax

; 1049 : 		return (_Right(_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 08	 add	 eax, 8

; 1050 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Rmost
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@ABI@Z
_TEXT	SEGMENT
?_Lbound@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@ABI@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Lbound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 988  : 		_Nodeptr _Pnode = _Root();

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	75 16		 jne	 SHORT $L29909
  0000c	8b 12		 mov	 edx, DWORD PTR [edx]
$L29908:

; 992  : 			if (this->comp(_Key(_Pnode), _Keyval))

  0000e	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00011	73 05		 jae	 SHORT $L29910

; 993  : 				_Pnode = _Right(_Pnode);	// descend right subtree

  00013	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 994  : 			else

  00016	eb 04		 jmp	 SHORT $L29911
$L29910:

; 995  : 				{	// _Pnode not less than _Keyval, remember it
; 996  : 				_Wherenode = _Pnode;

  00018	8b c1		 mov	 eax, ecx

; 997  : 				_Pnode = _Left(_Pnode);	// descend left subtree

  0001a	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L29911:

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

  0001c	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00020	74 ec		 je	 SHORT $L29908
$L29909:

; 998  : 				}
; 999  : 
; 1000 : 		return (_Wherenode);	// return best remembered candidate
; 1001 : 		}

  00022	c3		 ret	 0
?_Lbound@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Lbound
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?begin@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	89 08		 mov	 DWORD PTR [eax], ecx

; 409  : 		}

  00007	c3		 ret	 0
?begin@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::begin
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEAAV012@XZ PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::const_iterator::operator--, COMDAT
; _this$ = eax

; 184  : 			_Ptr = _Prevnode(_Ptr);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00005	89 08		 mov	 DWORD PTR [eax], ecx

; 185  : 			return (*this);
; 186  : 			}

  00007	c3		 ret	 0
??Fconst_iterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEAAV012@XZ ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::const_iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
??Eiterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE?AV012@H@Z PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::iterator::operator++, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax

; 256  : 			iterator _Tmp = *this;

  00000	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00002	56		 push	 esi

; 257  : 			++*this;

  00003	8b 31		 mov	 esi, DWORD PTR [ecx]
  00005	89 32		 mov	 DWORD PTR [edx], esi

; 258  : 			return (_Tmp);

  00007	89 08		 mov	 DWORD PTR [eax], ecx
  00009	5e		 pop	 esi

; 259  : 			}

  0000a	c3		 ret	 0
??Eiterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE?AV012@H@Z ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::iterator::operator++
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$list@IV?$allocator@I@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$list@IV?$allocator@I@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::const_iterator::operator--, COMDAT
; _this$ = eax

; 184  : 			_Ptr = _Prevnode(_Ptr);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00005	89 08		 mov	 DWORD PTR [eax], ecx

; 185  : 			return (*this);
; 186  : 			}

  00007	c3		 ret	 0
??Fconst_iterator@?$list@IV?$allocator@I@std@@@std@@QAEAAV012@XZ ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::const_iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@IV?$allocator@I@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
??Eiterator@?$list@IV?$allocator@I@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::iterator::operator++, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax

; 256  : 			iterator _Tmp = *this;

  00000	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00002	56		 push	 esi

; 257  : 			++*this;

  00003	8b 31		 mov	 esi, DWORD PTR [ecx]
  00005	89 32		 mov	 DWORD PTR [edx], esi

; 258  : 			return (_Tmp);

  00007	89 08		 mov	 DWORD PTR [eax], ecx
  00009	5e		 pop	 esi

; 259  : 			}

  0000a	c3		 ret	 0
??Eiterator@?$list@IV?$allocator@I@std@@@std@@QAE?AV012@H@Z ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::iterator::operator++
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@ABQAU342@@Z
_TEXT	SEGMENT
?construct@?$allocator@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node *>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $L44593
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
$L44593:

; 148  : 		}

  00008	c3		 ret	 0
?construct@?$allocator@PAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@ABQAU342@@Z ENDP ; std::allocator<std::_List_nod<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Node *>::construct
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@PAU342@0ABViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Buynode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@PAU342@0ABViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Buynode, COMDAT

; 918  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

  00000	6a 0c		 push	 12			; 0000000cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 919  : 		_TRY_BEGIN
; 920  : 		new ((void *)_Pnode) _Node(_Next, _Prev, _Val);

  00007	85 c0		 test	 eax, eax
  00009	59		 pop	 ecx
  0000a	74 16		 je	 SHORT $L44602
  0000c	8b 4c 24 04	 mov	 ecx, DWORD PTR __Next$[esp-4]
  00010	89 08		 mov	 DWORD PTR [eax], ecx
  00012	8b 4c 24 08	 mov	 ecx, DWORD PTR __Prev$[esp-4]
  00016	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00019	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0001d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001f	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$L44602:

; 921  : 		_CATCH_ALL
; 922  : 		this->_Alnod.deallocate(_Pnode, 1);
; 923  : 		_RERAISE;
; 924  : 		_CATCH_END
; 925  : 		return (_Pnode);
; 926  : 		}

  00022	c2 0c 00	 ret	 12			; 0000000cH
?_Buynode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@PAU342@0ABViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Buynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?clear@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXXZ PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::clear, COMDAT
; _this$ = esi

; 611  : 		_Nodeptr _Pnext;
; 612  : 		_Nodeptr _Pnode = _Nextnode(_Myhead);

  00000	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00003	8b 08		 mov	 ecx, DWORD PTR [eax]

; 613  : 		_Nextnode(_Myhead) = _Myhead;

  00005	89 00		 mov	 DWORD PTR [eax], eax

; 614  : 		_Prevnode(_Myhead) = _Myhead;

  00007	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000a	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 615  : 		_Mysize = 0;

  0000d	83 66 08 00	 and	 DWORD PTR [esi+8], 0

; 616  : 
; 617  : 		for (; _Pnode != _Myhead; _Pnode = _Pnext)

  00011	3b 4e 04	 cmp	 ecx, DWORD PTR [esi+4]
  00014	74 12		 je	 SHORT $L29671
  00016	57		 push	 edi
$L29669:

; 618  : 			{	// delete an element
; 619  : 			_Pnext = _Nextnode(_Pnode);

  00017	8b 39		 mov	 edi, DWORD PTR [ecx]

; 620  : 			this->_Alnod.destroy(_Pnode);
; 621  : 			this->_Alnod.deallocate(_Pnode, 1);

  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001f	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00022	59		 pop	 ecx
  00023	8b cf		 mov	 ecx, edi
  00025	75 f0		 jne	 SHORT $L29669
  00027	5f		 pop	 edi
$L29671:

; 622  : 			}
; 623  : 		}

  00028	c3		 ret	 0
?clear@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXXZ ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::clear
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
?construct@?$allocator@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node *>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $L44669
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
$L44669:

; 148  : 		}

  00008	c3		 ret	 0
?construct@?$allocator@PAU_Node@?$_List_nod@IV?$allocator@I@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_List_nod<unsigned int,std::allocator<unsigned int> >::_Node *>::construct
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??0?$_List_ptr@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_ptr@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z PROC NEAR ; std::_List_ptr<unsigned int,std::allocator<unsigned int> >::_List_ptr<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = eax

; 65   : 		}

  00000	c2 04 00	 ret	 4
??0?$_List_ptr@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ENDP ; std::_List_ptr<unsigned int,std::allocator<unsigned int> >::_List_ptr<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@IV?$allocator@I@std@@@std@@IAEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@PAU342@0ABI@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Buynode@?$list@IV?$allocator@I@std@@@std@@IAEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@PAU342@0ABI@Z PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::_Buynode, COMDAT

; 918  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

  00000	6a 0c		 push	 12			; 0000000cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 919  : 		_TRY_BEGIN
; 920  : 		new ((void *)_Pnode) _Node(_Next, _Prev, _Val);

  00007	85 c0		 test	 eax, eax
  00009	59		 pop	 ecx
  0000a	74 16		 je	 SHORT $L44697
  0000c	8b 4c 24 04	 mov	 ecx, DWORD PTR __Next$[esp-4]
  00010	89 08		 mov	 DWORD PTR [eax], ecx
  00012	8b 4c 24 08	 mov	 ecx, DWORD PTR __Prev$[esp-4]
  00016	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00019	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Val$[esp-4]
  0001d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001f	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$L44697:

; 921  : 		_CATCH_ALL
; 922  : 		this->_Alnod.deallocate(_Pnode, 1);
; 923  : 		_RERAISE;
; 924  : 		_CATCH_END
; 925  : 		return (_Pnode);
; 926  : 		}

  00022	c2 0c 00	 ret	 12			; 0000000cH
?_Buynode@?$list@IV?$allocator@I@std@@@std@@IAEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@PAU342@0ABI@Z ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::_Buynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?clear@?$list@IV?$allocator@I@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@IV?$allocator@I@std@@@std@@QAEXXZ PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::clear, COMDAT
; _this$ = esi

; 611  : 		_Nodeptr _Pnext;
; 612  : 		_Nodeptr _Pnode = _Nextnode(_Myhead);

  00000	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00003	8b 08		 mov	 ecx, DWORD PTR [eax]

; 613  : 		_Nextnode(_Myhead) = _Myhead;

  00005	89 00		 mov	 DWORD PTR [eax], eax

; 614  : 		_Prevnode(_Myhead) = _Myhead;

  00007	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000a	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 615  : 		_Mysize = 0;

  0000d	83 66 08 00	 and	 DWORD PTR [esi+8], 0

; 616  : 
; 617  : 		for (; _Pnode != _Myhead; _Pnode = _Pnext)

  00011	3b 4e 04	 cmp	 ecx, DWORD PTR [esi+4]
  00014	74 12		 je	 SHORT $L29594
  00016	57		 push	 edi
$L29592:

; 618  : 			{	// delete an element
; 619  : 			_Pnext = _Nextnode(_Pnode);

  00017	8b 39		 mov	 edi, DWORD PTR [ecx]

; 620  : 			this->_Alnod.destroy(_Pnode);
; 621  : 			this->_Alnod.deallocate(_Pnode, 1);

  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001f	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00022	59		 pop	 ecx
  00023	8b cf		 mov	 ecx, edi
  00025	75 f0		 jne	 SHORT $L29592
  00027	5f		 pop	 edi
$L29594:

; 622  : 			}
; 623  : 		}

  00028	c3		 ret	 0
?clear@?$list@IV?$allocator@I@std@@@std@@QAEXXZ ENDP	; std::list<unsigned int,std::allocator<unsigned int> >::clear
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 463  : 		return (iterator(_Myfirst));

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 		}

  00005	c3		 ret	 0
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBIPAVPatch@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBIPAVPatch@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::iterator::operator*, COMDAT
; _this$ = eax

; 317  : 			return ((reference)**(const_iterator *)this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 318  : 			}

  00005	c3		 ret	 0
??Diterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@$$CBIPAVPatch@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::iterator::operator*
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??Fiterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<MusicItem *,std::allocator<MusicItem *> >::iterator::operator--, COMDAT
; _this$ = eax

; 263  : 			--(*(const_iterator *)this);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00005	89 08		 mov	 DWORD PTR [eax], ecx

; 264  : 			return (*this);
; 265  : 			}

  00007	c3		 ret	 0
??Fiterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<MusicItem *,std::allocator<MusicItem *> >::iterator::operator--
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z
_TEXT	SEGMENT
?lower_bound@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::lower_bound, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Keyval$ = edx

; 810  : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

  00000	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Lbound
  00005	89 06		 mov	 DWORD PTR [esi], eax
  00007	8b c6		 mov	 eax, esi

; 811  : 		}

  00009	c3		 ret	 0
?lower_bound@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::lower_bound
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??Fiterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEAAV012@XZ PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::iterator::operator--, COMDAT
; _this$ = eax

; 263  : 			--(*(const_iterator *)this);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00005	89 08		 mov	 DWORD PTR [eax], ecx

; 264  : 			return (*this);
; 265  : 			}

  00007	c3		 ret	 0
??Fiterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEAAV012@XZ ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Fiterator@?$list@IV?$allocator@I@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$list@IV?$allocator@I@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::iterator::operator--, COMDAT
; _this$ = eax

; 263  : 			--(*(const_iterator *)this);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00005	89 08		 mov	 DWORD PTR [eax], ecx

; 264  : 			return (*this);
; 265  : 			}

  00007	c3		 ret	 0
??Fiterator@?$list@IV?$allocator@I@std@@@std@@QAEAAV012@XZ ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEXXZ PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Tidy, COMDAT
; _this$ = eax

; 929  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 930  : 		clear();

  00003	e8 00 00 00 00	 call	 ?clear@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXXZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::clear

; 931  : 		this->_Alptr.destroy(&_Nextnode(_Myhead));
; 932  : 		this->_Alptr.destroy(&_Prevnode(_Myhead));
; 933  : 		this->_Alnod.deallocate(_Myhead, 1);

  00008	ff 76 04	 push	 DWORD PTR [esi+4]
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 934  : 		_Myhead = 0;

  00010	83 66 04 00	 and	 DWORD PTR [esi+4], 0
  00014	59		 pop	 ecx
  00015	5e		 pop	 esi

; 935  : 		}

  00016	c3		 ret	 0
?_Tidy@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEXXZ ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Tidy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@XZ PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Buynode, COMDAT

; 899  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

  00000	6a 0c		 push	 12			; 0000000cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 900  : 		int _Linkcnt = 0;
; 901  : 
; 902  : 		_TRY_BEGIN
; 903  : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);

  00007	85 c0		 test	 eax, eax
  00009	59		 pop	 ecx
  0000a	74 02		 je	 SHORT $L44885
  0000c	89 00		 mov	 DWORD PTR [eax], eax
$L44885:

; 904  : 		++_Linkcnt;
; 905  : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);

  0000e	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00011	85 c9		 test	 ecx, ecx
  00013	74 02		 je	 SHORT $L44913
  00015	89 01		 mov	 DWORD PTR [ecx], eax
$L44913:

; 906  : 		_CATCH_ALL
; 907  : 		if (0 < _Linkcnt)
; 908  : 			this->_Alptr.destroy(&_Nextnode(_Pnode));
; 909  : 		this->_Alnod.deallocate(_Pnode, 1);
; 910  : 		_RERAISE;
; 911  : 		_CATCH_END
; 912  : 		return (_Pnode);
; 913  : 		}

  00017	c3		 ret	 0
?_Buynode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@XZ ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Buynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?erase@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
?erase@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::erase, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = ebx

; 587  : 		_Nodeptr _Pnode = (_Where++)._Mynode();

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Where$[esp-4]

; 588  : 		if (_Pnode != _Myhead)

  00004	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00007	57		 push	 edi
  00008	8b 38		 mov	 edi, DWORD PTR [eax]
  0000a	74 19		 je	 SHORT $L27870

; 589  : 			{	// not list head, safe to erase
; 590  : 			_Nextnode(_Prevnode(_Pnode)) = _Nextnode(_Pnode);

  0000c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	89 11		 mov	 DWORD PTR [ecx], edx

; 591  : 			_Prevnode(_Nextnode(_Pnode)) = _Prevnode(_Pnode);

  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 592  : 			this->_Alnod.destroy(_Pnode);
; 593  : 			this->_Alnod.deallocate(_Pnode, 1);

  00018	50		 push	 eax
  00019	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 594  : 			--_Mysize;

  00021	ff 4e 08	 dec	 DWORD PTR [esi+8]
  00024	59		 pop	 ecx
$L27870:

; 595  : 			}
; 596  : 		return (_Where);

  00025	89 3b		 mov	 DWORD PTR [ebx], edi
  00027	8b c3		 mov	 eax, ebx
  00029	5f		 pop	 edi

; 597  : 		}

  0002a	c2 04 00	 ret	 4
?erase@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::erase
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$_List_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z PROC NEAR ; std::_List_val<unsigned int,std::allocator<unsigned int> >::_List_val<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = eax

; 83   : 		}

  00000	c2 04 00	 ret	 4
??0?$_List_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ENDP ; std::_List_val<unsigned int,std::allocator<unsigned int> >::_List_val<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$list@IV?$allocator@I@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@IV?$allocator@I@std@@@std@@IAEXXZ PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::_Tidy, COMDAT
; _this$ = eax

; 929  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 930  : 		clear();

  00003	e8 00 00 00 00	 call	 ?clear@?$list@IV?$allocator@I@std@@@std@@QAEXXZ ; std::list<unsigned int,std::allocator<unsigned int> >::clear

; 931  : 		this->_Alptr.destroy(&_Nextnode(_Myhead));
; 932  : 		this->_Alptr.destroy(&_Prevnode(_Myhead));
; 933  : 		this->_Alnod.deallocate(_Myhead, 1);

  00008	ff 76 04	 push	 DWORD PTR [esi+4]
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 934  : 		_Myhead = 0;

  00010	83 66 04 00	 and	 DWORD PTR [esi+4], 0
  00014	59		 pop	 ecx
  00015	5e		 pop	 esi

; 935  : 		}

  00016	c3		 ret	 0
?_Tidy@?$list@IV?$allocator@I@std@@@std@@IAEXXZ ENDP	; std::list<unsigned int,std::allocator<unsigned int> >::_Tidy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@IV?$allocator@I@std@@@std@@IAEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$list@IV?$allocator@I@std@@@std@@IAEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@XZ PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::_Buynode, COMDAT

; 899  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

  00000	6a 0c		 push	 12			; 0000000cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 900  : 		int _Linkcnt = 0;
; 901  : 
; 902  : 		_TRY_BEGIN
; 903  : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);

  00007	85 c0		 test	 eax, eax
  00009	59		 pop	 ecx
  0000a	74 02		 je	 SHORT $L45100
  0000c	89 00		 mov	 DWORD PTR [eax], eax
$L45100:

; 904  : 		++_Linkcnt;
; 905  : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);

  0000e	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00011	85 c9		 test	 ecx, ecx
  00013	74 02		 je	 SHORT $L45128
  00015	89 01		 mov	 DWORD PTR [ecx], eax
$L45128:

; 906  : 		_CATCH_ALL
; 907  : 		if (0 < _Linkcnt)
; 908  : 			this->_Alptr.destroy(&_Nextnode(_Pnode));
; 909  : 		this->_Alnod.deallocate(_Pnode, 1);
; 910  : 		_RERAISE;
; 911  : 		_CATCH_END
; 912  : 		return (_Pnode);
; 913  : 		}

  00017	c3		 ret	 0
?_Buynode@?$list@IV?$allocator@I@std@@@std@@IAEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@XZ ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::_Buynode
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?erase@?$list@IV?$allocator@I@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
?erase@?$list@IV?$allocator@I@std@@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::erase, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = ebx

; 587  : 		_Nodeptr _Pnode = (_Where++)._Mynode();

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Where$[esp-4]

; 588  : 		if (_Pnode != _Myhead)

  00004	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00007	57		 push	 edi
  00008	8b 38		 mov	 edi, DWORD PTR [eax]
  0000a	74 19		 je	 SHORT $L27849

; 589  : 			{	// not list head, safe to erase
; 590  : 			_Nextnode(_Prevnode(_Pnode)) = _Nextnode(_Pnode);

  0000c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	89 11		 mov	 DWORD PTR [ecx], edx

; 591  : 			_Prevnode(_Nextnode(_Pnode)) = _Prevnode(_Pnode);

  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 592  : 			this->_Alnod.destroy(_Pnode);
; 593  : 			this->_Alnod.deallocate(_Pnode, 1);

  00018	50		 push	 eax
  00019	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 594  : 			--_Mysize;

  00021	ff 4e 08	 dec	 DWORD PTR [esi+8]
  00024	59		 pop	 ecx
$L27849:

; 595  : 			}
; 596  : 		return (_Where);

  00025	89 3b		 mov	 DWORD PTR [ebx], edi
  00027	8b c3		 mov	 eax, ebx
  00029	5f		 pop	 edi

; 597  : 		}

  0002a	c2 04 00	 ret	 4
?erase@?$list@IV?$allocator@I@std@@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::erase
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC NEAR ; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = esi

; 792  : 		if (_Myfirst != 0)

  00000	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00003	85 c0		 test	 eax, eax
  00005	74 07		 je	 SHORT $L45247

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);
; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000d	59		 pop	 ecx
$L45247:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  0000e	83 66 04 00	 and	 DWORD PTR [esi+4], 0
  00012	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  00016	83 66 0c 00	 and	 DWORD PTR [esi+12], 0

; 798  : 		}

  0001a	c3		 ret	 0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?empty@?$vector@HV?$allocator@H@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@HV?$allocator@H@std@@@std@@QBE_NXZ PROC NEAR ; std::vector<int,std::allocator<int> >::empty, COMDAT
; _this$ = eax

; 526  : 		return (size() == 0);

  00000	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  00005	f7 d8		 neg	 eax
  00007	1b c0		 sbb	 eax, eax
  00009	40		 inc	 eax

; 527  : 		}

  0000a	c3		 ret	 0
?empty@?$vector@HV?$allocator@H@std@@@std@@QBE_NXZ ENDP	; std::vector<int,std::allocator<int> >::empty
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??Fiterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
??Fiterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::list<MusicItem *,std::allocator<MusicItem *> >::iterator::operator--, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax

; 269  : 			iterator _Tmp = *this;

  00000	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00002	56		 push	 esi

; 270  : 			--*this;

  00003	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00006	89 32		 mov	 DWORD PTR [edx], esi

; 271  : 			return (_Tmp);

  00008	89 08		 mov	 DWORD PTR [eax], ecx
  0000a	5e		 pop	 esi

; 272  : 			}

  0000b	c3		 ret	 0
??Fiterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAE?AV012@H@Z ENDP ; std::list<MusicItem *,std::allocator<MusicItem *> >::iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Fiterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
??Fiterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE?AV012@H@Z PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::iterator::operator--, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax

; 269  : 			iterator _Tmp = *this;

  00000	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00002	56		 push	 esi

; 270  : 			--*this;

  00003	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00006	89 32		 mov	 DWORD PTR [edx], esi

; 271  : 			return (_Tmp);

  00008	89 08		 mov	 DWORD PTR [eax], ecx
  0000a	5e		 pop	 esi

; 272  : 			}

  0000b	c3		 ret	 0
??Fiterator@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE?AV012@H@Z ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??Fiterator@?$list@IV?$allocator@I@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
??Fiterator@?$list@IV?$allocator@I@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::iterator::operator--, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax

; 269  : 			iterator _Tmp = *this;

  00000	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00002	56		 push	 esi

; 270  : 			--*this;

  00003	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00006	89 32		 mov	 DWORD PTR [edx], esi

; 271  : 			return (_Tmp);

  00008	89 08		 mov	 DWORD PTR [eax], ecx
  0000a	5e		 pop	 esi

; 272  : 			}

  0000b	c3		 ret	 0
??Fiterator@?$list@IV?$allocator@I@std@@@std@@QAE?AV012@H@Z ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::iterator::operator--
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?pop_back@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXXZ
_TEXT	SEGMENT
$T45311 = -4						; size = 4
?pop_back@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXXZ PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::pop_back, COMDAT
; _this$ = eax

; 485  : 		{	// erase element at end

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	56		 push	 esi
  00003	8b f0		 mov	 esi, eax

; 486  : 		erase(--end());

  00005	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00008	ff 70 04	 push	 DWORD PTR [eax+4]
  0000b	8d 5c 24 0c	 lea	 ebx, DWORD PTR $T45311[esp+16]
  0000f	e8 00 00 00 00	 call	 ?erase@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE?AViterator@12@V312@@Z ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::erase
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx

; 487  : 		}

  00016	59		 pop	 ecx
  00017	c3		 ret	 0
?pop_back@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXXZ ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::pop_back
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??1?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::~list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >, COMDAT
; _this$ = eax

; 365  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEXXZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Tidy
??1?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::~list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >, COMDAT
; _this$ = esi

; 280  : 		{	// construct empty list

  00000	e8 00 00 00 00	 call	 ?_Buynode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@XZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Buynode
  00005	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  00009	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 281  : 		}

  0000c	8b c6		 mov	 eax, esi
  0000e	c3		 ret	 0
??0?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?pop_back@?$list@IV?$allocator@I@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T45413 = -4						; size = 4
?pop_back@?$list@IV?$allocator@I@std@@@std@@QAEXXZ PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::pop_back, COMDAT
; _this$ = eax

; 485  : 		{	// erase element at end

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	56		 push	 esi
  00003	8b f0		 mov	 esi, eax

; 486  : 		erase(--end());

  00005	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00008	ff 70 04	 push	 DWORD PTR [eax+4]
  0000b	8d 5c 24 0c	 lea	 ebx, DWORD PTR $T45413[esp+16]
  0000f	e8 00 00 00 00	 call	 ?erase@?$list@IV?$allocator@I@std@@@std@@QAE?AViterator@12@V312@@Z ; std::list<unsigned int,std::allocator<unsigned int> >::erase
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx

; 487  : 		}

  00016	59		 pop	 ecx
  00017	c3		 ret	 0
?pop_back@?$list@IV?$allocator@I@std@@@std@@QAEXXZ ENDP	; std::list<unsigned int,std::allocator<unsigned int> >::pop_back
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??1?$list@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@IV?$allocator@I@std@@@std@@QAE@XZ PROC NEAR	; std::list<unsigned int,std::allocator<unsigned int> >::~list<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = eax

; 365  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$list@IV?$allocator@I@std@@@std@@IAEXXZ ; std::list<unsigned int,std::allocator<unsigned int> >::_Tidy
??1?$list@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::list<unsigned int,std::allocator<unsigned int> >::~list<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$list@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$list@IV?$allocator@I@std@@@std@@QAE@XZ PROC NEAR	; std::list<unsigned int,std::allocator<unsigned int> >::list<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = esi

; 280  : 		{	// construct empty list

  00000	e8 00 00 00 00	 call	 ?_Buynode@?$list@IV?$allocator@I@std@@@std@@IAEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@XZ ; std::list<unsigned int,std::allocator<unsigned int> >::_Buynode
  00005	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  00009	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 281  : 		}

  0000c	8b c6		 mov	 eax, esi
  0000e	c3		 ret	 0
??0?$list@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::list<unsigned int,std::allocator<unsigned int> >::list<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?pop_back@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ PROC NEAR ; std::vector<int,std::allocator<int> >::pop_back, COMDAT
; _this$ = esi

; 588  : 		if (!empty())

  00000	8b c6		 mov	 eax, esi
  00002	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  00007	85 c0		 test	 eax, eax
  00009	74 04		 je	 SHORT $L26505

; 589  : 			{	// erase last element
; 590  : 			_Destroy(_Mylast - 1, _Mylast);
; 591  : 			--_Mylast;

  0000b	83 46 08 fc	 add	 DWORD PTR [esi+8], -4	; fffffffcH
$L26505:

; 592  : 			}
; 593  : 		}

  0000f	c3		 ret	 0
?pop_back@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ENDP ; std::vector<int,std::allocator<int> >::pop_back
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC NEAR	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = esi

; 388  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?SetKey@MusicTrack@@QAEXHH@Z			; MusicTrack::SetKey
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
; Function compile flags: /Ogsy
; File f:\nes\nsdl\src\nsc\musictrack.cpp
_TEXT	SEGMENT
_shift_scale$ = -12					; size = 7
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
tv381 = 8						; size = 4
__key$ = 8						; size = 4
?SetKey@MusicTrack@@QAEXHH@Z PROC NEAR			; MusicTrack::SetKey
; _this$ = edi
; __scale$ = ecx

; 1935 : {

  000ac	55		 push	 ebp
  000ad	8b ec		 mov	 ebp, esp
  000af	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000b2	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie

; 1936 : 
; 1937 : 	static	const	char	Shift[16]={3,6,2,5,1,4,0,3,6,2,5,1,4,0,3,6};
; 1938 : 
; 1939 : 	//
; 1940 : 	static	const	char	Key[16][7]={
; 1941 : 	//	  c  d  e  f  g  a  b			n	ID		Key			Shift
; 1942 : 		{-1,-1,-1, 0,-1,-1,-1},		//	0	-6		Gs			3
; 1943 : 		{ 0,-1,-1, 0,-1,-1,-1},		//	1	-5		Ds			6
; 1944 : 		{ 0,-1,-1, 0, 0,-1,-1},		//	2	-4		As			2
; 1945 : 		{ 0, 0,-1, 0, 0,-1,-1},		//	3	-3		Es			5
; 1946 : 		{ 0, 0,-1, 0, 0, 0,-1},		//	4	-2		Bs			1
; 1947 : 		{ 0, 0, 0, 0, 0, 0,-1},		//	5	-1		F			4
; 1948 : 		{ 0, 0, 0, 0, 0, 0, 0},		//	6	 0		C			0
; 1949 : 		{ 0, 0, 0, 1, 0, 0, 0},		//	7	 1		G			3
; 1950 : 		{ 1, 0, 0, 1, 0, 0, 0},		//	8	 2		D			6
; 1951 : 		{ 1, 0, 0, 1, 1, 0, 0},		//	9	 3		A			2
; 1952 : 		{ 1, 1, 0, 1, 1, 0, 0},		//	10	 4		E			5
; 1953 : 		{ 1, 1, 0, 1, 1, 1, 0},		//	11	 5		H			1
; 1954 : 		{ 1, 1, 1, 1, 1, 1, 0},		//	12	 6		Fis			4
; 1955 : 		{ 1, 1, 1, 1, 1, 1, 1},		//	13	 7		Cis			0		
; 1956 : 		{ 1, 1, 1, 2, 1, 1, 1},		//	14	 8		Gis			3
; 1957 : 		{ 2, 1, 1, 2, 1, 1, 1}		//	15	 9		Dis			6
; 1958 : 	};
; 1959 : 
; 1960 : 	//
; 1961 : 	static	const	char	Scale[80][7]={
; 1962 : 	//	  c  d  e  f  g  a  b		ID		Scale (Key = C)		Name
; 1963 : 		{ 0, 0, 0, 0, 0, 0, 0},	//	0		c d e f g a b		Ionian
; 1964 : 		{ 0, 0,-1, 0, 0, 0,-1},	//	1		c d e-f g a b-		Dorian
; 1965 : 		{ 0,-1,-1, 0, 0,-1,-1},	//	2		c d-e-f g a-b-		Phrygian
; 1966 : 		{ 0, 0, 0, 1, 0, 0, 0},	//	3		c d e f+g a b		Lydian
; 1967 : 		{ 0, 0, 0, 0, 0, 0,-1},	//	4		c d e f g a b-		Mixo-Lydian
; 1968 : 		{ 0, 0,-1, 0, 0,-1,-1},	//	5		c d e-f g a-b-		Aeolian
; 1969 : 		{ 0,-1,-1, 0,-1,-1,-1},	//	6		c d-e-f g-a-b-		Locrian
; 1970 : 		{ 0, 1, 1, 1, 0, 1, 0},	//	7		c d+e+f+g a+b		Minor blues
; 1971 : 		{ 0, 0,-1,-1, 0, 0, 0},	//	8		c d e-f-g a b		Major blues
; 1972 : 		{ 0, 0, 0, 0, 0, 0, 0},	//	9		Dummy
; 1973 : 
; 1974 : 		{ 0, 0,-1, 0, 0,-1, 0},	//	10		c d e-f g a-b		Harmonic minor
; 1975 : 		{ 0,-1,-1, 0,-1, 0,-1},	//	11		c d-e-f g-a b-		Locrian natural13
; 1976 : 		{ 0, 0, 0, 0, 1, 0, 0},	//	12		c d e f g+a b		Ionian Augmented
; 1977 : 		{ 0, 0,-1, 1, 0, 0,-1},	//	13		c d e-f g a b-		Dorian 11
; 1978 : 		{ 0,-1, 0, 0, 0,-1,-1},	//	14		c d-e f g a-b-		Harmonic minor perfect 5th below (Spanish Gypsy)
; 1979 : 		{ 0, 1, 0, 1, 0, 0, 0},	//	15		c d+e f+g a b		Lydian 9
; 1980 : 		{ 0,-1,-1,-1,-1,-1,-2},	//	16		c d-e-f-g-a-a		Altered 7 (Ultra Locrian)
; 1981 : 		{ 0, 0, 0, 0, 0, 0, 0},	//	17		Dummy
; 1982 : 		{ 0, 0, 0, 0, 0, 0, 0},	//	18		Dummy
; 1983 : 		{ 0, 0, 0, 0, 0, 0, 0},	//	19		Dummy
; 1984 : 
; 1985 : 		{ 0, 0,-1, 0, 0, 0, 0},	//	20		c d e-f g a b		Melodic minor
; 1986 : 		{ 0,-1,-1, 0, 0, 0,-1},	//	21		c d-e-f g a b-		Dorian 9
; 1987 : 		{ 0, 0, 0, 1, 1, 0, 0},	//	22		c d e f+g+a b		Lydian Augmented
; 1988 : 		{ 0, 0, 0, 1, 0, 0,-1},	//	23		c d e f+g a b-		Mixo-Lydian 11 (Lydian Dominant)
; 1989 : 		{ 0, 0, 0, 0, 0,-1,-1},	//	24		c d e f g a-b-		Mixo-Lydian 13
; 1990 : 		{ 0, 0,-1, 0,-1,-1,-1},	//	25		c d e-f g-a-b-		Aeolian 5 (Semi Locrian)
; 1991 : 		{ 0,-1,-1,-1,-1,-1,-1},	//	26		c d-e-f-g-a-b-		Altered (Super Locrian)
; 1992 : 		{-1,-1,-1, 0, 0,-1,-1},	//	27		c-d-e-f g a-b-		G Altered
; 1993 : 		{ 0, 0, 0, 0, 0, 0, 0},	//	28		Dummy
; 1994 : 		{ 0, 0, 0, 0, 0, 0, 0},	//	29		Dummy
; 1995 : 
; 1996 : 		//c  d  e  f  g  a  b
; 1997 : 		{ 0, 0, 0, 0, 0,-1, 0},	//	30		c d e f g a-b		Harmonic Major
; 1998 : 		{ 0, 0,-1, 0,-1, 0,-1},	//	31		c d e-f g-a b-		Dorian 5
; 1999 : 		{ 0,-1,-1,-1, 0,-1,-1},	//	32		c d-e-f-g a-b-		Phrygian 4
; 2000 : 		{ 0, 0,-1, 1, 0, 0, 0},	//	33		c d e-f+g a b		Lydian 3
; 2001 : 		{ 0,-1, 0, 0, 0, 0,-1},	//	34		c d-e f g a b-		Mixo-Lydian 9
; 2002 : 		{ 0, 1, 0, 1, 1, 0, 0},	//	35		c d+e f+g+a b		Lydian 2 5
; 2003 : 		{ 0,-1,-1, 0,-1,-1,-2},	//	36		c d-e-f g-a-a		Locrian 7
; 2004 : 		{ 0, 0, 0, 0, 0, 0, 0},	//	37		Dummy
; 2005 : 		{ 0, 0, 0, 0, 0, 0, 0},	//	38		Dummy
; 2006 : 		{ 0, 0, 0, 0, 0, 0, 0},	//	39		Dummy
; 2007 : 
; 2008 : 		{ 0,-1,-1, 0, 0, 0, 0},	//	40		c d-e-f g a b		Neapolitan
; 2009 : 		{ 0, 0, 0, 1, 1, 1, 0},	//	41		c d e f+g+a+b		Leading whole-tone
; 2010 : 		{ 0, 0, 0, 1, 1, 0,-1},	//	42		c d e f+g+a b-		Lydian Augmented Dominant
; 2011 : 		{ 0, 0, 0, 1, 0,-1,-1},	//	43		c d e f+g a-b-		Lydian Dominant 6 
; 2012 : 		{ 0, 0, 0, 0,-1,-1,-1},	//	44		c d e f g-a-b-		Major Locrian
; 2013 : 		{ 0, 0,-1,-1,-1,-1,-1},	//	45		c d e-f-g-a-b-		Semi Locrian 4 
; 2014 : 		{ 0,-1,-2,-1,-1,-1,-1},	//	46		c d-d f-g-a-b-		Super Locrian 3
; 2015 : 		{ 0, 0, 0, 0, 0, 0, 0},	//	47		Dummy
; 2016 : 		{ 0, 0, 0, 0, 0, 0, 0},	//	48		Dummy
; 2017 : 		{ 0, 0, 0, 0, 0, 0, 0},	//	49		Dummy
; 2018 : 
; 2019 : 		{ 0,-1,-1, 0, 0,-1, 0},	//	50		c d-e-f g a-b		Neapolitan minor
; 2020 : 		{ 0, 0, 0, 1, 0, 1, 0},	//	51		c d e f+g a+b		Lydian 6 
; 2021 : 		{ 0, 0, 0, 0, 1, 0,-1},	//	52		c d e f g+a b-		Mixo-Lydian Augmented
; 2022 : 		{ 0, 0,-1, 1, 0,-1,-1},	//	53		c d e-f+g a-b-		Hungarian Gypsy 
; 2023 : 		{ 0,-1, 0, 0,-1,-1,-1},	//	54		c d-e f g-a-b-		Locrian Dominant
; 2024 : 		{ 0, 1, 0, 0, 0, 0, 0},	//	55		c d+e f g a b		Ionian 2
; 2025 : 		{ 0,-1,-2,-1,-1,-1,-2},	//	56		c d-d f-g-a-a		Ultra Locrian 3
; 2026 : 		{ 0, 0, 0, 0, 0, 0, 0},	//	57		Dummy
; 2027 : 		{ 0, 0, 0, 0, 0, 0, 0},	//	58		Dummy
; 2028 : 		{ 0, 0, 0, 0, 0, 0, 0},	//	59		Dummy
; 2029 : 
; 2030 : 		{ 0,-1, 0, 0, 0,-1, 0},	//	60		c d-e f g a-b		Gypsy
; 2031 : 		{ 0, 1, 0, 1, 0, 1, 0},	//	61		c d+e f+g a+b		Lydian 2 6
; 2032 : 		{ 0,-1,-1,-1, 0,-1,-2},	//	62		c d-e-f-g a-a		Ultra Phrygian
; 2033 : 		{ 0, 0,-1, 1, 0,-1, 0},	//	63		c d e-f+g a-b		Hungarian minor
; 2034 : 		{ 0,-1, 0, 0,-1, 0,-1},	//	64		c d-e f g-a b-		Oriental
; 2035 : 		{ 0, 1, 0, 0, 1, 0, 0},	//	65		c d+e f g+a b		Ionian Augmented 2
; 2036 : 		{ 0,-1,-2, 0,-1,-1,-2},	//	66		c d-d f g-a-a		Locrian 3 7
; 2037 : 		{ 0, 0, 0, 0, 0, 0, 0},	//	67		Dummy
; 2038 : 		{ 0, 0, 0, 0, 0, 0, 0},	//	68		Dummy
; 2039 : 		{ 0, 0, 0, 0, 0, 0, 0},	//	69		Dummy
; 2040 : 
; 2041 : 		{ 0, 1, 0, 1, 0, 0,-1},	//	70		c d+e f+g a b-		Hungarian major
; 2042 : 		{ 0,-1,-1,-1,-1,-2,-2},	//	71		c d-e-f-g-g a		Super Locrian 6 7 
; 2043 : 		{ 0, 0,-1, 0,-1,-1, 0},	//	72		c d e-f g-a-b		Harmonic minor 5
; 2044 : 		{ 0,-1,-1,-1,-1, 0,-1},	//	73		c d-e-f-g-a b-		Super Locrian 6 
; 2045 : 		{ 0, 0,-1, 0, 1, 0, 0},	//	74		c d e-f g+a b		Melodic minor 5
; 2046 : 		{ 0,-1,-1, 1, 0, 0,-1},	//	75		c d-e-f+g a b-		Dorian 9 11
; 2047 : 		{ 0, 0, 1, 1, 1, 0, 0},	//	76		c d e+f+g+a b		Lydian Augmented 3
; 2048 : 		{ 0, 0, 0, 0, 0, 0, 0},	//	77		Dummy
; 2049 : 		{ 0, 0, 0, 0, 0, 0, 0},	//	78		Dummy
; 2050 : 		{ 0, 0, 0, 0, 0, 0, 0}	//	79		Dummy
; 2051 : 
; 2052 : 	};
; 2053 : 
; 2054 : 	char	shift;
; 2055 : 	char	shift_scale[7];
; 2056 : 
; 2057 : 	nowKey	 = (char)_key;
; 2058 : 	nowScale = 0;
; 2059 : 
; 2060 : 	shift = Shift[nowKey + 6];
; 2061 : 	shift_scale[0] = (char)Scale[_scale][(shift + 0) % 7];

  000b7	6b c9 07	 imul	 ecx, 7
  000ba	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  000bd	8a 45 08	 mov	 al, BYTE PTR __key$[ebp]
  000c0	88 87 d0 00 00
	00		 mov	 BYTE PTR [edi+208], al
  000c6	0f be c0	 movsx	 eax, al
  000c9	89 45 08	 mov	 DWORD PTR tv381[ebp], eax
  000cc	c6 87 d1 00 00
	00 00		 mov	 BYTE PTR [edi+209], 0
  000d3	53		 push	 ebx
  000d4	56		 push	 esi
  000d5	0f be b0 06 00
	00 00		 movsx	 esi, BYTE PTR ?Shift@?1??SetKey@MusicTrack@@QAEXHH@Z@4QBDB[eax+6]
  000dc	6a 07		 push	 7
  000de	5b		 pop	 ebx
  000df	8b c6		 mov	 eax, esi
  000e1	99		 cdq
  000e2	f7 fb		 idiv	 ebx

; 2062 : 	shift_scale[1] = (char)Scale[_scale][(shift + 1) % 7];
; 2063 : 	shift_scale[2] = (char)Scale[_scale][(shift + 2) % 7];
; 2064 : 	shift_scale[3] = (char)Scale[_scale][(shift + 3) % 7];
; 2065 : 	shift_scale[4] = (char)Scale[_scale][(shift + 4) % 7];
; 2066 : 	shift_scale[5] = (char)Scale[_scale][(shift + 5) % 7];
; 2067 : 	shift_scale[6] = (char)Scale[_scale][(shift + 6) % 7];

  000e4	6a 07		 push	 7
  000e6	8a 84 0a 00 00
	00 00		 mov	 al, BYTE PTR ?Scale@?1??SetKey@MusicTrack@@QAEXHH@Z@4QAY06$$CBDA[edx+ecx]
  000ed	88 45 f4	 mov	 BYTE PTR _shift_scale$[ebp], al
  000f0	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  000f3	99		 cdq
  000f4	f7 fb		 idiv	 ebx
  000f6	8a 84 0a 00 00
	00 00		 mov	 al, BYTE PTR ?Scale@?1??SetKey@MusicTrack@@QAEXHH@Z@4QAY06$$CBDA[edx+ecx]
  000fd	88 45 f5	 mov	 BYTE PTR _shift_scale$[ebp+1], al
  00100	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
  00103	99		 cdq
  00104	f7 fb		 idiv	 ebx
  00106	8a 84 0a 00 00
	00 00		 mov	 al, BYTE PTR ?Scale@?1??SetKey@MusicTrack@@QAEXHH@Z@4QAY06$$CBDA[edx+ecx]
  0010d	88 45 f6	 mov	 BYTE PTR _shift_scale$[ebp+2], al
  00110	8d 46 03	 lea	 eax, DWORD PTR [esi+3]
  00113	99		 cdq
  00114	f7 fb		 idiv	 ebx
  00116	8a 84 0a 00 00
	00 00		 mov	 al, BYTE PTR ?Scale@?1??SetKey@MusicTrack@@QAEXHH@Z@4QAY06$$CBDA[edx+ecx]
  0011d	88 45 f7	 mov	 BYTE PTR _shift_scale$[ebp+3], al
  00120	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00123	99		 cdq
  00124	f7 fb		 idiv	 ebx
  00126	8a 84 0a 00 00
	00 00		 mov	 al, BYTE PTR ?Scale@?1??SetKey@MusicTrack@@QAEXHH@Z@4QAY06$$CBDA[edx+ecx]
  0012d	88 45 f8	 mov	 BYTE PTR _shift_scale$[ebp+4], al
  00130	8d 46 05	 lea	 eax, DWORD PTR [esi+5]
  00133	99		 cdq
  00134	f7 fb		 idiv	 ebx
  00136	8d 46 06	 lea	 eax, DWORD PTR [esi+6]
  00139	5e		 pop	 esi
  0013a	8a 9c 0a 00 00
	00 00		 mov	 bl, BYTE PTR ?Scale@?1??SetKey@MusicTrack@@QAEXHH@Z@4QAY06$$CBDA[edx+ecx]
  00141	99		 cdq
  00142	f7 fe		 idiv	 esi

; 2068 : 
; 2069 : 	SetKeyFlag(	Key[nowKey + 6][0] + shift_scale[0],
; 2070 : 				Key[nowKey + 6][1] + shift_scale[1],
; 2071 : 				Key[nowKey + 6][2] + shift_scale[2],
; 2072 : 				Key[nowKey + 6][3] + shift_scale[3],
; 2073 : 				Key[nowKey + 6][4] + shift_scale[4],
; 2074 : 				Key[nowKey + 6][5] + shift_scale[5],
; 2075 : 				Key[nowKey + 6][6] + shift_scale[6]
; 2076 : 	);

  00144	8b 45 08	 mov	 eax, DWORD PTR tv381[ebp]
  00147	6b c0 07	 imul	 eax, 7
  0014a	8a 8c 0a 00 00
	00 00		 mov	 cl, BYTE PTR ?Scale@?1??SetKey@MusicTrack@@QAEXHH@Z@4QAY06$$CBDA[edx+ecx]
  00151	33 d2		 xor	 edx, edx
  00153	8a 90 30 00 00
	00		 mov	 dl, BYTE PTR ?Key@?1??SetKey@MusicTrack@@QAEXHH@Z@4QAY06$$CBDA[eax+48]
  00159	02 d1		 add	 dl, cl
  0015b	33 c9		 xor	 ecx, ecx
  0015d	8a 88 2f 00 00
	00		 mov	 cl, BYTE PTR ?Key@?1??SetKey@MusicTrack@@QAEXHH@Z@4QAY06$$CBDA[eax+47]
  00163	02 cb		 add	 cl, bl
  00165	52		 push	 edx
  00166	51		 push	 ecx
  00167	33 c9		 xor	 ecx, ecx
  00169	8a 88 2e 00 00
	00		 mov	 cl, BYTE PTR ?Key@?1??SetKey@MusicTrack@@QAEXHH@Z@4QAY06$$CBDA[eax+46]
  0016f	02 4d f8	 add	 cl, BYTE PTR _shift_scale$[ebp+4]
  00172	51		 push	 ecx
  00173	33 c9		 xor	 ecx, ecx
  00175	8a 88 2d 00 00
	00		 mov	 cl, BYTE PTR ?Key@?1??SetKey@MusicTrack@@QAEXHH@Z@4QAY06$$CBDA[eax+45]
  0017b	02 4d f7	 add	 cl, BYTE PTR _shift_scale$[ebp+3]
  0017e	51		 push	 ecx
  0017f	33 c9		 xor	 ecx, ecx
  00181	8a 88 2c 00 00
	00		 mov	 cl, BYTE PTR ?Key@?1??SetKey@MusicTrack@@QAEXHH@Z@4QAY06$$CBDA[eax+44]
  00187	02 4d f6	 add	 cl, BYTE PTR _shift_scale$[ebp+2]
  0018a	51		 push	 ecx
  0018b	33 c9		 xor	 ecx, ecx
  0018d	8a 88 2b 00 00
	00		 mov	 cl, BYTE PTR ?Key@?1??SetKey@MusicTrack@@QAEXHH@Z@4QAY06$$CBDA[eax+43]
  00193	02 4d f5	 add	 cl, BYTE PTR _shift_scale$[ebp+1]
  00196	51		 push	 ecx
  00197	8a 88 2a 00 00
	00		 mov	 cl, BYTE PTR ?Key@?1??SetKey@MusicTrack@@QAEXHH@Z@4QAY06$$CBDA[eax+42]
  0019d	02 4d f4	 add	 cl, BYTE PTR _shift_scale$[ebp]
  001a0	8b c7		 mov	 eax, edi
  001a2	e8 00 00 00 00	 call	 ?SetKeyFlag@MusicTrack@@QAEXDDDDDDD@Z ; MusicTrack::SetKeyFlag

; 2077 : }

  001a7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001aa	5e		 pop	 esi
  001ab	5b		 pop	 ebx
  001ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b1	c9		 leave
  001b2	c2 04 00	 ret	 4
?SetKey@MusicTrack@@QAEXHH@Z ENDP			; MusicTrack::SetKey
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Rrotate, COMDAT
; __Wherenode$ = ecx

; 1069 : 		_Nodeptr _Pnode = _Left(_Wherenode);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1070 : 		_Left(_Wherenode) = _Right(_Pnode);

  00002	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00005	89 11		 mov	 DWORD PTR [ecx], edx

; 1071 : 
; 1072 : 		if (!_Isnil(_Right(_Pnode)))

  00007	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000a	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0000e	75 03		 jne	 SHORT $L31059

; 1073 : 			_Parent(_Right(_Pnode)) = _Wherenode;

  00010	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L31059:

; 1074 : 		_Parent(_Pnode) = _Parent(_Wherenode);

  00013	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1075 : 
; 1076 : 		if (_Wherenode == _Root())

  00019	8b 54 24 04	 mov	 edx, DWORD PTR _this$[esp-4]
  0001d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00020	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00023	75 05		 jne	 SHORT $L31060

; 1077 : 			_Root() = _Pnode;

  00025	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1078 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

  00028	eb 0f		 jmp	 SHORT $L31063
$L31060:
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  00030	75 05		 jne	 SHORT $L31062

; 1079 : 			_Right(_Parent(_Wherenode)) = _Pnode;

  00032	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1080 : 		else

  00035	eb 02		 jmp	 SHORT $L31063
$L31062:

; 1081 : 			_Left(_Parent(_Wherenode)) = _Pnode;

  00037	89 02		 mov	 DWORD PTR [edx], eax
$L31063:

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

  00039	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

  0003c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1085 : 		}

  0003f	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?SetMinor@MusicTrack@@QAEXXZ			; MusicTrack::SetMinor
; Function compile flags: /Ogsy
; File f:\nes\nsdl\src\nsc\musictrack.cpp
_TEXT	SEGMENT
?SetMinor@MusicTrack@@QAEXXZ PROC NEAR			; MusicTrack::SetMinor
; _this$ = eax

; 2101 : {

  001b5	57		 push	 edi
  001b6	8b f8		 mov	 edi, eax

; 2102 : 	nowScale = 5;
; 2103 : 	SetKey(nowKey, nowScale);

  001b8	0f be 87 d0 00
	00 00		 movsx	 eax, BYTE PTR [edi+208]
  001bf	6a 05		 push	 5
  001c1	59		 pop	 ecx
  001c2	50		 push	 eax
  001c3	88 8f d1 00 00
	00		 mov	 BYTE PTR [edi+209], cl
  001c9	e8 00 00 00 00	 call	 ?SetKey@MusicTrack@@QAEXHH@Z ; MusicTrack::SetKey
  001ce	5f		 pop	 edi

; 2104 : }

  001cf	c3		 ret	 0
?SetMinor@MusicTrack@@QAEXXZ ENDP			; MusicTrack::SetMinor
_TEXT	ENDS
PUBLIC	?SetMajor@MusicTrack@@QAEXXZ			; MusicTrack::SetMajor
; Function compile flags: /Ogsy
_TEXT	SEGMENT
?SetMajor@MusicTrack@@QAEXXZ PROC NEAR			; MusicTrack::SetMajor
; _this$ = eax

; 2095 : {

  001d0	57		 push	 edi
  001d1	8b f8		 mov	 edi, eax

; 2096 : 	nowScale = 0;
; 2097 : 	SetKey(nowKey, nowScale);

  001d3	0f be 87 d0 00
	00 00		 movsx	 eax, BYTE PTR [edi+208]
  001da	50		 push	 eax
  001db	33 c9		 xor	 ecx, ecx
  001dd	c6 87 d1 00 00
	00 00		 mov	 BYTE PTR [edi+209], 0
  001e4	e8 00 00 00 00	 call	 ?SetKey@MusicTrack@@QAEXHH@Z ; MusicTrack::SetKey
  001e9	5f		 pop	 edi

; 2098 : }

  001ea	c3		 ret	 0
?SetMajor@MusicTrack@@QAEXXZ ENDP			; MusicTrack::SetMajor
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	SEGMENT
$T86166	DD	0ffffffffH
	DD	FLAT:$L85896
$T86158	DD	019930520H
	DD	01H
	DD	FLAT:$T86166
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIPAVPatch@@@2@@Z
_TEXT	SEGMENT
$T85894 = -80						; size = 40
$T85895 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Val$ = 16						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIPAVPatch@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Insert, COMDAT
; _this$ = edi
; __Wherenode$ = ecx

; 911  : 		{	// add node with value next to _Wherenode, to left if _Addnode

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIPAVPatch@@@2@@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 44	 sub	 esp, 68			; 00000044H

; 912  : 		if (max_size() - 1 <= _Mysize)

  0000d	81 7f 08 fe ff
	ff 1f		 cmp	 DWORD PTR [edi+8], 536870910 ; 1ffffffeH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b f1		 mov	 esi, ecx
  00018	72 32		 jb	 SHORT $L85918

; 913  : 			_THROW(length_error, "map/set<T> too long");

  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0001f	8d 4d d8	 lea	 ecx, DWORD PTR $T85895[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00027	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002b	8d 45 d8	 lea	 eax, DWORD PTR $T85895[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d b0	 lea	 ecx, DWORD PTR $T85894[ebp]
  00032	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00037	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  0003c	8d 45 b0	 lea	 eax, DWORD PTR $T85894[ebp]
  0003f	50		 push	 eax
  00040	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T85894[ebp], OFFSET FLAT:??_7length_error@std@@6B@
  00047	e8 00 00 00 00	 call	 __CxxThrowException@8
$L86167:
$L85918:

; 914  : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 915  : 			_Val, _Red);

  0004c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0004f	6a 00		 push	 0
  00051	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  00054	50		 push	 eax
  00055	56		 push	 esi
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVPatch@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Buynode

; 916  : 
; 917  : 		++_Mysize;

  0005c	ff 47 08	 inc	 DWORD PTR [edi+8]
  0005f	8b d8		 mov	 ebx, eax

; 918  : 		if (_Wherenode == _Myhead)

  00061	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00064	3b f0		 cmp	 esi, eax
  00066	75 0d		 jne	 SHORT $L29884

; 919  : 			{	// first node in tree, just set head values
; 920  : 			_Root() = _Newnode;

  00068	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 921  : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

  0006b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0006e	89 18		 mov	 DWORD PTR [eax], ebx
  00070	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 922  : 			}
; 923  : 		else if (_Addleft)

  00073	eb 1e		 jmp	 SHORT $L86162
$L29884:
  00075	80 7d 0c 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  00079	74 0d		 je	 SHORT $L29886

; 924  : 			{	// add to left of _Wherenode
; 925  : 			_Left(_Wherenode) = _Newnode;

  0007b	89 1e		 mov	 DWORD PTR [esi], ebx

; 926  : 			if (_Wherenode == _Lmost())

  0007d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00080	3b 30		 cmp	 esi, DWORD PTR [eax]
  00082	75 12		 jne	 SHORT $L29889

; 927  : 				_Lmost() = _Newnode;

  00084	89 18		 mov	 DWORD PTR [eax], ebx

; 928  : 			}
; 929  : 		else

  00086	eb 0e		 jmp	 SHORT $L29889
$L29886:

; 930  : 			{	// add to right of _Wherenode
; 931  : 			_Right(_Wherenode) = _Newnode;

  00088	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 932  : 			if (_Wherenode == _Rmost())

  0008b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0008e	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00091	75 03		 jne	 SHORT $L29889
$L86162:

; 933  : 				_Rmost() = _Newnode;

  00093	89 58 08	 mov	 DWORD PTR [eax+8], ebx
$L29889:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

  00096	8b f3		 mov	 esi, ebx
  00098	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0009b	e9 8f 00 00 00	 jmp	 $L86164
$L29892:

; 937  : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

  000a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a2	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a5	8b 12		 mov	 edx, DWORD PTR [edx]
  000a7	3b ca		 cmp	 ecx, edx
  000a9	75 52		 jne	 SHORT $L29894

; 938  : 				{	// fixup red-red in left subtree
; 939  : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

  000ab	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ae	8b 52 08	 mov	 edx, DWORD PTR [edx+8]

; 940  : 				if (_Color(_Wherenode) == _Red)

  000b1	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0
  000b5	75 1a		 jne	 SHORT $L29895
$L86165:

; 941  : 					{	// parent has two red children, blacken both
; 942  : 					_Color(_Parent(_Pnode)) = _Black;

  000b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b9	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1

; 943  : 					_Color(_Wherenode) = _Black;

  000bd	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1

; 944  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  000c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c3	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000c6	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0

; 945  : 					_Pnode = _Parent(_Parent(_Pnode));

  000ca	8b 00		 mov	 eax, DWORD PTR [eax]
  000cc	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 946  : 					}
; 947  : 				else

  000cf	eb 5b		 jmp	 SHORT $L29900
$L29895:

; 948  : 					{	// parent has red and black children
; 949  : 					if (_Pnode == _Right(_Parent(_Pnode)))

  000d1	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  000d4	75 08		 jne	 SHORT $L29897

; 950  : 						{	// rotate right child to left
; 951  : 						_Pnode = _Parent(_Pnode);
; 952  : 						_Lrotate(_Pnode);

  000d6	57		 push	 edi
  000d7	8b f1		 mov	 esi, ecx
  000d9	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Lrotate
$L29897:

; 953  : 						}
; 954  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  000de	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e1	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 955  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  000e5	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000eb	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0

; 956  : 					_Rrotate(_Parent(_Parent(_Pnode)));

  000ef	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000f2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f5	57		 push	 edi
  000f6	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Rrotate

; 957  : 					}
; 958  : 				}
; 959  : 			else

  000fb	eb 2f		 jmp	 SHORT $L29900
$L29894:

; 960  : 				{	// fixup red-red in right subtree
; 961  : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));
; 962  : 				if (_Color(_Wherenode) == _Red)

  000fd	80 7a 14 00	 cmp	 BYTE PTR [edx+20], 0

; 963  : 					{	// parent has two red children, blacken both
; 964  : 					_Color(_Parent(_Pnode)) = _Black;
; 965  : 					_Color(_Wherenode) = _Black;
; 966  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;
; 967  : 					_Pnode = _Parent(_Parent(_Pnode));
; 968  : 					}
; 969  : 				else

  00101	74 b4		 je	 SHORT $L86165

; 970  : 					{	// parent has red and black children
; 971  : 					if (_Pnode == _Left(_Parent(_Pnode)))

  00103	3b 31		 cmp	 esi, DWORD PTR [ecx]
  00105	75 08		 jne	 SHORT $L29901

; 972  : 						{	// rotate left child to right
; 973  : 						_Pnode = _Parent(_Pnode);
; 974  : 						_Rrotate(_Pnode);

  00107	57		 push	 edi
  00108	8b f1		 mov	 esi, ecx
  0010a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Rrotate
$L29901:

; 975  : 						}
; 976  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

  0010f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00112	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1

; 977  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

  00116	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00119	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0011c	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0

; 978  : 					_Lrotate(_Parent(_Parent(_Pnode)));

  00120	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00123	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00126	57		 push	 edi
  00127	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Lrotate
$L29900:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

  0012c	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
$L86164:
  0012f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00131	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00135	0f 84 65 ff ff
	ff		 je	 $L29892

; 979  : 					}
; 980  : 				}
; 981  : 
; 982  : 		_Color(_Root()) = _Black;	// root is always black

  0013b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 983  : 		return (_TREE_ITERATOR(_Newnode));
; 984  : 		}

  00141	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00144	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  00148	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0014b	89 18		 mov	 DWORD PTR [eax], ebx
  0014d	5e		 pop	 esi
  0014e	5b		 pop	 ebx
  0014f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00156	c9		 leave
  00157	c2 0c 00	 ret	 12			; 0000000cH
$L86161:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L85896:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T85895[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIPAVPatch@@@2@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T86158
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIPAVPatch@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Insert
; Function compile flags: /Ogsy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIPAVPatch@@@2@@Z
_TEXT	SEGMENT
__Where$29858 = -8					; size = 4
__Addleft$ = -4						; size = 1
$T86180 = 8						; size = 4
__Val$ = 8						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIPAVPatch@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::insert, COMDAT
; _this$ = ebx
; ___$ReturnUdt$ = esi

; 477  : 		{	// try to insert node with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 478  : 		_Nodeptr _Trynode = _Root();

  00005	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00008	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  0000b	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0000f	57		 push	 edi
  00010	8b f9		 mov	 edi, ecx
  00012	c6 45 fc 01	 mov	 BYTE PTR __Addleft$[ebp], 1
  00016	75 21		 jne	 SHORT $L86305

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  0001b	8b 09		 mov	 ecx, DWORD PTR [ecx]
$L29847:
  0001d	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00020	8b f8		 mov	 edi, eax
  00022	0f 92 45 fc	 setb	 BYTE PTR __Addleft$[ebp]
  00026	80 7d fc 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0002a	74 04		 je	 SHORT $L86172

; 482  : 			{	// look for leaf to insert before (_Addleft) or after
; 483  : 			_Wherenode = _Trynode;
; 484  : 			_Addleft = this->comp(this->_Kfn(_Val), _Key(_Trynode));
; 485  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	eb 03		 jmp	 SHORT $L86173
$L86172:
  00030	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$L86173:

; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

  00033	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00037	74 e4		 je	 SHORT $L29847
$L86305:

; 486  : 			}
; 487  : 
; 488  : 		if (this->_Multi)
; 489  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 490  : 		else
; 491  : 			{	// insert only if unique
; 492  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);
; 493  : 			if (!_Addleft)

  00039	80 7d fc 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0003d	8b c7		 mov	 eax, edi
  0003f	89 45 f8	 mov	 DWORD PTR __Where$29858[ebp], eax
  00042	74 19		 je	 SHORT $L86273

; 494  : 				;	// need to test if insert after is okay
; 495  : 			else if (_Where == begin())

  00044	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00047	3b 38		 cmp	 edi, DWORD PTR [eax]
  00049	75 07		 jne	 SHORT $L29863

; 496  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

  0004b	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  0004e	6a 01		 push	 1
  00050	eb 19		 jmp	 SHORT $L86307
$L29863:

; 497  : 			else
; 498  : 				--_Where;	// need to test if insert before is okay

  00052	8d 4d f8	 lea	 ecx, DWORD PTR __Where$29858[ebp]
  00055	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::_Dec
  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Where$29858[ebp]
$L86273:

; 499  : 
; 500  : 			if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))

  0005d	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00063	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00065	73 19		 jae	 SHORT $L29868

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

  00067	51		 push	 ecx
  00068	ff 75 fc	 push	 DWORD PTR __Addleft$[ebp]
$L86307:
  0006b	8d 45 08	 lea	 eax, DWORD PTR $T86180[ebp]
  0006e	8b cf		 mov	 ecx, edi
  00070	50		 push	 eax
  00071	8b fb		 mov	 edi, ebx
  00073	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIPAVPatch@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Insert
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1
  0007e	eb 04		 jmp	 SHORT $L86306
$L29868:

; 502  : 			else
; 503  : 				return (_Pairib(_Where, false));

  00080	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
$L86306:
  00084	89 06		 mov	 DWORD PTR [esi], eax
  00086	8b c6		 mov	 eax, esi
  00088	5f		 pop	 edi

; 504  : 			}
; 505  : 		}

  00089	c9		 leave
  0008a	c2 04 00	 ret	 4
?insert@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIPAVPatch@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::insert
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xstring
xdata$x	SEGMENT
$T86324	DD	0ffffffffH
	DD	FLAT:$L86312
$T86321	DD	019930520H
	DD	01H
	DD	FLAT:$T86324
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T86310 = -80						; size = 40
$T86311 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Xlen, COMDAT

; 883  : 		{	// report a length_error

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?_Xlen@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IBEXXZ
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 44	 sub	 esp, 68			; 00000044H

; 884  : 		_THROW(length_error, "vector<T> too long");

  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00012	8d 4d d8	 lea	 ecx, DWORD PTR $T86311[ebp]
  00015	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0001e	8d 45 d8	 lea	 eax, DWORD PTR $T86311[ebp]
  00021	50		 push	 eax
  00022	8d 4d b0	 lea	 ecx, DWORD PTR $T86310[ebp]
  00025	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  0002a	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  0002f	8d 45 b0	 lea	 eax, DWORD PTR $T86310[ebp]
  00032	50		 push	 eax
  00033	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T86310[ebp], OFFSET FLAT:??_7length_error@std@@6B@
  0003a	e8 00 00 00 00	 call	 __CxxThrowException@8
$L86325:
$L86323:
  0003f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L86312:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T86311[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IBEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T86321
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IBEXXZ ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Xlen
; Function compile flags: /Ogsy
;	COMDAT ?_Insert_n@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXViterator@12@IABQAVmml_Address@@@Z
_TEXT	SEGMENT
tv368 = -8						; size = 4
__Tmp$ = -4						; size = 4
tv393 = 8						; size = 4
tv380 = 8						; size = 4
__Cat$86574 = 8						; size = 1
__Cat$86503 = 8						; size = 1
__Cat$86561 = 8						; size = 1
__Cat$86395 = 8						; size = 1
__Cat$86416 = 8						; size = 1
__Where$ = 8						; size = 4
tv374 = 12						; size = 4
__Count$ = 12						; size = 4
?_Insert_n@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXViterator@12@IABQAVmml_Address@@@Z PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Insert_n, COMDAT
; _this$ = ecx
; __Val$ = eax

; 809  : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  00005	8b 00		 mov	 eax, DWORD PTR [eax]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	89 45 fc	 mov	 DWORD PTR __Tmp$[ebp], eax

; 811  : 		size_type _Capacity = capacity();

  0000f	8b c7		 mov	 eax, edi
  00011	e8 00 00 00 00	 call	 ?capacity@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::capacity

; 812  : 
; 813  : 		if (_Count == 0)

  00016	8b 75 0c	 mov	 esi, DWORD PTR __Count$[ebp]
  00019	85 f6		 test	 esi, esi
  0001b	8b d8		 mov	 ebx, eax
  0001d	0f 84 5e 01 00
	00		 je	 $L86580

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  00023	8b c7		 mov	 eax, edi
  00025	e8 00 00 00 00	 call	 ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
  0002a	b9 ff ff ff 3f	 mov	 ecx, 1073741823		; 3fffffffH
  0002f	2b c8		 sub	 ecx, eax
  00031	3b ce		 cmp	 ecx, esi
  00033	73 05		 jae	 SHORT $L29763

; 816  : 			_Xlen();	// result too long

  00035	e8 00 00 00 00	 call	 ?_Xlen@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IBEXXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Xlen
$L86592:
$L29763:

; 817  : 		else if (_Capacity < size() + _Count)

  0003a	8b c7		 mov	 eax, edi
  0003c	e8 00 00 00 00	 call	 ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
  00041	03 c6		 add	 eax, esi
  00043	3b d8		 cmp	 ebx, eax
  00045	0f 83 9d 00 00
	00		 jae	 $L29765

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0004b	8b c3		 mov	 eax, ebx
  0004d	d1 e8		 shr	 eax, 1
  0004f	b9 ff ff ff 3f	 mov	 ecx, 1073741823		; 3fffffffH
  00054	2b c8		 sub	 ecx, eax
  00056	3b cb		 cmp	 ecx, ebx
  00058	73 04		 jae	 SHORT $L86330
  0005a	33 db		 xor	 ebx, ebx
  0005c	eb 02		 jmp	 SHORT $L86331
$L86330:
  0005e	03 d8		 add	 ebx, eax
$L86331:

; 821  : 			if (_Capacity < size() + _Count)

  00060	8b c7		 mov	 eax, edi
  00062	e8 00 00 00 00	 call	 ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
  00067	03 c6		 add	 eax, esi
  00069	3b d8		 cmp	 ebx, eax
  0006b	73 0b		 jae	 SHORT $L29766

; 822  : 				_Capacity = size() + _Count;

  0006d	8b c7		 mov	 eax, edi
  0006f	e8 00 00 00 00	 call	 ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
  00074	8b d8		 mov	 ebx, eax
  00076	03 de		 add	 ebx, esi
$L29766:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  00078	c1 e3 02	 shl	 ebx, 2
  0007b	53		 push	 ebx
  0007c	89 5d f8	 mov	 DWORD PTR tv368[ebp], ebx
  0007f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 824  : 			pointer _Ptr = _Newvec;
; 825  : 
; 826  : 			_TRY_BEGIN
; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  00084	ff 75 08	 push	 DWORD PTR __Cat$86395[ebp]
  00087	8b d8		 mov	 ebx, eax
  00089	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0008c	53		 push	 ebx
  0008d	50		 push	 eax
  0008e	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00091	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAVmml_Address@@PAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00AAV?$allocator@PAVmml_Address@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<mml_Address *,mml_Address *>
  00096	83 c4 10	 add	 esp, 16			; 00000010H

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  00099	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0009c	51		 push	 ecx
  0009d	8b ce		 mov	 ecx, esi
  0009f	8b f0		 mov	 esi, eax
  000a1	e8 00 00 00 00	 call	 ?_Ufill@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEPAPAVmml_Address@@PAPAV3@IABQAV3@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Ufill

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  000a6	ff 75 08	 push	 DWORD PTR __Cat$86416[ebp]
  000a9	50		 push	 eax
  000aa	ff 75 08	 push	 DWORD PTR __Where$[ebp]
  000ad	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000b0	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAVmml_Address@@PAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00AAV?$allocator@PAVmml_Address@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<mml_Address *,mml_Address *>
  000b5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);
; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 834  : 			_RERAISE;
; 835  : 			_CATCH_END
; 836  : 
; 837  : 			_Count += size();

  000b8	8b c7		 mov	 eax, edi
  000ba	e8 00 00 00 00	 call	 ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
  000bf	8b 75 0c	 mov	 esi, DWORD PTR __Count$[ebp]
  000c2	03 f0		 add	 esi, eax

; 838  : 			if (_Myfirst != 0)

  000c4	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000c7	85 c0		 test	 eax, eax
  000c9	74 07		 je	 SHORT $L86480

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);
; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d1	59		 pop	 ecx
$L86480:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  000d2	8b 45 f8	 mov	 eax, DWORD PTR tv368[ebp]
  000d5	03 c3		 add	 eax, ebx
  000d7	89 47 0c	 mov	 DWORD PTR [edi+12], eax

; 844  : 			_Mylast = _Newvec + _Count;

  000da	8d 04 b3	 lea	 eax, DWORD PTR [ebx+esi*4]
  000dd	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 845  : 			_Myfirst = _Newvec;

  000e0	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  000e3	e9 99 00 00 00	 jmp	 $L86580
$L29765:
  000e8	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000eb	8b 5d 08	 mov	 ebx, DWORD PTR __Where$[ebp]
  000ee	8b c8		 mov	 ecx, eax
  000f0	2b cb		 sub	 ecx, ebx
  000f2	c1 f9 02	 sar	 ecx, 2
  000f5	3b ce		 cmp	 ecx, esi
  000f7	89 45 0c	 mov	 DWORD PTR tv374[ebp], eax
  000fa	73 4b		 jae	 SHORT $L29778

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  000fc	8b ce		 mov	 ecx, esi
  000fe	c1 e1 02	 shl	 ecx, 2
  00101	89 4d 08	 mov	 DWORD PTR tv380[ebp], ecx
  00104	ff 75 08	 push	 DWORD PTR __Cat$86503[ebp]
  00107	03 cb		 add	 ecx, ebx
  00109	51		 push	 ecx
  0010a	53		 push	 ebx
  0010b	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAVmml_Address@@PAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00AAV?$allocator@PAVmml_Address@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<mml_Address *,mml_Address *>

; 851  : 
; 852  : 			_TRY_BEGIN
; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  00110	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00113	8b d0		 mov	 edx, eax
  00115	83 c4 0c	 add	 esp, 12			; 0000000cH
  00118	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0011b	51		 push	 ecx
  0011c	2b d3		 sub	 edx, ebx
  0011e	c1 fa 02	 sar	 edx, 2
  00121	8b ce		 mov	 ecx, esi
  00123	2b ca		 sub	 ecx, edx
  00125	8b f0		 mov	 esi, eax
  00127	e8 00 00 00 00	 call	 ?_Ufill@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEPAPAVmml_Address@@PAPAV3@IABQAV3@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Ufill

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 857  : 			_RERAISE;
; 858  : 			_CATCH_END
; 859  : 
; 860  : 			_Mylast += _Count;

  0012c	8b 45 08	 mov	 eax, DWORD PTR tv380[ebp]
  0012f	01 47 08	 add	 DWORD PTR [edi+8], eax
  00132	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  00135	2b f8		 sub	 edi, eax
  00137	eb 08		 jmp	 SHORT $L86590
$L86536:
  00139	8b 45 fc	 mov	 eax, DWORD PTR __Tmp$[ebp]
  0013c	89 03		 mov	 DWORD PTR [ebx], eax
  0013e	83 c3 04	 add	 ebx, 4
$L86590:
  00141	3b df		 cmp	 ebx, edi
  00143	75 f4		 jne	 SHORT $L86536

; 863  : 			}
; 864  : 		else

  00145	eb 3a		 jmp	 SHORT $L86580
$L29778:

; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;
; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  00147	c1 e6 02	 shl	 esi, 2
  0014a	89 45 08	 mov	 DWORD PTR tv393[ebp], eax
  0014d	29 75 08	 sub	 DWORD PTR tv393[ebp], esi
  00150	ff 75 08	 push	 DWORD PTR __Cat$86561[ebp]
  00153	50		 push	 eax
  00154	ff 75 08	 push	 DWORD PTR tv393[ebp]
  00157	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAVmml_Address@@PAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00AAV?$allocator@PAVmml_Address@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<mml_Address *,mml_Address *>

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  0015c	ff 75 08	 push	 DWORD PTR __Cat$86574[ebp]
  0015f	8b 4d 0c	 mov	 ecx, DWORD PTR tv374[ebp]
  00162	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00165	8b 45 08	 mov	 eax, DWORD PTR tv393[ebp]
  00168	53		 push	 ebx
  00169	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAPAVmml_Address@@PAPAV1@@std@@YAPAPAVmml_Address@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<mml_Address * *,mml_Address * *>
  0016e	83 c4 14	 add	 esp, 20			; 00000014H

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  00171	03 f3		 add	 esi, ebx
  00173	eb 08		 jmp	 SHORT $L86591
$L86578:
  00175	8b 45 fc	 mov	 eax, DWORD PTR __Tmp$[ebp]
  00178	89 03		 mov	 DWORD PTR [ebx], eax
  0017a	83 c3 04	 add	 ebx, 4
$L86591:
  0017d	3b de		 cmp	 ebx, esi
  0017f	75 f4		 jne	 SHORT $L86578
$L86580:
  00181	5f		 pop	 edi
  00182	5e		 pop	 esi
  00183	5b		 pop	 ebx

; 873  : 			}
; 874  : 		}

  00184	c9		 leave
  00185	c2 08 00	 ret	 8
$L86589:
?_Insert_n@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXViterator@12@IABQAVmml_Address@@@Z ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Insert_n
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xstring
xdata$x	SEGMENT
$T86625	DD	0ffffffffH
	DD	FLAT:$L86597
$T86622	DD	019930520H
	DD	01H
	DD	FLAT:$T86625
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
xdata$x	ENDS
;	COMDAT ?_Incsize@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEXI@Z
_TEXT	SEGMENT
$T86595 = -80						; size = 40
$T86596 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?_Incsize@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEXI@Z PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Incsize, COMDAT
; _this$ = ecx
; __Count$ = edx

; 956  : 		{	// alter element count, with checking

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?_Incsize@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEXI@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 44	 sub	 esp, 68			; 00000044H

; 957  : 		if (max_size() - _Mysize < _Count)

  0000d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00010	56		 push	 esi
  00011	be ff ff ff 3f	 mov	 esi, 1073741823		; 3fffffffH
  00016	2b f0		 sub	 esi, eax
  00018	3b f2		 cmp	 esi, edx
  0001a	5e		 pop	 esi
  0001b	73 32		 jae	 SHORT $L86619

; 958  : 			_THROW(length_error, "list<T> too long");

  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00022	8d 4d d8	 lea	 ecx, DWORD PTR $T86596[ebp]
  00025	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002e	8d 45 d8	 lea	 eax, DWORD PTR $T86596[ebp]
  00031	50		 push	 eax
  00032	8d 4d b0	 lea	 ecx, DWORD PTR $T86595[ebp]
  00035	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  0003f	8d 45 b0	 lea	 eax, DWORD PTR $T86595[ebp]
  00042	50		 push	 eax
  00043	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T86595[ebp], OFFSET FLAT:??_7length_error@std@@6B@
  0004a	e8 00 00 00 00	 call	 __CxxThrowException@8
$L86626:
$L86619:

; 959  : 		_Mysize += _Count;

  0004f	03 c2		 add	 eax, edx
  00051	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 960  : 		}

  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0005e	c9		 leave
  0005f	c3		 ret	 0
$L86624:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L86597:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T86596[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Incsize@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEXI@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T86622
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Incsize@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEXI@Z ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Incsize
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xstring
xdata$x	SEGMENT
$T86661	DD	0ffffffffH
	DD	FLAT:$L86633
$T86658	DD	019930520H
	DD	01H
	DD	FLAT:$T86661
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
xdata$x	ENDS
;	COMDAT ?_Incsize@?$list@IV?$allocator@I@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T86631 = -80						; size = 40
$T86632 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?_Incsize@?$list@IV?$allocator@I@std@@@std@@IAEXI@Z PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::_Incsize, COMDAT
; _this$ = ecx
; __Count$ = edx

; 956  : 		{	// alter element count, with checking

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?_Incsize@?$list@IV?$allocator@I@std@@@std@@IAEXI@Z
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 44	 sub	 esp, 68			; 00000044H

; 957  : 		if (max_size() - _Mysize < _Count)

  0000d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00010	56		 push	 esi
  00011	be ff ff ff 3f	 mov	 esi, 1073741823		; 3fffffffH
  00016	2b f0		 sub	 esi, eax
  00018	3b f2		 cmp	 esi, edx
  0001a	5e		 pop	 esi
  0001b	73 32		 jae	 SHORT $L86655

; 958  : 			_THROW(length_error, "list<T> too long");

  0001d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00022	8d 4d d8	 lea	 ecx, DWORD PTR $T86632[ebp]
  00025	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002e	8d 45 d8	 lea	 eax, DWORD PTR $T86632[ebp]
  00031	50		 push	 eax
  00032	8d 4d b0	 lea	 ecx, DWORD PTR $T86631[ebp]
  00035	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  0003f	8d 45 b0	 lea	 eax, DWORD PTR $T86631[ebp]
  00042	50		 push	 eax
  00043	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T86631[ebp], OFFSET FLAT:??_7length_error@std@@6B@
  0004a	e8 00 00 00 00	 call	 __CxxThrowException@8
$L86662:
$L86655:

; 959  : 		_Mysize += _Count;

  0004f	03 c2		 add	 eax, edx
  00051	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 960  : 		}

  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0005e	c9		 leave
  0005f	c3		 ret	 0
$L86660:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L86633:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T86632[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Incsize@?$list@IV?$allocator@I@std@@@std@@IAEXI@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T86658
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Incsize@?$list@IV?$allocator@I@std@@@std@@IAEXI@Z ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::_Incsize
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xstring
xdata$x	SEGMENT
$T86681	DD	0ffffffffH
	DD	FLAT:$L86669
$T86678	DD	019930520H
	DD	01H
	DD	FLAT:$T86681
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T86667 = -80						; size = 40
$T86668 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ PROC NEAR ; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 883  : 		{	// report a length_error

  00000	b8 00 00 00 00	 mov	 eax, __ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
  00005	e8 00 00 00 00	 call	 __EH_prolog
  0000a	83 ec 44	 sub	 esp, 68			; 00000044H

; 884  : 		_THROW(length_error, "vector<T> too long");

  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00012	8d 4d d8	 lea	 ecx, DWORD PTR $T86668[ebp]
  00015	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0001e	8d 45 d8	 lea	 eax, DWORD PTR $T86668[ebp]
  00021	50		 push	 eax
  00022	8d 4d b0	 lea	 ecx, DWORD PTR $T86667[ebp]
  00025	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  0002a	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  0002f	8d 45 b0	 lea	 eax, DWORD PTR $T86667[ebp]
  00032	50		 push	 eax
  00033	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T86667[ebp], OFFSET FLAT:??_7length_error@std@@6B@
  0003a	e8 00 00 00 00	 call	 __CxxThrowException@8
$L86682:
$L86680:
  0003f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L86669:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T86668[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T86678
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Ogsy
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z
_TEXT	SEGMENT
tv368 = -8						; size = 4
__Tmp$ = -4						; size = 4
tv393 = 8						; size = 4
tv380 = 8						; size = 4
__Cat$86931 = 8						; size = 1
__Cat$86860 = 8						; size = 1
__Cat$86918 = 8						; size = 1
__Cat$86752 = 8						; size = 1
__Cat$86774 = 8						; size = 1
__Where$ = 8						; size = 4
tv374 = 12						; size = 4
__Count$ = 12						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx
; __Val$ = eax

; 809  : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  00005	8b 00		 mov	 eax, DWORD PTR [eax]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	89 45 fc	 mov	 DWORD PTR __Tmp$[ebp], eax

; 811  : 		size_type _Capacity = capacity();

  0000f	8b c7		 mov	 eax, edi
  00011	e8 00 00 00 00	 call	 ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity

; 812  : 
; 813  : 		if (_Count == 0)

  00016	8b 75 0c	 mov	 esi, DWORD PTR __Count$[ebp]
  00019	85 f6		 test	 esi, esi
  0001b	8b d8		 mov	 ebx, eax
  0001d	0f 84 5e 01 00
	00		 je	 $L86937

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  00023	8b c7		 mov	 eax, edi
  00025	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  0002a	b9 ff ff ff 3f	 mov	 ecx, 1073741823		; 3fffffffH
  0002f	2b c8		 sub	 ecx, eax
  00031	3b ce		 cmp	 ecx, esi
  00033	73 05		 jae	 SHORT $L29521

; 816  : 			_Xlen();	// result too long

  00035	e8 00 00 00 00	 call	 ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$L86949:
$L29521:

; 817  : 		else if (_Capacity < size() + _Count)

  0003a	8b c7		 mov	 eax, edi
  0003c	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  00041	03 c6		 add	 eax, esi
  00043	3b d8		 cmp	 ebx, eax
  00045	0f 83 9d 00 00
	00		 jae	 $L29523

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0004b	8b c3		 mov	 eax, ebx
  0004d	d1 e8		 shr	 eax, 1
  0004f	b9 ff ff ff 3f	 mov	 ecx, 1073741823		; 3fffffffH
  00054	2b c8		 sub	 ecx, eax
  00056	3b cb		 cmp	 ecx, ebx
  00058	73 04		 jae	 SHORT $L86687
  0005a	33 db		 xor	 ebx, ebx
  0005c	eb 02		 jmp	 SHORT $L86688
$L86687:
  0005e	03 d8		 add	 ebx, eax
$L86688:

; 821  : 			if (_Capacity < size() + _Count)

  00060	8b c7		 mov	 eax, edi
  00062	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  00067	03 c6		 add	 eax, esi
  00069	3b d8		 cmp	 ebx, eax
  0006b	73 0b		 jae	 SHORT $L29524

; 822  : 				_Capacity = size() + _Count;

  0006d	8b c7		 mov	 eax, edi
  0006f	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  00074	8b d8		 mov	 ebx, eax
  00076	03 de		 add	 ebx, esi
$L29524:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  00078	c1 e3 02	 shl	 ebx, 2
  0007b	53		 push	 ebx
  0007c	89 5d f8	 mov	 DWORD PTR tv368[ebp], ebx
  0007f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 824  : 			pointer _Ptr = _Newvec;
; 825  : 
; 826  : 			_TRY_BEGIN
; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  00084	ff 75 08	 push	 DWORD PTR __Cat$86752[ebp]
  00087	8b d8		 mov	 ebx, eax
  00089	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0008c	53		 push	 ebx
  0008d	50		 push	 eax
  0008e	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00091	e8 00 00 00 00	 call	 ??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<int,int>
  00096	83 c4 10	 add	 esp, 16			; 00000010H

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  00099	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0009c	51		 push	 ecx
  0009d	8b ce		 mov	 ecx, esi
  0009f	8b f0		 mov	 esi, eax
  000a1	e8 00 00 00 00	 call	 ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  000a6	ff 75 08	 push	 DWORD PTR __Cat$86774[ebp]
  000a9	50		 push	 eax
  000aa	ff 75 08	 push	 DWORD PTR __Where$[ebp]
  000ad	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000b0	e8 00 00 00 00	 call	 ??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<int,int>
  000b5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);
; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 834  : 			_RERAISE;
; 835  : 			_CATCH_END
; 836  : 
; 837  : 			_Count += size();

  000b8	8b c7		 mov	 eax, edi
  000ba	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  000bf	8b 75 0c	 mov	 esi, DWORD PTR __Count$[ebp]
  000c2	03 f0		 add	 esi, eax

; 838  : 			if (_Myfirst != 0)

  000c4	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000c7	85 c0		 test	 eax, eax
  000c9	74 07		 je	 SHORT $L86837

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);
; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d1	59		 pop	 ecx
$L86837:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  000d2	8b 45 f8	 mov	 eax, DWORD PTR tv368[ebp]
  000d5	03 c3		 add	 eax, ebx
  000d7	89 47 0c	 mov	 DWORD PTR [edi+12], eax

; 844  : 			_Mylast = _Newvec + _Count;

  000da	8d 04 b3	 lea	 eax, DWORD PTR [ebx+esi*4]
  000dd	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 845  : 			_Myfirst = _Newvec;

  000e0	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  000e3	e9 99 00 00 00	 jmp	 $L86937
$L29523:
  000e8	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000eb	8b 5d 08	 mov	 ebx, DWORD PTR __Where$[ebp]
  000ee	8b c8		 mov	 ecx, eax
  000f0	2b cb		 sub	 ecx, ebx
  000f2	c1 f9 02	 sar	 ecx, 2
  000f5	3b ce		 cmp	 ecx, esi
  000f7	89 45 0c	 mov	 DWORD PTR tv374[ebp], eax
  000fa	73 4b		 jae	 SHORT $L29536

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  000fc	8b ce		 mov	 ecx, esi
  000fe	c1 e1 02	 shl	 ecx, 2
  00101	89 4d 08	 mov	 DWORD PTR tv380[ebp], ecx
  00104	ff 75 08	 push	 DWORD PTR __Cat$86860[ebp]
  00107	03 cb		 add	 ecx, ebx
  00109	51		 push	 ecx
  0010a	53		 push	 ebx
  0010b	e8 00 00 00 00	 call	 ??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<int,int>

; 851  : 
; 852  : 			_TRY_BEGIN
; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  00110	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00113	8b d0		 mov	 edx, eax
  00115	83 c4 0c	 add	 esp, 12			; 0000000cH
  00118	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0011b	51		 push	 ecx
  0011c	2b d3		 sub	 edx, ebx
  0011e	c1 fa 02	 sar	 edx, 2
  00121	8b ce		 mov	 ecx, esi
  00123	2b ca		 sub	 ecx, edx
  00125	8b f0		 mov	 esi, eax
  00127	e8 00 00 00 00	 call	 ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 857  : 			_RERAISE;
; 858  : 			_CATCH_END
; 859  : 
; 860  : 			_Mylast += _Count;

  0012c	8b 45 08	 mov	 eax, DWORD PTR tv380[ebp]
  0012f	01 47 08	 add	 DWORD PTR [edi+8], eax
  00132	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  00135	2b f8		 sub	 edi, eax
  00137	eb 08		 jmp	 SHORT $L86947
$L86893:
  00139	8b 45 fc	 mov	 eax, DWORD PTR __Tmp$[ebp]
  0013c	89 03		 mov	 DWORD PTR [ebx], eax
  0013e	83 c3 04	 add	 ebx, 4
$L86947:
  00141	3b df		 cmp	 ebx, edi
  00143	75 f4		 jne	 SHORT $L86893

; 863  : 			}
; 864  : 		else

  00145	eb 3a		 jmp	 SHORT $L86937
$L29536:

; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;
; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  00147	c1 e6 02	 shl	 esi, 2
  0014a	89 45 08	 mov	 DWORD PTR tv393[ebp], eax
  0014d	29 75 08	 sub	 DWORD PTR tv393[ebp], esi
  00150	ff 75 08	 push	 DWORD PTR __Cat$86918[ebp]
  00153	50		 push	 eax
  00154	ff 75 08	 push	 DWORD PTR tv393[ebp]
  00157	e8 00 00 00 00	 call	 ??$_Uninit_copy@HH@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<int,int>

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  0015c	ff 75 08	 push	 DWORD PTR __Cat$86931[ebp]
  0015f	8b 4d 0c	 mov	 ecx, DWORD PTR tv374[ebp]
  00162	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00165	8b 45 08	 mov	 eax, DWORD PTR tv393[ebp]
  00168	53		 push	 ebx
  00169	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *>
  0016e	83 c4 14	 add	 esp, 20			; 00000014H

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  00171	03 f3		 add	 esi, ebx
  00173	eb 08		 jmp	 SHORT $L86948
$L86935:
  00175	8b 45 fc	 mov	 eax, DWORD PTR __Tmp$[ebp]
  00178	89 03		 mov	 DWORD PTR [ebx], eax
  0017a	83 c3 04	 add	 ebx, 4
$L86948:
  0017d	3b de		 cmp	 ebx, esi
  0017f	75 f4		 jne	 SHORT $L86935
$L86937:
  00181	5f		 pop	 edi
  00182	5e		 pop	 esi
  00183	5b		 pop	 ebx

; 873  : 			}
; 874  : 		}

  00184	c9		 leave
  00185	c2 08 00	 ret	 8
$L86946:
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBIPAVPatch@@@2@@Z
_TEXT	SEGMENT
$T86958 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Next$ = 12						; size = 4
__Where$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBIPAVPatch@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::insert, COMDAT
; _this$ = ecx
; __Val$ = eax

; 509  : 		{	// try to insert node with value _Val using _Where as a hint

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	8b d9		 mov	 ebx, ecx

; 510  : 		iterator _Next;
; 511  : 
; 512  : 		if (size() == 0)

  00008	83 7b 08 00	 cmp	 DWORD PTR [ebx+8], 0
  0000c	57		 push	 edi
  0000d	8b f8		 mov	 edi, eax
  0000f	75 18		 jne	 SHORT $L27948

; 513  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

  00011	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00014	57		 push	 edi
  00015	6a 01		 push	 1
  00017	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0001a	8b fb		 mov	 edi, ebx
  0001c	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIPAVPatch@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Insert
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00024	e9 c0 00 00 00	 jmp	 $L27946
$L27948:

; 514  : 		else if (this->_Multi)
; 515  : 			{	// insert even if duplicate
; 516  : 			if (_Where == begin())
; 517  : 				{	// insert at beginning if before first element
; 518  : 				if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 519  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 520  : 				}
; 521  : 			else if (_Where == end())
; 522  : 				{	// insert at end if after last element
; 523  : 				if (!this->comp(this->_Kfn(_Val), _Key(_Rmost())))
; 524  : 					return (_Insert(false, _Rmost(), _Val));
; 525  : 				}
; 526  : 			else if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 527  : 				&& !this->comp(this->_Kfn(_Val),
; 528  : 					_Key((--(_Next = _Where))._Mynode())))
; 529  : 				{	// insert before _Where
; 530  : 				if (_Isnil(_Right(_Next._Mynode())))
; 531  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 532  : 				else
; 533  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 534  : 				}
; 535  : 			else if (!this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 536  : 				&& (++(_Next = _Where) == end()
; 537  : 					|| !this->comp(_Key(_Next._Mynode()),
; 538  : 						this->_Kfn(_Val))))
; 539  : 				{	// insert after _Where
; 540  : 				if (_Isnil(_Right(_Where._Mynode())))
; 541  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 542  : 				else
; 543  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 544  : 				}
; 545  : 			}
; 546  : 		else
; 547  : 			{	// insert only if unique
; 548  : 			if (_Where == begin())

  00029	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0002c	56		 push	 esi
  0002d	8b 75 0c	 mov	 esi, DWORD PTR __Where$[ebp]
  00030	3b 30		 cmp	 esi, DWORD PTR [eax]
  00032	75 22		 jne	 SHORT $L27977

; 549  : 				{	// insert at beginning if before first element
; 550  : 				if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode())))

  00034	8b 07		 mov	 eax, DWORD PTR [edi]
  00036	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00039	0f 83 99 00 00
	00		 jae	 $L27997

; 551  : 					return (_Insert(true, _Where._Mynode(), _Val));

  0003f	57		 push	 edi
  00040	6a 01		 push	 1
  00042	8b ce		 mov	 ecx, esi
$L87504:
  00044	8b fb		 mov	 edi, ebx
$L87505:
  00046	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@ABU?$pair@$$CBIPAVPatch@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Insert
  0004e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00051	e9 92 00 00 00	 jmp	 $L87499
$L27977:

; 552  : 				}
; 553  : 			else if (_Where == end())

  00056	3b f0		 cmp	 esi, eax
  00058	75 11		 jne	 SHORT $L27982

; 554  : 				{	// insert at end if after last element
; 555  : 				if (this->comp(_Key(_Rmost()), this->_Kfn(_Val)))

  0005a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0005d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00060	3b 0f		 cmp	 ecx, DWORD PTR [edi]
  00062	73 74		 jae	 SHORT $L27997

; 556  : 					return (_Insert(false, _Rmost(), _Val));

  00064	57		 push	 edi
  00065	6a 00		 push	 0
  00067	8b c8		 mov	 ecx, eax
  00069	eb d9		 jmp	 SHORT $L87504
$L27982:

; 557  : 				}
; 558  : 			else if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 559  : 				&& this->comp(_Key((--(_Next = _Where))._Mynode()),
; 560  : 					this->_Kfn(_Val)))

  0006b	8b 07		 mov	 eax, DWORD PTR [edi]
  0006d	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00070	73 29		 jae	 SHORT $L27986
  00072	8d 4d 0c	 lea	 ecx, DWORD PTR __Next$[ebp]
  00075	89 75 0c	 mov	 DWORD PTR __Next$[ebp], esi
  00078	e8 00 00 00 00	 call	 ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::_Dec
  0007d	8b 4d 0c	 mov	 ecx, DWORD PTR __Next$[ebp]
  00080	8b 07		 mov	 eax, DWORD PTR [edi]
  00082	39 41 0c	 cmp	 DWORD PTR [ecx+12], eax
  00085	73 14		 jae	 SHORT $L27986

; 561  : 				{	// insert before _Where
; 562  : 				if (_Isnil(_Right(_Next._Mynode())))

  00087	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0008a	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0

; 563  : 					return (_Insert(false, _Next._Mynode(), _Val));

  0008e	57		 push	 edi
  0008f	8b fb		 mov	 edi, ebx
  00091	74 04		 je	 SHORT $L27987
  00093	6a 00		 push	 0
  00095	eb af		 jmp	 SHORT $L87505
$L27987:

; 564  : 				else
; 565  : 					return (_Insert(true, _Where._Mynode(), _Val));

  00097	6a 01		 push	 1
  00099	eb 2f		 jmp	 SHORT $L87502
$L27986:

; 566  : 				}
; 567  : 			else if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 568  : 				&& (++(_Next = _Where) == end()
; 569  : 					|| this->comp(this->_Kfn(_Val),
; 570  : 						_Key(_Next._Mynode()))))

  0009b	8b 07		 mov	 eax, DWORD PTR [edi]
  0009d	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  000a0	73 36		 jae	 SHORT $L27997
  000a2	8d 55 0c	 lea	 edx, DWORD PTR __Next$[ebp]
  000a5	89 75 0c	 mov	 DWORD PTR __Next$[ebp], esi
  000a8	e8 00 00 00 00	 call	 ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::const_iterator::_Inc
  000ad	8b 4d 0c	 mov	 ecx, DWORD PTR __Next$[ebp]
  000b0	3b 4b 04	 cmp	 ecx, DWORD PTR [ebx+4]
  000b3	74 07		 je	 SHORT $L27994
  000b5	8b 07		 mov	 eax, DWORD PTR [edi]
  000b7	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  000ba	73 1c		 jae	 SHORT $L27997
$L27994:

; 571  : 				{	// insert after _Where
; 572  : 				if (_Isnil(_Right(_Where._Mynode())))

  000bc	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000bf	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0

; 573  : 					return (_Insert(false, _Where._Mynode(), _Val));

  000c3	57		 push	 edi
  000c4	8b fb		 mov	 edi, ebx
  000c6	74 09		 je	 SHORT $L27995
  000c8	6a 00		 push	 0
$L87502:
  000ca	8b ce		 mov	 ecx, esi
  000cc	e9 75 ff ff ff	 jmp	 $L87505
$L27995:

; 574  : 				else
; 575  : 					return (_Insert(true, _Next._Mynode(), _Val));

  000d1	6a 01		 push	 1
  000d3	e9 6e ff ff ff	 jmp	 $L87505
$L27997:

; 576  : 				}
; 577  : 			}
; 578  : 
; 579  : 		return (insert(_Val).first);	// try usual insert if all else fails

  000d8	57		 push	 edi
  000d9	8d 75 f8	 lea	 esi, DWORD PTR $T86958[ebp]
  000dc	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIPAVPatch@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::insert
  000e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000e6	89 08		 mov	 DWORD PTR [eax], ecx
$L87499:
  000e8	5e		 pop	 esi
$L27946:
  000e9	5f		 pop	 edi
  000ea	5b		 pop	 ebx

; 580  : 		}

  000eb	c9		 leave
  000ec	c2 08 00	 ret	 8
?insert@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBIPAVPatch@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::insert
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = eax

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00000	33 c9		 xor	 ecx, ecx

; 772  : 		if (_Capacity == 0)

  00002	3b c1		 cmp	 eax, ecx
  00004	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00007	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0000a	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  0000d	75 03		 jne	 SHORT $L27916

; 773  : 			return (false);

  0000f	32 c0		 xor	 al, al

; 783  : 		}

  00011	c3		 ret	 0
$L27916:

; 774  : 		else if (max_size() < _Capacity)

  00012	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00017	76 05		 jbe	 SHORT $L27918

; 775  : 			_Xlen();	// result too long

  00019	e9 00 00 00 00	 jmp	 ?_Xlen@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IBEXXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Xlen
$L27918:
  0001e	57		 push	 edi

; 776  : 		else
; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  0001f	8b f8		 mov	 edi, eax
  00021	c1 e7 02	 shl	 edi, 2
  00024	57		 push	 edi
  00025	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 779  : 			_Mylast = _Myfirst;
; 780  : 			_Myend = _Myfirst + _Capacity;

  0002a	03 f8		 add	 edi, eax
  0002c	59		 pop	 ecx
  0002d	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00030	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00033	89 7e 0c	 mov	 DWORD PTR [esi+12], edi

; 781  : 			}
; 782  : 		return (true);

  00036	b0 01		 mov	 al, 1
  00038	5f		 pop	 edi

; 783  : 		}

  00039	c3		 ret	 0
?_Buy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Buy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?insert@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE?AViterator@12@V312@ABQAVmml_Address@@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Val$ = 12						; size = 4
?insert@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE?AViterator@12@V312@ABQAVmml_Address@@@Z PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::insert, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = ebx

; 620  : 		{	// insert _Val at _Where

  00000	56		 push	 esi

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00001	8b c7		 mov	 eax, edi
  00003	e8 00 00 00 00	 call	 ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
  00008	85 c0		 test	 eax, eax
  0000a	75 04		 jne	 SHORT $L87537
  0000c	33 f6		 xor	 esi, esi
  0000e	eb 0a		 jmp	 SHORT $L87538
$L87537:
  00010	8b 74 24 08	 mov	 esi, DWORD PTR __Where$[esp]
  00014	2b 77 04	 sub	 esi, DWORD PTR [edi+4]
  00017	c1 fe 02	 sar	 esi, 2
$L87538:

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  0001a	8b 44 24 0c	 mov	 eax, DWORD PTR __Val$[esp]
  0001e	6a 01		 push	 1
  00020	ff 74 24 0c	 push	 DWORD PTR __Where$[esp+4]
  00024	8b cf		 mov	 ecx, edi
  00026	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXViterator@12@IABQAVmml_Address@@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Insert_n

; 623  : 		return (begin() + _Off);

  0002b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0002e	8d 04 b0	 lea	 eax, DWORD PTR [eax+esi*4]
  00031	89 03		 mov	 DWORD PTR [ebx], eax
  00033	8b c3		 mov	 eax, ebx
  00035	5e		 pop	 esi

; 624  : 		}

  00036	c2 08 00	 ret	 8
?insert@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE?AViterator@12@V312@ABQAVmml_Address@@@Z ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::insert
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?_Insert@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXViterator@12@ABV3?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXViterator@12@ABV3?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Insert, COMDAT

; 521  : 		{	// insert _Val at _Where

  00000	56		 push	 esi
  00001	57		 push	 edi

; 522  : 		_Nodeptr _Pnode = _Where._Mynode();
; 523  : 		_Nodeptr _Newnode = _Buynode(_Pnode, _Prevnode(_Pnode), _Val);

  00002	ff 74 24 14	 push	 DWORD PTR __Val$[esp+4]
  00006	8b 7c 24 14	 mov	 edi, DWORD PTR __Where$[esp+8]
  0000a	ff 77 04	 push	 DWORD PTR [edi+4]
  0000d	57		 push	 edi
  0000e	e8 00 00 00 00	 call	 ?_Buynode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@PAU342@0ABViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Buynode

; 524  : 		_Incsize(1);

  00013	8b 4c 24 0c	 mov	 ecx, DWORD PTR _this$[esp+4]
  00017	33 d2		 xor	 edx, edx
  00019	42		 inc	 edx
  0001a	8b f0		 mov	 esi, eax
  0001c	e8 00 00 00 00	 call	 ?_Incsize@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEXI@Z ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Incsize

; 525  : 		_Prevnode(_Pnode) = _Newnode;

  00021	89 77 04	 mov	 DWORD PTR [edi+4], esi

; 526  : 		_Nextnode(_Prevnode(_Newnode)) = _Newnode;

  00024	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00027	5f		 pop	 edi
  00028	89 30		 mov	 DWORD PTR [eax], esi
  0002a	5e		 pop	 esi

; 527  : 		}

  0002b	c2 0c 00	 ret	 12			; 0000000cH
?_Insert@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXViterator@12@ABV3?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Insert
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?_Insert@?$list@IV?$allocator@I@std@@@std@@QAEXViterator@12@ABI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert@?$list@IV?$allocator@I@std@@@std@@QAEXViterator@12@ABI@Z PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::_Insert, COMDAT

; 521  : 		{	// insert _Val at _Where

  00000	56		 push	 esi
  00001	57		 push	 edi

; 522  : 		_Nodeptr _Pnode = _Where._Mynode();
; 523  : 		_Nodeptr _Newnode = _Buynode(_Pnode, _Prevnode(_Pnode), _Val);

  00002	ff 74 24 14	 push	 DWORD PTR __Val$[esp+4]
  00006	8b 7c 24 14	 mov	 edi, DWORD PTR __Where$[esp+8]
  0000a	ff 77 04	 push	 DWORD PTR [edi+4]
  0000d	57		 push	 edi
  0000e	e8 00 00 00 00	 call	 ?_Buynode@?$list@IV?$allocator@I@std@@@std@@IAEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@PAU342@0ABI@Z ; std::list<unsigned int,std::allocator<unsigned int> >::_Buynode

; 524  : 		_Incsize(1);

  00013	8b 4c 24 0c	 mov	 ecx, DWORD PTR _this$[esp+4]
  00017	33 d2		 xor	 edx, edx
  00019	42		 inc	 edx
  0001a	8b f0		 mov	 esi, eax
  0001c	e8 00 00 00 00	 call	 ?_Incsize@?$list@IV?$allocator@I@std@@@std@@IAEXI@Z ; std::list<unsigned int,std::allocator<unsigned int> >::_Incsize

; 525  : 		_Prevnode(_Pnode) = _Newnode;

  00021	89 77 04	 mov	 DWORD PTR [edi+4], esi

; 526  : 		_Nextnode(_Prevnode(_Newnode)) = _Newnode;

  00024	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00027	5f		 pop	 edi
  00028	89 30		 mov	 DWORD PTR [eax], esi
  0002a	5e		 pop	 esi

; 527  : 		}

  0002b	c2 0c 00	 ret	 12			; 0000000cH
?_Insert@?$list@IV?$allocator@I@std@@@std@@QAEXViterator@12@ABI@Z ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::_Insert
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = eax

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00000	33 c9		 xor	 ecx, ecx

; 772  : 		if (_Capacity == 0)

  00002	3b c1		 cmp	 eax, ecx
  00004	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00007	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0000a	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  0000d	75 03		 jne	 SHORT $L27802

; 773  : 			return (false);

  0000f	32 c0		 xor	 al, al

; 783  : 		}

  00011	c3		 ret	 0
$L27802:

; 774  : 		else if (max_size() < _Capacity)

  00012	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00017	76 05		 jbe	 SHORT $L27804

; 775  : 			_Xlen();	// result too long

  00019	e9 00 00 00 00	 jmp	 ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$L27804:
  0001e	57		 push	 edi

; 776  : 		else
; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  0001f	8b f8		 mov	 edi, eax
  00021	c1 e7 02	 shl	 edi, 2
  00024	57		 push	 edi
  00025	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 779  : 			_Mylast = _Myfirst;
; 780  : 			_Myend = _Myfirst + _Capacity;

  0002a	03 f8		 add	 edi, eax
  0002c	59		 pop	 ecx
  0002d	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00030	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00033	89 7e 0c	 mov	 DWORD PTR [esi+12], edi

; 781  : 			}
; 782  : 		return (true);

  00036	b0 01		 mov	 al, 1
  00038	5f		 pop	 edi

; 783  : 		}

  00039	c3		 ret	 0
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Val$ = 12						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = ebx

; 620  : 		{	// insert _Val at _Where

  00000	56		 push	 esi

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  00001	8b c7		 mov	 eax, edi
  00003	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  00008	85 c0		 test	 eax, eax
  0000a	75 04		 jne	 SHORT $L87661
  0000c	33 f6		 xor	 esi, esi
  0000e	eb 0a		 jmp	 SHORT $L87662
$L87661:
  00010	8b 74 24 08	 mov	 esi, DWORD PTR __Where$[esp]
  00014	2b 77 04	 sub	 esi, DWORD PTR [edi+4]
  00017	c1 fe 02	 sar	 esi, 2
$L87662:

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  0001a	8b 44 24 0c	 mov	 eax, DWORD PTR __Val$[esp]
  0001e	6a 01		 push	 1
  00020	ff 74 24 0c	 push	 DWORD PTR __Where$[esp+4]
  00024	8b cf		 mov	 ecx, edi
  00026	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXViterator@12@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 623  : 		return (begin() + _Off);

  0002b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0002e	8d 04 b0	 lea	 eax, DWORD PTR [eax+esi*4]
  00031	89 03		 mov	 DWORD PTR [ebx], eax
  00033	8b c3		 mov	 eax, ebx
  00035	5e		 pop	 esi

; 624  : 		}

  00036	c2 08 00	 ret	 8
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z
_TEXT	SEGMENT
$T87719 = -12						; size = 8
$T87721 = -4						; size = 4
??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z PROC NEAR ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[], COMDAT
; _this$ = edi
; __Keyval$ = esi

; 142  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 143  : 		iterator _Where = this->lower_bound(_Keyval);

  00006	8b d6		 mov	 edx, esi
  00008	8b c7		 mov	 eax, edi
  0000a	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::_Lbound

; 144  : 		if (_Where == this->end() || this->comp(_Keyval, this->_Key(_Where._Mynode())))

  0000f	3b 47 04	 cmp	 eax, DWORD PTR [edi+4]
  00012	74 07		 je	 SHORT $L26687
  00014	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00016	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00019	73 1a		 jae	 SHORT $L26686
$L26687:

; 145  : 			_Where = this->insert(_Where,
; 146  : 				value_type(_Keyval, mapped_type()));

  0001b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001d	83 65 f8 00	 and	 DWORD PTR $T87719[ebp+4], 0
  00021	50		 push	 eax
  00022	8d 45 fc	 lea	 eax, DWORD PTR $T87721[ebp]
  00025	89 4d f4	 mov	 DWORD PTR $T87719[ebp], ecx
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR $T87719[ebp]
  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?insert@?$_Tree@V?$_Tmap_traits@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBIPAVPatch@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> >,0> >::insert
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
$L26686:

; 147  : 		return ((*_Where).second);

  00035	83 c0 10	 add	 eax, 16			; 00000010H

; 148  : 		}

  00038	c9		 leave
  00039	c3		 ret	 0
??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ENDP ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEXABQAVmml_Address@@@Z
_TEXT	SEGMENT
$T87797 = -4						; size = 4
?push_back@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEXABQAVmml_Address@@@Z PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::push_back, COMDAT
; _this$ = eax
; __Val$ = esi

; 579  : 		{	// insert element at end

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	57		 push	 edi
  00003	8b f8		 mov	 edi, eax

; 580  : 		if (size() < capacity())

  00005	e8 00 00 00 00	 call	 ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
  0000a	8b d8		 mov	 ebx, eax
  0000c	8b c7		 mov	 eax, edi
  0000e	e8 00 00 00 00	 call	 ?capacity@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::capacity
  00013	3b d8		 cmp	 ebx, eax

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00015	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00018	73 0c		 jae	 SHORT $L26600
  0001a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001c	89 08		 mov	 DWORD PTR [eax], ecx
  0001e	83 c0 04	 add	 eax, 4
  00021	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 582  : 		else

  00024	eb 0b		 jmp	 SHORT $L26601
$L26600:

; 583  : 			insert(end(), _Val);

  00026	56		 push	 esi
  00027	50		 push	 eax
  00028	8d 5c 24 10	 lea	 ebx, DWORD PTR $T87797[esp+20]
  0002c	e8 00 00 00 00	 call	 ?insert@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE?AViterator@12@V312@ABQAVmml_Address@@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::insert
$L26601:
  00031	5f		 pop	 edi
  00032	5b		 pop	 ebx

; 584  : 		}

  00033	59		 pop	 ecx
  00034	c3		 ret	 0
?push_back@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEXABQAVmml_Address@@@Z ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::push_back
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<mml_Address *,std::allocator<mml_Address *> >::vector<mml_Address *,std::allocator<mml_Address *> >, COMDAT
; _this$ = eax

; 300  : 		_Buy(0);

  00000	33 c9		 xor	 ecx, ecx
  00002	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00005	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00008	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 301  : 		}

  0000b	c3		 ret	 0
??0?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ ENDP ; std::vector<mml_Address *,std::allocator<mml_Address *> >::vector<mml_Address *,std::allocator<mml_Address *> >
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?push_back@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXABViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXABViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z PROC NEAR ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::push_back, COMDAT
; _this$ = eax

; 481  : 		_Insert(end(), _Val);

  00000	ff 74 24 04	 push	 DWORD PTR __Val$[esp-4]
  00004	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00007	51		 push	 ecx
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?_Insert@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXViterator@12@ABV3?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Insert

; 482  : 		}

  0000e	c2 04 00	 ret	 4
?push_back@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXABViterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z ENDP ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::push_back
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ?push_back@?$list@IV?$allocator@I@std@@@std@@QAEXABI@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$list@IV?$allocator@I@std@@@std@@QAEXABI@Z PROC NEAR ; std::list<unsigned int,std::allocator<unsigned int> >::push_back, COMDAT
; _this$ = eax

; 481  : 		_Insert(end(), _Val);

  00000	ff 74 24 04	 push	 DWORD PTR __Val$[esp-4]
  00004	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00007	51		 push	 ecx
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?_Insert@?$list@IV?$allocator@I@std@@@std@@QAEXViterator@12@ABI@Z ; std::list<unsigned int,std::allocator<unsigned int> >::_Insert

; 482  : 		}

  0000e	c2 04 00	 ret	 4
?push_back@?$list@IV?$allocator@I@std@@@std@@QAEXABI@Z ENDP ; std::list<unsigned int,std::allocator<unsigned int> >::push_back
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
$T87971 = -4						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC NEAR ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = eax
; __Val$ = esi

; 579  : 		{	// insert element at end

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	57		 push	 edi
  00003	8b f8		 mov	 edi, eax

; 580  : 		if (size() < capacity())

  00005	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  0000a	8b d8		 mov	 ebx, eax
  0000c	8b c7		 mov	 eax, edi
  0000e	e8 00 00 00 00	 call	 ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
  00013	3b d8		 cmp	 ebx, eax

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00015	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00018	73 0c		 jae	 SHORT $L26499
  0001a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001c	89 08		 mov	 DWORD PTR [eax], ecx
  0001e	83 c0 04	 add	 eax, 4
  00021	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 582  : 		else

  00024	eb 0b		 jmp	 SHORT $L26500
$L26499:

; 583  : 			insert(end(), _Val);

  00026	56		 push	 esi
  00027	50		 push	 eax
  00028	8d 5c 24 10	 lea	 ebx, DWORD PTR $T87971[esp+20]
  0002c	e8 00 00 00 00	 call	 ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AViterator@12@V312@ABH@Z ; std::vector<int,std::allocator<int> >::insert
$L26500:
  00031	5f		 pop	 edi
  00032	5b		 pop	 ebx

; 584  : 		}

  00033	59		 pop	 ecx
  00034	c3		 ret	 0
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC NEAR	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = eax

; 300  : 		_Buy(0);

  00000	33 c9		 xor	 ecx, ecx
  00002	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00005	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00008	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 301  : 		}

  0000b	c3		 ret	 0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??1MusicTrack@@QAE@XZ				; MusicTrack::~MusicTrack
; Function compile flags: /Ogsy
; File f:\nes\nsdl\src\nsc\musictrack.cpp
_TEXT	SEGMENT
??1MusicTrack@@QAE@XZ PROC NEAR				; MusicTrack::~MusicTrack
; _this$ = edi

; 99   : {

  001eb	56		 push	 esi

; 100  : }

  001ec	8d b7 d8 02 00
	00		 lea	 esi, DWORD PTR [edi+728]
  001f2	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET FLAT:??_7MusicTrack@@6B@
  001f8	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Tidy
  001fd	8d b7 c8 02 00
	00		 lea	 esi, DWORD PTR [edi+712]
  00203	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Tidy
  00208	8d b7 b8 02 00
	00		 lea	 esi, DWORD PTR [edi+696]
  0020e	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Tidy
  00213	8d b7 a8 02 00
	00		 lea	 esi, DWORD PTR [edi+680]
  00219	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Tidy
  0021e	8d b7 98 02 00
	00		 lea	 esi, DWORD PTR [edi+664]
  00224	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Tidy
  00229	8d b7 88 02 00
	00		 lea	 esi, DWORD PTR [edi+648]
  0022f	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Tidy
  00234	8d b7 78 02 00
	00		 lea	 esi, DWORD PTR [edi+632]
  0023a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@IAEXXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::_Tidy
  0023f	8d 87 5c 02 00
	00		 lea	 eax, DWORD PTR [edi+604]
  00245	e8 00 00 00 00	 call	 ?_Tidy@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEXXZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Tidy
  0024a	8d 87 50 02 00
	00		 lea	 eax, DWORD PTR [edi+592]
  00250	e8 00 00 00 00	 call	 ?_Tidy@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEXXZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Tidy
  00255	8d 87 44 02 00
	00		 lea	 eax, DWORD PTR [edi+580]
  0025b	e8 00 00 00 00	 call	 ?_Tidy@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEXXZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Tidy
  00260	8d 87 38 02 00
	00		 lea	 eax, DWORD PTR [edi+568]
  00266	e8 00 00 00 00	 call	 ?_Tidy@?$list@IV?$allocator@I@std@@@std@@IAEXXZ ; std::list<unsigned int,std::allocator<unsigned int> >::_Tidy
  0026b	8d b7 20 02 00
	00		 lea	 esi, DWORD PTR [edi+544]
  00271	e8 00 00 00 00	 call	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
  00276	8b cf		 mov	 ecx, edi
  00278	5e		 pop	 esi
  00279	e9 00 00 00 00	 jmp	 ??1MusicItem@@QAE@XZ	; MusicItem::~MusicItem
??1MusicTrack@@QAE@XZ ENDP				; MusicTrack::~MusicTrack
PUBLIC	?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z	; MusicTrack::SetEvent
; Function compile flags: /Ogsy
_TEXT	SEGMENT
__item$ = 8						; size = 4
?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z PROC NEAR	; MusicTrack::SetEvent
; _this$ = eax

; 736  : 	//TCYAItZbgB
; 737  : 	offset_now += (unsigned int)_item->getSize();

  0027e	8b 4c 24 04	 mov	 ecx, DWORD PTR __item$[esp-4]
  00282	8b 49 30	 mov	 ecx, DWORD PTR [ecx+48]
  00285	01 88 9c 00 00
	00		 add	 DWORD PTR [eax+156], ecx

; 738  : 
; 739  : 	//object|C^B
; 740  : 	ptcItem.push_back(_item);

  0028b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0028e	83 c0 08	 add	 eax, 8
  00291	8d 54 24 04	 lea	 edx, DWORD PTR __item$[esp-4]
  00295	52		 push	 edx
  00296	51		 push	 ecx
  00297	50		 push	 eax
  00298	e8 00 00 00 00	 call	 ?_Insert@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@QAEXViterator@12@ABQAVMusicItem@@@Z ; std::list<MusicItem *,std::allocator<MusicItem *> >::_Insert

; 741  : 
; 742  : }

  0029d	c2 04 00	 ret	 4
?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ENDP		; MusicTrack::SetEvent
_TEXT	ENDS
PUBLIC	?Fix_Address@MusicTrack@@QAEXPAVMusicFile@@@Z	; MusicTrack::Fix_Address
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T101305 = -12						; size = 4
$T101304 = -12						; size = 4
$T101300 = -12						; size = 4
$T101299 = -12						; size = 4
$T101295 = -12						; size = 4
$T101294 = -12						; size = 4
$T101290 = -12						; size = 4
$T101289 = -12						; size = 4
$T101285 = -12						; size = 4
$T101284 = -12						; size = 4
$T101280 = -12						; size = 4
$T101279 = -12						; size = 4
_itN163$ = -8						; size = 4
_itVRC7$ = -8						; size = 4
_itFDSM$ = -8						; size = 4
_itFDSC$ = -8						; size = 4
_itEnv$ = -8						; size = 4
_itSub$ = -8						; size = 4
_itSE$ = -8						; size = 4
__com_offset$ = -4					; size = 4
$T101310 = 8						; size = 4
$T101309 = 8						; size = 4
_MUS$ = 8						; size = 4
?Fix_Address@MusicTrack@@QAEXPAVMusicFile@@@Z PROC NEAR	; MusicTrack::Fix_Address
; _this$ = ebx

; 563  : {

  002a0	55		 push	 ebp
  002a1	8b ec		 mov	 ebp, esp
  002a3	83 ec 0c	 sub	 esp, 12			; 0000000cH
  002a6	56		 push	 esi
  002a7	57		 push	 edi

; 564  : 	//----------------------
; 565  : 	//Local
; 566  : 	vector<	mml_Address*	>::iterator	itSE;
; 567  : 	vector<	mml_Address*	>::iterator	itSub;
; 568  : 	vector<	mml_Address*	>::iterator	itEnv;
; 569  : 	vector<	mml_Address*	>::iterator	itFDSC;
; 570  : 	vector<	mml_Address*	>::iterator	itFDSM;
; 571  : 	vector<	mml_Address*	>::iterator	itVRC7;
; 572  : 	vector<	mml_Address*	>::iterator	itN163;
; 573  : 	unsigned	int	_no;
; 574  : 	unsigned	int	_sub_offset;
; 575  : 	unsigned	int	_com_offset;
; 576  : 
; 577  : 	//----------------------
; 578  : 	//SE
; 579  : 	if(!ptcSE.empty()){

  002a8	8d 83 b8 02 00
	00		 lea	 eax, DWORD PTR [ebx+696]
  002ae	e8 00 00 00 00	 call	 ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
  002b3	85 c0		 test	 eax, eax
  002b5	74 67		 je	 SHORT $L24583

; 580  : 		itSE = ptcSE.begin();

  002b7	8b 83 bc 02 00
	00		 mov	 eax, DWORD PTR [ebx+700]

; 581  : 		while(itSE != ptcSE.end()){

  002bd	3b 83 c0 02 00
	00		 cmp	 eax, DWORD PTR [ebx+704]
  002c3	89 45 f8	 mov	 DWORD PTR _itSE$[ebp], eax
  002c6	74 56		 je	 SHORT $L24583
  002c8	8b 7d 08	 mov	 edi, DWORD PTR _MUS$[ebp]
  002cb	81 c7 b4 01 00
	00		 add	 edi, 436		; 000001b4H
  002d1	eb 03		 jmp	 SHORT $L24582
$L102040:
  002d3	8b 45 f8	 mov	 eax, DWORD PTR _itSE$[ebp]
$L24582:

; 582  : 			_no			= (*itSE)->get_id();		//Tu[`No.

  002d6	8b 00		 mov	 eax, DWORD PTR [eax]
  002d8	8b 70 3c	 mov	 esi, DWORD PTR [eax+60]

; 583  : 			_com_offset	= (*itSE)->getOffset();

  002db	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  002de	89 45 fc	 mov	 DWORD PTR __com_offset$[ebp], eax

; 584  : 			if( MUS->ptcSE.count(_no) == 0){

  002e1	8d 45 f4	 lea	 eax, DWORD PTR $T101279[ebp]
  002e4	50		 push	 eax
  002e5	57		 push	 edi
  002e6	89 75 f4	 mov	 DWORD PTR $T101279[ebp], esi
  002e9	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> >,0> >::count
  002ee	85 c0		 test	 eax, eax
  002f0	74 5b		 je	 SHORT $L102033

; 588  : 					_COUT << _T("SE(") << _no << _T(")B") << endl;
; 589  : 				}
; 590  : 				nsc_exit(EXIT_FAILURE);
; 591  : 			}
; 592  : 			_sub_offset = MUS->ptcSE[_no]->getOffset();	//wTu[`ItZbg

  002f2	89 75 f4	 mov	 DWORD PTR $T101280[ebp], esi
  002f5	8d 75 f4	 lea	 esi, DWORD PTR $T101280[ebp]
  002f8	e8 00 00 00 00	 call	 ??A?$map@HPAVSE@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSE@@@std@@@3@@std@@QAEAAPAVSE@@ABH@Z ; std::map<int,SE *,std::less<int>,std::allocator<std::pair<int const ,SE *> > >::operator[]
  002fd	8b 00		 mov	 eax, DWORD PTR [eax]

; 593  : 			(*itSE)->set_Address(_sub_offset - _com_offset - 1);

  002ff	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00302	2b 4d fc	 sub	 ecx, DWORD PTR __com_offset$[ebp]
  00305	8b 75 f8	 mov	 esi, DWORD PTR _itSE$[ebp]
  00308	8b 06		 mov	 eax, DWORD PTR [esi]
  0030a	49		 dec	 ecx
  0030b	e8 00 00 00 00	 call	 ?set_Address@mml_Address@@QAEXI@Z ; mml_Address::set_Address

; 594  : 			itSE++;

  00310	83 c6 04	 add	 esi, 4
  00313	3b b3 c0 02 00
	00		 cmp	 esi, DWORD PTR [ebx+704]
  00319	89 75 f8	 mov	 DWORD PTR _itSE$[ebp], esi
  0031c	75 b5		 jne	 SHORT $L102040
$L24583:

; 595  : 		}
; 596  : 	}
; 597  : 
; 598  : 	//----------------------
; 599  : 	//Surbortine
; 600  : 	if(!ptcSub.empty()){

  0031e	8d 83 c8 02 00
	00		 lea	 eax, DWORD PTR [ebx+712]
  00324	e8 00 00 00 00	 call	 ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
  00329	85 c0		 test	 eax, eax
  0032b	0f 84 8b 00 00
	00		 je	 $L24600

; 601  : 		itSub = ptcSub.begin();

  00331	8b 83 cc 02 00
	00		 mov	 eax, DWORD PTR [ebx+716]

; 602  : 		while(itSub != ptcSub.end()){

  00337	3b 83 d0 02 00
	00		 cmp	 eax, DWORD PTR [ebx+720]
  0033d	89 45 f8	 mov	 DWORD PTR _itSub$[ebp], eax
  00340	74 7a		 je	 SHORT $L24600
  00342	8b 7d 08	 mov	 edi, DWORD PTR _MUS$[ebp]
  00345	81 c7 c0 01 00
	00		 add	 edi, 448		; 000001c0H
  0034b	eb 27		 jmp	 SHORT $L24599
$L102033:

; 585  : 				if(cOptionSW->fErr == true){
; 586  : 					_CERR << _T("SE(") << _no << _T(")B") << endl;

  0034d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BG@DLEDEKK@?$AA?$CJuj0L?$FLXW?$CI0W0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
  00352	56		 push	 esi
  00353	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_17HLGHMILN@?$AAS?$AAE?$AA?$CI?$AA?$AA@
$L102056:
  00358	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cOptionSW@@3PAVOPSW@@A ; cOptionSW
  0035d	80 78 01 01	 cmp	 BYTE PTR [eax+1], 1
  00361	0f 85 0a 03 00
	00		 jne	 $L24684
  00367	68 00 00 00 00	 push	 OFFSET FLAT:?wcerr@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A ; std::wcerr

; 587  : 				} else {

  0036c	e9 05 03 00 00	 jmp	 $L102054
$L102041:

; 602  : 		while(itSub != ptcSub.end()){

  00371	8b 45 f8	 mov	 eax, DWORD PTR _itSub$[ebp]
$L24599:

; 603  : 			_no			= (*itSub)->get_id();		//Tu[`No.

  00374	8b 00		 mov	 eax, DWORD PTR [eax]
  00376	8b 70 3c	 mov	 esi, DWORD PTR [eax+60]

; 604  : 			_com_offset	= (*itSub)->getOffset();

  00379	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  0037c	89 45 fc	 mov	 DWORD PTR __com_offset$[ebp], eax

; 605  : 			if( MUS->ptcSub.count(_no) == 0){

  0037f	8d 45 f4	 lea	 eax, DWORD PTR $T101284[ebp]
  00382	50		 push	 eax
  00383	57		 push	 edi
  00384	89 75 f4	 mov	 DWORD PTR $T101284[ebp], esi
  00387	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::count
  0038c	85 c0		 test	 eax, eax
  0038e	74 57		 je	 SHORT $L102034

; 609  : 					_COUT << _T("Sub(") << _no << _T(")B") << endl;
; 610  : 				}
; 611  : 				nsc_exit(EXIT_FAILURE);
; 612  : 			}
; 613  : 			_sub_offset = MUS->ptcSub[_no]->getOffset();	//wTu[`ItZbg

  00390	89 75 f4	 mov	 DWORD PTR $T101285[ebp], esi
  00393	8d 75 f4	 lea	 esi, DWORD PTR $T101285[ebp]
  00396	e8 00 00 00 00	 call	 ??A?$map@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@@std@@QAEAAPAVSub@@ABH@Z ; std::map<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> > >::operator[]
  0039b	8b 00		 mov	 eax, DWORD PTR [eax]

; 614  : 			(*itSub)->set_Address(_sub_offset - _com_offset - 1);

  0039d	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  003a0	2b 4d fc	 sub	 ecx, DWORD PTR __com_offset$[ebp]
  003a3	8b 75 f8	 mov	 esi, DWORD PTR _itSub$[ebp]
  003a6	8b 06		 mov	 eax, DWORD PTR [esi]
  003a8	49		 dec	 ecx
  003a9	e8 00 00 00 00	 call	 ?set_Address@mml_Address@@QAEXI@Z ; mml_Address::set_Address

; 615  : 			itSub++;

  003ae	83 c6 04	 add	 esi, 4
  003b1	3b b3 d0 02 00
	00		 cmp	 esi, DWORD PTR [ebx+720]
  003b7	89 75 f8	 mov	 DWORD PTR _itSub$[ebp], esi
  003ba	75 b5		 jne	 SHORT $L102041
$L24600:

; 616  : 		}
; 617  : 	}
; 618  : 
; 619  : 	//----------------------
; 620  : 	//Envelope
; 621  : 	if(!ptcEnv.empty()){

  003bc	8d 83 d8 02 00
	00		 lea	 eax, DWORD PTR [ebx+728]
  003c2	e8 00 00 00 00	 call	 ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
  003c7	85 c0		 test	 eax, eax
  003c9	74 77		 je	 SHORT $L24616

; 622  : 		itEnv = ptcEnv.begin();

  003cb	8b 83 dc 02 00
	00		 mov	 eax, DWORD PTR [ebx+732]

; 623  : 		while(itEnv != ptcEnv.end()){

  003d1	3b 83 e0 02 00
	00		 cmp	 eax, DWORD PTR [ebx+736]
  003d7	89 45 f8	 mov	 DWORD PTR _itEnv$[ebp], eax
  003da	74 66		 je	 SHORT $L24616
  003dc	8b 7d 08	 mov	 edi, DWORD PTR _MUS$[ebp]
  003df	81 c7 9c 01 00
	00		 add	 edi, 412		; 0000019cH
  003e5	eb 13		 jmp	 SHORT $L24615
$L102034:

; 606  : 				if(cOptionSW->fErr == true){
; 607  : 					_CERR << _T("Sub(") << _no << _T(")B") << endl;

  003e7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BG@DLEDEKK@?$AA?$CJuj0L?$FLXW?$CI0W0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
  003ec	56		 push	 esi
  003ed	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_19IKFMBMLG@?$AAS?$AAu?$AAb?$AA?$CI?$AA?$AA@

; 608  : 				} else {

  003f2	e9 61 ff ff ff	 jmp	 $L102056
$L102042:

; 623  : 		while(itEnv != ptcEnv.end()){

  003f7	8b 45 f8	 mov	 eax, DWORD PTR _itEnv$[ebp]
$L24615:

; 624  : 			_no			= (*itEnv)->get_id();		//Gx[vNo.

  003fa	8b 00		 mov	 eax, DWORD PTR [eax]
  003fc	8b 70 3c	 mov	 esi, DWORD PTR [eax+60]

; 625  : 			_com_offset	= (*itEnv)->getOffset();

  003ff	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00402	89 45 fc	 mov	 DWORD PTR __com_offset$[ebp], eax

; 626  : 			if( MUS->ptcEnv.count(_no) == 0){

  00405	8d 45 f4	 lea	 eax, DWORD PTR $T101289[ebp]
  00408	50		 push	 eax
  00409	57		 push	 edi
  0040a	89 75 f4	 mov	 DWORD PTR $T101289[ebp], esi
  0040d	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::count
  00412	85 c0		 test	 eax, eax
  00414	74 57		 je	 SHORT $L102035

; 630  : 					_COUT << _T("Envelope(") << _no << _T(")B") << endl;
; 631  : 				}
; 632  : 				nsc_exit(EXIT_FAILURE);
; 633  : 			}
; 634  : 			_sub_offset = MUS->ptcEnv[_no]->getOffset();	//wGx[vItZbg

  00416	89 75 f4	 mov	 DWORD PTR $T101290[ebp], esi
  00419	8d 75 f4	 lea	 esi, DWORD PTR $T101290[ebp]
  0041c	e8 00 00 00 00	 call	 ??A?$map@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@@std@@QAEAAPAVEnvelop@@ABH@Z ; std::map<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> > >::operator[]
  00421	8b 00		 mov	 eax, DWORD PTR [eax]

; 635  : 			(*itEnv)->set_Address(_sub_offset - _com_offset - 1);

  00423	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00426	2b 4d fc	 sub	 ecx, DWORD PTR __com_offset$[ebp]
  00429	8b 75 f8	 mov	 esi, DWORD PTR _itEnv$[ebp]
  0042c	8b 06		 mov	 eax, DWORD PTR [esi]
  0042e	49		 dec	 ecx
  0042f	e8 00 00 00 00	 call	 ?set_Address@mml_Address@@QAEXI@Z ; mml_Address::set_Address

; 636  : 			itEnv++;

  00434	83 c6 04	 add	 esi, 4
  00437	3b b3 e0 02 00
	00		 cmp	 esi, DWORD PTR [ebx+736]
  0043d	89 75 f8	 mov	 DWORD PTR _itEnv$[ebp], esi
  00440	75 b5		 jne	 SHORT $L102042
$L24616:

; 637  : 		}
; 638  : 	}
; 639  : 
; 640  : 	//----------------------
; 641  : 	//FDSC
; 642  : 	if(!ptcFDSC.empty()){

  00442	8d 83 78 02 00
	00		 lea	 eax, DWORD PTR [ebx+632]
  00448	e8 00 00 00 00	 call	 ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
  0044d	85 c0		 test	 eax, eax
  0044f	74 77		 je	 SHORT $L24632

; 643  : 		itFDSC = ptcFDSC.begin();

  00451	8b 83 7c 02 00
	00		 mov	 eax, DWORD PTR [ebx+636]

; 644  : 		while(itFDSC != ptcFDSC.end()){

  00457	3b 83 80 02 00
	00		 cmp	 eax, DWORD PTR [ebx+640]
  0045d	89 45 f8	 mov	 DWORD PTR _itFDSC$[ebp], eax
  00460	74 66		 je	 SHORT $L24632
  00462	8b 7d 08	 mov	 edi, DWORD PTR _MUS$[ebp]
  00465	81 c7 6c 01 00
	00		 add	 edi, 364		; 0000016cH
  0046b	eb 13		 jmp	 SHORT $L24631
$L102035:

; 627  : 				if(cOptionSW->fErr == true){
; 628  : 					_CERR << _T("Envelope(") << _no << _T(")B") << endl;

  0046d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BG@DLEDEKK@?$AA?$CJuj0L?$FLXW?$CI0W0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
  00472	56		 push	 esi
  00473	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@IGMADMH@?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$CI?$AA?$AA@

; 629  : 				} else {

  00478	e9 db fe ff ff	 jmp	 $L102056
$L102043:

; 644  : 		while(itFDSC != ptcFDSC.end()){

  0047d	8b 45 f8	 mov	 eax, DWORD PTR _itFDSC$[ebp]
$L24631:

; 645  : 			_no			= (*itFDSC)->get_id();		//Gx[vNo.

  00480	8b 00		 mov	 eax, DWORD PTR [eax]
  00482	8b 70 3c	 mov	 esi, DWORD PTR [eax+60]

; 646  : 			_com_offset	= (*itFDSC)->getOffset();

  00485	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00488	89 45 fc	 mov	 DWORD PTR __com_offset$[ebp], eax

; 647  : 			if( MUS->ptcFDSC.count(_no) == 0){

  0048b	8d 45 f4	 lea	 eax, DWORD PTR $T101294[ebp]
  0048e	50		 push	 eax
  0048f	57		 push	 edi
  00490	89 75 f4	 mov	 DWORD PTR $T101294[ebp], esi
  00493	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::count
  00498	85 c0		 test	 eax, eax
  0049a	74 57		 je	 SHORT $L102036

; 651  : 					_COUT << _T("FDSC(") << _no << _T(")B") << endl;
; 652  : 				}
; 653  : 				nsc_exit(EXIT_FAILURE);
; 654  : 			}
; 655  : 			_sub_offset = MUS->ptcFDSC[_no]->getOffset();	//wGx[vItZbg

  0049c	89 75 f4	 mov	 DWORD PTR $T101295[ebp], esi
  0049f	8d 75 f4	 lea	 esi, DWORD PTR $T101295[ebp]
  004a2	e8 00 00 00 00	 call	 ??A?$map@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@@std@@QAEAAPAVFDSC@@ABH@Z ; std::map<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> > >::operator[]
  004a7	8b 00		 mov	 eax, DWORD PTR [eax]

; 656  : 			(*itFDSC)->set_Address(_sub_offset - _com_offset - 1);

  004a9	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  004ac	2b 4d fc	 sub	 ecx, DWORD PTR __com_offset$[ebp]
  004af	8b 75 f8	 mov	 esi, DWORD PTR _itFDSC$[ebp]
  004b2	8b 06		 mov	 eax, DWORD PTR [esi]
  004b4	49		 dec	 ecx
  004b5	e8 00 00 00 00	 call	 ?set_Address@mml_Address@@QAEXI@Z ; mml_Address::set_Address

; 657  : 			itFDSC++;

  004ba	83 c6 04	 add	 esi, 4
  004bd	3b b3 80 02 00
	00		 cmp	 esi, DWORD PTR [ebx+640]
  004c3	89 75 f8	 mov	 DWORD PTR _itFDSC$[ebp], esi
  004c6	75 b5		 jne	 SHORT $L102043
$L24632:

; 658  : 		}
; 659  : 	}
; 660  : 
; 661  : 	//----------------------
; 662  : 	//FDSM
; 663  : 	if(!ptcFDSM.empty()){

  004c8	8d 83 88 02 00
	00		 lea	 eax, DWORD PTR [ebx+648]
  004ce	e8 00 00 00 00	 call	 ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
  004d3	85 c0		 test	 eax, eax
  004d5	74 77		 je	 SHORT $L24648

; 664  : 		itFDSM = ptcFDSM.begin();

  004d7	8b 83 8c 02 00
	00		 mov	 eax, DWORD PTR [ebx+652]

; 665  : 		while(itFDSM != ptcFDSM.end()){

  004dd	3b 83 90 02 00
	00		 cmp	 eax, DWORD PTR [ebx+656]
  004e3	89 45 f8	 mov	 DWORD PTR _itFDSM$[ebp], eax
  004e6	74 66		 je	 SHORT $L24648
  004e8	8b 7d 08	 mov	 edi, DWORD PTR _MUS$[ebp]
  004eb	81 c7 78 01 00
	00		 add	 edi, 376		; 00000178H
  004f1	eb 13		 jmp	 SHORT $L24647
$L102036:

; 648  : 				if(cOptionSW->fErr == true){
; 649  : 					_CERR << _T("FDSC(") << _no << _T(")B") << endl;

  004f3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BG@DLEDEKK@?$AA?$CJuj0L?$FLXW?$CI0W0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
  004f8	56		 push	 esi
  004f9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1M@PLMGIHGM@?$AAF?$AAD?$AAS?$AAC?$AA?$CI?$AA?$AA@

; 650  : 				} else {

  004fe	e9 55 fe ff ff	 jmp	 $L102056
$L102044:

; 665  : 		while(itFDSM != ptcFDSM.end()){

  00503	8b 45 f8	 mov	 eax, DWORD PTR _itFDSM$[ebp]
$L24647:

; 666  : 			_no			= (*itFDSM)->get_id();		//Gx[vNo.

  00506	8b 00		 mov	 eax, DWORD PTR [eax]
  00508	8b 70 3c	 mov	 esi, DWORD PTR [eax+60]

; 667  : 			_com_offset	= (*itFDSM)->getOffset();

  0050b	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  0050e	89 45 fc	 mov	 DWORD PTR __com_offset$[ebp], eax

; 668  : 			if( MUS->ptcFDSM.count(_no) == 0){

  00511	8d 45 f4	 lea	 eax, DWORD PTR $T101299[ebp]
  00514	50		 push	 eax
  00515	57		 push	 edi
  00516	89 75 f4	 mov	 DWORD PTR $T101299[ebp], esi
  00519	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::count
  0051e	85 c0		 test	 eax, eax
  00520	74 57		 je	 SHORT $L102037

; 672  : 					_COUT << _T("FDSM(") << _no << _T(")B") << endl;
; 673  : 				}
; 674  : 				nsc_exit(EXIT_FAILURE);
; 675  : 			}
; 676  : 			_sub_offset = MUS->ptcFDSM[_no]->getOffset();	//wGx[vItZbg

  00522	89 75 f4	 mov	 DWORD PTR $T101300[ebp], esi
  00525	8d 75 f4	 lea	 esi, DWORD PTR $T101300[ebp]
  00528	e8 00 00 00 00	 call	 ??A?$map@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@@std@@QAEAAPAVFDSM@@ABH@Z ; std::map<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> > >::operator[]
  0052d	8b 00		 mov	 eax, DWORD PTR [eax]

; 677  : 			(*itFDSM)->set_Address(_sub_offset - _com_offset - 1);

  0052f	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00532	2b 4d fc	 sub	 ecx, DWORD PTR __com_offset$[ebp]
  00535	8b 75 f8	 mov	 esi, DWORD PTR _itFDSM$[ebp]
  00538	8b 06		 mov	 eax, DWORD PTR [esi]
  0053a	49		 dec	 ecx
  0053b	e8 00 00 00 00	 call	 ?set_Address@mml_Address@@QAEXI@Z ; mml_Address::set_Address

; 678  : 			itFDSM++;

  00540	83 c6 04	 add	 esi, 4
  00543	3b b3 90 02 00
	00		 cmp	 esi, DWORD PTR [ebx+656]
  00549	89 75 f8	 mov	 DWORD PTR _itFDSM$[ebp], esi
  0054c	75 b5		 jne	 SHORT $L102044
$L24648:

; 679  : 		}
; 680  : 	}
; 681  : 
; 682  : 	//----------------------
; 683  : 	//OPLL
; 684  : 	if(!ptcOPLL.empty()){

  0054e	8d 83 98 02 00
	00		 lea	 eax, DWORD PTR [ebx+664]
  00554	e8 00 00 00 00	 call	 ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
  00559	85 c0		 test	 eax, eax
  0055b	74 77		 je	 SHORT $L24664

; 685  : 		itVRC7 = ptcOPLL.begin();

  0055d	8b 83 9c 02 00
	00		 mov	 eax, DWORD PTR [ebx+668]

; 686  : 		while(itVRC7 != ptcOPLL.end()){

  00563	3b 83 a0 02 00
	00		 cmp	 eax, DWORD PTR [ebx+672]
  00569	89 45 f8	 mov	 DWORD PTR _itVRC7$[ebp], eax
  0056c	74 66		 je	 SHORT $L24664
  0056e	8b 7d 08	 mov	 edi, DWORD PTR _MUS$[ebp]
  00571	81 c7 84 01 00
	00		 add	 edi, 388		; 00000184H
  00577	eb 13		 jmp	 SHORT $L24663
$L102037:

; 669  : 				if(cOptionSW->fErr == true){
; 670  : 					_CERR << _T("FDSM(") << _no << _T(")B") << endl;

  00579	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BG@DLEDEKK@?$AA?$CJuj0L?$FLXW?$CI0W0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
  0057e	56		 push	 esi
  0057f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1M@MBMMOGBM@?$AAF?$AAD?$AAS?$AAM?$AA?$CI?$AA?$AA@

; 671  : 				} else {

  00584	e9 cf fd ff ff	 jmp	 $L102056
$L102045:

; 686  : 		while(itVRC7 != ptcOPLL.end()){

  00589	8b 45 f8	 mov	 eax, DWORD PTR _itVRC7$[ebp]
$L24663:

; 687  : 			_no			= (*itVRC7)->get_id();		//Gx[vNo.

  0058c	8b 00		 mov	 eax, DWORD PTR [eax]
  0058e	8b 70 3c	 mov	 esi, DWORD PTR [eax+60]

; 688  : 			_com_offset	= (*itVRC7)->getOffset();

  00591	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00594	89 45 fc	 mov	 DWORD PTR __com_offset$[ebp], eax

; 689  : 			if( MUS->ptcVRC7.count(_no) == 0){

  00597	8d 45 f4	 lea	 eax, DWORD PTR $T101304[ebp]
  0059a	50		 push	 eax
  0059b	57		 push	 edi
  0059c	89 75 f4	 mov	 DWORD PTR $T101304[ebp], esi
  0059f	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::count
  005a4	85 c0		 test	 eax, eax
  005a6	74 57		 je	 SHORT $L102038

; 693  : 					_COUT << _T("VRC7(") << _no << _T(")B") << endl;
; 694  : 				}
; 695  : 				nsc_exit(EXIT_FAILURE);
; 696  : 			}
; 697  : 			_sub_offset = MUS->ptcVRC7[_no]->getOffset();	//wGx[vItZbg

  005a8	89 75 f4	 mov	 DWORD PTR $T101305[ebp], esi
  005ab	8d 75 f4	 lea	 esi, DWORD PTR $T101305[ebp]
  005ae	e8 00 00 00 00	 call	 ??A?$map@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@@std@@QAEAAPAVVRC7@@ABH@Z ; std::map<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> > >::operator[]
  005b3	8b 00		 mov	 eax, DWORD PTR [eax]

; 698  : 			(*itVRC7)->set_Address(_sub_offset - _com_offset - 1);

  005b5	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  005b8	2b 4d fc	 sub	 ecx, DWORD PTR __com_offset$[ebp]
  005bb	8b 75 f8	 mov	 esi, DWORD PTR _itVRC7$[ebp]
  005be	8b 06		 mov	 eax, DWORD PTR [esi]
  005c0	49		 dec	 ecx
  005c1	e8 00 00 00 00	 call	 ?set_Address@mml_Address@@QAEXI@Z ; mml_Address::set_Address

; 699  : 			itVRC7++;

  005c6	83 c6 04	 add	 esi, 4
  005c9	3b b3 a0 02 00
	00		 cmp	 esi, DWORD PTR [ebx+672]
  005cf	89 75 f8	 mov	 DWORD PTR _itVRC7$[ebp], esi
  005d2	75 b5		 jne	 SHORT $L102045
$L24664:

; 700  : 		}
; 701  : 	}
; 702  : 
; 703  : 	//----------------------
; 704  : 	//N163
; 705  : 	if(!ptcWave.empty()){

  005d4	8d 83 a8 02 00
	00		 lea	 eax, DWORD PTR [ebx+680]
  005da	e8 00 00 00 00	 call	 ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
  005df	85 c0		 test	 eax, eax
  005e1	74 78		 je	 SHORT $L24680

; 706  : 		itN163 = ptcWave.begin();

  005e3	8b 83 ac 02 00
	00		 mov	 eax, DWORD PTR [ebx+684]

; 707  : 		while(itN163 != ptcWave.end()){

  005e9	3b 83 b0 02 00
	00		 cmp	 eax, DWORD PTR [ebx+688]
  005ef	89 45 f8	 mov	 DWORD PTR _itN163$[ebp], eax
  005f2	74 67		 je	 SHORT $L24680
  005f4	8b 7d 08	 mov	 edi, DWORD PTR _MUS$[ebp]
  005f7	81 c7 90 01 00
	00		 add	 edi, 400		; 00000190H
  005fd	eb 13		 jmp	 SHORT $L24679
$L102038:

; 690  : 				if(cOptionSW->fErr == true){
; 691  : 					_CERR << _T("VRC7(") << _no << _T(")B") << endl;

  005ff	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BG@DLEDEKK@?$AA?$CJuj0L?$FLXW?$CI0W0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
  00604	56		 push	 esi
  00605	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1M@DBGGOFMD@?$AAV?$AAR?$AAC?$AA7?$AA?$CI?$AA?$AA@

; 692  : 				} else {

  0060a	e9 49 fd ff ff	 jmp	 $L102056
$L102046:

; 707  : 		while(itN163 != ptcWave.end()){

  0060f	8b 45 f8	 mov	 eax, DWORD PTR _itN163$[ebp]
$L24679:

; 708  : 			_no			= (*itN163)->get_id();		//Gx[vNo.

  00612	8b 00		 mov	 eax, DWORD PTR [eax]
  00614	8b 70 3c	 mov	 esi, DWORD PTR [eax+60]

; 709  : 			_com_offset	= (*itN163)->getOffset();

  00617	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  0061a	89 45 fc	 mov	 DWORD PTR __com_offset$[ebp], eax

; 710  : 			if( MUS->ptcN163.count(_no) == 0){

  0061d	8d 45 08	 lea	 eax, DWORD PTR $T101309[ebp]
  00620	50		 push	 eax
  00621	57		 push	 edi
  00622	89 75 08	 mov	 DWORD PTR $T101309[ebp], esi
  00625	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::count
  0062a	85 c0		 test	 eax, eax
  0062c	74 33		 je	 SHORT $L102039

; 717  : 			}
; 718  : 			_sub_offset = MUS->ptcN163[_no]->getOffset();	//wGx[vItZbg

  0062e	89 75 08	 mov	 DWORD PTR $T101310[ebp], esi
  00631	8d 75 08	 lea	 esi, DWORD PTR $T101310[ebp]
  00634	e8 00 00 00 00	 call	 ??A?$map@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@@std@@QAEAAPAVN163@@ABH@Z ; std::map<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> > >::operator[]
  00639	8b 00		 mov	 eax, DWORD PTR [eax]

; 719  : 			(*itN163)->set_Address(_sub_offset - _com_offset - 2);

  0063b	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0063e	2b 4d fc	 sub	 ecx, DWORD PTR __com_offset$[ebp]
  00641	8b 75 f8	 mov	 esi, DWORD PTR _itN163$[ebp]
  00644	8b 06		 mov	 eax, DWORD PTR [esi]
  00646	49		 dec	 ecx
  00647	49		 dec	 ecx
  00648	e8 00 00 00 00	 call	 ?set_Address@mml_Address@@QAEXI@Z ; mml_Address::set_Address

; 720  : 			itN163++;

  0064d	83 c6 04	 add	 esi, 4
  00650	3b b3 b0 02 00
	00		 cmp	 esi, DWORD PTR [ebx+688]
  00656	89 75 f8	 mov	 DWORD PTR _itN163$[ebp], esi
  00659	75 b4		 jne	 SHORT $L102046
$L24680:
  0065b	5f		 pop	 edi
  0065c	5e		 pop	 esi

; 721  : 		}
; 722  : 	}
; 723  : 
; 724  : }

  0065d	c9		 leave
  0065e	c2 04 00	 ret	 4
$L102039:

; 711  : 				if(cOptionSW->fErr == true){
; 712  : 					_CERR << _T("N163(") << _no << _T(")B") << endl;

  00661	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BG@DLEDEKK@?$AA?$CJuj0L?$FLXW?$CI0W0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
  00666	56		 push	 esi
  00667	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1M@HOIDBMFA@?$AAN?$AA1?$AA6?$AA3?$AA?$CI?$AA?$AA@

; 713  : 				} else {

  0066c	e9 e7 fc ff ff	 jmp	 $L102056
$L24684:

; 714  : 					_COUT << _T("N163(") << _no << _T(")B") << endl;

  00671	68 00 00 00 00	 push	 OFFSET FLAT:?wcout@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A ; std::wcout
$L102054:
  00676	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  0067b	59		 pop	 ecx
  0067c	59		 pop	 ecx
  0067d	50		 push	 eax
  0067e	e8 00 00 00 00	 call	 ??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::operator<<
  00683	50		 push	 eax
  00684	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  00689	50		 push	 eax
  0068a	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl

; 715  : 				}
; 716  : 				nsc_exit(EXIT_FAILURE);

  0068f	33 c0		 xor	 eax, eax
  00691	83 c4 0c	 add	 esp, 12			; 0000000cH
  00694	40		 inc	 eax
  00695	e8 00 00 00 00	 call	 ?nsc_exit@@YAXH@Z	; nsc_exit
$L102057:
$L102047:
  0069a	cc		 int	 3
?Fix_Address@MusicTrack@@QAEXPAVMusicFile@@@Z ENDP	; MusicTrack::Fix_Address
_TEXT	ENDS
PUBLIC	?OptimizeDefineCheck@MusicTrack@@QAEXPAVMusicFile@@@Z ; MusicTrack::OptimizeDefineCheck
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_itN163$ = -8						; size = 4
_itVRC7$ = -8						; size = 4
_itFDSM$ = -8						; size = 4
_itFDSC$ = -8						; size = 4
_itEnv$ = -8						; size = 4
_itSub$ = -8						; size = 4
$T102082 = -4						; size = 4
$T102081 = -4						; size = 4
$T102077 = -4						; size = 4
$T102076 = -4						; size = 4
$T102072 = -4						; size = 4
$T102071 = -4						; size = 4
$T102067 = -4						; size = 4
$T102066 = -4						; size = 4
$T102062 = -4						; size = 4
$T102061 = -4						; size = 4
_f_ERR$ = 8						; size = 1
_this$ = 8						; size = 4
$T102087 = 12						; size = 4
$T102086 = 12						; size = 4
_MUS$ = 12						; size = 4
?OptimizeDefineCheck@MusicTrack@@QAEXPAVMusicFile@@@Z PROC NEAR ; MusicTrack::OptimizeDefineCheck

; 420  : {

  0069b	51		 push	 ecx
  0069c	51		 push	 ecx
  0069d	53		 push	 ebx
  0069e	55		 push	 ebp
  0069f	8b 6c 24 14	 mov	 ebp, DWORD PTR _this$[esp+12]
  006a3	56		 push	 esi
  006a4	57		 push	 edi

; 421  : 	//----------------------
; 422  : 	//Local
; 423  : 	vector<	mml_Address*	>::iterator	itSub;
; 424  : 	vector<	mml_Address*	>::iterator	itEnv;
; 425  : 	vector<	mml_Address*	>::iterator	itFDSC;
; 426  : 	vector<	mml_Address*	>::iterator	itFDSM;
; 427  : 	vector<	mml_Address*	>::iterator	itVRC7;
; 428  : 	vector<	mml_Address*	>::iterator	itN163;
; 429  : 	unsigned	int		_no;
; 430  : 
; 431  : 				bool	f_ERR = false;
; 432  : 
; 433  : 	//----------------------
; 434  : 	//Surbortine
; 435  : 
; 436  : 	if(!ptcSub.empty()){

  006a5	8d 85 c8 02 00
	00		 lea	 eax, DWORD PTR [ebp+712]
  006ab	c6 44 24 1c 00	 mov	 BYTE PTR _f_ERR$[esp+20], 0
  006b0	e8 00 00 00 00	 call	 ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
  006b5	85 c0		 test	 eax, eax
  006b7	bb 00 00 00 00	 mov	 ebx, OFFSET FLAT:??_C@_1BG@DLEDEKK@?$AA?$CJuj0L?$FLXW?$CI0W0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
  006bc	0f 84 a1 00 00
	00		 je	 $L24265

; 437  : 		itSub = ptcSub.begin();

  006c2	8b 85 cc 02 00
	00		 mov	 eax, DWORD PTR [ebp+716]

; 438  : 		while(itSub != ptcSub.end()){

  006c8	3b 85 d0 02 00
	00		 cmp	 eax, DWORD PTR [ebp+720]
  006ce	89 44 24 10	 mov	 DWORD PTR _itSub$[esp+24], eax
  006d2	0f 84 8b 00 00
	00		 je	 $L24265
  006d8	8b 7c 24 20	 mov	 edi, DWORD PTR _MUS$[esp+20]
  006dc	81 c7 c0 01 00
	00		 add	 edi, 448		; 000001c0H
  006e2	eb 04		 jmp	 SHORT $L24264
$L102593:
  006e4	8b 44 24 10	 mov	 eax, DWORD PTR _itSub$[esp+24]
$L24264:

; 439  : 			_no			= (*itSub)->get_id();		//Tu[`No.

  006e8	8b 00		 mov	 eax, DWORD PTR [eax]
  006ea	8b 70 3c	 mov	 esi, DWORD PTR [eax+60]

; 440  : 			if( MUS->ptcSub.count(_no) == 0){

  006ed	8d 44 24 14	 lea	 eax, DWORD PTR $T102061[esp+24]
  006f1	50		 push	 eax
  006f2	57		 push	 edi
  006f3	89 74 24 1c	 mov	 DWORD PTR $T102061[esp+32], esi
  006f7	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> >,0> >::count
  006fc	85 c0		 test	 eax, eax
  006fe	75 3f		 jne	 SHORT $L24268

; 441  : 				if(cOptionSW->fErr == true){

  00700	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cOptionSW@@3PAVOPSW@@A ; cOptionSW
  00705	80 78 01 01	 cmp	 BYTE PTR [eax+1], 1

; 442  : 					_CERR << _T("Sub(") << _no << _T(")B") << endl;

  00709	53		 push	 ebx
  0070a	56		 push	 esi
  0070b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_19IKFMBMLG@?$AAS?$AAu?$AAb?$AA?$CI?$AA?$AA@
  00710	75 07		 jne	 SHORT $L24269
  00712	68 00 00 00 00	 push	 OFFSET FLAT:?wcerr@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A ; std::wcerr

; 443  : 				} else {

  00717	eb 05		 jmp	 SHORT $L102600
$L24269:

; 444  : 					_COUT << _T("Sub(") << _no << _T(")B") << endl;

  00719	68 00 00 00 00	 push	 OFFSET FLAT:?wcout@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A ; std::wcout
$L102600:
  0071e	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  00723	59		 pop	 ecx
  00724	59		 pop	 ecx
  00725	50		 push	 eax
  00726	e8 00 00 00 00	 call	 ??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::operator<<
  0072b	50		 push	 eax
  0072c	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  00731	50		 push	 eax
  00732	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl
  00737	83 c4 0c	 add	 esp, 12			; 0000000cH

; 445  : 				}
; 446  : 				f_ERR = true;

  0073a	c6 44 24 1c 01	 mov	 BYTE PTR _f_ERR$[esp+20], 1
$L24268:

; 447  : 			}
; 448  : 			MUS->ptcSub[_no]->setUse();	//gtO

  0073f	89 74 24 14	 mov	 DWORD PTR $T102062[esp+24], esi
  00743	8d 74 24 14	 lea	 esi, DWORD PTR $T102062[esp+24]
  00747	e8 00 00 00 00	 call	 ??A?$map@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@@std@@QAEAAPAVSub@@ABH@Z ; std::map<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> > >::operator[]
  0074c	8b 00		 mov	 eax, DWORD PTR [eax]

; 449  : 			itSub++;

  0074e	83 44 24 10 04	 add	 DWORD PTR _itSub$[esp+24], 4
  00753	c6 40 38 01	 mov	 BYTE PTR [eax+56], 1
  00757	8b 44 24 10	 mov	 eax, DWORD PTR _itSub$[esp+24]
  0075b	3b 85 d0 02 00
	00		 cmp	 eax, DWORD PTR [ebp+720]
  00761	75 81		 jne	 SHORT $L102593
$L24265:

; 450  : 		}
; 451  : 	}
; 452  : 
; 453  : 	//----------------------
; 454  : 	//Envelope
; 455  : 	if(!ptcEnv.empty()){

  00763	8d 85 d8 02 00
	00		 lea	 eax, DWORD PTR [ebp+728]
  00769	e8 00 00 00 00	 call	 ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
  0076e	85 c0		 test	 eax, eax
  00770	0f 84 a1 00 00
	00		 je	 $L24476

; 456  : 		itEnv = ptcEnv.begin();

  00776	8b 85 dc 02 00
	00		 mov	 eax, DWORD PTR [ebp+732]

; 457  : 		while(itEnv != ptcEnv.end()){

  0077c	3b 85 e0 02 00
	00		 cmp	 eax, DWORD PTR [ebp+736]
  00782	89 44 24 10	 mov	 DWORD PTR _itEnv$[esp+24], eax
  00786	0f 84 8b 00 00
	00		 je	 $L24476
  0078c	8b 7c 24 20	 mov	 edi, DWORD PTR _MUS$[esp+20]
  00790	81 c7 9c 01 00
	00		 add	 edi, 412		; 0000019cH
  00796	eb 04		 jmp	 SHORT $L24475
$L102594:
  00798	8b 44 24 10	 mov	 eax, DWORD PTR _itEnv$[esp+24]
$L24475:

; 458  : 			_no			= (*itEnv)->get_id();		//Gx[vNo.

  0079c	8b 00		 mov	 eax, DWORD PTR [eax]
  0079e	8b 70 3c	 mov	 esi, DWORD PTR [eax+60]

; 459  : 			if( MUS->ptcEnv.count(_no) == 0){

  007a1	8d 44 24 14	 lea	 eax, DWORD PTR $T102066[esp+24]
  007a5	50		 push	 eax
  007a6	57		 push	 edi
  007a7	89 74 24 1c	 mov	 DWORD PTR $T102066[esp+32], esi
  007ab	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> >,0> >::count
  007b0	85 c0		 test	 eax, eax
  007b2	75 3f		 jne	 SHORT $L24479

; 460  : 				if(cOptionSW->fErr == true){

  007b4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cOptionSW@@3PAVOPSW@@A ; cOptionSW
  007b9	80 78 01 01	 cmp	 BYTE PTR [eax+1], 1

; 461  : 					_CERR << _T("Envelope(") << _no << _T(")B") << endl;

  007bd	53		 push	 ebx
  007be	56		 push	 esi
  007bf	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@IGMADMH@?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$CI?$AA?$AA@
  007c4	75 07		 jne	 SHORT $L24480
  007c6	68 00 00 00 00	 push	 OFFSET FLAT:?wcerr@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A ; std::wcerr

; 462  : 				} else {

  007cb	eb 05		 jmp	 SHORT $L102601
$L24480:

; 463  : 					_COUT << _T("Envelope(") << _no << _T(")B") << endl;

  007cd	68 00 00 00 00	 push	 OFFSET FLAT:?wcout@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A ; std::wcout
$L102601:
  007d2	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  007d7	59		 pop	 ecx
  007d8	59		 pop	 ecx
  007d9	50		 push	 eax
  007da	e8 00 00 00 00	 call	 ??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::operator<<
  007df	50		 push	 eax
  007e0	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  007e5	50		 push	 eax
  007e6	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl
  007eb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 464  : 				}
; 465  : 				f_ERR = true;

  007ee	c6 44 24 1c 01	 mov	 BYTE PTR _f_ERR$[esp+20], 1
$L24479:

; 466  : 			}
; 467  : 			MUS->ptcEnv[_no]->setUse();	//gtO

  007f3	89 74 24 14	 mov	 DWORD PTR $T102067[esp+24], esi
  007f7	8d 74 24 14	 lea	 esi, DWORD PTR $T102067[esp+24]
  007fb	e8 00 00 00 00	 call	 ??A?$map@HPAVEnvelop@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVEnvelop@@@std@@@3@@std@@QAEAAPAVEnvelop@@ABH@Z ; std::map<int,Envelop *,std::less<int>,std::allocator<std::pair<int const ,Envelop *> > >::operator[]
  00800	8b 00		 mov	 eax, DWORD PTR [eax]

; 468  : 			itEnv++;

  00802	83 44 24 10 04	 add	 DWORD PTR _itEnv$[esp+24], 4
  00807	c6 40 38 01	 mov	 BYTE PTR [eax+56], 1
  0080b	8b 44 24 10	 mov	 eax, DWORD PTR _itEnv$[esp+24]
  0080f	3b 85 e0 02 00
	00		 cmp	 eax, DWORD PTR [ebp+736]
  00815	75 81		 jne	 SHORT $L102594
$L24476:

; 469  : 		}
; 470  : 	}
; 471  : 
; 472  : 	//----------------------
; 473  : 	//FDSC
; 474  : 	if(!ptcFDSC.empty()){

  00817	8d 85 78 02 00
	00		 lea	 eax, DWORD PTR [ebp+632]
  0081d	e8 00 00 00 00	 call	 ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
  00822	85 c0		 test	 eax, eax
  00824	0f 84 a1 00 00
	00		 je	 $L24493

; 475  : 		itFDSC = ptcFDSC.begin();

  0082a	8b 85 7c 02 00
	00		 mov	 eax, DWORD PTR [ebp+636]

; 476  : 		while(itFDSC != ptcFDSC.end()){

  00830	3b 85 80 02 00
	00		 cmp	 eax, DWORD PTR [ebp+640]
  00836	89 44 24 10	 mov	 DWORD PTR _itFDSC$[esp+24], eax
  0083a	0f 84 8b 00 00
	00		 je	 $L24493
  00840	8b 7c 24 20	 mov	 edi, DWORD PTR _MUS$[esp+20]
  00844	81 c7 6c 01 00
	00		 add	 edi, 364		; 0000016cH
  0084a	eb 04		 jmp	 SHORT $L24492
$L102595:
  0084c	8b 44 24 10	 mov	 eax, DWORD PTR _itFDSC$[esp+24]
$L24492:

; 477  : 			_no			= (*itFDSC)->get_id();		//Gx[vNo.

  00850	8b 00		 mov	 eax, DWORD PTR [eax]
  00852	8b 70 3c	 mov	 esi, DWORD PTR [eax+60]

; 478  : 			if( MUS->ptcFDSC.count(_no) == 0){

  00855	8d 44 24 14	 lea	 eax, DWORD PTR $T102071[esp+24]
  00859	50		 push	 eax
  0085a	57		 push	 edi
  0085b	89 74 24 1c	 mov	 DWORD PTR $T102071[esp+32], esi
  0085f	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> >,0> >::count
  00864	85 c0		 test	 eax, eax
  00866	75 3f		 jne	 SHORT $L24496

; 479  : 				if(cOptionSW->fErr == true){

  00868	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cOptionSW@@3PAVOPSW@@A ; cOptionSW
  0086d	80 78 01 01	 cmp	 BYTE PTR [eax+1], 1

; 480  : 					_CERR << _T("FDSC(") << _no << _T(")B") << endl;

  00871	53		 push	 ebx
  00872	56		 push	 esi
  00873	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1M@PLMGIHGM@?$AAF?$AAD?$AAS?$AAC?$AA?$CI?$AA?$AA@
  00878	75 07		 jne	 SHORT $L24497
  0087a	68 00 00 00 00	 push	 OFFSET FLAT:?wcerr@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A ; std::wcerr

; 481  : 				} else {

  0087f	eb 05		 jmp	 SHORT $L102602
$L24497:

; 482  : 					_COUT << _T("FDSC(") << _no << _T(")B") << endl;

  00881	68 00 00 00 00	 push	 OFFSET FLAT:?wcout@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A ; std::wcout
$L102602:
  00886	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  0088b	59		 pop	 ecx
  0088c	59		 pop	 ecx
  0088d	50		 push	 eax
  0088e	e8 00 00 00 00	 call	 ??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::operator<<
  00893	50		 push	 eax
  00894	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  00899	50		 push	 eax
  0089a	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl
  0089f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 483  : 				}
; 484  : 				f_ERR = true;

  008a2	c6 44 24 1c 01	 mov	 BYTE PTR _f_ERR$[esp+20], 1
$L24496:

; 485  : 			}
; 486  : 			MUS->ptcFDSC[_no]->setUse();	//gtO

  008a7	89 74 24 14	 mov	 DWORD PTR $T102072[esp+24], esi
  008ab	8d 74 24 14	 lea	 esi, DWORD PTR $T102072[esp+24]
  008af	e8 00 00 00 00	 call	 ??A?$map@HPAVFDSC@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSC@@@std@@@3@@std@@QAEAAPAVFDSC@@ABH@Z ; std::map<int,FDSC *,std::less<int>,std::allocator<std::pair<int const ,FDSC *> > >::operator[]
  008b4	8b 00		 mov	 eax, DWORD PTR [eax]

; 487  : 			itFDSC++;

  008b6	83 44 24 10 04	 add	 DWORD PTR _itFDSC$[esp+24], 4
  008bb	c6 40 38 01	 mov	 BYTE PTR [eax+56], 1
  008bf	8b 44 24 10	 mov	 eax, DWORD PTR _itFDSC$[esp+24]
  008c3	3b 85 80 02 00
	00		 cmp	 eax, DWORD PTR [ebp+640]
  008c9	75 81		 jne	 SHORT $L102595
$L24493:

; 488  : 		}
; 489  : 	}
; 490  : 
; 491  : 	//----------------------
; 492  : 	//FDSM
; 493  : 	if(!ptcFDSM.empty()){

  008cb	8d 85 88 02 00
	00		 lea	 eax, DWORD PTR [ebp+648]
  008d1	e8 00 00 00 00	 call	 ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
  008d6	85 c0		 test	 eax, eax
  008d8	0f 84 a1 00 00
	00		 je	 $L24510

; 494  : 		itFDSM = ptcFDSM.begin();

  008de	8b 85 8c 02 00
	00		 mov	 eax, DWORD PTR [ebp+652]

; 495  : 		while(itFDSM != ptcFDSM.end()){

  008e4	3b 85 90 02 00
	00		 cmp	 eax, DWORD PTR [ebp+656]
  008ea	89 44 24 10	 mov	 DWORD PTR _itFDSM$[esp+24], eax
  008ee	0f 84 8b 00 00
	00		 je	 $L24510
  008f4	8b 7c 24 20	 mov	 edi, DWORD PTR _MUS$[esp+20]
  008f8	81 c7 78 01 00
	00		 add	 edi, 376		; 00000178H
  008fe	eb 04		 jmp	 SHORT $L24509
$L102596:
  00900	8b 44 24 10	 mov	 eax, DWORD PTR _itFDSM$[esp+24]
$L24509:

; 496  : 			_no			= (*itFDSM)->get_id();		//Gx[vNo.

  00904	8b 00		 mov	 eax, DWORD PTR [eax]
  00906	8b 70 3c	 mov	 esi, DWORD PTR [eax+60]

; 497  : 			if( MUS->ptcFDSM.count(_no) == 0){

  00909	8d 44 24 14	 lea	 eax, DWORD PTR $T102076[esp+24]
  0090d	50		 push	 eax
  0090e	57		 push	 edi
  0090f	89 74 24 1c	 mov	 DWORD PTR $T102076[esp+32], esi
  00913	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> >,0> >::count
  00918	85 c0		 test	 eax, eax
  0091a	75 3f		 jne	 SHORT $L24513

; 498  : 				if(cOptionSW->fErr == true){

  0091c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cOptionSW@@3PAVOPSW@@A ; cOptionSW
  00921	80 78 01 01	 cmp	 BYTE PTR [eax+1], 1

; 499  : 					_CERR << _T("FDSM(") << _no << _T(")B") << endl;

  00925	53		 push	 ebx
  00926	56		 push	 esi
  00927	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1M@MBMMOGBM@?$AAF?$AAD?$AAS?$AAM?$AA?$CI?$AA?$AA@
  0092c	75 07		 jne	 SHORT $L24514
  0092e	68 00 00 00 00	 push	 OFFSET FLAT:?wcerr@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A ; std::wcerr

; 500  : 				} else {

  00933	eb 05		 jmp	 SHORT $L102603
$L24514:

; 501  : 					_COUT << _T("FDSM(") << _no << _T(")B") << endl;

  00935	68 00 00 00 00	 push	 OFFSET FLAT:?wcout@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A ; std::wcout
$L102603:
  0093a	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  0093f	59		 pop	 ecx
  00940	59		 pop	 ecx
  00941	50		 push	 eax
  00942	e8 00 00 00 00	 call	 ??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::operator<<
  00947	50		 push	 eax
  00948	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  0094d	50		 push	 eax
  0094e	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl
  00953	83 c4 0c	 add	 esp, 12			; 0000000cH

; 502  : 				}
; 503  : 				f_ERR = true;

  00956	c6 44 24 1c 01	 mov	 BYTE PTR _f_ERR$[esp+20], 1
$L24513:

; 504  : 			}
; 505  : 			MUS->ptcFDSM[_no]->setUse();	//gtO

  0095b	89 74 24 14	 mov	 DWORD PTR $T102077[esp+24], esi
  0095f	8d 74 24 14	 lea	 esi, DWORD PTR $T102077[esp+24]
  00963	e8 00 00 00 00	 call	 ??A?$map@HPAVFDSM@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVFDSM@@@std@@@3@@std@@QAEAAPAVFDSM@@ABH@Z ; std::map<int,FDSM *,std::less<int>,std::allocator<std::pair<int const ,FDSM *> > >::operator[]
  00968	8b 00		 mov	 eax, DWORD PTR [eax]

; 506  : 			itFDSM++;

  0096a	83 44 24 10 04	 add	 DWORD PTR _itFDSM$[esp+24], 4
  0096f	c6 40 38 01	 mov	 BYTE PTR [eax+56], 1
  00973	8b 44 24 10	 mov	 eax, DWORD PTR _itFDSM$[esp+24]
  00977	3b 85 90 02 00
	00		 cmp	 eax, DWORD PTR [ebp+656]
  0097d	75 81		 jne	 SHORT $L102596
$L24510:

; 507  : 		}
; 508  : 	}
; 509  : 
; 510  : 	//----------------------
; 511  : 	//OPLL
; 512  : 	if(!ptcOPLL.empty()){

  0097f	8d 85 98 02 00
	00		 lea	 eax, DWORD PTR [ebp+664]
  00985	e8 00 00 00 00	 call	 ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
  0098a	85 c0		 test	 eax, eax
  0098c	0f 84 a1 00 00
	00		 je	 $L24527

; 513  : 		itVRC7 = ptcOPLL.begin();

  00992	8b 85 9c 02 00
	00		 mov	 eax, DWORD PTR [ebp+668]

; 514  : 		while(itVRC7 != ptcOPLL.end()){

  00998	3b 85 a0 02 00
	00		 cmp	 eax, DWORD PTR [ebp+672]
  0099e	89 44 24 10	 mov	 DWORD PTR _itVRC7$[esp+24], eax
  009a2	0f 84 8b 00 00
	00		 je	 $L24527
  009a8	8b 7c 24 20	 mov	 edi, DWORD PTR _MUS$[esp+20]
  009ac	81 c7 84 01 00
	00		 add	 edi, 388		; 00000184H
  009b2	eb 04		 jmp	 SHORT $L24526
$L102597:
  009b4	8b 44 24 10	 mov	 eax, DWORD PTR _itVRC7$[esp+24]
$L24526:

; 515  : 			_no			= (*itVRC7)->get_id();		//Gx[vNo.

  009b8	8b 00		 mov	 eax, DWORD PTR [eax]
  009ba	8b 70 3c	 mov	 esi, DWORD PTR [eax+60]

; 516  : 			if( MUS->ptcVRC7.count(_no) == 0){

  009bd	8d 44 24 14	 lea	 eax, DWORD PTR $T102081[esp+24]
  009c1	50		 push	 eax
  009c2	57		 push	 edi
  009c3	89 74 24 1c	 mov	 DWORD PTR $T102081[esp+32], esi
  009c7	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> >,0> >::count
  009cc	85 c0		 test	 eax, eax
  009ce	75 3f		 jne	 SHORT $L24530

; 517  : 				if(cOptionSW->fErr == true){

  009d0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cOptionSW@@3PAVOPSW@@A ; cOptionSW
  009d5	80 78 01 01	 cmp	 BYTE PTR [eax+1], 1

; 518  : 					_CERR << _T("VRC7(") << _no << _T(")B") << endl;

  009d9	53		 push	 ebx
  009da	56		 push	 esi
  009db	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1M@DBGGOFMD@?$AAV?$AAR?$AAC?$AA7?$AA?$CI?$AA?$AA@
  009e0	75 07		 jne	 SHORT $L24531
  009e2	68 00 00 00 00	 push	 OFFSET FLAT:?wcerr@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A ; std::wcerr

; 519  : 				} else {

  009e7	eb 05		 jmp	 SHORT $L102604
$L24531:

; 520  : 					_COUT << _T("VRC7(") << _no << _T(")B") << endl;

  009e9	68 00 00 00 00	 push	 OFFSET FLAT:?wcout@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A ; std::wcout
$L102604:
  009ee	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  009f3	59		 pop	 ecx
  009f4	59		 pop	 ecx
  009f5	50		 push	 eax
  009f6	e8 00 00 00 00	 call	 ??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::operator<<
  009fb	50		 push	 eax
  009fc	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  00a01	50		 push	 eax
  00a02	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl
  00a07	83 c4 0c	 add	 esp, 12			; 0000000cH

; 521  : 				}
; 522  : 				f_ERR = true;

  00a0a	c6 44 24 1c 01	 mov	 BYTE PTR _f_ERR$[esp+20], 1
$L24530:

; 523  : 			}
; 524  : 			MUS->ptcVRC7[_no]->setUse();	//gtO

  00a0f	89 74 24 14	 mov	 DWORD PTR $T102082[esp+24], esi
  00a13	8d 74 24 14	 lea	 esi, DWORD PTR $T102082[esp+24]
  00a17	e8 00 00 00 00	 call	 ??A?$map@HPAVVRC7@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVVRC7@@@std@@@3@@std@@QAEAAPAVVRC7@@ABH@Z ; std::map<int,VRC7 *,std::less<int>,std::allocator<std::pair<int const ,VRC7 *> > >::operator[]
  00a1c	8b 00		 mov	 eax, DWORD PTR [eax]

; 525  : 			itVRC7++;

  00a1e	83 44 24 10 04	 add	 DWORD PTR _itVRC7$[esp+24], 4
  00a23	c6 40 38 01	 mov	 BYTE PTR [eax+56], 1
  00a27	8b 44 24 10	 mov	 eax, DWORD PTR _itVRC7$[esp+24]
  00a2b	3b 85 a0 02 00
	00		 cmp	 eax, DWORD PTR [ebp+672]
  00a31	75 81		 jne	 SHORT $L102597
$L24527:

; 526  : 		}
; 527  : 	}
; 528  : 
; 529  : 	//----------------------
; 530  : 	//N163
; 531  : 	if(!ptcWave.empty()){

  00a33	8d 85 a8 02 00
	00		 lea	 eax, DWORD PTR [ebp+680]
  00a39	e8 00 00 00 00	 call	 ?size@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QBEIXZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::size
  00a3e	85 c0		 test	 eax, eax
  00a40	0f 84 a1 00 00
	00		 je	 $L24544

; 532  : 		itN163 = ptcWave.begin();

  00a46	8b 85 ac 02 00
	00		 mov	 eax, DWORD PTR [ebp+684]

; 533  : 		while(itN163 != ptcWave.end()){

  00a4c	3b 85 b0 02 00
	00		 cmp	 eax, DWORD PTR [ebp+688]
  00a52	89 44 24 10	 mov	 DWORD PTR _itN163$[esp+24], eax
  00a56	0f 84 8b 00 00
	00		 je	 $L24544
  00a5c	8b 7c 24 20	 mov	 edi, DWORD PTR _MUS$[esp+20]
  00a60	81 c7 90 01 00
	00		 add	 edi, 400		; 00000190H
  00a66	eb 04		 jmp	 SHORT $L24543
$L102598:
  00a68	8b 44 24 10	 mov	 eax, DWORD PTR _itN163$[esp+24]
$L24543:

; 534  : 			_no			= (*itN163)->get_id();		//Gx[vNo.

  00a6c	8b 00		 mov	 eax, DWORD PTR [eax]
  00a6e	8b 70 3c	 mov	 esi, DWORD PTR [eax+60]

; 535  : 			if( MUS->ptcN163.count(_no) == 0){

  00a71	8d 44 24 20	 lea	 eax, DWORD PTR $T102086[esp+20]
  00a75	50		 push	 eax
  00a76	57		 push	 edi
  00a77	89 74 24 28	 mov	 DWORD PTR $T102086[esp+28], esi
  00a7b	e8 00 00 00 00	 call	 ?count@?$_Tree@V?$_Tmap_traits@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tmap_traits<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> >,0> >::count
  00a80	85 c0		 test	 eax, eax
  00a82	75 3f		 jne	 SHORT $L24547

; 536  : 				if(cOptionSW->fErr == true){

  00a84	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cOptionSW@@3PAVOPSW@@A ; cOptionSW
  00a89	80 78 01 01	 cmp	 BYTE PTR [eax+1], 1

; 537  : 					_CERR << _T("N163(") << _no << _T(")B") << endl;

  00a8d	53		 push	 ebx
  00a8e	56		 push	 esi
  00a8f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1M@HOIDBMFA@?$AAN?$AA1?$AA6?$AA3?$AA?$CI?$AA?$AA@
  00a94	75 07		 jne	 SHORT $L24548
  00a96	68 00 00 00 00	 push	 OFFSET FLAT:?wcerr@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A ; std::wcerr

; 538  : 				} else {

  00a9b	eb 05		 jmp	 SHORT $L102605
$L24548:

; 539  : 					_COUT << _T("N163(") << _no << _T(")B") << endl;

  00a9d	68 00 00 00 00	 push	 OFFSET FLAT:?wcout@std@@3V?$basic_ostream@GU?$char_traits@G@std@@@1@A ; std::wcout
$L102605:
  00aa2	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  00aa7	59		 pop	 ecx
  00aa8	59		 pop	 ecx
  00aa9	50		 push	 eax
  00aaa	e8 00 00 00 00	 call	 ??6?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<unsigned short,std::char_traits<unsigned short> >::operator<<
  00aaf	50		 push	 eax
  00ab0	e8 00 00 00 00	 call	 ??$?6GU?$char_traits@G@std@@@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@0@AAV10@PBG@Z ; std::operator<<<unsigned short,std::char_traits<unsigned short> >
  00ab5	50		 push	 eax
  00ab6	e8 00 00 00 00	 call	 ?endl@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@AAV21@@Z ; std::endl
  00abb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 540  : 				}
; 541  : 				f_ERR = true;

  00abe	c6 44 24 1c 01	 mov	 BYTE PTR _f_ERR$[esp+20], 1
$L24547:

; 542  : 			}
; 543  : 			MUS->ptcN163[_no]->setUse();	//gtO

  00ac3	89 74 24 20	 mov	 DWORD PTR $T102087[esp+20], esi
  00ac7	8d 74 24 20	 lea	 esi, DWORD PTR $T102087[esp+20]
  00acb	e8 00 00 00 00	 call	 ??A?$map@HPAVN163@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVN163@@@std@@@3@@std@@QAEAAPAVN163@@ABH@Z ; std::map<int,N163 *,std::less<int>,std::allocator<std::pair<int const ,N163 *> > >::operator[]
  00ad0	8b 00		 mov	 eax, DWORD PTR [eax]

; 544  : 			itN163++;

  00ad2	83 44 24 10 04	 add	 DWORD PTR _itN163$[esp+24], 4
  00ad7	c6 40 38 01	 mov	 BYTE PTR [eax+56], 1
  00adb	8b 44 24 10	 mov	 eax, DWORD PTR _itN163$[esp+24]
  00adf	3b 85 b0 02 00
	00		 cmp	 eax, DWORD PTR [ebp+688]
  00ae5	75 81		 jne	 SHORT $L102598
$L24544:

; 545  : 		}
; 546  : 	}
; 547  : 	
; 548  : 	if(f_ERR == true){

  00ae7	80 7c 24 1c 01	 cmp	 BYTE PTR _f_ERR$[esp+20], 1
  00aec	5f		 pop	 edi
  00aed	5e		 pop	 esi
  00aee	5d		 pop	 ebp
  00aef	5b		 pop	 ebx
  00af0	75 08		 jne	 SHORT $L24557

; 549  : 		nsc_exit(EXIT_FAILURE);

  00af2	33 c0		 xor	 eax, eax
  00af4	40		 inc	 eax
  00af5	e8 00 00 00 00	 call	 ?nsc_exit@@YAXH@Z	; nsc_exit
$L102606:
$L24557:

; 550  : 	}
; 551  : 
; 552  : }

  00afa	59		 pop	 ecx
  00afb	59		 pop	 ecx
  00afc	c2 08 00	 ret	 8
$L102599:
?OptimizeDefineCheck@MusicTrack@@QAEXPAVMusicFile@@@Z ENDP ; MusicTrack::OptimizeDefineCheck
; Function compile flags: /Ogsy
$T102610 = -36						; size = 4
_itRepeatB_start$ = -32					; size = 4
_itRepeatB_end$ = -28					; size = 4
_itRepeatA_start$ = -24					; size = 4
_itRepeatA_end$ = -20					; size = 4
_iRepeatB_count$ = -16					; size = 4
_iRepeatA_count$ = -12					; size = 4
_itItem$ = -8						; size = 4
_f_RepeatB$ = -2					; size = 1
_f_RepeatA$ = -1					; size = 1
_MUS$ = 8						; size = 4
?TickCount@MusicTrack@@QAEIPAVMusicFile@@@Z PROC NEAR	; MusicTrack::TickCount
; _this$ = ecx

; 131  : {

  00aff	55		 push	 ebp
  00b00	8b ec		 mov	 ebp, esp
  00b02	83 ec 24	 sub	 esp, 36			; 00000024H

; 132  : 	//----------------------
; 133  : 	//Local
; 134  : 	list<	MusicItem*>::iterator	itItem;
; 135  : 	unsigned	char				iCode;
; 136  : 
; 137  : 	list<	MusicItem*>::iterator	itRepeatA_start;

  00b05	33 c0		 xor	 eax, eax
  00b07	53		 push	 ebx
  00b08	8b d9		 mov	 ebx, ecx

; 138  : 	list<	MusicItem*>::iterator	itRepeatA_end;
; 139  : 				int					iRepeatA_count	= 0;
; 140  : 				bool				f_RepeatA	=	false;	//s[gQ~H
; 141  : 
; 142  : 	list<	MusicItem*>::iterator	itRepeatB_start;
; 143  : 	list<	MusicItem*>::iterator	itRepeatB_end;
; 144  : 				int					iRepeatB_count	= 0;
; 145  : 				bool				f_RepeatB	=	false;	//s[gQ~H
; 146  : 
; 147  : 	/*
; 148  : 		
; 149  : 					to do
; 150  : 		
; 151  : 
; 152  : 			@s[g[vK@
; 153  : 
; 154  : 			Ks[goCiTCY
; 155  : 			As[gEAhXCII
; 156  : 
; 157  : 			sR}ht					
; 158  : 				:	R}h	c	:	`	]
; 159  : 				]	R}h	c	[	`	]
; 160  : 				:|	R}h	c	|:	`	:|		
; 161  : 				L	R}h	c	L	`	I[
; 162  : 
; 163  : 			st
; 164  : 				s[gR}hA[vR}hAhXA
; 165  : 				llk@@AhXB
; 166  : 
; 167  : 				vFJn_A_AI_AtXg
; 168  : 
; 169  : 		
; 170  : 	*/
; 171  : 
; 172  : 	unsigned	int					_no;
; 173  : 	//			int					i;
; 174  : 				mml_Address*		adrObj;
; 175  : 
; 176  : 	offset_now	=	0;		//oCi[ItZbg
; 177  : 	iTickTotal	=	0;		//
; 178  : 	iTickLoop	=	0;
; 179  : 
; 180  : 
; 181  : 	//----------------------
; 182  : 	//vt
; 183  : 
; 184  : 	//V[PXf[^H
; 185  : 	if(!ptcItem.empty()){

  00b0a	39 43 10	 cmp	 DWORD PTR [ebx+16], eax
  00b0d	89 45 e8	 mov	 DWORD PTR _itRepeatA_start$[ebp], eax
  00b10	89 45 ec	 mov	 DWORD PTR _itRepeatA_end$[ebp], eax
  00b13	89 45 f4	 mov	 DWORD PTR _iRepeatA_count$[ebp], eax
  00b16	88 45 ff	 mov	 BYTE PTR _f_RepeatA$[ebp], al
  00b19	89 45 e0	 mov	 DWORD PTR _itRepeatB_start$[ebp], eax
  00b1c	89 45 e4	 mov	 DWORD PTR _itRepeatB_end$[ebp], eax
  00b1f	89 45 f0	 mov	 DWORD PTR _iRepeatB_count$[ebp], eax
  00b22	88 45 fe	 mov	 BYTE PTR _f_RepeatB$[ebp], al
  00b25	89 83 9c 00 00
	00		 mov	 DWORD PTR [ebx+156], eax
  00b2b	89 83 94 00 00
	00		 mov	 DWORD PTR [ebx+148], eax
  00b31	89 83 98 00 00
	00		 mov	 DWORD PTR [ebx+152], eax
  00b37	0f 84 15 02 00
	00		 je	 $L24048

; 186  : 		//Avt
; 187  : 		itItem = ptcItem.begin();

  00b3d	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00b40	8b 10		 mov	 edx, DWORD PTR [eax]

; 188  : 		while(itItem != ptcItem.end()){

  00b42	3b d0		 cmp	 edx, eax
  00b44	89 55 f8	 mov	 DWORD PTR _itItem$[ebp], edx
  00b47	0f 84 05 02 00
	00		 je	 $L24048
  00b4d	56		 push	 esi
  00b4e	57		 push	 edi
  00b4f	eb 03		 jmp	 SHORT $L24047
$L102863:
  00b51	8b 55 f8	 mov	 edx, DWORD PTR _itItem$[ebp]
$L24047:

; 189  : 			if(offset_loop == offset_now){

  00b54	8b bb 9c 00 00
	00		 mov	 edi, DWORD PTR [ebx+156]
  00b5a	39 bb 00 02 00
	00		 cmp	 DWORD PTR [ebx+512], edi
  00b60	75 0c		 jne	 SHORT $L24050

; 190  : 				iTickLoop = iTickTotal;

  00b62	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [ebx+148]
  00b68	89 83 98 00 00
	00		 mov	 DWORD PTR [ebx+152], eax
$L24050:

; 191  : 			}
; 192  : 			iCode		=	(*itItem)->getCode((unsigned int)0);

  00b6e	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00b71	33 c9		 xor	 ecx, ecx
  00b73	8b c6		 mov	 eax, esi
  00b75	e8 00 00 00 00	 call	 ?getCode@MusicItem@@QAEEI@Z ; MusicItem::getCode

; 193  : 			if((f_RepeatA == false) && (f_RepeatB == false)){

  00b7a	38 4d ff	 cmp	 BYTE PTR _f_RepeatA$[ebp], cl
  00b7d	75 10		 jne	 SHORT $L24052
  00b7f	38 4d fe	 cmp	 BYTE PTR _f_RepeatB$[ebp], cl
  00b82	75 0b		 jne	 SHORT $L24052

; 194  : 				offset_now	+=	(*itItem)->getSize();

  00b84	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00b87	03 cf		 add	 ecx, edi
  00b89	89 8b 9c 00 00
	00		 mov	 DWORD PTR [ebx+156], ecx
$L24052:

; 195  : 			}
; 196  : 			if(iCode < 0x80){

  00b8f	3c 80		 cmp	 al, 128			; 00000080H
  00b91	0f 83 8e 01 00
	00		 jae	 $L24053

; 197  : 				//command
; 198  : 				adrObj = (mml_Address*)(*itItem);
; 199  : 				switch(iCode){

  00b97	0f b6 c0	 movzx	 eax, al
  00b9a	83 c0 fe	 add	 eax, -2			; fffffffeH
  00b9d	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  00ba0	0f 87 76 01 00
	00		 ja	 $L24120
  00ba6	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $L102862[eax]
  00bad	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L102867[eax*4]
$L24059:

; 200  : 					case(nsd_Call):
; 201  : 						{
; 202  : 							mml_Address*	ptAdd	= (mml_Address*)(*itItem);
; 203  : 							Sub*			cSub	= MUS->ptcSub[ptAdd->get_id()];

  00bb4	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00bb7	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  00bba	8b 7d 08	 mov	 edi, DWORD PTR _MUS$[ebp]
  00bbd	81 c7 c0 01 00
	00		 add	 edi, 448		; 000001c0H
  00bc3	8d 75 dc	 lea	 esi, DWORD PTR $T102610[ebp]
  00bc6	89 45 dc	 mov	 DWORD PTR $T102610[ebp], eax
  00bc9	e8 00 00 00 00	 call	 ??A?$map@HPAVSub@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAVSub@@@std@@@3@@std@@QAEAAPAVSub@@ABH@Z ; std::map<int,Sub *,std::less<int>,std::allocator<std::pair<int const ,Sub *> > >::operator[]
  00bce	8b 00		 mov	 eax, DWORD PTR [eax]

; 204  : 							iTickTotal		+= cSub->TickCount(MUS, &nsd);

  00bd0	8d 4b 3c	 lea	 ecx, DWORD PTR [ebx+60]
  00bd3	51		 push	 ecx
  00bd4	ff 75 08	 push	 DWORD PTR _MUS$[ebp]
  00bd7	e8 00 00 00 00	 call	 ?TickCount@Sub@@QAEIPAVMusicFile@@PAVNSD_WORK@@@Z ; Sub::TickCount

; 205  : 						}
; 206  : 						break;

  00bdc	8b 55 f8	 mov	 edx, DWORD PTR _itItem$[ebp]
  00bdf	e9 58 01 00 00	 jmp	 $L102864
$L24064:

; 207  : 
; 208  : 					//----------
; 209  : 					//Repeat A
; 210  : 					case(nsd_Repeat_A_Start):
; 211  : 						itRepeatA_start	= itItem;	//o_
; 212  : 						iRepeatA_count	= (*itItem)->getCode(1);

  00be4	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00be7	33 c9		 xor	 ecx, ecx
  00be9	41		 inc	 ecx
  00bea	89 55 e8	 mov	 DWORD PTR _itRepeatA_start$[ebp], edx
  00bed	e8 00 00 00 00	 call	 ?getCode@MusicItem@@QAEEI@Z ; MusicItem::getCode
  00bf2	0f b6 c0	 movzx	 eax, al
  00bf5	89 45 f4	 mov	 DWORD PTR _iRepeatA_count$[ebp], eax

; 213  : 						break;

  00bf8	e9 45 01 00 00	 jmp	 $L24124
$L24065:

; 214  : 
; 215  : 					case(nsd_Repeat_A_Branch):
; 216  : 						if(iRepeatA_count == 1){

  00bfd	83 7d f4 01	 cmp	 DWORD PTR _iRepeatA_count$[ebp], 1
  00c01	0f 85 3b 01 00
	00		 jne	 $L24124

; 217  : 							itItem = itRepeatA_end;	//I_s

  00c07	8b 45 ec	 mov	 eax, DWORD PTR _itRepeatA_end$[ebp]

; 218  : 							f_RepeatA = false;

  00c0a	c6 45 ff 00	 mov	 BYTE PTR _f_RepeatA$[ebp], 0
$L102866:
  00c0e	89 45 f8	 mov	 DWORD PTR _itItem$[ebp], eax

; 219  : 						}
; 220  : 						break;

  00c11	8b d0		 mov	 edx, eax
  00c13	e9 2a 01 00 00	 jmp	 $L24124
$L24067:

; 221  : 
; 222  : 					case(nsd_Repeat_A_End):
; 223  : 						itRepeatA_end = itItem;		//I_L
; 224  : 						iRepeatA_count--;

  00c18	ff 4d f4	 dec	 DWORD PTR _iRepeatA_count$[ebp]
  00c1b	89 55 ec	 mov	 DWORD PTR _itRepeatA_end$[ebp], edx

; 225  : 						if(iRepeatA_count != 0){

  00c1e	74 09		 je	 SHORT $L24068

; 226  : 							itItem = itRepeatA_start;

  00c20	8b 45 e8	 mov	 eax, DWORD PTR _itRepeatA_start$[ebp]

; 227  : 							f_RepeatA = true;

  00c23	c6 45 ff 01	 mov	 BYTE PTR _f_RepeatA$[ebp], 1

; 228  : 						} else {

  00c27	eb e5		 jmp	 SHORT $L102866
$L24068:

; 229  : 							f_RepeatA = false;

  00c29	c6 45 ff 00	 mov	 BYTE PTR _f_RepeatA$[ebp], 0

; 230  : 						}
; 231  : 						break;

  00c2d	e9 10 01 00 00	 jmp	 $L24124
$L24070:

; 232  : 
; 233  : 					//----------
; 234  : 					//Repeat B
; 235  : 					case(nsd_Repeat_B_Start):
; 236  : 						itRepeatB_start = itItem;	//o_
; 237  : 						iRepeatB_count	= 0;

  00c32	83 65 f0 00	 and	 DWORD PTR _iRepeatB_count$[ebp], 0
  00c36	89 55 e0	 mov	 DWORD PTR _itRepeatB_start$[ebp], edx

; 238  : 						break;

  00c39	e9 04 01 00 00	 jmp	 $L24124
$L24071:

; 239  : 
; 240  : 					case(nsd_Repeat_B_Branch):
; 241  : 						if(iRepeatB_count != 0){

  00c3e	83 7d f0 00	 cmp	 DWORD PTR _iRepeatB_count$[ebp], 0
  00c42	74 08		 je	 SHORT $L24072

; 242  : 							itItem = itRepeatB_end;	//

  00c44	8b 45 e4	 mov	 eax, DWORD PTR _itRepeatB_end$[ebp]
  00c47	89 45 f8	 mov	 DWORD PTR _itItem$[ebp], eax
  00c4a	8b d0		 mov	 edx, eax
$L24072:

; 243  : 						}
; 244  : 						f_RepeatB = false;

  00c4c	c6 45 fe 00	 mov	 BYTE PTR _f_RepeatB$[ebp], 0

; 245  : 						break;

  00c50	e9 ed 00 00 00	 jmp	 $L24124
$L24073:

; 246  : 
; 247  : 					case(nsd_Repeat_B_End):
; 248  : 						itRepeatB_end = itItem;		//L
; 249  : 						itItem = itRepeatB_start;

  00c55	8b 45 e0	 mov	 eax, DWORD PTR _itRepeatB_start$[ebp]

; 250  : 						iRepeatB_count++;

  00c58	ff 45 f0	 inc	 DWORD PTR _iRepeatB_count$[ebp]
  00c5b	89 55 e4	 mov	 DWORD PTR _itRepeatB_end$[ebp], edx

; 251  : 						f_RepeatB = true;

  00c5e	c6 45 fe 01	 mov	 BYTE PTR _f_RepeatB$[ebp], 1

; 252  : 						break;

  00c62	eb aa		 jmp	 SHORT $L102866
$L24103:

; 253  : 
; 254  : 					//----------
; 255  : 					//Event
; 256  : 					case(nsd_GateTime_q):
; 257  : 			//			nsd.gate_q = (*itItem)->getCode(1);
; 258  : 						break;
; 259  : 					case(nsd_GateTime_u):
; 260  : 			//			nsd.gate_u = (*itItem)->getCode(1);
; 261  : 						break;
; 262  : 
; 263  : 					case(nsd_GateMode_0):
; 264  : 						break;
; 265  : 					case(nsd_GateMode_1):
; 266  : 						break;
; 267  : 					case(nsd_GateMode_2):
; 268  : 						break;
; 269  : 
; 270  : 					case(nsd_Detune_Cent):
; 271  : 						break;
; 272  : 					case(nsd_Derune_Register):
; 273  : 						break;
; 274  : 					case(nsd_Sweep):
; 275  : 						break;
; 276  : 
; 277  : 					case(nsd_Volume_Down):
; 278  : 						break;
; 279  : 					case(nsd_Volume_Up):
; 280  : 						break;
; 281  : 
; 282  : 					case(nsd_Octave_Down):
; 283  : 						break;
; 284  : 					case(nsd_Octave_Up):
; 285  : 						break;
; 286  : 					case(nsd_Octave_Down_1):
; 287  : 						break;
; 288  : 					case(nsd_Octave_Up_1):
; 289  : 						break;
; 290  : 
; 291  : 					case(nsd_Transpose):
; 292  : 						break;
; 293  : 					case(nsd_Relative_Transpose):
; 294  : 						break;
; 295  : 					case(nsd_Transpose_1):
; 296  : 						break;
; 297  : 
; 298  : 					case(nsd_SubCommand):
; 299  : 						break;
; 300  : 
; 301  : 					case(nsc_N163_Channel):
; 302  : 						break;
; 303  : 					case(nsd_FDS_Frequency):
; 304  : 						break;
; 305  : 					case(nsd_FDS_Volume):
; 306  : 						break;
; 307  : 					case(nsc_FME7_frequency):
; 308  : 						break;
; 309  : 
; 310  : 					//----------
; 311  : 					//Define
; 312  : 					case(nsd_Voice):
; 313  : 						break;
; 314  : 
; 315  : 					case(nsd_Envelop_Voice):
; 316  : 					case(nsd_Envelop_Volume):
; 317  : 					case(nsd_Envelop_Frequency):
; 318  : 					case(nsd_Envelop_Note):
; 319  : 						_no = adrObj->get_id();
; 320  : 						break;
; 321  : 
; 322  : 					case(nsd_FDS_Career):
; 323  : 						break;
; 324  : 					case(nsd_FDS_Modlator):
; 325  : 						break;
; 326  : 
; 327  : 					case(nsc_VRC7):
; 328  : 						break;
; 329  : 					case(nsc_VRC7_reg):
; 330  : 						break;
; 331  : 					case(nsc_N163):
; 332  : 						break;
; 333  : 
; 334  : 					//----------
; 335  : 					//Length
; 336  : 					case(nsd_Length):
; 337  : 						nsd.length = (*itItem)->getCode(1);

  00c64	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00c67	33 c9		 xor	 ecx, ecx
  00c69	41		 inc	 ecx
  00c6a	e8 00 00 00 00	 call	 ?getCode@MusicItem@@QAEEI@Z ; MusicItem::getCode
  00c6f	0f b6 c0	 movzx	 eax, al
  00c72	89 43 40	 mov	 DWORD PTR [ebx+64], eax

; 338  : 						break;

  00c75	e9 c8 00 00 00	 jmp	 $L24124
$L24104:

; 339  : 					case(nsd_Length_96):
; 340  : 						nsd.length = 96;

  00c7a	c7 43 40 60 00
	00 00		 mov	 DWORD PTR [ebx+64], 96	; 00000060H

; 341  : 						break;

  00c81	e9 bc 00 00 00	 jmp	 $L24124
$L24105:

; 342  : 					case(nsd_Length_72):
; 343  : 						nsd.length = 72;

  00c86	c7 43 40 48 00
	00 00		 mov	 DWORD PTR [ebx+64], 72	; 00000048H

; 344  : 						break;

  00c8d	e9 b0 00 00 00	 jmp	 $L24124
$L24106:

; 345  : 					case(nsd_Length_48):
; 346  : 						nsd.length = 48;

  00c92	c7 43 40 30 00
	00 00		 mov	 DWORD PTR [ebx+64], 48	; 00000030H

; 347  : 						break;

  00c99	e9 a4 00 00 00	 jmp	 $L24124
$L24107:

; 348  : 					case(nsd_Length_36):
; 349  : 						nsd.length = 36;

  00c9e	c7 43 40 24 00
	00 00		 mov	 DWORD PTR [ebx+64], 36	; 00000024H

; 350  : 						break;

  00ca5	e9 98 00 00 00	 jmp	 $L24124
$L24108:

; 351  : 					case(nsd_Length_32):
; 352  : 						nsd.length = 32;

  00caa	c7 43 40 20 00
	00 00		 mov	 DWORD PTR [ebx+64], 32	; 00000020H

; 353  : 						break;

  00cb1	e9 8c 00 00 00	 jmp	 $L24124
$L24109:

; 354  : 					case(nsd_Length_24):
; 355  : 						nsd.length = 24;

  00cb6	c7 43 40 18 00
	00 00		 mov	 DWORD PTR [ebx+64], 24	; 00000018H

; 356  : 						break;

  00cbd	e9 80 00 00 00	 jmp	 $L24124
$L24110:

; 357  : 					case(nsd_Length_18):
; 358  : 						nsd.length = 18;

  00cc2	c7 43 40 12 00
	00 00		 mov	 DWORD PTR [ebx+64], 18	; 00000012H

; 359  : 						break;

  00cc9	eb 77		 jmp	 SHORT $L24124
$L24111:

; 360  : 					case(nsd_Length_16):
; 361  : 						nsd.length = 16;

  00ccb	c7 43 40 10 00
	00 00		 mov	 DWORD PTR [ebx+64], 16	; 00000010H

; 362  : 						break;

  00cd2	eb 6e		 jmp	 SHORT $L24124
$L24112:

; 363  : 					case(nsd_Length_12):
; 364  : 						nsd.length = 12;

  00cd4	c7 43 40 0c 00
	00 00		 mov	 DWORD PTR [ebx+64], 12	; 0000000cH

; 365  : 						break;

  00cdb	eb 65		 jmp	 SHORT $L24124
$L24113:

; 366  : 					case(nsd_Length_9):
; 367  : 						nsd.length = 9;

  00cdd	c7 43 40 09 00
	00 00		 mov	 DWORD PTR [ebx+64], 9

; 368  : 						break;

  00ce4	eb 5c		 jmp	 SHORT $L24124
$L24114:

; 369  : 					case(nsd_Length_8):
; 370  : 						nsd.length = 8;

  00ce6	c7 43 40 08 00
	00 00		 mov	 DWORD PTR [ebx+64], 8

; 371  : 						break;

  00ced	eb 53		 jmp	 SHORT $L24124
$L24115:

; 372  : 					case(nsd_Length_6):
; 373  : 						nsd.length = 6;

  00cef	c7 43 40 06 00
	00 00		 mov	 DWORD PTR [ebx+64], 6

; 374  : 						break;

  00cf6	eb 4a		 jmp	 SHORT $L24124
$L24116:

; 375  : 					case(nsd_Length_4):
; 376  : 						nsd.length = 4;

  00cf8	c7 43 40 04 00
	00 00		 mov	 DWORD PTR [ebx+64], 4

; 377  : 						break;

  00cff	eb 41		 jmp	 SHORT $L24124
$L24117:

; 378  : 					case(nsd_Length_3):
; 379  : 						nsd.length = 3;

  00d01	c7 43 40 03 00
	00 00		 mov	 DWORD PTR [ebx+64], 3

; 380  : 						break;

  00d08	eb 38		 jmp	 SHORT $L24124
$L24118:

; 381  : 					case(nsd_Length_2):
; 382  : 						nsd.length = 2;

  00d0a	c7 43 40 02 00
	00 00		 mov	 DWORD PTR [ebx+64], 2

; 383  : 						break;

  00d11	eb 2f		 jmp	 SHORT $L24124
$L24119:

; 384  : 					case(nsd_Length_1):
; 385  : 						nsd.length = 1;

  00d13	c7 43 40 01 00
	00 00		 mov	 DWORD PTR [ebx+64], 1

; 386  : 						break;

  00d1a	eb 26		 jmp	 SHORT $L24124
$L24120:

; 387  : 					default:
; 388  : 						(*itItem)->setUse();

  00d1c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00d1f	c6 40 38 01	 mov	 BYTE PTR [eax+56], 1

; 389  : 						break;
; 390  : 				}
; 391  : 			} else {

  00d23	eb 1d		 jmp	 SHORT $L24124
$L24053:

; 392  : 				//note
; 393  : 				iCode &= 0x7F;
; 394  : 				if(iCode & nsd_Note_Length){

  00d25	a8 20		 test	 al, 32			; 00000020H
  00d27	74 10		 je	 SHORT $L24122

; 395  : 					iTickTotal += (int)(*itItem)->getCode(1);

  00d29	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00d2c	33 c9		 xor	 ecx, ecx
  00d2e	41		 inc	 ecx
  00d2f	e8 00 00 00 00	 call	 ?getCode@MusicItem@@QAEEI@Z ; MusicItem::getCode
  00d34	0f b6 c0	 movzx	 eax, al

; 396  : 				} else {

  00d37	eb 03		 jmp	 SHORT $L102864
$L24122:

; 397  : 					iTickTotal += nsd.length;

  00d39	8b 43 40	 mov	 eax, DWORD PTR [ebx+64]
$L102864:
  00d3c	01 83 94 00 00
	00		 add	 DWORD PTR [ebx+148], eax
$L24124:

; 398  : 				}
; 399  : 			}
; 400  : 			itItem++;

  00d42	8b 12		 mov	 edx, DWORD PTR [edx]
  00d44	3b 53 0c	 cmp	 edx, DWORD PTR [ebx+12]
  00d47	89 55 f8	 mov	 DWORD PTR _itItem$[ebp], edx
  00d4a	0f 85 01 fe ff
	ff		 jne	 $L102863
  00d50	5f		 pop	 edi
  00d51	5e		 pop	 esi
$L24048:

; 401  : 		}
; 402  : 	}
; 403  : 
; 404  : 	if(loop_flag == false){

  00d52	80 bb fc 01 00
	00 00		 cmp	 BYTE PTR [ebx+508], 0
  00d59	75 07		 jne	 SHORT $L24126

; 405  : 		iTickLoop = -1;

  00d5b	83 8b 98 00 00
	00 ff		 or	 DWORD PTR [ebx+152], -1
$L24126:

; 406  : 	}
; 407  : 
; 408  : 	return(iTickTotal);

  00d62	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [ebx+148]
  00d68	5b		 pop	 ebx

; 409  : }

  00d69	c9		 leave
  00d6a	c2 04 00	 ret	 4
$L102867:
  00d6d	00 00 00 00	 DD	 $L24059
  00d71	00 00 00 00	 DD	 $L24064
  00d75	00 00 00 00	 DD	 $L24065
  00d79	00 00 00 00	 DD	 $L24067
  00d7d	00 00 00 00	 DD	 $L24103
  00d81	00 00 00 00	 DD	 $L24124
  00d85	00 00 00 00	 DD	 $L24070
  00d89	00 00 00 00	 DD	 $L24071
  00d8d	00 00 00 00	 DD	 $L24073
  00d91	00 00 00 00	 DD	 $L24104
  00d95	00 00 00 00	 DD	 $L24105
  00d99	00 00 00 00	 DD	 $L24106
  00d9d	00 00 00 00	 DD	 $L24107
  00da1	00 00 00 00	 DD	 $L24108
  00da5	00 00 00 00	 DD	 $L24109
  00da9	00 00 00 00	 DD	 $L24110
  00dad	00 00 00 00	 DD	 $L24111
  00db1	00 00 00 00	 DD	 $L24112
  00db5	00 00 00 00	 DD	 $L24113
  00db9	00 00 00 00	 DD	 $L24114
  00dbd	00 00 00 00	 DD	 $L24115
  00dc1	00 00 00 00	 DD	 $L24116
  00dc5	00 00 00 00	 DD	 $L24117
  00dc9	00 00 00 00	 DD	 $L24118
  00dcd	00 00 00 00	 DD	 $L24119
  00dd1	00 00 00 00	 DD	 $L24120
$L102862:
  00dd5	00		 DB	 0
  00dd6	01		 DB	 1
  00dd7	02		 DB	 2
  00dd8	03		 DB	 3
  00dd9	19		 DB	 25			; 00000019H
  00dda	19		 DB	 25			; 00000019H
  00ddb	19		 DB	 25			; 00000019H
  00ddc	04		 DB	 4
  00ddd	05		 DB	 5
  00dde	05		 DB	 5
  00ddf	19		 DB	 25			; 00000019H
  00de0	05		 DB	 5
  00de1	05		 DB	 5
  00de2	05		 DB	 5
  00de3	05		 DB	 5
  00de4	05		 DB	 5
  00de5	05		 DB	 5
  00de6	05		 DB	 5
  00de7	05		 DB	 5
  00de8	05		 DB	 5
  00de9	05		 DB	 5
  00dea	19		 DB	 25			; 00000019H
  00deb	06		 DB	 6
  00dec	07		 DB	 7
  00ded	08		 DB	 8
  00dee	05		 DB	 5
  00def	05		 DB	 5
  00df0	05		 DB	 5
  00df1	05		 DB	 5
  00df2	05		 DB	 5
  00df3	05		 DB	 5
  00df4	05		 DB	 5
  00df5	05		 DB	 5
  00df6	05		 DB	 5
  00df7	05		 DB	 5
  00df8	05		 DB	 5
  00df9	05		 DB	 5
  00dfa	19		 DB	 25			; 00000019H
  00dfb	05		 DB	 5
  00dfc	05		 DB	 5
  00dfd	05		 DB	 5
  00dfe	05		 DB	 5
  00dff	05		 DB	 5
  00e00	05		 DB	 5
  00e01	05		 DB	 5
  00e02	05		 DB	 5
  00e03	19		 DB	 25			; 00000019H
  00e04	19		 DB	 25			; 00000019H
  00e05	19		 DB	 25			; 00000019H
  00e06	19		 DB	 25			; 00000019H
  00e07	19		 DB	 25			; 00000019H
  00e08	19		 DB	 25			; 00000019H
  00e09	19		 DB	 25			; 00000019H
  00e0a	19		 DB	 25			; 00000019H
  00e0b	19		 DB	 25			; 00000019H
  00e0c	19		 DB	 25			; 00000019H
  00e0d	19		 DB	 25			; 00000019H
  00e0e	19		 DB	 25			; 00000019H
  00e0f	19		 DB	 25			; 00000019H
  00e10	19		 DB	 25			; 00000019H
  00e11	19		 DB	 25			; 00000019H
  00e12	19		 DB	 25			; 00000019H
  00e13	09		 DB	 9
  00e14	0a		 DB	 10			; 0000000aH
  00e15	0b		 DB	 11			; 0000000bH
  00e16	0c		 DB	 12			; 0000000cH
  00e17	0d		 DB	 13			; 0000000dH
  00e18	0e		 DB	 14			; 0000000eH
  00e19	0f		 DB	 15			; 0000000fH
  00e1a	10		 DB	 16			; 00000010H
  00e1b	11		 DB	 17			; 00000011H
  00e1c	12		 DB	 18			; 00000012H
  00e1d	13		 DB	 19			; 00000013H
  00e1e	14		 DB	 20			; 00000014H
  00e1f	15		 DB	 21			; 00000015H
  00e20	16		 DB	 22			; 00000016H
  00e21	17		 DB	 23			; 00000017H
  00e22	18		 DB	 24			; 00000018H
?TickCount@MusicTrack@@QAEIPAVMusicFile@@@Z ENDP	; MusicTrack::TickCount
_TEXT	ENDS
PUBLIC	??0MusicTrack@@QAE@PAVMMLfile@@QBG@Z		; MusicTrack::MusicTrack
$T104080 DD	0ffffffffH
	DD	FLAT:$L102875
	DD	00H
	DD	FLAT:$L102876
	DD	01H
	DD	FLAT:$L102877
	DD	02H
	DD	FLAT:$L102878
	DD	03H
	DD	FLAT:$L102879
	DD	04H
	DD	FLAT:$L102880
	DD	05H
	DD	FLAT:$L102881
	DD	06H
	DD	FLAT:$L102882
	DD	07H
	DD	FLAT:$L102883
	DD	08H
	DD	FLAT:$L102884
	DD	09H
	DD	FLAT:$L102885
	DD	0aH
	DD	FLAT:$L102886
	DD	0bH
	DD	FLAT:$L102887
	DD	0cH
	DD	FLAT:$L102888
$T104076 DD	019930520H
	DD	0eH
	DD	FLAT:$T104080
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
$T102870 = 12						; size = 4
$T102869 = 12						; size = 4
_MML$ = 12						; size = 4
$T102872 = 16						; size = 4
_pt_itMusic$24004 = 16					; size = 4
__strName$ = 16						; size = 4
??0MusicTrack@@QAE@PAVMMLfile@@QBG@Z PROC NEAR		; MusicTrack::MusicTrack

; 49   : {

  00e23	b8 00 00 00 00	 mov	 eax, __ehhandler$??0MusicTrack@@QAE@PAVMMLfile@@QBG@Z
  00e28	e8 00 00 00 00	 call	 __EH_prolog
  00e2d	53		 push	 ebx
  00e2e	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00e31	56		 push	 esi
  00e32	57		 push	 edi
  00e33	ff 75 10	 push	 DWORD PTR __strName$[ebp]
  00e36	53		 push	 ebx
  00e37	e8 00 00 00 00	 call	 ??0MusicItem@@QAE@QBG@Z	; MusicItem::MusicItem
  00e3c	33 f6		 xor	 esi, esi
  00e3e	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  00e41	83 8b dc 00 00
	00 ff		 or	 DWORD PTR [ebx+220], -1
  00e48	8d 83 20 02 00
	00		 lea	 eax, DWORD PTR [ebx+544]
  00e4e	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7MusicTrack@@6B@
  00e54	89 b3 9c 00 00
	00		 mov	 DWORD PTR [ebx+156], esi
  00e5a	c6 83 a0 00 00
	00 00		 mov	 BYTE PTR [ebx+160], 0
  00e61	c6 83 a1 00 00
	00 00		 mov	 BYTE PTR [ebx+161], 0
  00e68	89 b3 d4 00 00
	00		 mov	 DWORD PTR [ebx+212], esi
  00e6e	c6 83 d8 00 00
	00 00		 mov	 BYTE PTR [ebx+216], 0
  00e75	c6 83 d9 00 00
	00 00		 mov	 BYTE PTR [ebx+217], 0
  00e7c	c6 83 da 00 00
	00 00		 mov	 BYTE PTR [ebx+218], 0
  00e83	c6 83 e2 01 00
	00 00		 mov	 BYTE PTR [ebx+482], 0
  00e8a	c6 83 e3 01 00
	00 00		 mov	 BYTE PTR [ebx+483], 0
  00e91	c6 83 fc 01 00
	00 00		 mov	 BYTE PTR [ebx+508], 0
  00e98	89 b3 00 02 00
	00		 mov	 DWORD PTR [ebx+512], esi
  00e9e	89 b3 0c 02 00
	00		 mov	 DWORD PTR [ebx+524], esi
  00ea4	89 b3 10 02 00
	00		 mov	 DWORD PTR [ebx+528], esi
  00eaa	89 b3 14 02 00
	00		 mov	 DWORD PTR [ebx+532], esi
  00eb0	89 b3 18 02 00
	00		 mov	 DWORD PTR [ebx+536], esi
  00eb6	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00eb9	89 70 08	 mov	 DWORD PTR [eax+8], esi
  00ebc	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  00ebf	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00ec3	89 b3 30 02 00
	00		 mov	 DWORD PTR [ebx+560], esi
  00ec9	89 b3 34 02 00
	00		 mov	 DWORD PTR [ebx+564], esi
  00ecf	e8 00 00 00 00	 call	 ?_Buynode@?$list@IV?$allocator@I@std@@@std@@IAEPAU_Node@?$_List_nod@IV?$allocator@I@std@@@2@XZ ; std::list<unsigned int,std::allocator<unsigned int> >::_Buynode
  00ed4	89 83 3c 02 00
	00		 mov	 DWORD PTR [ebx+572], eax
  00eda	89 b3 40 02 00
	00		 mov	 DWORD PTR [ebx+576], esi
  00ee0	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00ee4	e8 00 00 00 00	 call	 ?_Buynode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@XZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Buynode
  00ee9	89 83 48 02 00
	00		 mov	 DWORD PTR [ebx+584], eax
  00eef	89 b3 4c 02 00
	00		 mov	 DWORD PTR [ebx+588], esi
  00ef5	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00ef9	e8 00 00 00 00	 call	 ?_Buynode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@XZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Buynode
  00efe	89 83 54 02 00
	00		 mov	 DWORD PTR [ebx+596], eax
  00f04	89 b3 58 02 00
	00		 mov	 DWORD PTR [ebx+600], esi
  00f0a	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00f0e	e8 00 00 00 00	 call	 ?_Buynode@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@IAEPAU_Node@?$_List_nod@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@2@XZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Buynode
  00f13	89 83 60 02 00
	00		 mov	 DWORD PTR [ebx+608], eax
  00f19	89 b3 64 02 00
	00		 mov	 DWORD PTR [ebx+612], esi
  00f1f	89 b3 68 02 00
	00		 mov	 DWORD PTR [ebx+616], esi
  00f25	89 b3 6c 02 00
	00		 mov	 DWORD PTR [ebx+620], esi
  00f2b	89 b3 70 02 00
	00		 mov	 DWORD PTR [ebx+624], esi
  00f31	8d 83 78 02 00
	00		 lea	 eax, DWORD PTR [ebx+632]
  00f37	89 b3 74 02 00
	00		 mov	 DWORD PTR [ebx+628], esi
  00f3d	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00f40	89 70 08	 mov	 DWORD PTR [eax+8], esi
  00f43	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  00f46	8d 83 88 02 00
	00		 lea	 eax, DWORD PTR [ebx+648]
  00f4c	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00f4f	89 70 08	 mov	 DWORD PTR [eax+8], esi
  00f52	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  00f55	8d 83 98 02 00
	00		 lea	 eax, DWORD PTR [ebx+664]
  00f5b	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00f5e	89 70 08	 mov	 DWORD PTR [eax+8], esi
  00f61	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  00f64	8d 83 a8 02 00
	00		 lea	 eax, DWORD PTR [ebx+680]
  00f6a	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00f6d	89 70 08	 mov	 DWORD PTR [eax+8], esi
  00f70	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  00f73	8d 83 b8 02 00
	00		 lea	 eax, DWORD PTR [ebx+696]
  00f79	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00f7c	89 70 08	 mov	 DWORD PTR [eax+8], esi
  00f7f	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  00f82	8d 83 c8 02 00
	00		 lea	 eax, DWORD PTR [ebx+712]
  00f88	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00f8b	89 70 08	 mov	 DWORD PTR [eax+8], esi
  00f8e	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  00f91	8d 83 d8 02 00
	00		 lea	 eax, DWORD PTR [ebx+728]
  00f97	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00f9a	89 70 08	 mov	 DWORD PTR [eax+8], esi
  00f9d	89 70 0c	 mov	 DWORD PTR [eax+12], esi

; 50   : 	unsigned	int	i = 0;
; 51   : 
; 52   : 	nsd.init();

  00fa0	8d 43 3c	 lea	 eax, DWORD PTR [ebx+60]
  00fa3	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  00fa7	e8 00 00 00 00	 call	 ?init@NSD_WORK@@QAEXXZ	; NSD_WORK::init

; 53   : 	nsd.length = -1;

  00fac	83 4b 40 ff	 or	 DWORD PTR [ebx+64], -1

; 54   : 
; 55   : 	while(i < 256){
; 56   : 		oldNote[i] = -1;

  00fb0	6a 40		 push	 64			; 00000040H
  00fb2	83 c8 ff	 or	 eax, -1
  00fb5	59		 pop	 ecx
  00fb6	8d bb e2 00 00
	00		 lea	 edi, DWORD PTR [ebx+226]
  00fbc	f3 ab		 rep stosd

; 57   : 		i++;
; 58   : 	}
; 59   : 
; 60   : 	Reset_opt();

  00fbe	8b c3		 mov	 eax, ebx
  00fc0	e8 00 00 00 00	 call	 ?Reset_opt@MusicTrack@@QAEXXZ ; MusicTrack::Reset_opt

; 61   : 
; 62   : 	QMax = MML->QMax;

  00fc5	8b 45 0c	 mov	 eax, DWORD PTR _MML$[ebp]
  00fc8	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [eax+160]

; 63   : 	gatetime_Q = QMax;
; 64   : 
; 65   : 	//iDefault = C-Durj
; 66   : 	nowKey		=0;
; 67   : 	nowScale	=0;
; 68   : 	SetKey(nowKey, nowScale);

  00fce	56		 push	 esi
  00fcf	33 c9		 xor	 ecx, ecx
  00fd1	8b fb		 mov	 edi, ebx
  00fd3	89 83 a8 00 00
	00		 mov	 DWORD PTR [ebx+168], eax
  00fd9	89 83 b0 00 00
	00		 mov	 DWORD PTR [ebx+176], eax
  00fdf	c6 83 d0 00 00
	00 00		 mov	 BYTE PTR [ebx+208], 0
  00fe6	c6 83 d1 00 00
	00 00		 mov	 BYTE PTR [ebx+209], 0
  00fed	e8 00 00 00 00	 call	 ?SetKey@MusicTrack@@QAEXHH@Z ; MusicTrack::SetKey

; 69   : 
; 70   : 	//OANZXOiMMLRpCWJs[gj
; 71   : 	//Visual C++.net 2008 AAOlB
; 72   : 	//A
; 73   : 	{
; 74   : 		list<MusicItem*>::iterator	pt_itMusic	=	ptcItem.end();

  00ff2	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00ff5	89 45 10	 mov	 DWORD PTR _pt_itMusic$24004[ebp], eax

; 75   : 
; 76   : 		//s[g^Cv
; 77   : 		repeat_type.push_back(0);

  00ff8	89 75 0c	 mov	 DWORD PTR $T102869[ebp], esi
  00ffb	8d 75 0c	 lea	 esi, DWORD PTR $T102869[ebp]
  00ffe	8d 83 20 02 00
	00		 lea	 eax, DWORD PTR [ebx+544]
  01004	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 78   : 
; 79   : 		//s[g(C)
; 80   : 		st_ct_repeat_c.push_back(0);

  01009	83 65 0c 00	 and	 DWORD PTR $T102870[ebp], 0
  0100d	8d 83 38 02 00
	00		 lea	 eax, DWORD PTR [ebx+568]
  01013	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01016	8d 55 0c	 lea	 edx, DWORD PTR $T102870[ebp]
  01019	52		 push	 edx
  0101a	51		 push	 ecx
  0101b	50		 push	 eax
  0101c	e8 00 00 00 00	 call	 ?_Insert@?$list@IV?$allocator@I@std@@@std@@QAEXViterator@12@ABI@Z ; std::list<unsigned int,std::allocator<unsigned int> >::_Insert

; 81   : 		st_it_repeat_c_s.push_back(pt_itMusic);

  01021	8d 83 44 02 00
	00		 lea	 eax, DWORD PTR [ebx+580]
  01027	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0102a	8d 55 10	 lea	 edx, DWORD PTR _pt_itMusic$24004[ebp]
  0102d	52		 push	 edx
  0102e	51		 push	 ecx
  0102f	50		 push	 eax
  01030	e8 00 00 00 00	 call	 ?_Insert@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXViterator@12@ABV3?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Insert

; 82   : 		st_it_repeat_c_b.push_back(pt_itMusic);

  01035	8d 83 50 02 00
	00		 lea	 eax, DWORD PTR [ebx+592]
  0103b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0103e	8d 55 10	 lea	 edx, DWORD PTR _pt_itMusic$24004[ebp]
  01041	52		 push	 edx
  01042	51		 push	 ecx
  01043	50		 push	 eax
  01044	e8 00 00 00 00	 call	 ?_Insert@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXViterator@12@ABV3?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Insert

; 83   : 		st_it_repeat_c_e.push_back(pt_itMusic);

  01049	8d 83 5c 02 00
	00		 lea	 eax, DWORD PTR [ebx+604]
  0104f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01052	8d 55 10	 lea	 edx, DWORD PTR _pt_itMusic$24004[ebp]
  01055	52		 push	 edx
  01056	51		 push	 ecx
  01057	50		 push	 eax
  01058	e8 00 00 00 00	 call	 ?_Insert@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXViterator@12@ABV3?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Insert

; 84   : 
; 85   : 		//Cxg
; 86   : 		SetEvent(new MusicItem(_T("Null")));

  0105d	6a 3c		 push	 60			; 0000003cH
  0105f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01064	59		 pop	 ecx
  01065	89 45 10	 mov	 DWORD PTR $T102872[ebp], eax
  01068	85 c0		 test	 eax, eax
  0106a	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  0106e	74 0d		 je	 SHORT $L102873
  01070	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_19HGHALIPE@?$AAN?$AAu?$AAl?$AAl?$AA?$AA@
  01075	50		 push	 eax
  01076	e8 00 00 00 00	 call	 ??0MusicItem@@QAE@QBG@Z	; MusicItem::MusicItem
  0107b	eb 02		 jmp	 SHORT $L102874
$L102873:
  0107d	33 c0		 xor	 eax, eax
$L102874:
  0107f	50		 push	 eax
  01080	8b c3		 mov	 eax, ebx
  01082	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  01086	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 87   : 	}
; 88   : }

  0108b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0108e	5f		 pop	 edi
  0108f	5e		 pop	 esi
  01090	8b c3		 mov	 eax, ebx
  01092	5b		 pop	 ebx
  01093	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0109a	c9		 leave
  0109b	c2 0c 00	 ret	 12			; 0000000cH
$L102875:
  0053f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00542	e9 00 00 00 00	 jmp	 ??1MusicItem@@QAE@XZ	; MusicItem::~MusicItem
$L102876:
  00547	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  0054a	81 c6 20 02 00
	00		 add	 esi, 544		; 00000220H
  00550	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
$L102877:
  00555	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00558	05 38 02 00 00	 add	 eax, 568		; 00000238H
  0055d	e9 00 00 00 00	 jmp	 ??1?$list@IV?$allocator@I@std@@@std@@QAE@XZ ; std::list<unsigned int,std::allocator<unsigned int> >::~list<unsigned int,std::allocator<unsigned int> >
$L102878:
  00562	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00565	05 44 02 00 00	 add	 eax, 580		; 00000244H
  0056a	e9 00 00 00 00	 jmp	 ??1?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::~list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >
$L102879:
  0056f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00572	05 50 02 00 00	 add	 eax, 592		; 00000250H
  00577	e9 00 00 00 00	 jmp	 ??1?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::~list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >
$L102880:
  0057c	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0057f	05 5c 02 00 00	 add	 eax, 604		; 0000025cH
  00584	e9 00 00 00 00	 jmp	 ??1?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAE@XZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::~list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >
$L102881:
  00589	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  0058c	81 c6 78 02 00
	00		 add	 esi, 632		; 00000278H
  00592	e9 00 00 00 00	 jmp	 ??1?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::~vector<mml_Address *,std::allocator<mml_Address *> >
$L102882:
  00597	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  0059a	81 c6 88 02 00
	00		 add	 esi, 648		; 00000288H
  005a0	e9 00 00 00 00	 jmp	 ??1?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::~vector<mml_Address *,std::allocator<mml_Address *> >
$L102883:
  005a5	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  005a8	81 c6 98 02 00
	00		 add	 esi, 664		; 00000298H
  005ae	e9 00 00 00 00	 jmp	 ??1?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::~vector<mml_Address *,std::allocator<mml_Address *> >
$L102884:
  005b3	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  005b6	81 c6 a8 02 00
	00		 add	 esi, 680		; 000002a8H
  005bc	e9 00 00 00 00	 jmp	 ??1?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::~vector<mml_Address *,std::allocator<mml_Address *> >
$L102885:
  005c1	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  005c4	81 c6 b8 02 00
	00		 add	 esi, 696		; 000002b8H
  005ca	e9 00 00 00 00	 jmp	 ??1?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::~vector<mml_Address *,std::allocator<mml_Address *> >
$L102886:
  005cf	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  005d2	81 c6 c8 02 00
	00		 add	 esi, 712		; 000002c8H
  005d8	e9 00 00 00 00	 jmp	 ??1?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::~vector<mml_Address *,std::allocator<mml_Address *> >
$L102887:
  005dd	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  005e0	81 c6 d8 02 00
	00		 add	 esi, 728		; 000002d8H
  005e6	e9 00 00 00 00	 jmp	 ??1?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAE@XZ ; std::vector<mml_Address *,std::allocator<mml_Address *> >::~vector<mml_Address *,std::allocator<mml_Address *> >
$L102888:
  005eb	ff 75 10	 push	 DWORD PTR $T102872[ebp]
  005ee	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  005f3	59		 pop	 ecx
  005f4	c3		 ret	 0
__ehhandler$??0MusicTrack@@QAE@PAVMMLfile@@QBG@Z:
  005f5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T104076
  005fa	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
??0MusicTrack@@QAE@PAVMMLfile@@QBG@Z ENDP		; MusicTrack::MusicTrack
PUBLIC	?SetOctaveOne_Dec@MusicTrack@@QAEXXZ		; MusicTrack::SetOctaveOne_Dec
$T104741 DD	0ffffffffH
	DD	FLAT:$L104737
$T104739 DD	019930520H
	DD	01H
	DD	FLAT:$T104741
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T104734 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetOctaveOne_Dec@MusicTrack@@QAEXXZ PROC NEAR		; MusicTrack::SetOctaveOne_Dec
; _this$ = esi

; 3537 : {

  0109e	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetOctaveOne_Dec@MusicTrack@@QAEXXZ
  010a3	e8 00 00 00 00	 call	 __EH_prolog
  010a8	51		 push	 ecx

; 3538 : 	if(jump_flag == false){

  010a9	80 be a1 00 00
	00 00		 cmp	 BYTE PTR [esi+161], 0
  010b0	75 33		 jne	 SHORT $L26220

; 3539 : 		SetEvent(new mml_general(nsd_Octave_Down_1, _T("One time octave down")));

  010b2	6a 3c		 push	 60			; 0000003cH
  010b4	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  010b9	59		 pop	 ecx
  010ba	89 45 f0	 mov	 DWORD PTR $T104734[ebp], eax
  010bd	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  010c1	85 c0		 test	 eax, eax
  010c3	74 0f		 je	 SHORT $L104735
  010c5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CK@JCJILIHF@?$AAO?$AAn?$AAe?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?5?$AAo?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAd?$AAo?$AAw?$AAn@
  010ca	6a 2c		 push	 44			; 0000002cH
  010cc	50		 push	 eax
  010cd	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  010d2	eb 02		 jmp	 SHORT $L104736
$L104735:
  010d4	33 c0		 xor	 eax, eax
$L104736:
  010d6	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  010da	50		 push	 eax
  010db	8b c6		 mov	 eax, esi
  010dd	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 3540 : 		nsd.octave1--;

  010e2	ff 4e 50	 dec	 DWORD PTR [esi+80]
$L26220:

; 3541 : 	}
; 3542 : }

  010e5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  010e8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  010ef	c9		 leave
  010f0	c3		 ret	 0
$L104737:
  00631	ff 75 f0	 push	 DWORD PTR $T104734[ebp]
  00634	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00639	59		 pop	 ecx
  0063a	c3		 ret	 0
__ehhandler$?SetOctaveOne_Dec@MusicTrack@@QAEXXZ:
  0063b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T104739
  00640	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetOctaveOne_Dec@MusicTrack@@QAEXXZ ENDP		; MusicTrack::SetOctaveOne_Dec
PUBLIC	?SetOctaveOne_Inc@MusicTrack@@QAEXXZ		; MusicTrack::SetOctaveOne_Inc
$T104751 DD	0ffffffffH
	DD	FLAT:$L104747
$T104749 DD	019930520H
	DD	01H
	DD	FLAT:$T104751
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T104744 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetOctaveOne_Inc@MusicTrack@@QAEXXZ PROC NEAR		; MusicTrack::SetOctaveOne_Inc
; _this$ = esi

; 3528 : {

  010f1	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetOctaveOne_Inc@MusicTrack@@QAEXXZ
  010f6	e8 00 00 00 00	 call	 __EH_prolog
  010fb	51		 push	 ecx

; 3529 : 	if(jump_flag == false){

  010fc	80 be a1 00 00
	00 00		 cmp	 BYTE PTR [esi+161], 0
  01103	75 33		 jne	 SHORT $L26212

; 3530 : 		SetEvent(new mml_general(nsd_Octave_Up_1, _T("One time octave up")));

  01105	6a 3c		 push	 60			; 0000003cH
  01107	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0110c	59		 pop	 ecx
  0110d	89 45 f0	 mov	 DWORD PTR $T104744[ebp], eax
  01110	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  01114	85 c0		 test	 eax, eax
  01116	74 0f		 je	 SHORT $L104745
  01118	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CG@IKGHOBJA@?$AAO?$AAn?$AAe?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?5?$AAo?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAu?$AAp?$AA?$AA@
  0111d	6a 2d		 push	 45			; 0000002dH
  0111f	50		 push	 eax
  01120	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  01125	eb 02		 jmp	 SHORT $L104746
$L104745:
  01127	33 c0		 xor	 eax, eax
$L104746:
  01129	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0112d	50		 push	 eax
  0112e	8b c6		 mov	 eax, esi
  01130	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 3531 : 		nsd.octave1++;

  01135	ff 46 50	 inc	 DWORD PTR [esi+80]
$L26212:

; 3532 : 	}
; 3533 : }

  01138	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0113b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01142	c9		 leave
  01143	c3		 ret	 0
$L104747:
  00645	ff 75 f0	 push	 DWORD PTR $T104744[ebp]
  00648	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0064d	59		 pop	 ecx
  0064e	c3		 ret	 0
__ehhandler$?SetOctaveOne_Inc@MusicTrack@@QAEXXZ:
  0064f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T104749
  00654	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetOctaveOne_Inc@MusicTrack@@QAEXXZ ENDP		; MusicTrack::SetOctaveOne_Inc
PUBLIC	?SetOctaveDec@MusicTrack@@QAEXXZ		; MusicTrack::SetOctaveDec
$T104761 DD	0ffffffffH
	DD	FLAT:$L104757
$T104759 DD	019930520H
	DD	01H
	DD	FLAT:$T104761
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T104754 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetOctaveDec@MusicTrack@@QAEXXZ PROC NEAR		; MusicTrack::SetOctaveDec
; _this$ = esi

; 3516 : {

  01144	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetOctaveDec@MusicTrack@@QAEXXZ
  01149	e8 00 00 00 00	 call	 __EH_prolog
  0114e	51		 push	 ecx

; 3517 : 	SetEvent(new mml_general(nsd_Octave_Down, _T("Octave Down")));

  0114f	6a 3c		 push	 60			; 0000003cH
  01151	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01156	59		 pop	 ecx
  01157	89 45 f0	 mov	 DWORD PTR $T104754[ebp], eax
  0115a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0115e	85 c0		 test	 eax, eax
  01160	74 0f		 je	 SHORT $L104755
  01162	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BI@KEBEFOPC@?$AAO?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAD?$AAo?$AAw?$AAn?$AA?$AA@
  01167	6a 28		 push	 40			; 00000028H
  01169	50		 push	 eax
  0116a	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  0116f	eb 02		 jmp	 SHORT $L104756
$L104755:
  01171	33 c0		 xor	 eax, eax
$L104756:
  01173	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  01177	50		 push	 eax
  01178	8b c6		 mov	 eax, esi
  0117a	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 3518 : 	if(nsd.octave>0){

  0117f	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  01182	85 c0		 test	 eax, eax
  01184	7e 11		 jle	 SHORT $L26208

; 3519 : 		nsd.octave--;

  01186	48		 dec	 eax

; 3520 : 		if(opt_octave != -1){

  01187	8d 8e c0 00 00
	00		 lea	 ecx, DWORD PTR [esi+192]
  0118d	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  01190	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  01193	74 02		 je	 SHORT $L26208

; 3521 : 			opt_octave = nsd.octave;

  01195	89 01		 mov	 DWORD PTR [ecx], eax
$L26208:

; 3522 : 		}
; 3523 : 	}
; 3524 : }

  01197	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0119a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  011a1	c9		 leave
  011a2	c3		 ret	 0
$L104757:
  00659	ff 75 f0	 push	 DWORD PTR $T104754[ebp]
  0065c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00661	59		 pop	 ecx
  00662	c3		 ret	 0
__ehhandler$?SetOctaveDec@MusicTrack@@QAEXXZ:
  00663	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T104759
  00668	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetOctaveDec@MusicTrack@@QAEXXZ ENDP			; MusicTrack::SetOctaveDec
PUBLIC	?SetOctaveInc@MusicTrack@@QAEXXZ		; MusicTrack::SetOctaveInc
$T104771 DD	0ffffffffH
	DD	FLAT:$L104767
$T104769 DD	019930520H
	DD	01H
	DD	FLAT:$T104771
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T104764 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetOctaveInc@MusicTrack@@QAEXXZ PROC NEAR		; MusicTrack::SetOctaveInc
; _this$ = esi

; 3504 : {

  011a3	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetOctaveInc@MusicTrack@@QAEXXZ
  011a8	e8 00 00 00 00	 call	 __EH_prolog
  011ad	51		 push	 ecx

; 3505 : 	SetEvent(new mml_general(nsd_Octave_Up, _T("Octave Up")));

  011ae	6a 3c		 push	 60			; 0000003cH
  011b0	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  011b5	59		 pop	 ecx
  011b6	89 45 f0	 mov	 DWORD PTR $T104764[ebp], eax
  011b9	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  011bd	85 c0		 test	 eax, eax
  011bf	74 0f		 je	 SHORT $L104765
  011c1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@JMDGIABI@?$AAO?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAU?$AAp?$AA?$AA@
  011c6	6a 29		 push	 41			; 00000029H
  011c8	50		 push	 eax
  011c9	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  011ce	eb 02		 jmp	 SHORT $L104766
$L104765:
  011d0	33 c0		 xor	 eax, eax
$L104766:
  011d2	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  011d6	50		 push	 eax
  011d7	8b c6		 mov	 eax, esi
  011d9	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 3506 : 	if(nsd.octave<10){

  011de	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  011e1	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  011e4	7d 11		 jge	 SHORT $L26198

; 3507 : 		nsd.octave++;

  011e6	40		 inc	 eax

; 3508 : 		if(opt_octave != -1){

  011e7	8d 8e c0 00 00
	00		 lea	 ecx, DWORD PTR [esi+192]
  011ed	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  011f0	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  011f3	74 02		 je	 SHORT $L26198

; 3509 : 			opt_octave = nsd.octave;

  011f5	89 01		 mov	 DWORD PTR [ecx], eax
$L26198:

; 3510 : 		}
; 3511 : 	}
; 3512 : }

  011f7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  011fa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01201	c9		 leave
  01202	c3		 ret	 0
$L104767:
  0066d	ff 75 f0	 push	 DWORD PTR $T104764[ebp]
  00670	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00675	59		 pop	 ecx
  00676	c3		 ret	 0
__ehhandler$?SetOctaveInc@MusicTrack@@QAEXXZ:
  00677	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T104769
  0067c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetOctaveInc@MusicTrack@@QAEXXZ ENDP			; MusicTrack::SetOctaveInc
PUBLIC	?SetTranspose_Relative@MusicTrack@@QAEXH@Z	; MusicTrack::SetTranspose_Relative
$T104781 DD	0ffffffffH
	DD	FLAT:$L104777
$T104779 DD	019930520H
	DD	01H
	DD	FLAT:$T104781
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T104774 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetTranspose_Relative@MusicTrack@@QAEXH@Z PROC NEAR	; MusicTrack::SetTranspose_Relative
; _this$ = esi
; __no$ = edi

; 3475 : {

  01203	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetTranspose_Relative@MusicTrack@@QAEXH@Z
  01208	e8 00 00 00 00	 call	 __EH_prolog
  0120d	51		 push	 ecx

; 3476 : 	nsd.trans += _no;

  0120e	01 7e 5c	 add	 DWORD PTR [esi+92], edi

; 3477 : 	SetEvent(new mml_general(nsd_Relative_Transpose, (char)_no, _T("Relative Transpose")));

  01211	6a 3c		 push	 60			; 0000003cH
  01213	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01218	59		 pop	 ecx
  01219	89 45 f0	 mov	 DWORD PTR $T104774[ebp], eax
  0121c	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  01220	85 c0		 test	 eax, eax
  01222	74 10		 je	 SHORT $L104775
  01224	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CG@MDOKKNHL@?$AAR?$AAe?$AAl?$AAa?$AAt?$AAi?$AAv?$AAe?$AA?5?$AAT?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AA?$AA@
  01229	57		 push	 edi
  0122a	6a 2b		 push	 43			; 0000002bH
  0122c	50		 push	 eax
  0122d	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EDQBG@Z ; mml_general::mml_general
  01232	eb 02		 jmp	 SHORT $L104776
$L104775:
  01234	33 c0		 xor	 eax, eax
$L104776:
  01236	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0123a	50		 push	 eax
  0123b	8b c6		 mov	 eax, esi
  0123d	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 3478 : }

  01242	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01245	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0124c	c9		 leave
  0124d	c3		 ret	 0
$L104777:
  00681	ff 75 f0	 push	 DWORD PTR $T104774[ebp]
  00684	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00689	59		 pop	 ecx
  0068a	c3		 ret	 0
__ehhandler$?SetTranspose_Relative@MusicTrack@@QAEXH@Z:
  0068b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T104779
  00690	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetTranspose_Relative@MusicTrack@@QAEXH@Z ENDP		; MusicTrack::SetTranspose_Relative
PUBLIC	?SetTranspose@MusicTrack@@QAEXH@Z		; MusicTrack::SetTranspose
$T104791 DD	0ffffffffH
	DD	FLAT:$L104787
$T104789 DD	019930520H
	DD	01H
	DD	FLAT:$T104791
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T104784 = 8						; size = 4
__no$ = 8						; size = 4
?SetTranspose@MusicTrack@@QAEXH@Z PROC NEAR		; MusicTrack::SetTranspose
; _this$ = esi

; 3458 : {

  0124e	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetTranspose@MusicTrack@@QAEXH@Z
  01253	e8 00 00 00 00	 call	 __EH_prolog
  01258	8b 45 08	 mov	 eax, DWORD PTR __no$[ebp]

; 3459 : 	if((nsd.trans != _no) || (f_opt_Key == false)){

  0125b	39 46 5c	 cmp	 DWORD PTR [esi+92], eax
  0125e	75 09		 jne	 SHORT $L26157
  01260	80 be f9 01 00
	00 00		 cmp	 BYTE PTR [esi+505], 0
  01267	75 40		 jne	 SHORT $L26156
$L26157:

; 3460 : 		f_opt_Key	= true;
; 3461 : 		nsd.trans	= _no;
; 3462 : 		SetEvent(new mml_general(nsd_Transpose, (char)nsd.trans, _T("Transpose")));

  01269	6a 3c		 push	 60			; 0000003cH
  0126b	c6 86 f9 01 00
	00 01		 mov	 BYTE PTR [esi+505], 1
  01272	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  01275	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0127a	59		 pop	 ecx
  0127b	89 45 08	 mov	 DWORD PTR $T104784[ebp], eax
  0127e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  01282	85 c0		 test	 eax, eax
  01284	74 15		 je	 SHORT $L104785
  01286	33 c9		 xor	 ecx, ecx
  01288	8a 4e 5c	 mov	 cl, BYTE PTR [esi+92]
  0128b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@FKDCKBLJ@?$AAT?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AA?$AA@
  01290	51		 push	 ecx
  01291	6a 2a		 push	 42			; 0000002aH
  01293	50		 push	 eax
  01294	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EDQBG@Z ; mml_general::mml_general
  01299	eb 02		 jmp	 SHORT $L104786
$L104785:
  0129b	33 c0		 xor	 eax, eax
$L104786:
  0129d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  012a1	50		 push	 eax
  012a2	8b c6		 mov	 eax, esi
  012a4	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent
$L26156:

; 3463 : 	}
; 3464 : }

  012a9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  012ac	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  012b3	c9		 leave
  012b4	c2 04 00	 ret	 4
$L104787:
  00695	ff 75 08	 push	 DWORD PTR $T104784[ebp]
  00698	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0069d	59		 pop	 ecx
  0069e	c3		 ret	 0
__ehhandler$?SetTranspose@MusicTrack@@QAEXH@Z:
  0069f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T104789
  006a4	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetTranspose@MusicTrack@@QAEXH@Z ENDP			; MusicTrack::SetTranspose
PUBLIC	?EchoVolRet@MusicTrack@@QAEXXZ			; MusicTrack::EchoVolRet
$T104801 DD	0ffffffffH
	DD	FLAT:$L104797
$T104799 DD	019930520H
	DD	01H
	DD	FLAT:$T104801
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T104794 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?EchoVolRet@MusicTrack@@QAEXXZ PROC NEAR		; MusicTrack::EchoVolRet
; _this$ = esi

; 2889 : {

  012b7	b8 00 00 00 00	 mov	 eax, __ehhandler$?EchoVolRet@MusicTrack@@QAEXXZ
  012bc	e8 00 00 00 00	 call	 __EH_prolog
  012c1	51		 push	 ecx

; 2890 : 	//B
; 2891 : 	if(echo_vol_ret == true){

  012c2	80 be d9 00 00
	00 01		 cmp	 BYTE PTR [esi+217], 1
  012c9	75 3e		 jne	 SHORT $L25879

; 2892 : 		//volume return
; 2893 : 		SetEvent(new mml_general(nsd_Volume + nsd.volume, _T("Volume")));

  012cb	6a 3c		 push	 60			; 0000003cH
  012cd	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  012d2	59		 pop	 ecx
  012d3	89 45 f0	 mov	 DWORD PTR $T104794[ebp], eax
  012d6	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  012da	85 c0		 test	 eax, eax
  012dc	74 16		 je	 SHORT $L104795
  012de	33 c9		 xor	 ecx, ecx
  012e0	8a 4e 64	 mov	 cl, BYTE PTR [esi+100]
  012e3	80 c1 60	 add	 cl, 96			; 00000060H
  012e6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1O@DMLCJFNF@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@
  012eb	51		 push	 ecx
  012ec	50		 push	 eax
  012ed	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  012f2	eb 02		 jmp	 SHORT $L104796
$L104795:
  012f4	33 c0		 xor	 eax, eax
$L104796:
  012f6	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  012fa	50		 push	 eax
  012fb	8b c6		 mov	 eax, esi
  012fd	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 2894 : 		echo_vol_ret = false;

  01302	c6 86 d9 00 00
	00 00		 mov	 BYTE PTR [esi+217], 0
$L25879:

; 2895 : 	}
; 2896 : }

  01309	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0130c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01313	c9		 leave
  01314	c3		 ret	 0
$L104797:
  006a9	ff 75 f0	 push	 DWORD PTR $T104794[ebp]
  006ac	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  006b1	59		 pop	 ecx
  006b2	c3		 ret	 0
__ehhandler$?EchoVolRet@MusicTrack@@QAEXXZ:
  006b3	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T104799
  006b8	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?EchoVolRet@MusicTrack@@QAEXXZ ENDP			; MusicTrack::EchoVolRet
PUBLIC	?SetEcho@MusicTrack@@QAEXXZ			; MusicTrack::SetEcho
; Function compile flags: /Ogsy
_TEXT	SEGMENT
?SetEcho@MusicTrack@@QAEXXZ PROC NEAR			; MusicTrack::SetEcho
; _this$ = eax

; 2703 : {

  01315	56		 push	 esi
  01316	8b f0		 mov	 esi, eax

; 2704 : 	//B
; 2705 : 	EchoVolRet();

  01318	e8 00 00 00 00	 call	 ?EchoVolRet@MusicTrack@@QAEXXZ ; MusicTrack::EchoVolRet

; 2706 : 
; 2707 : 	echo_flag = false;

  0131d	c6 86 da 00 00
	00 00		 mov	 BYTE PTR [esi+218], 0
  01324	5e		 pop	 esi

; 2708 : }

  01325	c3		 ret	 0
?SetEcho@MusicTrack@@QAEXXZ ENDP			; MusicTrack::SetEcho
_TEXT	ENDS
PUBLIC	?calc_slur@MusicTrack@@QAE_NPAVMMLfile@@@Z	; MusicTrack::calc_slur
; Function compile flags: /Ogsy
_TEXT	SEGMENT
?calc_slur@MusicTrack@@QAE_NPAVMMLfile@@@Z PROC NEAR	; MusicTrack::calc_slur
; _MML$ = eax

; 2681 : {

  01326	53		 push	 ebx
  01327	57		 push	 edi
  01328	8b f8		 mov	 edi, eax

; 2682 : 	unsigned	char	cData = MML->GetChar();

  0132a	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 2683 : 				bool	slur;
; 2684 : 
; 2685 : 	if(cData == '&') {

  0132f	3c 26		 cmp	 al, 38			; 00000026H
  01331	75 04		 jne	 SHORT $L25783

; 2686 : 		slur = true;

  01333	b3 01		 mov	 bl, 1

; 2687 : 	} else {

  01335	eb 09		 jmp	 SHORT $L25784
$L25783:

; 2688 : 		slur = false;
; 2689 : 		MML->Back();

  01337	8b c7		 mov	 eax, edi
  01339	32 db		 xor	 bl, bl
  0133b	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back
$L25784:
  01340	5f		 pop	 edi

; 2690 : 	}
; 2691 : 	return(slur);

  01341	8a c3		 mov	 al, bl
  01343	5b		 pop	 ebx

; 2692 : }

  01344	c3		 ret	 0
?calc_slur@MusicTrack@@QAE_NPAVMMLfile@@@Z ENDP		; MusicTrack::calc_slur
_TEXT	ENDS
PUBLIC	?calc_note@MusicTrack@@QAEDPAVMMLfile@@H@Z	; MusicTrack::calc_note
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_this$ = 8						; size = 4
?calc_note@MusicTrack@@QAEDPAVMMLfile@@H@Z PROC NEAR	; MusicTrack::calc_note
; _MML$ = eax
; _note$ = esi

; 2591 : {

  01345	53		 push	 ebx
  01346	57		 push	 edi
  01347	8b f8		 mov	 edi, eax

; 2592 : 	unsigned		char	cData = MML->GetChar();

  01349	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 2593 : 	static	const	char	note_code[]={0,2,4,5,7,9,11};
; 2594 : 					char	_key = note_code[note];
; 2595 : 
; 2596 : 	//L
; 2597 : 	//If Natural then skip
; 2598 : 	if((cData != '=') && (cData != '*')){

  0134e	3c 3d		 cmp	 al, 61			; 0000003dH
  01350	8a 9e 00 00 00
	00		 mov	 bl, BYTE PTR ?note_code@?1??calc_note@MusicTrack@@QAEDPAVMMLfile@@H@Z@4QBDB[esi]
  01356	74 40		 je	 SHORT $L25745
  01358	3c 2a		 cmp	 al, 42			; 0000002aH
  0135a	74 3c		 je	 SHORT $L25745

; 2599 : 		//i`
; 2600 : 		_key += KeySignature[note];

  0135c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _this$[esp+4]
  01360	02 9c 0e c8 00
	00 00		 add	 bl, BYTE PTR [esi+ecx+200]
$L25747:

; 2601 : 		while((cData == '#') || (cData == '+') || (cData == '-')){

  01367	3c 23		 cmp	 al, 35			; 00000023H
  01369	74 08		 je	 SHORT $L25749
  0136b	3c 2b		 cmp	 al, 43			; 0000002bH
  0136d	74 04		 je	 SHORT $L25749
  0136f	3c 2d		 cmp	 al, 45			; 0000002dH
  01371	75 1e		 jne	 SHORT $L25748
$L25749:

; 2602 : 			switch(cData){

  01373	0f b6 c0	 movzx	 eax, al
  01376	83 e8 23	 sub	 eax, 35			; 00000023H
  01379	74 0d		 je	 SHORT $L25754
  0137b	83 e8 08	 sub	 eax, 8
  0137e	74 08		 je	 SHORT $L25754
  01380	48		 dec	 eax
  01381	48		 dec	 eax
  01382	75 06		 jne	 SHORT $L25751

; 2606 : 					break;
; 2607 : 				case('-'):
; 2608 : 					_key--;

  01384	fe cb		 dec	 bl

; 2609 : 					break;

  01386	eb 02		 jmp	 SHORT $L25751
$L25754:

; 2603 : 				case('#'):
; 2604 : 				case('+'):
; 2605 : 					_key++;

  01388	fe c3		 inc	 bl
$L25751:

; 2610 : 				default:
; 2611 : 					break;
; 2612 : 			}
; 2613 : 			cData = MML->GetChar();	//

  0138a	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 2614 : 		}

  0138f	eb d6		 jmp	 SHORT $L25747
$L25748:

; 2615 : 		//LA|C^B
; 2616 : 		MML->Back();

  01391	8b c7		 mov	 eax, edi
  01393	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back
$L25745:
  01398	5f		 pop	 edi

; 2617 : 	}
; 2618 : 	return(_key);

  01399	8a c3		 mov	 al, bl
  0139b	5b		 pop	 ebx

; 2619 : }

  0139c	c2 04 00	 ret	 4
?calc_note@MusicTrack@@QAEDPAVMMLfile@@H@Z ENDP		; MusicTrack::calc_note
_TEXT	ENDS
PUBLIC	?SetKeySignature@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetKeySignature
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_sign$ = 8						; size = 1
_this$ = 8						; size = 4
?SetKeySignature@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR ; MusicTrack::SetKeySignature
; _MML$ = eax

; 2144 : {

  0139f	55		 push	 ebp
  013a0	8b 6c 24 08	 mov	 ebp, DWORD PTR _this$[esp]
  013a4	56		 push	 esi
  013a5	8b f0		 mov	 esi, eax

; 2145 : 	//R}hID
; 2146 : 	enum	KeySignature_ID {
; 2147 : 		ks_Sharp,
; 2148 : 		ks_Flat,
; 2149 : 		ks_Natural,
; 2150 : 		ks_c,
; 2151 : 		ks_d,
; 2152 : 		ks_e,
; 2153 : 		ks_f,
; 2154 : 		ks_g,
; 2155 : 		ks_a,
; 2156 : 		ks_b,
; 2157 : 		ks_r,
; 2158 : 
; 2159 : 		ks_0,
; 2160 : 		ks_s1,
; 2161 : 		ks_s2,
; 2162 : 		ks_s3,
; 2163 : 		ks_s4,
; 2164 : 		ks_s5,
; 2165 : 		ks_s6,
; 2166 : 		ks_s7,
; 2167 : 		ks_f1,
; 2168 : 		ks_f2,
; 2169 : 		ks_f3,
; 2170 : 		ks_f4,
; 2171 : 		ks_f5,
; 2172 : 		ks_f6,
; 2173 : 		ks_f7,
; 2174 : 
; 2175 : 		ks_m0,
; 2176 : 		ks_ms1,
; 2177 : 		ks_ms2,
; 2178 : 		ks_ms3,
; 2179 : 		ks_ms4,
; 2180 : 		ks_ms5,
; 2181 : 		ks_ms6,
; 2182 : 		ks_ms7,
; 2183 : 		ks_ms8,
; 2184 : 		ks_ms9,
; 2185 : 
; 2186 : 		ks_mf1,
; 2187 : 		ks_mf2,
; 2188 : 		ks_mf3,
; 2189 : 		ks_mf4,
; 2190 : 		ks_mf5,
; 2191 : 		ks_mf6,
; 2192 : 	};
; 2193 : 
; 2194 : 	//R}h`
; 2195 : 	static	const	Command_Info	KS_Command[] = {
; 2196 : 		{	"C-Dur",	ks_0		},	//
; 2197 : 		{	"Ds-Dur",	ks_f5		},	//bbbbb
; 2198 : 		{	"Des-Dur",	ks_f5		},	//bbbbb
; 2199 : 		{	"D-Dur",	ks_s2		},	//##
; 2200 : 		{	"Es-Dur",	ks_f3		},	//bbb
; 2201 : 		{	"E-Dur",	ks_s4		},	//####
; 2202 : 		{	"F-Dur",	ks_f1		},	//b
; 2203 : 		{	"Fis-Dur",	ks_s6		},	//######
; 2204 : 		{	"Gs-Dur",	ks_f6		},	//bbbbbb
; 2205 : 		{	"Ges-Dur",	ks_f6		},	//bbbbbb
; 2206 : 		{	"G-Dur",	ks_s1		},	//#
; 2207 : 		{	"As-Dur",	ks_f4		},	//bbbb
; 2208 : 		{	"A-Dur",	ks_s3		},	//###
; 2209 : 		{	"B-Dur",	ks_f2		},	//bb
; 2210 : 		{	"Bs-Dur",	ks_f2		},	//bb
; 2211 : 		{	"H-Dur",	ks_s5		},	//#####
; 2212 : 
; 2213 : 		{	"c-moll",	ks_m0		},	//bbb
; 2214 : 		{	"cis-moll",	ks_ms7		},	//####
; 2215 : 		{	"d-moll",	ks_ms2		},	//b
; 2216 : 		{	"dis-moll",	ks_ms9		},	//######
; 2217 : 		{	"es-moll",	ks_mf3		},	//bbbbbb
; 2218 : 		{	"e-moll",	ks_ms4		},	//#
; 2219 : 		{	"f-moll",	ks_mf1		},	//bbbb
; 2220 : 		{	"fis-moll",	ks_ms6		},	//###
; 2221 : 		{	"g-moll",	ks_ms1		},	//bb
; 2222 : 		{	"gis-moll",	ks_ms8		},	//#####
; 2223 : 		{	"a-moll",	ks_ms3		},	//
; 2224 : 		{	"b-moll",	ks_mf2		},	//bbbbb
; 2225 : 		{	"bs-moll",	ks_mf2		},	//bbbbb
; 2226 : 		{	"h-moll",	ks_ms5		},	//##
; 2227 : 
; 2228 : 		//y_IBnI
; 2229 : 		{	"ds-moll",	ks_mf5		},	//####
; 2230 : 		{	"des-moll",	ks_mf5		},	//####
; 2231 : 		{	"gs-moll",	ks_mf6		},	//###
; 2232 : 		{	"ges-moll",	ks_mf6		},	//###
; 2233 : 		{	"as-moll",	ks_mf4		},	//#####
; 2234 : 
; 2235 : 		{	"+",		ks_Sharp	},
; 2236 : 		{	"{",		ks_Sharp	},
; 2237 : 		{	"#",		ks_Sharp	},
; 2238 : 		{	"",		ks_Sharp	},
; 2239 : 		{	"-",		ks_Flat		},
; 2240 : 		{	"|",		ks_Flat		},
; 2241 : 		{	"",		ks_Flat		},
; 2242 : 		{	"=",		ks_Natural	},
; 2243 : 		{	"",		ks_Natural	},
; 2244 : 		{	"*",		ks_Natural	},
; 2245 : 		{	"",		ks_Natural	},
; 2246 : 
; 2247 : 		{	"c",		ks_c		},
; 2248 : 		{	"d",		ks_d		},
; 2249 : 		{	"e",		ks_e		},
; 2250 : 		{	"f",		ks_f		},
; 2251 : 		{	"g",		ks_g		},
; 2252 : 		{	"a",		ks_a		},
; 2253 : 		{	"b",		ks_b		},
; 2254 : 		{	"r",		ks_r		},
; 2255 : 
; 2256 : 		{	"h",		ks_c		},
; 2257 : 		{	"",		ks_d		},
; 2258 : 		{	"~",		ks_e		},
; 2259 : 		{	"t@",		ks_f		},
; 2260 : 		{	"t",		ks_f		},
; 2261 : 		{	"\",		ks_g		},
; 2262 : 		{	"",		ks_a		},
; 2263 : 		{	"V",		ks_b		},
; 2264 : 		{	"",		ks_r		},
; 2265 : 		{	"b",		ks_r		},
; 2266 : 
; 2267 : 		{	"",		ks_c		},
; 2268 : 		{	"",		ks_d		},
; 2269 : 		{	"",		ks_e		},
; 2270 : 		{	"",		ks_f		},
; 2271 : 		{	"",		ks_f		},
; 2272 : 		{	"",		ks_g		},
; 2273 : 		{	"",		ks_a		},
; 2274 : 		{	"",		ks_b		},
; 2275 : 		{	"",		ks_r		},
; 2276 : 		{	"",		ks_r		},
; 2277 : 
; 2278 : 		{	"n",		ks_c		},
; 2279 : 		{	"j",		ks_d		},
; 2280 : 		{	"z",		ks_e		},
; 2281 : 		{	"w",		ks_f		},
; 2282 : 		{	"g",		ks_g		},
; 2283 : 		{	"C",		ks_a		},
; 2284 : 		{	"",		ks_b		}
; 2285 : 
; 2286 : 	};
; 2287 : 
; 2288 : 	unsigned	char	cData;
; 2289 : 				char	sign = 0;

  013a7	c6 44 24 0c 00	 mov	 BYTE PTR _sign$[esp+4], 0

; 2290 : 
; 2291 : 	while(MML->cRead() != '{'){

  013ac	eb 0f		 jmp	 SHORT $L104847
$L25568:

; 2292 : 		if(MML->eof()){

  013ae	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  013b1	8b 08		 mov	 ecx, DWORD PTR [eax]
  013b3	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  013b6	f6 44 01 08 01	 test	 BYTE PTR [ecx+eax+8], 1
  013bb	75 55		 jne	 SHORT $L104841
$L104847:

; 2290 : 
; 2291 : 	while(MML->cRead() != '{'){

  013bd	e8 00 00 00 00	 call	 ?cRead@MMLfile@@QAEDXZ	; MMLfile::cRead
  013c2	3c 7b		 cmp	 al, 123			; 0000007bH
  013c4	75 e8		 jne	 SHORT $L25568
  013c6	57		 push	 edi

; 2294 : 		}
; 2295 : 	}
; 2296 : 
; 2297 : 	// } ALqubNRpCB
; 2298 : 	while((cData = MML->GetChar()) != '}'){

  013c7	8b fe		 mov	 edi, esi
  013c9	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar
  013ce	3c 7d		 cmp	 al, 125			; 0000007dH
  013d0	0f 84 56 02 00
	00		 je	 $L104843
  013d6	53		 push	 ebx
  013d7	6a 05		 push	 5
  013d9	5b		 pop	 ebx
$L25573:

; 2299 : 		
; 2300 : 		// } OA[EOF]G[
; 2301 : 		if( MML->eof() ){

  013da	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  013dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  013df	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  013e2	f6 44 01 08 01	 test	 BYTE PTR [ecx+eax+8], 1

; 2303 : 		}
; 2304 : 
; 2305 : 		//P
; 2306 : 		MML->Back();

  013e7	8b c6		 mov	 eax, esi
  013e9	0f 85 43 02 00
	00		 jne	 $L104842
  013ef	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back

; 2307 : 
; 2308 : 		switch(MML->GetCommandID(KS_Command, sizeof(KS_Command)/sizeof(Command_Info))){

  013f4	6a 51		 push	 81			; 00000051H
  013f6	68 00 00 00 00	 push	 OFFSET FLAT:?KS_Command@?1??SetKeySignature@MusicTrack@@QAEXPAVMMLfile@@@Z@4QBUCommand_Info@@B
  013fb	8b c6		 mov	 eax, esi
  013fd	e8 00 00 00 00	 call	 ?GetCommandID@MMLfile@@QAEHQBUCommand_Info@@I@Z ; MMLfile::GetCommandID
  01402	83 f8 29	 cmp	 eax, 41			; 00000029H
  01405	0f 87 2e 02 00
	00		 ja	 $L25622
  0140b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L104855[eax*4]
$L104841:

; 2293 : 			MML->Err(_T("R}hEubNJn{B"));

  01412	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DI@JCDDEPJK@?$IK?$LPS?w0?$LD0?$NO0?s0?I0?$PL0?V0?m0?C0?$KP0n?$JF?$ILY?K0?$JCy?30Y?$AA?$HL0L?$IJ?$IL@
  01417	8b c6		 mov	 eax, esi
  01419	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L104856:
$L25582:

; 2309 : 			case(ks_c):
; 2310 : 				KeySignature[0] = sign;

  0141e	8a 44 24 14	 mov	 al, BYTE PTR _sign$[esp+12]
  01422	88 85 c8 00 00
	00		 mov	 BYTE PTR [ebp+200], al

; 2311 : 				break;

  01428	e9 ef 01 00 00	 jmp	 $L25579
$L25583:

; 2312 : 			case(ks_d):
; 2313 : 				KeySignature[1] = sign;

  0142d	8a 44 24 14	 mov	 al, BYTE PTR _sign$[esp+12]
  01431	88 85 c9 00 00
	00		 mov	 BYTE PTR [ebp+201], al

; 2314 : 				break;

  01437	e9 e0 01 00 00	 jmp	 $L25579
$L25584:

; 2315 : 			case(ks_e):
; 2316 : 				KeySignature[2] = sign;

  0143c	8a 44 24 14	 mov	 al, BYTE PTR _sign$[esp+12]
  01440	88 85 ca 00 00
	00		 mov	 BYTE PTR [ebp+202], al

; 2317 : 				break;

  01446	e9 d1 01 00 00	 jmp	 $L25579
$L25585:

; 2318 : 			case(ks_f):
; 2319 : 				KeySignature[3] = sign;

  0144b	8a 44 24 14	 mov	 al, BYTE PTR _sign$[esp+12]
  0144f	88 85 cb 00 00
	00		 mov	 BYTE PTR [ebp+203], al

; 2320 : 				break;

  01455	e9 c2 01 00 00	 jmp	 $L25579
$L25586:

; 2321 : 			case(ks_g):
; 2322 : 				KeySignature[4] = sign;

  0145a	8a 44 24 14	 mov	 al, BYTE PTR _sign$[esp+12]
  0145e	88 85 cc 00 00
	00		 mov	 BYTE PTR [ebp+204], al

; 2323 : 				break;

  01464	e9 b3 01 00 00	 jmp	 $L25579
$L25587:

; 2324 : 			case(ks_a):
; 2325 : 				KeySignature[5] = sign;

  01469	8a 44 24 14	 mov	 al, BYTE PTR _sign$[esp+12]
  0146d	88 85 cd 00 00
	00		 mov	 BYTE PTR [ebp+205], al

; 2326 : 				break;

  01473	e9 a4 01 00 00	 jmp	 $L25579
$L25588:

; 2327 : 			case(ks_b):
; 2328 : 				KeySignature[6] = sign;

  01478	8a 44 24 14	 mov	 al, BYTE PTR _sign$[esp+12]
  0147c	88 85 ce 00 00
	00		 mov	 BYTE PTR [ebp+206], al

; 2329 : 				break;

  01482	e9 95 01 00 00	 jmp	 $L25579
$L25589:

; 2330 : 			case(ks_r):
; 2331 : 				KeySignature[7] = sign;

  01487	8a 44 24 14	 mov	 al, BYTE PTR _sign$[esp+12]
  0148b	88 85 cf 00 00
	00		 mov	 BYTE PTR [ebp+207], al

; 2332 : 				break;

  01491	e9 86 01 00 00	 jmp	 $L25579
$L25590:

; 2333 : 			case(ks_Natural):
; 2334 : 				sign = 0;

  01496	c6 44 24 14 00	 mov	 BYTE PTR _sign$[esp+12], 0

; 2335 : 				break;

  0149b	e9 7c 01 00 00	 jmp	 $L25579
$L25591:

; 2336 : 			case(ks_Sharp):
; 2337 : 				sign = 1;

  014a0	c6 44 24 14 01	 mov	 BYTE PTR _sign$[esp+12], 1

; 2338 : 				break;

  014a5	e9 72 01 00 00	 jmp	 $L25579
$L25592:

; 2339 : 			case(ks_Flat):
; 2340 : 				sign = -1;

  014aa	c6 44 24 14 ff	 mov	 BYTE PTR _sign$[esp+12], -1

; 2341 : 				break;

  014af	e9 68 01 00 00	 jmp	 $L25579
$L25593:

; 2342 : 
; 2343 : 			case(ks_0):
; 2344 : 				nowKey		= 0;

  014b4	c6 85 d0 00 00
	00 00		 mov	 BYTE PTR [ebp+208], 0

; 2345 : 				nowScale	= 0;
; 2346 : 				SetKey(nowKey, nowScale);

  014bb	6a 00		 push	 0

; 2347 : 				break;

  014bd	eb 75		 jmp	 SHORT $L104853
$L25594:

; 2348 : 			case(ks_s1):
; 2349 : 				nowKey		= 1;

  014bf	c6 85 d0 00 00
	00 01		 mov	 BYTE PTR [ebp+208], 1

; 2350 : 				nowScale	= 0;
; 2351 : 				SetKey(nowKey, nowScale);

  014c6	6a 01		 push	 1

; 2352 : 				break;

  014c8	eb 6a		 jmp	 SHORT $L104853
$L25595:

; 2353 : 			case(ks_s2):
; 2354 : 				nowKey		= 2;

  014ca	c6 85 d0 00 00
	00 02		 mov	 BYTE PTR [ebp+208], 2

; 2355 : 				nowScale	= 0;
; 2356 : 				SetKey(nowKey, nowScale);

  014d1	6a 02		 push	 2

; 2357 : 				break;

  014d3	eb 5f		 jmp	 SHORT $L104853
$L25596:

; 2358 : 			case(ks_s3):
; 2359 : 				nowKey		= 3;

  014d5	c6 85 d0 00 00
	00 03		 mov	 BYTE PTR [ebp+208], 3

; 2360 : 				nowScale	= 0;
; 2361 : 				SetKey(nowKey, nowScale);

  014dc	6a 03		 push	 3

; 2362 : 				break;

  014de	eb 54		 jmp	 SHORT $L104853
$L25597:

; 2363 : 			case(ks_s4):
; 2364 : 				nowKey		= 4;

  014e0	c6 85 d0 00 00
	00 04		 mov	 BYTE PTR [ebp+208], 4

; 2365 : 				nowScale	= 0;
; 2366 : 				SetKey(nowKey, nowScale);

  014e7	6a 04		 push	 4

; 2367 : 				break;

  014e9	eb 49		 jmp	 SHORT $L104853
$L25598:

; 2368 : 			case(ks_s5):
; 2369 : 				nowKey		= 5;

  014eb	88 9d d0 00 00
	00		 mov	 BYTE PTR [ebp+208], bl

; 2370 : 				nowScale	= 0;
; 2371 : 				SetKey(nowKey, nowScale);

  014f1	53		 push	 ebx

; 2372 : 				break;

  014f2	eb 40		 jmp	 SHORT $L104853
$L25599:

; 2373 : 			case(ks_s6):
; 2374 : 				nowKey		= 6;

  014f4	c6 85 d0 00 00
	00 06		 mov	 BYTE PTR [ebp+208], 6

; 2375 : 				nowScale	= 0;
; 2376 : 				SetKey(nowKey, nowScale);

  014fb	6a 06		 push	 6

; 2377 : 				break;

  014fd	eb 35		 jmp	 SHORT $L104853
$L25600:

; 2378 : 			case(ks_f1):
; 2379 : 				nowKey		= -1;

  014ff	c6 85 d0 00 00
	00 ff		 mov	 BYTE PTR [ebp+208], -1

; 2380 : 				nowScale	= 0;
; 2381 : 				SetKey(nowKey, nowScale);

  01506	6a ff		 push	 -1

; 2382 : 				break;

  01508	eb 2a		 jmp	 SHORT $L104853
$L25601:

; 2383 : 			case(ks_f2):
; 2384 : 				nowKey		= -2;

  0150a	c6 85 d0 00 00
	00 fe		 mov	 BYTE PTR [ebp+208], -2	; fffffffeH

; 2385 : 				nowScale	= 0;
; 2386 : 				SetKey(nowKey, nowScale);

  01511	6a fe		 push	 -2			; fffffffeH

; 2387 : 				break;

  01513	eb 1f		 jmp	 SHORT $L104853
$L25602:

; 2388 : 			case(ks_f3):
; 2389 : 				nowKey		= -3;

  01515	c6 85 d0 00 00
	00 fd		 mov	 BYTE PTR [ebp+208], -3	; fffffffdH

; 2390 : 				nowScale	= 0;
; 2391 : 				SetKey(nowKey, nowScale);

  0151c	6a fd		 push	 -3			; fffffffdH

; 2392 : 				break;

  0151e	eb 14		 jmp	 SHORT $L104853
$L25603:

; 2393 : 			case(ks_f4):
; 2394 : 				nowKey		= -4;

  01520	c6 85 d0 00 00
	00 fc		 mov	 BYTE PTR [ebp+208], -4	; fffffffcH

; 2395 : 				nowScale	= 0;
; 2396 : 				SetKey(nowKey, nowScale);

  01527	6a fc		 push	 -4			; fffffffcH

; 2397 : 				break;

  01529	eb 09		 jmp	 SHORT $L104853
$L25604:

; 2398 : 			case(ks_f5):
; 2399 : 				nowKey		= -5;

  0152b	c6 85 d0 00 00
	00 fb		 mov	 BYTE PTR [ebp+208], -5	; fffffffbH

; 2400 : 				nowScale	= 0;
; 2401 : 				SetKey(nowKey, nowScale);

  01532	6a fb		 push	 -5			; fffffffbH
$L104853:
  01534	c6 85 d1 00 00
	00 00		 mov	 BYTE PTR [ebp+209], 0
  0153b	33 c9		 xor	 ecx, ecx

; 2402 : 				break;

  0153d	e9 d3 00 00 00	 jmp	 $L104848
$L25605:

; 2403 : 			case(ks_f6):
; 2404 : 				nowKey		= -6;
; 2405 : 				nowScale	= 0;

  01542	c6 85 d1 00 00
	00 00		 mov	 BYTE PTR [ebp+209], 0

; 2406 : 				SetKey(nowKey, nowScale);

  01549	33 c9		 xor	 ecx, ecx

; 2407 : 				break;

  0154b	e9 bc 00 00 00	 jmp	 $L104849
$L25606:

; 2408 : 
; 2409 : 			case(ks_m0):
; 2410 : 				nowKey		= 0;

  01550	c6 85 d0 00 00
	00 00		 mov	 BYTE PTR [ebp+208], 0

; 2411 : 				nowScale	= 5;
; 2412 : 				SetKey(nowKey, nowScale);

  01557	6a 00		 push	 0

; 2413 : 				break;

  01559	e9 9c 00 00 00	 jmp	 $L104854
$L25607:

; 2414 : 			case(ks_ms1):
; 2415 : 				nowKey		= 1;

  0155e	c6 85 d0 00 00
	00 01		 mov	 BYTE PTR [ebp+208], 1

; 2416 : 				nowScale	= 5;
; 2417 : 				SetKey(nowKey, nowScale);

  01565	6a 01		 push	 1

; 2418 : 				break;

  01567	e9 8e 00 00 00	 jmp	 $L104854
$L25608:

; 2419 : 			case(ks_ms2):
; 2420 : 				nowKey		= 2;

  0156c	c6 85 d0 00 00
	00 02		 mov	 BYTE PTR [ebp+208], 2

; 2421 : 				nowScale	= 5;
; 2422 : 				SetKey(nowKey, nowScale);

  01573	6a 02		 push	 2

; 2423 : 				break;

  01575	e9 80 00 00 00	 jmp	 $L104854
$L25609:

; 2424 : 			case(ks_ms3):
; 2425 : 				nowKey		= 3;

  0157a	c6 85 d0 00 00
	00 03		 mov	 BYTE PTR [ebp+208], 3

; 2426 : 				nowScale	= 5;
; 2427 : 				SetKey(nowKey, nowScale);

  01581	6a 03		 push	 3

; 2428 : 				break;

  01583	eb 75		 jmp	 SHORT $L104854
$L25610:

; 2429 : 			case(ks_ms4):
; 2430 : 				nowKey		= 4;

  01585	c6 85 d0 00 00
	00 04		 mov	 BYTE PTR [ebp+208], 4

; 2431 : 				nowScale	= 5;
; 2432 : 				SetKey(nowKey, nowScale);

  0158c	6a 04		 push	 4

; 2433 : 				break;

  0158e	eb 6a		 jmp	 SHORT $L104854
$L25611:

; 2434 : 			case(ks_ms5):
; 2435 : 				nowKey		= 5;

  01590	88 9d d0 00 00
	00		 mov	 BYTE PTR [ebp+208], bl

; 2436 : 				nowScale	= 5;
; 2437 : 				SetKey(nowKey, nowScale);

  01596	53		 push	 ebx

; 2438 : 				break;

  01597	eb 61		 jmp	 SHORT $L104854
$L25612:

; 2439 : 			case(ks_ms6):
; 2440 : 				nowKey		= 6;

  01599	c6 85 d0 00 00
	00 06		 mov	 BYTE PTR [ebp+208], 6

; 2441 : 				nowScale	= 5;
; 2442 : 				SetKey(nowKey, nowScale);

  015a0	6a 06		 push	 6

; 2443 : 				break;

  015a2	eb 56		 jmp	 SHORT $L104854
$L25613:

; 2444 : 			case(ks_ms7):
; 2445 : 				nowKey		= 7;

  015a4	c6 85 d0 00 00
	00 07		 mov	 BYTE PTR [ebp+208], 7

; 2446 : 				nowScale	= 5;
; 2447 : 				SetKey(nowKey, nowScale);

  015ab	6a 07		 push	 7

; 2448 : 				break;

  015ad	eb 4b		 jmp	 SHORT $L104854
$L25614:

; 2449 : 			case(ks_ms8):
; 2450 : 				nowKey		= 8;

  015af	c6 85 d0 00 00
	00 08		 mov	 BYTE PTR [ebp+208], 8

; 2451 : 				nowScale	= 5;
; 2452 : 				SetKey(nowKey, nowScale);

  015b6	6a 08		 push	 8

; 2453 : 				break;

  015b8	eb 40		 jmp	 SHORT $L104854
$L25615:

; 2454 : 			case(ks_ms9):
; 2455 : 				nowKey		= 9;

  015ba	c6 85 d0 00 00
	00 09		 mov	 BYTE PTR [ebp+208], 9

; 2456 : 				nowScale	= 5;
; 2457 : 				SetKey(nowKey, nowScale);

  015c1	6a 09		 push	 9

; 2458 : 				break;

  015c3	eb 35		 jmp	 SHORT $L104854
$L25616:

; 2459 : 
; 2460 : 
; 2461 : 
; 2462 : 			case(ks_mf1):
; 2463 : 				nowKey		= -1;

  015c5	c6 85 d0 00 00
	00 ff		 mov	 BYTE PTR [ebp+208], -1

; 2464 : 				nowScale	= 5;
; 2465 : 				SetKey(nowKey, nowScale);

  015cc	6a ff		 push	 -1

; 2466 : 				break;

  015ce	eb 2a		 jmp	 SHORT $L104854
$L25617:

; 2467 : 			case(ks_mf2):
; 2468 : 				nowKey		= -2;

  015d0	c6 85 d0 00 00
	00 fe		 mov	 BYTE PTR [ebp+208], -2	; fffffffeH

; 2469 : 				nowScale	= 5;
; 2470 : 				SetKey(nowKey, nowScale);

  015d7	6a fe		 push	 -2			; fffffffeH

; 2471 : 				break;

  015d9	eb 1f		 jmp	 SHORT $L104854
$L25618:

; 2472 : 			case(ks_mf3):
; 2473 : 				nowKey		= -3;

  015db	c6 85 d0 00 00
	00 fd		 mov	 BYTE PTR [ebp+208], -3	; fffffffdH

; 2474 : 				nowScale	= 5;
; 2475 : 				SetKey(nowKey, nowScale);

  015e2	6a fd		 push	 -3			; fffffffdH

; 2476 : 				break;

  015e4	eb 14		 jmp	 SHORT $L104854
$L25619:

; 2477 : 			case(ks_mf4):
; 2478 : 				nowKey		= -4;

  015e6	c6 85 d0 00 00
	00 fc		 mov	 BYTE PTR [ebp+208], -4	; fffffffcH

; 2479 : 				nowScale	= 5;
; 2480 : 				SetKey(nowKey, nowScale);

  015ed	6a fc		 push	 -4			; fffffffcH

; 2481 : 				break;

  015ef	eb 09		 jmp	 SHORT $L104854
$L25620:

; 2482 : 			case(ks_mf5):
; 2483 : 				nowKey		= -5;

  015f1	c6 85 d0 00 00
	00 fb		 mov	 BYTE PTR [ebp+208], -5	; fffffffbH

; 2484 : 				nowScale	= 5;
; 2485 : 				SetKey(nowKey, nowScale);

  015f8	6a fb		 push	 -5			; fffffffbH
$L104854:
  015fa	88 9d d1 00 00
	00		 mov	 BYTE PTR [ebp+209], bl
  01600	8b cb		 mov	 ecx, ebx

; 2486 : 				break;

  01602	eb 11		 jmp	 SHORT $L104848
$L25621:

; 2487 : 			case(ks_mf6):
; 2488 : 				nowKey		= -6;
; 2489 : 				nowScale	= 5;

  01604	88 9d d1 00 00
	00		 mov	 BYTE PTR [ebp+209], bl

; 2490 : 				SetKey(nowKey, nowScale);

  0160a	8b cb		 mov	 ecx, ebx
$L104849:
  0160c	c6 85 d0 00 00
	00 fa		 mov	 BYTE PTR [ebp+208], -6	; fffffffaH
  01613	6a fa		 push	 -6			; fffffffaH
$L104848:
  01615	8b fd		 mov	 edi, ebp
  01617	e8 00 00 00 00	 call	 ?SetKey@MusicTrack@@QAEXHH@Z ; MusicTrack::SetKey
$L25579:
  0161c	8b fe		 mov	 edi, esi
  0161e	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar
  01623	3c 7d		 cmp	 al, 125			; 0000007dH
  01625	0f 85 af fd ff
	ff		 jne	 $L25573
  0162b	5b		 pop	 ebx
$L104843:
  0162c	5f		 pop	 edi
  0162d	5e		 pop	 esi
  0162e	5d		 pop	 ebp

; 2495 : 				break;
; 2496 : 		}
; 2497 : 	}
; 2498 : 
; 2499 : 	//for Debug
; 2500 : /*
; 2501 : 	_COUT << _T("[0] c = ") << (int)KeySignature[0] << endl;
; 2502 : 	_COUT << _T("[1] d = ") << (int)KeySignature[1] << endl;
; 2503 : 	_COUT << _T("[2] e = ") << (int)KeySignature[2] << endl;
; 2504 : 	_COUT << _T("[3] f = ") << (int)KeySignature[3] << endl;
; 2505 : 	_COUT << _T("[4] g = ") << (int)KeySignature[4] << endl;
; 2506 : 	_COUT << _T("[5] a = ") << (int)KeySignature[5] << endl;
; 2507 : 	_COUT << _T("[6] b = ") << (int)KeySignature[6] << endl;
; 2508 : */
; 2509 : }

  0162f	c2 04 00	 ret	 4
$L104842:

; 2302 : 			MML->Err(_T("R}hEubNI[`}'B"));

  01632	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DI@GALIBNKP@?$IK?$LPS?w0?$LD0?$NO0?s0?I0?$PL0?V0?m0?C0?$KP0n?$HNBz?o0?$JCy?30Y?$AA?$GA?$AA?$HN?$AA?8@
  01637	eb 07		 jmp	 SHORT $L104852
$L25622:

; 2491 : 				break;
; 2492 : 
; 2493 : 			default:
; 2494 : 				MML->Err(_T(" K{} R}hmwB"));

  01639	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DM@KNFDIHJH@?$IK?$LPS?w?$AA?5?$AAK?$AA?$HL?$AA?$HN?$AA?50?$LD0?$NO0?s0?I0n_?$BFep0gg?$CKw?e0ne?$IH?$FLW@
  0163e	8b c6		 mov	 eax, esi
$L104852:
  01640	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L104857:
$L104845:
$L104855:

; 2495 : 				break;
; 2496 : 		}
; 2497 : 	}
; 2498 : 
; 2499 : 	//for Debug
; 2500 : /*
; 2501 : 	_COUT << _T("[0] c = ") << (int)KeySignature[0] << endl;
; 2502 : 	_COUT << _T("[1] d = ") << (int)KeySignature[1] << endl;
; 2503 : 	_COUT << _T("[2] e = ") << (int)KeySignature[2] << endl;
; 2504 : 	_COUT << _T("[3] f = ") << (int)KeySignature[3] << endl;
; 2505 : 	_COUT << _T("[4] g = ") << (int)KeySignature[4] << endl;
; 2506 : 	_COUT << _T("[5] a = ") << (int)KeySignature[5] << endl;
; 2507 : 	_COUT << _T("[6] b = ") << (int)KeySignature[6] << endl;
; 2508 : */
; 2509 : }

  01645	00 00 00 00	 DD	 $L25591
  01649	00 00 00 00	 DD	 $L25592
  0164d	00 00 00 00	 DD	 $L25590
  01651	00 00 00 00	 DD	 $L25582
  01655	00 00 00 00	 DD	 $L25583
  01659	00 00 00 00	 DD	 $L25584
  0165d	00 00 00 00	 DD	 $L25585
  01661	00 00 00 00	 DD	 $L25586
  01665	00 00 00 00	 DD	 $L25587
  01669	00 00 00 00	 DD	 $L25588
  0166d	00 00 00 00	 DD	 $L25589
  01671	00 00 00 00	 DD	 $L25593
  01675	00 00 00 00	 DD	 $L25594
  01679	00 00 00 00	 DD	 $L25595
  0167d	00 00 00 00	 DD	 $L25596
  01681	00 00 00 00	 DD	 $L25597
  01685	00 00 00 00	 DD	 $L25598
  01689	00 00 00 00	 DD	 $L25599
  0168d	00 00 00 00	 DD	 $L25622
  01691	00 00 00 00	 DD	 $L25600
  01695	00 00 00 00	 DD	 $L25601
  01699	00 00 00 00	 DD	 $L25602
  0169d	00 00 00 00	 DD	 $L25603
  016a1	00 00 00 00	 DD	 $L25604
  016a5	00 00 00 00	 DD	 $L25605
  016a9	00 00 00 00	 DD	 $L25622
  016ad	00 00 00 00	 DD	 $L25606
  016b1	00 00 00 00	 DD	 $L25607
  016b5	00 00 00 00	 DD	 $L25608
  016b9	00 00 00 00	 DD	 $L25609
  016bd	00 00 00 00	 DD	 $L25610
  016c1	00 00 00 00	 DD	 $L25611
  016c5	00 00 00 00	 DD	 $L25612
  016c9	00 00 00 00	 DD	 $L25613
  016cd	00 00 00 00	 DD	 $L25614
  016d1	00 00 00 00	 DD	 $L25615
  016d5	00 00 00 00	 DD	 $L25616
  016d9	00 00 00 00	 DD	 $L25617
  016dd	00 00 00 00	 DD	 $L25618
  016e1	00 00 00 00	 DD	 $L25619
  016e5	00 00 00 00	 DD	 $L25620
  016e9	00 00 00 00	 DD	 $L25621
?SetKeySignature@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP	; MusicTrack::SetKeySignature
_TEXT	ENDS
PUBLIC	?Set_u@MusicTrack@@QAEXH@Z			; MusicTrack::Set_u
$T104867 DD	0ffffffffH
	DD	FLAT:$L104863
$T104865 DD	019930520H
	DD	01H
	DD	FLAT:$T104867
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T104860 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Set_u@MusicTrack@@QAEXH@Z PROC NEAR			; MusicTrack::Set_u
; _this$ = edi
; _i$ = esi

; 1766 : {

  016ed	b8 00 00 00 00	 mov	 eax, __ehhandler$?Set_u@MusicTrack@@QAEXH@Z
  016f2	e8 00 00 00 00	 call	 __EH_prolog
  016f7	51		 push	 ecx

; 1767 : 	if(opt_gatetime_u != i){

  016f8	8d 87 b8 00 00
	00		 lea	 eax, DWORD PTR [edi+184]
  016fe	39 30		 cmp	 DWORD PTR [eax], esi
  01700	74 33		 je	 SHORT $L25289

; 1768 : 		opt_gatetime_u = i;
; 1769 : 		SetEvent(new mml_general(nsd_GateTime_u, (unsigned char)i, _T("GateTime(u)")));

  01702	6a 3c		 push	 60			; 0000003cH
  01704	89 30		 mov	 DWORD PTR [eax], esi
  01706	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0170b	59		 pop	 ecx
  0170c	89 45 f0	 mov	 DWORD PTR $T104860[ebp], eax
  0170f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  01713	85 c0		 test	 eax, eax
  01715	74 10		 je	 SHORT $L104861
  01717	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BI@IPILGHHC@?$AAG?$AAa?$AAt?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@
  0171c	56		 push	 esi
  0171d	6a 0b		 push	 11			; 0000000bH
  0171f	50		 push	 eax
  01720	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EDQBG@Z ; mml_general::mml_general
  01725	eb 02		 jmp	 SHORT $L104862
$L104861:
  01727	33 c0		 xor	 eax, eax
$L104862:
  01729	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0172d	50		 push	 eax
  0172e	8b c7		 mov	 eax, edi
  01730	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent
$L25289:

; 1770 : 	}	
; 1771 : }

  01735	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01738	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0173f	c9		 leave
  01740	c3		 ret	 0
$L104863:
  006bd	ff 75 f0	 push	 DWORD PTR $T104860[ebp]
  006c0	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  006c5	59		 pop	 ecx
  006c6	c3		 ret	 0
__ehhandler$?Set_u@MusicTrack@@QAEXH@Z:
  006c7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T104865
  006cc	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?Set_u@MusicTrack@@QAEXH@Z ENDP				; MusicTrack::Set_u
PUBLIC	?Set_q@MusicTrack@@QAEXH@Z			; MusicTrack::Set_q
$T104882 DD	0ffffffffH
	DD	FLAT:$L104877
	DD	0ffffffffH
	DD	FLAT:$L104878
$T104880 DD	019930520H
	DD	02H
	DD	FLAT:$T104882
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T104874 = -16						; size = 4
$T104870 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Set_q@MusicTrack@@QAEXH@Z PROC NEAR			; MusicTrack::Set_q
; _this$ = esi
; _i$ = ecx

; 1745 : {

  01741	b8 00 00 00 00	 mov	 eax, __ehhandler$?Set_q@MusicTrack@@QAEXH@Z
  01746	e8 00 00 00 00	 call	 __EH_prolog
  0174b	51		 push	 ecx
  0174c	53		 push	 ebx
  0174d	8b d9		 mov	 ebx, ecx

; 1746 : 	if(opt_gatetime_q != i){

  0174f	8d 86 b4 00 00
	00		 lea	 eax, DWORD PTR [esi+180]
  01755	39 18		 cmp	 DWORD PTR [eax], ebx
  01757	74 63		 je	 SHORT $L25278

; 1747 : 		opt_gatetime_q = i;
; 1748 : 		if( (i <= 15) && (i >= 0) ){

  01759	83 fb 0f	 cmp	 ebx, 15			; 0000000fH
  0175c	89 18		 mov	 DWORD PTR [eax], ebx
  0175e	7f 28		 jg	 SHORT $L25271
  01760	85 db		 test	 ebx, ebx
  01762	7c 24		 jl	 SHORT $L25271

; 1749 : 			SetEvent(new mml_general(nsd_GateTime_Byte + (unsigned char)i, _T("Gatetime(q) Byte")));

  01764	6a 3c		 push	 60			; 0000003cH
  01766	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0176b	59		 pop	 ecx
  0176c	89 45 f0	 mov	 DWORD PTR $T104870[ebp], eax
  0176f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  01773	85 c0		 test	 eax, eax
  01775	74 37		 je	 SHORT $L104875
  01777	80 c3 50	 add	 bl, 80			; 00000050H
  0177a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CC@EMHPIIFB@?$AAG?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AA?$CI?$AAq?$AA?$CJ?$AA?5?$AAB?$AAy?$AAt?$AAe?$AA?$AA@
  0177f	53		 push	 ebx
  01780	50		 push	 eax
  01781	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  01786	eb 28		 jmp	 SHORT $L104876
$L25271:

; 1750 : 		} else {
; 1751 : 			SetEvent(new mml_general(nsd_GateTime_q, (unsigned char)i, _T("Gatetime(q)")));

  01788	6a 3c		 push	 60			; 0000003cH
  0178a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0178f	59		 pop	 ecx
  01790	89 45 f0	 mov	 DWORD PTR $T104874[ebp], eax
  01793	85 c0		 test	 eax, eax
  01795	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0179c	74 10		 je	 SHORT $L104875
  0179e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BI@DCFFOBJ@?$AAG?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AA?$CI?$AAq?$AA?$CJ?$AA?$AA@
  017a3	53		 push	 ebx
  017a4	6a 0a		 push	 10			; 0000000aH
  017a6	50		 push	 eax
  017a7	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EDQBG@Z ; mml_general::mml_general
  017ac	eb 02		 jmp	 SHORT $L104876
$L104875:
  017ae	33 c0		 xor	 eax, eax
$L104876:
  017b0	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  017b4	50		 push	 eax
  017b5	8b c6		 mov	 eax, esi
  017b7	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent
$L25278:

; 1752 : 		}
; 1753 : 	}
; 1754 : 
; 1755 : }

  017bc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  017bf	5b		 pop	 ebx
  017c0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  017c7	c9		 leave
  017c8	c3		 ret	 0
$L104877:
  006d1	ff 75 f0	 push	 DWORD PTR $T104870[ebp]
  006d4	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  006d9	59		 pop	 ecx
  006da	c3		 ret	 0
$L104878:
  006db	ff 75 f0	 push	 DWORD PTR $T104874[ebp]
  006de	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  006e3	59		 pop	 ecx
  006e4	c3		 ret	 0
__ehhandler$?Set_q@MusicTrack@@QAEXH@Z:
  006e5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T104880
  006ea	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?Set_q@MusicTrack@@QAEXH@Z ENDP				; MusicTrack::Set_q
PUBLIC	?SetSweep@MusicTrack@@QAEXE@Z			; MusicTrack::SetSweep
$T104892 DD	0ffffffffH
	DD	FLAT:$L104888
$T104890 DD	019930520H
	DD	01H
	DD	FLAT:$T104892
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T104885 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetSweep@MusicTrack@@QAEXE@Z PROC NEAR			; MusicTrack::SetSweep
; _this$ = esi
; __c$ = ebx

; 1563 : {

  017c9	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetSweep@MusicTrack@@QAEXE@Z
  017ce	e8 00 00 00 00	 call	 __EH_prolog
  017d3	51		 push	 ecx

; 1564 : 	//
; 1565 : 	if((f_opt_Sweep == false) || ((unsigned char)iSweep != _c)){

  017d4	8d 86 fa 01 00
	00		 lea	 eax, DWORD PTR [esi+506]
  017da	80 38 00	 cmp	 BYTE PTR [eax], 0
  017dd	74 08		 je	 SHORT $L25165
  017df	38 9e e8 01 00
	00		 cmp	 BYTE PTR [esi+488], bl
  017e5	74 3a		 je	 SHORT $L25164
$L25165:

; 1566 : 		iSweep		= _c;
; 1567 : 		f_opt_Sweep	= true;		//KtO
; 1568 : 		SetEvent(new mml_general(nsd_Sweep, _c, _T("Sweep")));

  017e7	6a 3c		 push	 60			; 0000003cH
  017e9	88 9e e8 01 00
	00		 mov	 BYTE PTR [esi+488], bl
  017ef	c6 00 01	 mov	 BYTE PTR [eax], 1
  017f2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  017f7	59		 pop	 ecx
  017f8	89 45 f0	 mov	 DWORD PTR $T104885[ebp], eax
  017fb	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  017ff	85 c0		 test	 eax, eax
  01801	74 10		 je	 SHORT $L104886
  01803	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1M@HAFHLPCH@?$AAS?$AAw?$AAe?$AAe?$AAp?$AA?$AA@
  01808	53		 push	 ebx
  01809	6a 16		 push	 22			; 00000016H
  0180b	50		 push	 eax
  0180c	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EDQBG@Z ; mml_general::mml_general
  01811	eb 02		 jmp	 SHORT $L104887
$L104886:
  01813	33 c0		 xor	 eax, eax
$L104887:
  01815	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  01819	50		 push	 eax
  0181a	8b c6		 mov	 eax, esi
  0181c	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent
$L25164:

; 1569 : 	}
; 1570 : }

  01821	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01824	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0182b	c9		 leave
  0182c	c3		 ret	 0
$L104888:
  006ef	ff 75 f0	 push	 DWORD PTR $T104885[ebp]
  006f2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  006f7	59		 pop	 ecx
  006f8	c3		 ret	 0
__ehhandler$?SetSweep@MusicTrack@@QAEXE@Z:
  006f9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T104890
  006fe	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetSweep@MusicTrack@@QAEXE@Z ENDP			; MusicTrack::SetSweep
PUBLIC	?SetEnvelop_En@MusicTrack@@QAEXXZ		; MusicTrack::SetEnvelop_En
$T104902 DD	0ffffffffH
	DD	FLAT:$L104898
$T104900 DD	019930520H
	DD	01H
	DD	FLAT:$T104902
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T104895 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetEnvelop_En@MusicTrack@@QAEXXZ PROC NEAR		; MusicTrack::SetEnvelop_En
; _this$ = esi

; 1519 : {

  0182d	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetEnvelop_En@MusicTrack@@QAEXXZ
  01832	e8 00 00 00 00	 call	 __EH_prolog
  01837	51		 push	 ecx

; 1520 : 	if((f_opt_En == false) || (sw_En == true)){

  01838	8d 86 f8 01 00
	00		 lea	 eax, DWORD PTR [esi+504]
  0183e	80 38 00	 cmp	 BYTE PTR [eax], 0
  01841	74 09		 je	 SHORT $L25133
  01843	80 be f3 01 00
	00 01		 cmp	 BYTE PTR [esi+499], 1
  0184a	75 3a		 jne	 SHORT $L25132
$L25133:

; 1521 : 		sw_En		= false;
; 1522 : 		f_opt_En	= true;		//KtO
; 1523 : 		SetEvent(new mml_Address(nsd_Envelop_Note, _T("Note Envelope Off")));

  0184c	6a 44		 push	 68			; 00000044H
  0184e	c6 86 f3 01 00
	00 00		 mov	 BYTE PTR [esi+499], 0
  01855	c6 00 01	 mov	 BYTE PTR [eax], 1
  01858	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0185d	59		 pop	 ecx
  0185e	89 45 f0	 mov	 DWORD PTR $T104895[ebp], eax
  01861	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  01865	85 c0		 test	 eax, eax
  01867	74 0f		 je	 SHORT $L104896
  01869	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CE@KEOAGLPM@?$AAN?$AAo?$AAt?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?5?$AAO?$AAf?$AAf?$AA?$AA@
  0186e	6a 13		 push	 19			; 00000013H
  01870	50		 push	 eax
  01871	e8 00 00 00 00	 call	 ??0mml_Address@@QAE@EQBG@Z ; mml_Address::mml_Address
  01876	eb 02		 jmp	 SHORT $L104897
$L104896:
  01878	33 c0		 xor	 eax, eax
$L104897:
  0187a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0187e	50		 push	 eax
  0187f	8b c6		 mov	 eax, esi
  01881	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent
$L25132:

; 1524 : 	}
; 1525 : }

  01886	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01889	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01890	c9		 leave
  01891	c3		 ret	 0
$L104898:
  00703	ff 75 f0	 push	 DWORD PTR $T104895[ebp]
  00706	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0070b	59		 pop	 ecx
  0070c	c3		 ret	 0
__ehhandler$?SetEnvelop_En@MusicTrack@@QAEXXZ:
  0070d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T104900
  00712	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetEnvelop_En@MusicTrack@@QAEXXZ ENDP			; MusicTrack::SetEnvelop_En
PUBLIC	?SetEnvelop_Em@MusicTrack@@QAEXXZ		; MusicTrack::SetEnvelop_Em
$T104912 DD	0ffffffffH
	DD	FLAT:$L104908
$T104910 DD	019930520H
	DD	01H
	DD	FLAT:$T104912
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T104905 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetEnvelop_Em@MusicTrack@@QAEXXZ PROC NEAR		; MusicTrack::SetEnvelop_Em
; _this$ = esi

; 1509 : {

  01892	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetEnvelop_Em@MusicTrack@@QAEXXZ
  01897	e8 00 00 00 00	 call	 __EH_prolog
  0189c	51		 push	 ecx

; 1510 : 	if((f_opt_Em == false) || (sw_Em == true)){

  0189d	8d 86 f7 01 00
	00		 lea	 eax, DWORD PTR [esi+503]
  018a3	80 38 00	 cmp	 BYTE PTR [eax], 0
  018a6	74 09		 je	 SHORT $L25123
  018a8	80 be f2 01 00
	00 01		 cmp	 BYTE PTR [esi+498], 1
  018af	75 3a		 jne	 SHORT $L25122
$L25123:

; 1511 : 		sw_Em		= false;
; 1512 : 		f_opt_Em	= true;		//KtO
; 1513 : 		SetEvent(new mml_Address(nsd_Envelop_Frequency, _T("Frequency Envelope Off")));

  018b1	6a 44		 push	 68			; 00000044H
  018b3	c6 86 f2 01 00
	00 00		 mov	 BYTE PTR [esi+498], 0
  018ba	c6 00 01	 mov	 BYTE PTR [eax], 1
  018bd	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  018c2	59		 pop	 ecx
  018c3	89 45 f0	 mov	 DWORD PTR $T104905[ebp], eax
  018c6	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  018ca	85 c0		 test	 eax, eax
  018cc	74 0f		 je	 SHORT $L104906
  018ce	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CO@BJABPOLD@?$AAF?$AAr?$AAe?$AAq?$AAu?$AAe?$AAn?$AAc?$AAy?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?5?$AAO@
  018d3	6a 12		 push	 18			; 00000012H
  018d5	50		 push	 eax
  018d6	e8 00 00 00 00	 call	 ??0mml_Address@@QAE@EQBG@Z ; mml_Address::mml_Address
  018db	eb 02		 jmp	 SHORT $L104907
$L104906:
  018dd	33 c0		 xor	 eax, eax
$L104907:
  018df	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  018e3	50		 push	 eax
  018e4	8b c6		 mov	 eax, esi
  018e6	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent
$L25122:

; 1514 : 	}
; 1515 : }

  018eb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  018ee	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  018f5	c9		 leave
  018f6	c3		 ret	 0
$L104908:
  00717	ff 75 f0	 push	 DWORD PTR $T104905[ebp]
  0071a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0071f	59		 pop	 ecx
  00720	c3		 ret	 0
__ehhandler$?SetEnvelop_Em@MusicTrack@@QAEXXZ:
  00721	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T104910
  00726	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetEnvelop_Em@MusicTrack@@QAEXXZ ENDP			; MusicTrack::SetEnvelop_Em
PUBLIC	?SetEnvelop_Evol@MusicTrack@@QAEXXZ		; MusicTrack::SetEnvelop_Evol
$T104922 DD	0ffffffffH
	DD	FLAT:$L104918
$T104920 DD	019930520H
	DD	01H
	DD	FLAT:$T104922
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T104915 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetEnvelop_Evol@MusicTrack@@QAEXXZ PROC NEAR		; MusicTrack::SetEnvelop_Evol
; _this$ = esi

; 1499 : {

  018f7	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetEnvelop_Evol@MusicTrack@@QAEXXZ
  018fc	e8 00 00 00 00	 call	 __EH_prolog
  01901	51		 push	 ecx

; 1500 : 	if((f_opt_Evol == false) || (sw_Evol == true)){

  01902	8d 86 f6 01 00
	00		 lea	 eax, DWORD PTR [esi+502]
  01908	80 38 00	 cmp	 BYTE PTR [eax], 0
  0190b	74 09		 je	 SHORT $L25113
  0190d	80 be f1 01 00
	00 01		 cmp	 BYTE PTR [esi+497], 1
  01914	75 3a		 jne	 SHORT $L25112
$L25113:

; 1501 : 		sw_Evol		= false;
; 1502 : 		f_opt_Evol	= true;		//KtO
; 1503 : 		SetEvent(new mml_Address(nsd_Envelop_Volume, _T("Volume Envelope Off")));

  01916	6a 44		 push	 68			; 00000044H
  01918	c6 86 f1 01 00
	00 00		 mov	 BYTE PTR [esi+497], 0
  0191f	c6 00 01	 mov	 BYTE PTR [eax], 1
  01922	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01927	59		 pop	 ecx
  01928	89 45 f0	 mov	 DWORD PTR $T104915[ebp], eax
  0192b	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0192f	85 c0		 test	 eax, eax
  01931	74 0f		 je	 SHORT $L104916
  01933	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CI@DNAKKDOB@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?5?$AAO?$AAf?$AAf?$AA?$AA@
  01938	6a 11		 push	 17			; 00000011H
  0193a	50		 push	 eax
  0193b	e8 00 00 00 00	 call	 ??0mml_Address@@QAE@EQBG@Z ; mml_Address::mml_Address
  01940	eb 02		 jmp	 SHORT $L104917
$L104916:
  01942	33 c0		 xor	 eax, eax
$L104917:
  01944	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  01948	50		 push	 eax
  01949	8b c6		 mov	 eax, esi
  0194b	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent
$L25112:

; 1504 : 	}
; 1505 : }

  01950	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01953	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0195a	c9		 leave
  0195b	c3		 ret	 0
$L104918:
  0072b	ff 75 f0	 push	 DWORD PTR $T104915[ebp]
  0072e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00733	59		 pop	 ecx
  00734	c3		 ret	 0
__ehhandler$?SetEnvelop_Evol@MusicTrack@@QAEXXZ:
  00735	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T104920
  0073a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetEnvelop_Evol@MusicTrack@@QAEXXZ ENDP		; MusicTrack::SetEnvelop_Evol
PUBLIC	?SetVoice@MusicTrack@@QAEXI@Z			; MusicTrack::SetVoice
$T104932 DD	0ffffffffH
	DD	FLAT:$L104928
$T104930 DD	019930520H
	DD	01H
	DD	FLAT:$T104932
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T104925 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetVoice@MusicTrack@@QAEXI@Z PROC NEAR			; MusicTrack::SetVoice
; _this$ = esi
; __no$ = edi

; 1488 : {

  0195c	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetVoice@MusicTrack@@QAEXI@Z
  01961	e8 00 00 00 00	 call	 __EH_prolog
  01966	51		 push	 ecx

; 1489 : 	if((_no != nsd.voice) || (f_opt_Evoi == false) || (sw_Evoi == true)){

  01967	3b 7e 60	 cmp	 edi, DWORD PTR [esi+96]
  0196a	75 12		 jne	 SHORT $L25102
  0196c	80 be f5 01 00
	00 00		 cmp	 BYTE PTR [esi+501], 0
  01973	74 09		 je	 SHORT $L25102
  01975	80 be f0 01 00
	00 01		 cmp	 BYTE PTR [esi+496], 1
  0197c	75 42		 jne	 SHORT $L25101
$L25102:

; 1490 : 		nsd.voice			= _no;
; 1491 : 		sw_Evoi				= false;
; 1492 : 		f_opt_Evoi			= true;		//KtO
; 1493 : 		SetEvent(new mml_general(nsd_Voice, (unsigned char)_no, _T("Voice")));

  0197e	6a 3c		 push	 60			; 0000003cH
  01980	89 7e 60	 mov	 DWORD PTR [esi+96], edi
  01983	c6 86 f0 01 00
	00 00		 mov	 BYTE PTR [esi+496], 0
  0198a	c6 86 f5 01 00
	00 01		 mov	 BYTE PTR [esi+501], 1
  01991	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01996	59		 pop	 ecx
  01997	89 45 f0	 mov	 DWORD PTR $T104925[ebp], eax
  0199a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0199e	85 c0		 test	 eax, eax
  019a0	74 10		 je	 SHORT $L104926
  019a2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1M@DKLMFINE@?$AAV?$AAo?$AAi?$AAc?$AAe?$AA?$AA@
  019a7	57		 push	 edi
  019a8	6a 1b		 push	 27			; 0000001bH
  019aa	50		 push	 eax
  019ab	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EDQBG@Z ; mml_general::mml_general
  019b0	eb 02		 jmp	 SHORT $L104927
$L104926:
  019b2	33 c0		 xor	 eax, eax
$L104927:
  019b4	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  019b8	50		 push	 eax
  019b9	8b c6		 mov	 eax, esi
  019bb	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent
$L25101:

; 1494 : 	}
; 1495 : }

  019c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  019c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  019ca	c9		 leave
  019cb	c3		 ret	 0
$L104928:
  0073f	ff 75 f0	 push	 DWORD PTR $T104925[ebp]
  00742	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00747	59		 pop	 ecx
  00748	c3		 ret	 0
__ehhandler$?SetVoice@MusicTrack@@QAEXI@Z:
  00749	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T104930
  0074e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetVoice@MusicTrack@@QAEXI@Z ENDP			; MusicTrack::SetVoice
PUBLIC	?SetEnvelop_En@MusicTrack@@QAEXI@Z		; MusicTrack::SetEnvelop_En
$T104946 DD	0ffffffffH
	DD	FLAT:$L104938
$T104944 DD	019930520H
	DD	01H
	DD	FLAT:$T104946
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T104935 = -16						; size = 4
__event$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetEnvelop_En@MusicTrack@@QAEXI@Z PROC NEAR		; MusicTrack::SetEnvelop_En
; _this$ = ecx
; __no$ = edi

; 1471 : {

  019cc	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetEnvelop_En@MusicTrack@@QAEXI@Z
  019d1	e8 00 00 00 00	 call	 __EH_prolog
  019d6	51		 push	 ecx
  019d7	56		 push	 esi
  019d8	8b f1		 mov	 esi, ecx

; 1472 : 	mml_Address*		_event;
; 1473 : 
; 1474 : 	if((_no != nsd.env_note) || (f_opt_En == false) || (sw_En == false)){

  019da	3b 7e 74	 cmp	 edi, DWORD PTR [esi+116]
  019dd	75 12		 jne	 SHORT $L25091
  019df	80 be f8 01 00
	00 00		 cmp	 BYTE PTR [esi+504], 0
  019e6	74 09		 je	 SHORT $L25091
  019e8	80 be f3 01 00
	00 00		 cmp	 BYTE PTR [esi+499], 0
  019ef	75 59		 jne	 SHORT $L25090
$L25091:

; 1475 : 		nsd.env_note		= _no;
; 1476 : 		sw_En				= true;
; 1477 : 		f_opt_En			= true;		//KtO
; 1478 : 		_event				= new mml_Address(nsd_Envelop_Note, _T("Note Envelope"));

  019f1	6a 44		 push	 68			; 00000044H
  019f3	89 7e 74	 mov	 DWORD PTR [esi+116], edi
  019f6	c6 86 f3 01 00
	00 01		 mov	 BYTE PTR [esi+499], 1
  019fd	c6 86 f8 01 00
	00 01		 mov	 BYTE PTR [esi+504], 1
  01a04	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01a09	59		 pop	 ecx
  01a0a	89 45 f0	 mov	 DWORD PTR $T104935[ebp], eax
  01a0d	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  01a11	85 c0		 test	 eax, eax
  01a13	74 0f		 je	 SHORT $L104936
  01a15	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BM@CBOHIOMD@?$AAN?$AAo?$AAt?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@
  01a1a	6a 13		 push	 19			; 00000013H
  01a1c	50		 push	 eax
  01a1d	e8 00 00 00 00	 call	 ??0mml_Address@@QAE@EQBG@Z ; mml_Address::mml_Address
  01a22	eb 02		 jmp	 SHORT $L104937
$L104936:
  01a24	33 c0		 xor	 eax, eax
$L104937:
  01a26	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  01a2a	89 45 f0	 mov	 DWORD PTR __event$[ebp], eax

; 1479 : 
; 1480 : 		_event->set_id(_no);

  01a2d	c6 40 40 01	 mov	 BYTE PTR [eax+64], 1
  01a31	89 78 3c	 mov	 DWORD PTR [eax+60], edi

; 1481 : 		SetEvent(_event);

  01a34	50		 push	 eax
  01a35	8b c6		 mov	 eax, esi
  01a37	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 1482 : 		ptcEnv.push_back(_event);

  01a3c	8d 86 d8 02 00
	00		 lea	 eax, DWORD PTR [esi+728]
  01a42	8d 75 f0	 lea	 esi, DWORD PTR __event$[ebp]
  01a45	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEXABQAVmml_Address@@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::push_back
$L25090:

; 1483 : 	}
; 1484 : }

  01a4a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01a4d	5e		 pop	 esi
  01a4e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01a55	c9		 leave
  01a56	c3		 ret	 0
$L104938:
  00753	ff 75 f0	 push	 DWORD PTR $T104935[ebp]
  00756	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0075b	59		 pop	 ecx
  0075c	c3		 ret	 0
__ehhandler$?SetEnvelop_En@MusicTrack@@QAEXI@Z:
  0075d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T104944
  00762	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetEnvelop_En@MusicTrack@@QAEXI@Z ENDP			; MusicTrack::SetEnvelop_En
PUBLIC	?SetEnvelop_Em@MusicTrack@@QAEXI@Z		; MusicTrack::SetEnvelop_Em
$T104960 DD	0ffffffffH
	DD	FLAT:$L104952
$T104958 DD	019930520H
	DD	01H
	DD	FLAT:$T104960
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T104949 = -16						; size = 4
__event$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetEnvelop_Em@MusicTrack@@QAEXI@Z PROC NEAR		; MusicTrack::SetEnvelop_Em
; _this$ = ecx
; __no$ = edi

; 1454 : {

  01a57	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetEnvelop_Em@MusicTrack@@QAEXI@Z
  01a5c	e8 00 00 00 00	 call	 __EH_prolog
  01a61	51		 push	 ecx
  01a62	56		 push	 esi
  01a63	8b f1		 mov	 esi, ecx

; 1455 : 	mml_Address*		_event;
; 1456 : 
; 1457 : 	if((_no != nsd.env_frequency) || (f_opt_Em == false) || (sw_Em == false)){

  01a65	3b 7e 70	 cmp	 edi, DWORD PTR [esi+112]
  01a68	75 12		 jne	 SHORT $L25079
  01a6a	80 be f7 01 00
	00 00		 cmp	 BYTE PTR [esi+503], 0
  01a71	74 09		 je	 SHORT $L25079
  01a73	80 be f2 01 00
	00 00		 cmp	 BYTE PTR [esi+498], 0
  01a7a	75 59		 jne	 SHORT $L25078
$L25079:

; 1458 : 		nsd.env_frequency	= _no;
; 1459 : 		sw_Em				= true;
; 1460 : 		f_opt_Em			= true;		//KtO
; 1461 : 		_event				= new mml_Address(nsd_Envelop_Frequency, _T("Frequency Envelope"));

  01a7c	6a 44		 push	 68			; 00000044H
  01a7e	89 7e 70	 mov	 DWORD PTR [esi+112], edi
  01a81	c6 86 f2 01 00
	00 01		 mov	 BYTE PTR [esi+498], 1
  01a88	c6 86 f7 01 00
	00 01		 mov	 BYTE PTR [esi+503], 1
  01a8f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01a94	59		 pop	 ecx
  01a95	89 45 f0	 mov	 DWORD PTR $T104949[ebp], eax
  01a98	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  01a9c	85 c0		 test	 eax, eax
  01a9e	74 0f		 je	 SHORT $L104950
  01aa0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CG@HDOLOCJJ@?$AAF?$AAr?$AAe?$AAq?$AAu?$AAe?$AAn?$AAc?$AAy?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@
  01aa5	6a 12		 push	 18			; 00000012H
  01aa7	50		 push	 eax
  01aa8	e8 00 00 00 00	 call	 ??0mml_Address@@QAE@EQBG@Z ; mml_Address::mml_Address
  01aad	eb 02		 jmp	 SHORT $L104951
$L104950:
  01aaf	33 c0		 xor	 eax, eax
$L104951:
  01ab1	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  01ab5	89 45 f0	 mov	 DWORD PTR __event$[ebp], eax

; 1462 : 
; 1463 : 		_event->set_id(_no);

  01ab8	c6 40 40 01	 mov	 BYTE PTR [eax+64], 1
  01abc	89 78 3c	 mov	 DWORD PTR [eax+60], edi

; 1464 : 		SetEvent(_event);

  01abf	50		 push	 eax
  01ac0	8b c6		 mov	 eax, esi
  01ac2	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 1465 : 		ptcEnv.push_back(_event);

  01ac7	8d 86 d8 02 00
	00		 lea	 eax, DWORD PTR [esi+728]
  01acd	8d 75 f0	 lea	 esi, DWORD PTR __event$[ebp]
  01ad0	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEXABQAVmml_Address@@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::push_back
$L25078:

; 1466 : 	}
; 1467 : }

  01ad5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01ad8	5e		 pop	 esi
  01ad9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01ae0	c9		 leave
  01ae1	c3		 ret	 0
$L104952:
  00767	ff 75 f0	 push	 DWORD PTR $T104949[ebp]
  0076a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0076f	59		 pop	 ecx
  00770	c3		 ret	 0
__ehhandler$?SetEnvelop_Em@MusicTrack@@QAEXI@Z:
  00771	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T104958
  00776	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetEnvelop_Em@MusicTrack@@QAEXI@Z ENDP			; MusicTrack::SetEnvelop_Em
PUBLIC	?SetEnvelop_Evol@MusicTrack@@QAEXI@Z		; MusicTrack::SetEnvelop_Evol
$T104974 DD	0ffffffffH
	DD	FLAT:$L104966
$T104972 DD	019930520H
	DD	01H
	DD	FLAT:$T104974
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T104963 = -16						; size = 4
__event$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetEnvelop_Evol@MusicTrack@@QAEXI@Z PROC NEAR		; MusicTrack::SetEnvelop_Evol
; _this$ = ecx
; __no$ = edi

; 1437 : {

  01ae2	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetEnvelop_Evol@MusicTrack@@QAEXI@Z
  01ae7	e8 00 00 00 00	 call	 __EH_prolog
  01aec	51		 push	 ecx
  01aed	56		 push	 esi
  01aee	8b f1		 mov	 esi, ecx

; 1438 : 	mml_Address*		_event;
; 1439 : 
; 1440 : 	if((_no != nsd.env_voice) || (f_opt_Evol == false) || (sw_Evol == false)){

  01af0	3b 7e 6c	 cmp	 edi, DWORD PTR [esi+108]
  01af3	75 12		 jne	 SHORT $L25067
  01af5	80 be f6 01 00
	00 00		 cmp	 BYTE PTR [esi+502], 0
  01afc	74 09		 je	 SHORT $L25067
  01afe	80 be f1 01 00
	00 00		 cmp	 BYTE PTR [esi+497], 0
  01b05	75 59		 jne	 SHORT $L25066
$L25067:

; 1441 : 		nsd.env_voice		= _no;
; 1442 : 		sw_Evol				= true;
; 1443 : 		f_opt_Evol			= true;		//KtO
; 1444 : 		_event				= new mml_Address(nsd_Envelop_Volume, _T("Volume Envelope"));

  01b07	6a 44		 push	 68			; 00000044H
  01b09	89 7e 6c	 mov	 DWORD PTR [esi+108], edi
  01b0c	c6 86 f1 01 00
	00 01		 mov	 BYTE PTR [esi+497], 1
  01b13	c6 86 f6 01 00
	00 01		 mov	 BYTE PTR [esi+502], 1
  01b1a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01b1f	59		 pop	 ecx
  01b20	89 45 f0	 mov	 DWORD PTR $T104963[ebp], eax
  01b23	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  01b27	85 c0		 test	 eax, eax
  01b29	74 0f		 je	 SHORT $L104964
  01b2b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CA@BOAFBFBE@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@
  01b30	6a 11		 push	 17			; 00000011H
  01b32	50		 push	 eax
  01b33	e8 00 00 00 00	 call	 ??0mml_Address@@QAE@EQBG@Z ; mml_Address::mml_Address
  01b38	eb 02		 jmp	 SHORT $L104965
$L104964:
  01b3a	33 c0		 xor	 eax, eax
$L104965:
  01b3c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  01b40	89 45 f0	 mov	 DWORD PTR __event$[ebp], eax

; 1445 : 
; 1446 : 		_event->set_id(_no);

  01b43	c6 40 40 01	 mov	 BYTE PTR [eax+64], 1
  01b47	89 78 3c	 mov	 DWORD PTR [eax+60], edi

; 1447 : 		SetEvent(_event);

  01b4a	50		 push	 eax
  01b4b	8b c6		 mov	 eax, esi
  01b4d	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 1448 : 		ptcEnv.push_back(_event);

  01b52	8d 86 d8 02 00
	00		 lea	 eax, DWORD PTR [esi+728]
  01b58	8d 75 f0	 lea	 esi, DWORD PTR __event$[ebp]
  01b5b	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEXABQAVmml_Address@@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::push_back
$L25066:

; 1449 : 	}
; 1450 : }

  01b60	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01b63	5e		 pop	 esi
  01b64	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01b6b	c9		 leave
  01b6c	c3		 ret	 0
$L104966:
  0077b	ff 75 f0	 push	 DWORD PTR $T104963[ebp]
  0077e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00783	59		 pop	 ecx
  00784	c3		 ret	 0
__ehhandler$?SetEnvelop_Evol@MusicTrack@@QAEXI@Z:
  00785	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T104972
  0078a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetEnvelop_Evol@MusicTrack@@QAEXI@Z ENDP		; MusicTrack::SetEnvelop_Evol
PUBLIC	?SetEnvelop_Evoi@MusicTrack@@QAEXI@Z		; MusicTrack::SetEnvelop_Evoi
$T104988 DD	0ffffffffH
	DD	FLAT:$L104980
$T104986 DD	019930520H
	DD	01H
	DD	FLAT:$T104988
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T104977 = -16						; size = 4
__event$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetEnvelop_Evoi@MusicTrack@@QAEXI@Z PROC NEAR		; MusicTrack::SetEnvelop_Evoi
; _this$ = ecx
; __no$ = edi

; 1420 : {

  01b6d	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetEnvelop_Evoi@MusicTrack@@QAEXI@Z
  01b72	e8 00 00 00 00	 call	 __EH_prolog
  01b77	51		 push	 ecx
  01b78	56		 push	 esi
  01b79	8b f1		 mov	 esi, ecx

; 1421 : 	mml_Address*		_event;
; 1422 : 
; 1423 : 	if((_no != nsd.env_volume) || (f_opt_Evoi == false) || (sw_Evoi == false)){

  01b7b	3b 7e 68	 cmp	 edi, DWORD PTR [esi+104]
  01b7e	75 12		 jne	 SHORT $L25055
  01b80	80 be f5 01 00
	00 00		 cmp	 BYTE PTR [esi+501], 0
  01b87	74 09		 je	 SHORT $L25055
  01b89	80 be f0 01 00
	00 00		 cmp	 BYTE PTR [esi+496], 0
  01b90	75 59		 jne	 SHORT $L25054
$L25055:

; 1424 : 		nsd.env_volume		= _no;
; 1425 : 		sw_Evoi				= true;
; 1426 : 		f_opt_Evoi			= true;		//KtO
; 1427 : 		_event				= new mml_Address(nsd_Envelop_Voice, _T("Voice Envelope"));

  01b92	6a 44		 push	 68			; 00000044H
  01b94	89 7e 68	 mov	 DWORD PTR [esi+104], edi
  01b97	c6 86 f0 01 00
	00 01		 mov	 BYTE PTR [esi+496], 1
  01b9e	c6 86 f5 01 00
	00 01		 mov	 BYTE PTR [esi+501], 1
  01ba5	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01baa	59		 pop	 ecx
  01bab	89 45 f0	 mov	 DWORD PTR $T104977[ebp], eax
  01bae	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  01bb2	85 c0		 test	 eax, eax
  01bb4	74 0f		 je	 SHORT $L104978
  01bb6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BO@GFLIMKC@?$AAV?$AAo?$AAi?$AAc?$AAe?$AA?5?$AAE?$AAn?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AA?$AA@
  01bbb	6a 10		 push	 16			; 00000010H
  01bbd	50		 push	 eax
  01bbe	e8 00 00 00 00	 call	 ??0mml_Address@@QAE@EQBG@Z ; mml_Address::mml_Address
  01bc3	eb 02		 jmp	 SHORT $L104979
$L104978:
  01bc5	33 c0		 xor	 eax, eax
$L104979:
  01bc7	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  01bcb	89 45 f0	 mov	 DWORD PTR __event$[ebp], eax

; 1428 : 
; 1429 : 		_event->set_id(_no);

  01bce	c6 40 40 01	 mov	 BYTE PTR [eax+64], 1
  01bd2	89 78 3c	 mov	 DWORD PTR [eax+60], edi

; 1430 : 		SetEvent(_event);

  01bd5	50		 push	 eax
  01bd6	8b c6		 mov	 eax, esi
  01bd8	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 1431 : 		ptcEnv.push_back(_event);

  01bdd	8d 86 d8 02 00
	00		 lea	 eax, DWORD PTR [esi+728]
  01be3	8d 75 f0	 lea	 esi, DWORD PTR __event$[ebp]
  01be6	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEXABQAVmml_Address@@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::push_back
$L25054:

; 1432 : 	}
; 1433 : }

  01beb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01bee	5e		 pop	 esi
  01bef	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01bf6	c9		 leave
  01bf7	c3		 ret	 0
$L104980:
  0078f	ff 75 f0	 push	 DWORD PTR $T104977[ebp]
  00792	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00797	59		 pop	 ecx
  00798	c3		 ret	 0
__ehhandler$?SetEnvelop_Evoi@MusicTrack@@QAEXI@Z:
  00799	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T104986
  0079e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetEnvelop_Evoi@MusicTrack@@QAEXI@Z ENDP		; MusicTrack::SetEnvelop_Evoi
PUBLIC	?SetSubWithParch@MusicTrack@@QAEXI_N@Z		; MusicTrack::SetSubWithParch
$T105002 DD	0ffffffffH
	DD	FLAT:$L104994
$T105000 DD	019930520H
	DD	01H
	DD	FLAT:$T105002
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T104991 = 8						; size = 4
__event$25011 = 8					; size = 4
__f$ = 8						; size = 1
?SetSubWithParch@MusicTrack@@QAEXI_N@Z PROC NEAR	; MusicTrack::SetSubWithParch
; _this$ = ecx
; __no$ = edi

; 1302 : {

  01bf8	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetSubWithParch@MusicTrack@@QAEXI_N@Z
  01bfd	e8 00 00 00 00	 call	 __EH_prolog
  01c02	56		 push	 esi
  01c03	8b f1		 mov	 esi, ecx

; 1303 : 	if((_no != iSub) || (f_opt_Sub == false) || (_f == true)){

  01c05	8d 86 ec 01 00
	00		 lea	 eax, DWORD PTR [esi+492]
  01c0b	3b 38		 cmp	 edi, DWORD PTR [eax]
  01c0d	75 0f		 jne	 SHORT $L25009
  01c0f	80 be fb 01 00
	00 00		 cmp	 BYTE PTR [esi+507], 0
  01c16	74 06		 je	 SHORT $L25009
  01c18	80 7d 08 01	 cmp	 BYTE PTR __f$[ebp], 1
  01c1c	75 5a		 jne	 SHORT $L25010
$L25009:

; 1304 : 		iSub = _no;
; 1305 : 		f_opt_Sub	= true;
; 1306 : 		if(jump_flag==false){

  01c1e	80 be a1 00 00
	00 00		 cmp	 BYTE PTR [esi+161], 0
  01c25	89 38		 mov	 DWORD PTR [eax], edi
  01c27	c6 86 fb 01 00
	00 01		 mov	 BYTE PTR [esi+507], 1
  01c2e	75 48		 jne	 SHORT $L25010

; 1307 : 			mml_Address*		_event = new mml_Address(nsd_Call, _T("Subroutine for Patch"));

  01c30	6a 44		 push	 68			; 00000044H
  01c32	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01c37	59		 pop	 ecx
  01c38	89 45 08	 mov	 DWORD PTR $T104991[ebp], eax
  01c3b	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  01c3f	85 c0		 test	 eax, eax
  01c41	74 0f		 je	 SHORT $L104992
  01c43	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CK@JNKNAIAA@?$AAS?$AAu?$AAb?$AAr?$AAo?$AAu?$AAt?$AAi?$AAn?$AAe?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAP?$AAa?$AAt?$AAc?$AAh@
  01c48	6a 02		 push	 2
  01c4a	50		 push	 eax
  01c4b	e8 00 00 00 00	 call	 ??0mml_Address@@QAE@EQBG@Z ; mml_Address::mml_Address
  01c50	eb 02		 jmp	 SHORT $L104993
$L104992:
  01c52	33 c0		 xor	 eax, eax
$L104993:
  01c54	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  01c58	89 45 08	 mov	 DWORD PTR __event$25011[ebp], eax

; 1308 : 			_event->set_id(_no);

  01c5b	c6 40 40 01	 mov	 BYTE PTR [eax+64], 1
  01c5f	89 78 3c	 mov	 DWORD PTR [eax+60], edi

; 1309 : 			SetEvent(_event);

  01c62	50		 push	 eax
  01c63	8b c6		 mov	 eax, esi
  01c65	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 1310 : 			ptcSub.push_back(_event);

  01c6a	8d 86 c8 02 00
	00		 lea	 eax, DWORD PTR [esi+712]
  01c70	8d 75 08	 lea	 esi, DWORD PTR __event$25011[ebp]
  01c73	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEXABQAVmml_Address@@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::push_back
$L25010:

; 1311 : 		};
; 1312 : 	}
; 1313 : }

  01c78	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01c7b	5e		 pop	 esi
  01c7c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01c83	c9		 leave
  01c84	c2 04 00	 ret	 4
$L104994:
  007a3	ff 75 08	 push	 DWORD PTR $T104991[ebp]
  007a6	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  007ab	59		 pop	 ecx
  007ac	c3		 ret	 0
__ehhandler$?SetSubWithParch@MusicTrack@@QAEXI_N@Z:
  007ad	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T105000
  007b2	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetSubWithParch@MusicTrack@@QAEXI_N@Z ENDP		; MusicTrack::SetSubWithParch
PUBLIC	?SetSubroutine@MusicTrack@@QAEXI@Z		; MusicTrack::SetSubroutine
$T105016 DD	0ffffffffH
	DD	FLAT:$L105008
$T105014 DD	019930520H
	DD	01H
	DD	FLAT:$T105016
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T105005 = -16						; size = 4
__event$24997 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__no$ = 8						; size = 4
?SetSubroutine@MusicTrack@@QAEXI@Z PROC NEAR		; MusicTrack::SetSubroutine
; _this$ = edi

; 1288 : {

  01c87	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetSubroutine@MusicTrack@@QAEXI@Z
  01c8c	e8 00 00 00 00	 call	 __EH_prolog
  01c91	51		 push	 ecx

; 1289 : 	if(jump_flag==false){

  01c92	80 bf a1 00 00
	00 00		 cmp	 BYTE PTR [edi+161], 0
  01c99	75 4d		 jne	 SHORT $L24996

; 1290 : 		mml_Address*		_event = new mml_Address(nsd_Call, _T("Subroutine"));

  01c9b	6a 44		 push	 68			; 00000044H
  01c9d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01ca2	59		 pop	 ecx
  01ca3	89 45 f0	 mov	 DWORD PTR $T105005[ebp], eax
  01ca6	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  01caa	85 c0		 test	 eax, eax
  01cac	74 0f		 je	 SHORT $L105006
  01cae	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BG@DLCGAOAF@?$AAS?$AAu?$AAb?$AAr?$AAo?$AAu?$AAt?$AAi?$AAn?$AAe?$AA?$AA@
  01cb3	6a 02		 push	 2
  01cb5	50		 push	 eax
  01cb6	e8 00 00 00 00	 call	 ??0mml_Address@@QAE@EQBG@Z ; mml_Address::mml_Address
  01cbb	eb 02		 jmp	 SHORT $L105007
$L105006:
  01cbd	33 c0		 xor	 eax, eax
$L105007:
  01cbf	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 1291 : 		_event->set_id(_no);

  01cc3	8b 4d 08	 mov	 ecx, DWORD PTR __no$[ebp]
  01cc6	56		 push	 esi
  01cc7	89 45 f0	 mov	 DWORD PTR __event$24997[ebp], eax
  01cca	c6 40 40 01	 mov	 BYTE PTR [eax+64], 1
  01cce	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 1292 : 		SetEvent(_event);

  01cd1	50		 push	 eax
  01cd2	8b c7		 mov	 eax, edi
  01cd4	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 1293 : 		ptcSub.push_back(_event);

  01cd9	8d 87 c8 02 00
	00		 lea	 eax, DWORD PTR [edi+712]
  01cdf	8d 75 f0	 lea	 esi, DWORD PTR __event$24997[ebp]
  01ce2	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEXABQAVmml_Address@@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::push_back
  01ce7	5e		 pop	 esi
$L24996:

; 1294 : 	};
; 1295 : 	Reset_opt();

  01ce8	8b c7		 mov	 eax, edi
  01cea	e8 00 00 00 00	 call	 ?Reset_opt@MusicTrack@@QAEXXZ ; MusicTrack::Reset_opt

; 1296 : }

  01cef	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01cf2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01cf9	c9		 leave
  01cfa	c2 04 00	 ret	 4
$L105008:
  007b7	ff 75 f0	 push	 DWORD PTR $T105005[ebp]
  007ba	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  007bf	59		 pop	 ecx
  007c0	c3		 ret	 0
__ehhandler$?SetSubroutine@MusicTrack@@QAEXI@Z:
  007c1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T105014
  007c6	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetSubroutine@MusicTrack@@QAEXI@Z ENDP			; MusicTrack::SetSubroutine
PUBLIC	?CopyEnvEvent@MusicTrack@@QAEXEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@3@@Z ; MusicTrack::CopyEnvEvent
$T105053 DD	0ffffffffH
	DD	FLAT:$L105022
$T105051 DD	019930520H
	DD	01H
	DD	FLAT:$T105053
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T105019 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_cOpCode$ = 8						; size = 1
__event$ = 8						; size = 4
_sOpCode$ = 12						; size = 4
_pt_itMusic$ = 16					; size = 4
?CopyEnvEvent@MusicTrack@@QAEXEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@3@@Z PROC NEAR ; MusicTrack::CopyEnvEvent
; _this$ = ebx

; 1249 : {

  01cfd	b8 00 00 00 00	 mov	 eax, __ehhandler$?CopyEnvEvent@MusicTrack@@QAEXEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@3@@Z
  01d02	e8 00 00 00 00	 call	 __EH_prolog
  01d07	51		 push	 ecx
  01d08	56		 push	 esi
  01d09	57		 push	 edi

; 1250 : 	mml_Address*	_event		=	new mml_Address(cOpCode);

  01d0a	6a 44		 push	 68			; 00000044H
  01d0c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01d11	59		 pop	 ecx
  01d12	89 45 f0	 mov	 DWORD PTR $T105019[ebp], eax
  01d15	33 ff		 xor	 edi, edi
  01d17	3b c7		 cmp	 eax, edi
  01d19	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  01d1c	74 10		 je	 SHORT $L105021
  01d1e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BA@LDPMAPOD@?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?$AA@
  01d23	ff 75 08	 push	 DWORD PTR _cOpCode$[ebp]
  01d26	50		 push	 eax
  01d27	e8 00 00 00 00	 call	 ??0mml_Address@@QAE@EQBG@Z ; mml_Address::mml_Address
  01d2c	8b f8		 mov	 edi, eax
$L105021:
  01d2e	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 1251 : 	mml_Address*	ptAdrItem	=	(mml_Address*)(*pt_itMusic);

  01d32	8b 45 10	 mov	 eax, DWORD PTR _pt_itMusic$[ebp]
  01d35	8b 70 08	 mov	 esi, DWORD PTR [eax+8]

; 1252 : 	_event->setCode(sOpCode);

  01d38	ff 75 0c	 push	 DWORD PTR _sOpCode$[ebp]
  01d3b	8b 07		 mov	 eax, DWORD PTR [edi]
  01d3d	8b cf		 mov	 ecx, edi
  01d3f	89 7d 08	 mov	 DWORD PTR __event$[ebp], edi
  01d42	ff 50 04	 call	 DWORD PTR [eax+4]

; 1253 : 	if(ptAdrItem->get_flag() == true){

  01d45	80 7e 40 01	 cmp	 BYTE PTR [esi+64], 1
  01d49	75 18		 jne	 SHORT $L24979

; 1254 : 		_event->set_id(ptAdrItem->get_id());

  01d4b	8b 76 3c	 mov	 esi, DWORD PTR [esi+60]
  01d4e	89 77 3c	 mov	 DWORD PTR [edi+60], esi

; 1255 : 		ptcEnv.push_back(_event);

  01d51	8d 83 d8 02 00
	00		 lea	 eax, DWORD PTR [ebx+728]
  01d57	8d 75 08	 lea	 esi, DWORD PTR __event$[ebp]
  01d5a	c6 47 40 01	 mov	 BYTE PTR [edi+64], 1
  01d5e	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEXABQAVmml_Address@@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::push_back
$L24979:

; 1256 : 	}
; 1257 : 	SetEvent(_event);

  01d63	57		 push	 edi
  01d64	8b c3		 mov	 eax, ebx
  01d66	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 1258 : }

  01d6b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01d6e	5f		 pop	 edi
  01d6f	5e		 pop	 esi
  01d70	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01d77	c9		 leave
  01d78	c2 0c 00	 ret	 12			; 0000000cH
$L105022:
  007cb	ff 75 f0	 push	 DWORD PTR $T105019[ebp]
  007ce	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  007d3	59		 pop	 ecx
  007d4	c3		 ret	 0
__ehhandler$?CopyEnvEvent@MusicTrack@@QAEXEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@3@@Z:
  007d5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T105051
  007da	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?CopyEnvEvent@MusicTrack@@QAEXEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@3@@Z ENDP ; MusicTrack::CopyEnvEvent
PUBLIC	?CopyAddressEvent@MusicTrack@@QAEPAVmml_Address@@EPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@4@@Z ; MusicTrack::CopyAddressEvent
$T105085 DD	0ffffffffH
	DD	FLAT:$L105059
$T105083 DD	019930520H
	DD	01H
	DD	FLAT:$T105085
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T105056 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_cOpCode$ = 12						; size = 1
_sOpCode$ = 16						; size = 4
_pt_itMusic$ = 20					; size = 4
?CopyAddressEvent@MusicTrack@@QAEPAVmml_Address@@EPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@4@@Z PROC NEAR ; MusicTrack::CopyAddressEvent

; 1239 : {

  01d7b	b8 00 00 00 00	 mov	 eax, __ehhandler$?CopyAddressEvent@MusicTrack@@QAEPAVmml_Address@@EPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@4@@Z
  01d80	e8 00 00 00 00	 call	 __EH_prolog
  01d85	51		 push	 ecx
  01d86	56		 push	 esi
  01d87	57		 push	 edi

; 1240 : 	mml_Address*	_event		=	new mml_Address(cOpCode);

  01d88	6a 44		 push	 68			; 00000044H
  01d8a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01d8f	59		 pop	 ecx
  01d90	89 45 f0	 mov	 DWORD PTR $T105056[ebp], eax
  01d93	33 f6		 xor	 esi, esi
  01d95	3b c6		 cmp	 eax, esi
  01d97	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  01d9a	74 10		 je	 SHORT $L105058
  01d9c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BA@LDPMAPOD@?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?$AA@
  01da1	ff 75 0c	 push	 DWORD PTR _cOpCode$[ebp]
  01da4	50		 push	 eax
  01da5	e8 00 00 00 00	 call	 ??0mml_Address@@QAE@EQBG@Z ; mml_Address::mml_Address
  01daa	8b f0		 mov	 esi, eax
$L105058:
  01dac	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 1241 : 	mml_Address*	ptAdrItem	=	(mml_Address*)(*pt_itMusic);

  01db0	8b 45 14	 mov	 eax, DWORD PTR _pt_itMusic$[ebp]
  01db3	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 1242 : 	_event->setCode(sOpCode);

  01db6	ff 75 10	 push	 DWORD PTR _sOpCode$[ebp]
  01db9	8b 06		 mov	 eax, DWORD PTR [esi]
  01dbb	8b ce		 mov	 ecx, esi
  01dbd	ff 50 04	 call	 DWORD PTR [eax+4]

; 1243 : 	_event->set_id(ptAdrItem->get_id());

  01dc0	8b 7f 3c	 mov	 edi, DWORD PTR [edi+60]

; 1244 : 	SetEvent(_event);

  01dc3	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  01dc6	56		 push	 esi
  01dc7	c6 46 40 01	 mov	 BYTE PTR [esi+64], 1
  01dcb	89 7e 3c	 mov	 DWORD PTR [esi+60], edi
  01dce	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 1245 : 	return(_event);
; 1246 : }

  01dd3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01dd6	5f		 pop	 edi
  01dd7	8b c6		 mov	 eax, esi
  01dd9	5e		 pop	 esi
  01dda	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01de1	c9		 leave
  01de2	c2 10 00	 ret	 16			; 00000010H
$L105059:
  007df	ff 75 f0	 push	 DWORD PTR $T105056[ebp]
  007e2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  007e7	59		 pop	 ecx
  007e8	c3		 ret	 0
__ehhandler$?CopyAddressEvent@MusicTrack@@QAEPAVmml_Address@@EPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@4@@Z:
  007e9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T105083
  007ee	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?CopyAddressEvent@MusicTrack@@QAEPAVmml_Address@@EPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@4@@Z ENDP ; MusicTrack::CopyAddressEvent
PUBLIC	?SetRepeat_Branch@MusicTrack@@QAEXPAVMMLfile@@@Z ; MusicTrack::SetRepeat_Branch
$T105196 DD	0ffffffffH
	DD	FLAT:$L105092
$T105192 DD	019930520H
	DD	01H
	DD	FLAT:$T105196
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T105088 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetRepeat_Branch@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR ; MusicTrack::SetRepeat_Branch
; _this$ = ecx
; _MML$ = ebx

; 991  : {

  01de5	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetRepeat_Branch@MusicTrack@@QAEXPAVMMLfile@@@Z
  01dea	e8 00 00 00 00	 call	 __EH_prolog
  01def	51		 push	 ecx
  01df0	56		 push	 esi
  01df1	8b f1		 mov	 esi, ecx

; 992  : 	EchoVolRet();	//^GR[A

  01df3	e8 00 00 00 00	 call	 ?EchoVolRet@MusicTrack@@QAEXXZ ; MusicTrack::EchoVolRet

; 993  : 
; 994  : 	list<MusicItem*>::iterator	pt_itMusic	=	ptcItem.end();
; 995  : 
; 996  : 	switch(*it_repeat_type){

  01df8	8b 86 30 02 00
	00		 mov	 eax, DWORD PTR [esi+560]
  01dfe	8b 00		 mov	 eax, DWORD PTR [eax]
  01e00	48		 dec	 eax
  01e01	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01e04	74 4c		 je	 SHORT $L24828
  01e06	48		 dec	 eax
  01e07	48		 dec	 eax
  01e08	74 0a		 je	 SHORT $L24840

; 1020 : 			}
; 1021 : 			break;
; 1022 : 		default:
; 1023 : 			MML->Err(_T("s[gJnR}hB"));

  01e0a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CE@PJCEBMDC@0?j0?T0?$PM0?H?$JF?$ILY?K0?$LD0?$NO0?s0?I0L0B0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
  01e0f	e9 9f 00 00 00	 jmp	 $L105195
$L24840:

; 1008 : 			}
; 1009 : 			break;
; 1010 : 		case(3):
; 1011 : 			if(sp_repeat_c > 0){

  01e14	83 be 34 02 00
	00 00		 cmp	 DWORD PTR [esi+564], 0
  01e1b	76 2e		 jbe	 SHORT $L24841

; 1012 : 				if((*it_it_repeat_c_b) == (*it_it_repeat_c_s)){

  01e1d	8b 86 70 02 00
	00		 mov	 eax, DWORD PTR [esi+624]
  01e23	8b 96 6c 02 00
	00		 mov	 edx, DWORD PTR [esi+620]
  01e29	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  01e2c	3b 72 08	 cmp	 esi, DWORD PTR [edx+8]
  01e2f	75 13		 jne	 SHORT $L24842

; 1013 : 					pt_itMusic--;
; 1014 : 					(*it_it_repeat_c_b) = pt_itMusic;

  01e31	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  01e34	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$L24820:

; 1024 : 			break;
; 1025 : 	}
; 1026 : 
; 1027 : }

  01e37	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01e3a	5e		 pop	 esi
  01e3b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01e42	c9		 leave
  01e43	c3		 ret	 0
$L24842:

; 1015 : 				} else {
; 1016 : 					MML->Err(_T("s[g(C) : R}hdB"));

  01e44	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DE@OPGCJNPF@0?j0?T0?$PM0?H?$AA?$CI?$AAC?$AA?$CJQ?$IF0g?$AA?5?$AA?3?$AA?50?$LD0?$NO0?s0?I0L?$JB?M?$IJ?$AH0W@
  01e49	eb 68		 jmp	 SHORT $L105195
$L24841:

; 1017 : 				}
; 1018 : 			} else {
; 1019 : 				MML->Err(_T("s[g(C)Jn [: R}hB"));

  01e4b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DE@PIDIKAJB@0?j0?T0?$PM0?H?$AA?$CI?$AAC?$AA?$CJ0n?$JF?$ILY?K?$AA?5?$AA?$FL?$AA?3?$AA?50?$LD0?$NO0?s0?I0L0B@
  01e50	eb 61		 jmp	 SHORT $L105195
$L24828:

; 997  : 		case(1):
; 998  : 			if(offset_repeat_a_s != 0){

  01e52	83 be 0c 02 00
	00 00		 cmp	 DWORD PTR [esi+524], 0
  01e59	74 53		 je	 SHORT $L24829

; 999  : 				if(offset_repeat_a_b == 0){

  01e5b	8d 86 10 02 00
	00		 lea	 eax, DWORD PTR [esi+528]
  01e61	83 38 00	 cmp	 DWORD PTR [eax], 0
  01e64	75 41		 jne	 SHORT $L24830

; 1000 : 					offset_repeat_a_b = offset_now + 1;	//u

  01e66	8b 8e 9c 00 00
	00		 mov	 ecx, DWORD PTR [esi+156]
  01e6c	41		 inc	 ecx

; 1001 : 					_old_repeatA_Branch = new mml_Address(nsd_Repeat_A_Branch, _T("Repeat(A) Branch"));

  01e6d	6a 44		 push	 68			; 00000044H
  01e6f	89 08		 mov	 DWORD PTR [eax], ecx
  01e71	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01e76	59		 pop	 ecx
  01e77	89 45 f0	 mov	 DWORD PTR $T105088[ebp], eax
  01e7a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  01e7e	85 c0		 test	 eax, eax
  01e80	74 0f		 je	 SHORT $L105089
  01e82	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CC@MGIFLNF@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAA?$AA?$CJ?$AA?5?$AAB?$AAr?$AAa?$AAn?$AAc?$AAh?$AA?$AA@
  01e87	6a 04		 push	 4
  01e89	50		 push	 eax
  01e8a	e8 00 00 00 00	 call	 ??0mml_Address@@QAE@EQBG@Z ; mml_Address::mml_Address
  01e8f	eb 02		 jmp	 SHORT $L105090
$L105089:
  01e91	33 c0		 xor	 eax, eax
$L105090:
  01e93	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  01e97	89 86 04 02 00
	00		 mov	 DWORD PTR [esi+516], eax

; 1002 : 					SetEvent(_old_repeatA_Branch);

  01e9d	50		 push	 eax
  01e9e	8b c6		 mov	 eax, esi
  01ea0	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 1024 : 			break;
; 1025 : 	}
; 1026 : 
; 1027 : }

  01ea5	eb 90		 jmp	 SHORT $L24820
$L24830:

; 1003 : 				} else {
; 1004 : 					MML->Err(_T("s[g(A) : R}hdB"));

  01ea7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DE@HGGAJCGI@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJQ?$IF0g?$AA?5?$AA?3?$AA?50?$LD0?$NO0?s0?I0L?$JB?M?$IJ?$AH0W@
  01eac	eb 05		 jmp	 SHORT $L105195
$L24829:

; 1005 : 				}
; 1006 : 			} else {
; 1007 : 				MML->Err(_T("s[g(A)Jn [ R}hB"));

  01eae	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DC@IPGNKEJP@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJ0n?$JF?$ILY?K?$AA?5?$AA?$FL?$AA?50?$LD0?$NO0?s0?I0L0B0?$IK@
$L105195:
  01eb3	8b c3		 mov	 eax, ebx
  01eb5	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L105197:
$L105194:
  01eba	cc		 int	 3
$L105092:
  007f3	ff 75 f0	 push	 DWORD PTR $T105088[ebp]
  007f6	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  007fb	59		 pop	 ecx
  007fc	c3		 ret	 0
__ehhandler$?SetRepeat_Branch@MusicTrack@@QAEXPAVMMLfile@@@Z:
  007fd	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T105192
  00802	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetRepeat_Branch@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP	; MusicTrack::SetRepeat_Branch
PUBLIC	?SetRepeat_B_End@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetRepeat_B_End
$T105209 DD	0ffffffffH
	DD	FLAT:$L105203
$T105205 DD	019930520H
	DD	01H
	DD	FLAT:$T105209
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T105200 = 8						; size = 4
_MML$ = 8						; size = 4
?SetRepeat_B_End@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR ; MusicTrack::SetRepeat_B_End
; _this$ = ecx

; 846  : {

  01ebb	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetRepeat_B_End@MusicTrack@@QAEXPAVMMLfile@@@Z
  01ec0	e8 00 00 00 00	 call	 __EH_prolog
  01ec5	56		 push	 esi
  01ec6	57		 push	 edi
  01ec7	8b f1		 mov	 esi, ecx

; 847  : 	mml_Address*	_event;
; 848  : 
; 849  : 	EchoVolRet();	//^GR[A

  01ec9	e8 00 00 00 00	 call	 ?EchoVolRet@MusicTrack@@QAEXXZ ; MusicTrack::EchoVolRet

; 850  : 
; 851  : 	if(offset_repeat_b_s != 0){

  01ece	8b 86 14 02 00
	00		 mov	 eax, DWORD PTR [esi+532]
  01ed4	33 ff		 xor	 edi, edi
  01ed6	3b c7		 cmp	 eax, edi
  01ed8	74 76		 je	 SHORT $L24750

; 852  : 		if(offset_repeat_b_b != 0){

  01eda	39 be 18 02 00
	00		 cmp	 DWORD PTR [esi+536], edi
  01ee0	74 67		 je	 SHORT $L24751

; 853  : 			if(offset_repeat_b_s < offset_repeat_a_s){

  01ee2	3b 86 0c 02 00
	00		 cmp	 eax, DWORD PTR [esi+524]
  01ee8	73 07		 jae	 SHORT $L24752

; 854  : 				MML->Err(_T("s[g(A)rB"));

  01eea	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CC@DHDLBODE@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJ0nS?3?$JF?$JD0n?$JA?$BEN?90g0Y0?$AC?$AA?$AA@
  01eef	eb 64		 jmp	 SHORT $L105208
$L24752:

; 855  : 			}
; 856  : 			_event = new mml_Address(nsd_Repeat_B_End, _T("Repeat(B) End"));

  01ef1	6a 44		 push	 68			; 00000044H
  01ef3	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01ef8	59		 pop	 ecx
  01ef9	89 45 08	 mov	 DWORD PTR $T105200[ebp], eax
  01efc	3b c7		 cmp	 eax, edi
  01efe	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  01f01	74 0f		 je	 SHORT $L105202
  01f03	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BM@EDCBEBGE@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAB?$AA?$CJ?$AA?5?$AAE?$AAn?$AAd?$AA?$AA@
  01f08	6a 1a		 push	 26			; 0000001aH
  01f0a	50		 push	 eax
  01f0b	e8 00 00 00 00	 call	 ??0mml_Address@@QAE@EQBG@Z ; mml_Address::mml_Address
  01f10	8b f8		 mov	 edi, eax
$L105202:
  01f12	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 857  : 			_event->set_Address(offset_repeat_b_s - offset_now - 1);

  01f16	8b 8e 14 02 00
	00		 mov	 ecx, DWORD PTR [esi+532]
  01f1c	2b 8e 9c 00 00
	00		 sub	 ecx, DWORD PTR [esi+156]
  01f22	8b c7		 mov	 eax, edi
  01f24	49		 dec	 ecx
  01f25	e8 00 00 00 00	 call	 ?set_Address@mml_Address@@QAEXI@Z ; mml_Address::set_Address

; 858  : 			SetEvent(_event);

  01f2a	57		 push	 edi
  01f2b	8b c6		 mov	 eax, esi
  01f2d	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 864  : 	}
; 865  : 
; 866  : 	Reset_opt();

  01f32	8b c6		 mov	 eax, esi
  01f34	e8 00 00 00 00	 call	 ?Reset_opt@MusicTrack@@QAEXXZ ; MusicTrack::Reset_opt

; 867  : }

  01f39	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01f3c	5f		 pop	 edi
  01f3d	5e		 pop	 esi
  01f3e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01f45	c9		 leave
  01f46	c2 04 00	 ret	 4
$L24751:

; 859  : 		} else {
; 860  : 			MML->Err(_T("s[g(B) \\ R}hBK_ \\ wB"));

  01f49	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1FK@BKKHDBPB@0?j0?T0?$PM0?H?$AA?$CI?$AAB?$AA?$CJQ?$IF0g?$AA?5?$AA?2?$AA?50?$LD0?$NO0?s0?I0L0B0?$IK0?$HO@
  01f4e	eb 05		 jmp	 SHORT $L105208
$L24750:

; 861  : 		}
; 862  : 	} else {
; 863  : 		MML->Err(_T("s[g(B)Jn |: R}hB"));

  01f50	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DE@NPLPFED@0?j0?T0?$PM0?H?$AA?$CI?$AAB?$AA?$CJ0n?$JF?$ILY?K?$AA?5?$AA?$HM?$AA?3?$AA?50?$LD0?$NO0?s0?I0L0B@
$L105208:
  01f55	8b 45 08	 mov	 eax, DWORD PTR _MML$[ebp]
  01f58	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L105210:
$L105207:
  01f5d	cc		 int	 3
$L105203:
  00807	ff 75 08	 push	 DWORD PTR $T105200[ebp]
  0080a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0080f	59		 pop	 ecx
  00810	c3		 ret	 0
__ehhandler$?SetRepeat_B_End@MusicTrack@@QAEXPAVMMLfile@@@Z:
  00811	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T105205
  00816	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetRepeat_B_End@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP	; MusicTrack::SetRepeat_B_End
PUBLIC	?SetRepeat_B_Branch@MusicTrack@@QAEXPAVMMLfile@@@Z ; MusicTrack::SetRepeat_B_Branch
$T105222 DD	0ffffffffH
	DD	FLAT:$L105216
$T105218 DD	019930520H
	DD	01H
	DD	FLAT:$T105222
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T105213 = 8						; size = 4
_MML$ = 8						; size = 4
?SetRepeat_B_Branch@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR ; MusicTrack::SetRepeat_B_Branch
; _this$ = ecx

; 822  : {

  01f5e	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetRepeat_B_Branch@MusicTrack@@QAEXPAVMMLfile@@@Z
  01f63	e8 00 00 00 00	 call	 __EH_prolog
  01f68	56		 push	 esi
  01f69	8b f1		 mov	 esi, ecx

; 823  : 	EchoVolRet();	//^GR[A

  01f6b	e8 00 00 00 00	 call	 ?EchoVolRet@MusicTrack@@QAEXXZ ; MusicTrack::EchoVolRet

; 824  : 
; 825  : 	if(offset_repeat_b_s != 0){

  01f70	83 be 14 02 00
	00 00		 cmp	 DWORD PTR [esi+532], 0
  01f77	74 59		 je	 SHORT $L24734

; 826  : 		if(offset_repeat_b_b == 0){

  01f79	8d 86 18 02 00
	00		 lea	 eax, DWORD PTR [esi+536]
  01f7f	83 38 00	 cmp	 DWORD PTR [eax], 0
  01f82	75 47		 jne	 SHORT $L24735

; 827  : 			offset_repeat_b_b = offset_now;	//R}hB

  01f84	8b 8e 9c 00 00
	00		 mov	 ecx, DWORD PTR [esi+156]

; 828  : 			SetEvent(new mml_general(nsd_Repeat_B_Branch, _T("Repeat(B) Branch")));

  01f8a	6a 3c		 push	 60			; 0000003cH
  01f8c	89 08		 mov	 DWORD PTR [eax], ecx
  01f8e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01f93	59		 pop	 ecx
  01f94	89 45 08	 mov	 DWORD PTR $T105213[ebp], eax
  01f97	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  01f9b	85 c0		 test	 eax, eax
  01f9d	74 0f		 je	 SHORT $L105214
  01f9f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CC@KDMBBGBP@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAB?$AA?$CJ?$AA?5?$AAB?$AAr?$AAa?$AAn?$AAc?$AAh?$AA?$AA@
  01fa4	6a 19		 push	 25			; 00000019H
  01fa6	50		 push	 eax
  01fa7	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  01fac	eb 02		 jmp	 SHORT $L105215
$L105214:
  01fae	33 c0		 xor	 eax, eax
$L105215:
  01fb0	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  01fb4	50		 push	 eax
  01fb5	8b c6		 mov	 eax, esi
  01fb7	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 834  : 	}
; 835  : }

  01fbc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01fbf	5e		 pop	 esi
  01fc0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  01fc7	c9		 leave
  01fc8	c2 04 00	 ret	 4
$L24735:

; 829  : 		} else {
; 830  : 			MML->Err(_T("s[g(B) \\ R}hdB"));

  01fcb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DE@EIMDGIFC@0?j0?T0?$PM0?H?$AA?$CI?$AAB?$AA?$CJQ?$IF0g?$AA?5?$AA?2?$AA?50?$LD0?$NO0?s0?I0L?$JB?M?$IJ?$AH0W@
  01fd0	eb 05		 jmp	 SHORT $L105221
$L24734:

; 831  : 		}
; 832  : 	} else {
; 833  : 		MML->Err(_T("s[g(B)Jn |: R}hB"));

  01fd2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DE@NPLPFED@0?j0?T0?$PM0?H?$AA?$CI?$AAB?$AA?$CJ0n?$JF?$ILY?K?$AA?5?$AA?$HM?$AA?3?$AA?50?$LD0?$NO0?s0?I0L0B@
$L105221:
  01fd7	8b 45 08	 mov	 eax, DWORD PTR _MML$[ebp]
  01fda	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L105223:
$L105220:
  01fdf	cc		 int	 3
$L105216:
  0081b	ff 75 08	 push	 DWORD PTR $T105213[ebp]
  0081e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00823	59		 pop	 ecx
  00824	c3		 ret	 0
__ehhandler$?SetRepeat_B_Branch@MusicTrack@@QAEXPAVMMLfile@@@Z:
  00825	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T105218
  0082a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetRepeat_B_Branch@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP	; MusicTrack::SetRepeat_B_Branch
PUBLIC	?SetRepeat_B_Start@MusicTrack@@QAEXXZ		; MusicTrack::SetRepeat_B_Start
$T105233 DD	0ffffffffH
	DD	FLAT:$L105229
$T105231 DD	019930520H
	DD	01H
	DD	FLAT:$T105233
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T105226 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetRepeat_B_Start@MusicTrack@@QAEXXZ PROC NEAR		; MusicTrack::SetRepeat_B_Start
; _this$ = esi

; 805  : {

  01fe0	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetRepeat_B_Start@MusicTrack@@QAEXXZ
  01fe5	e8 00 00 00 00	 call	 __EH_prolog
  01fea	51		 push	 ecx

; 806  : 	SetEvent(new mml_general(nsd_Repeat_B_Start, _T("Repeat(B) Start")));

  01feb	6a 3c		 push	 60			; 0000003cH
  01fed	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  01ff2	59		 pop	 ecx
  01ff3	89 45 f0	 mov	 DWORD PTR $T105226[ebp], eax
  01ff6	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  01ffa	85 c0		 test	 eax, eax
  01ffc	74 0f		 je	 SHORT $L105227
  01ffe	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CA@JPKIEODC@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAB?$AA?$CJ?$AA?5?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@
  02003	6a 18		 push	 24			; 00000018H
  02005	50		 push	 eax
  02006	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  0200b	eb 02		 jmp	 SHORT $L105228
$L105227:
  0200d	33 c0		 xor	 eax, eax
$L105228:
  0200f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  02013	50		 push	 eax
  02014	8b c6		 mov	 eax, esi
  02016	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 807  : 	offset_repeat_b_s = offset_now;	// :| R}hAR}hB

  0201b	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]

; 808  : 	offset_repeat_b_b = 0;

  02021	83 a6 18 02 00
	00 00		 and	 DWORD PTR [esi+536], 0
  02028	89 86 14 02 00
	00		 mov	 DWORD PTR [esi+532], eax

; 809  : 
; 810  : 	Reset_opt();

  0202e	8b c6		 mov	 eax, esi
  02030	e8 00 00 00 00	 call	 ?Reset_opt@MusicTrack@@QAEXXZ ; MusicTrack::Reset_opt

; 811  : }

  02035	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  02038	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0203f	c9		 leave
  02040	c3		 ret	 0
$L105229:
  0082f	ff 75 f0	 push	 DWORD PTR $T105226[ebp]
  00832	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00837	59		 pop	 ecx
  00838	c3		 ret	 0
__ehhandler$?SetRepeat_B_Start@MusicTrack@@QAEXXZ:
  00839	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T105231
  0083e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetRepeat_B_Start@MusicTrack@@QAEXXZ ENDP		; MusicTrack::SetRepeat_B_Start
PUBLIC	?SetEnd@MusicTrack@@QAEIPAVMMLfile@@@Z		; MusicTrack::SetEnd
$T105251 DD	0ffffffffH
	DD	FLAT:$L105243
	DD	0ffffffffH
	DD	FLAT:$L105244
$T105246 DD	019930520H
	DD	02H
	DD	FLAT:$T105251
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T105240 = 8						; size = 4
$T105236 = 8						; size = 4
_MML$ = 8						; size = 4
?SetEnd@MusicTrack@@QAEIPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetEnd
; _this$ = ecx

; 753  : {

  02041	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetEnd@MusicTrack@@QAEIPAVMMLfile@@@Z
  02046	e8 00 00 00 00	 call	 __EH_prolog
  0204b	8b 45 08	 mov	 eax, DWORD PTR _MML$[ebp]
  0204e	53		 push	 ebx
  0204f	56		 push	 esi
  02050	8b f1		 mov	 esi, ecx

; 754  : 	mml_Address*	_event;
; 755  : 
; 756  : 	//s[g`FbN
; 757  : 	if(offset_repeat_a_s != 0){

  02052	33 db		 xor	 ebx, ebx
  02054	39 9e 0c 02 00
	00		 cmp	 DWORD PTR [esi+524], ebx
  0205a	74 07		 je	 SHORT $L24702

; 758  : 		MML->Err(_T("s[g(A)IB"));

  0205c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CE@JMOHEOPF@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJ0L?$HNB0?$IP0c0f0D0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
  02061	eb 0d		 jmp	 SHORT $L105250
$L24702:

; 759  : 	}
; 760  : 	if(sp_repeat_c != 0){

  02063	39 9e 34 02 00
	00		 cmp	 DWORD PTR [esi+564], ebx
  02069	74 0a		 je	 SHORT $L24704

; 761  : 		MML->Err(_T("s[g(C)IB"));

  0206b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CE@IJKNAFJK@0?j0?T0?$PM0?H?$AA?$CI?$AAC?$AA?$CJ0L?$HNB0?$IP0c0f0D0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
$L105250:
  02070	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L105252:
$L24704:

; 762  : 	}
; 763  : 
; 764  : 	if(offset_now != 0){

  02075	39 9e 9c 00 00
	00		 cmp	 DWORD PTR [esi+156], ebx
  0207b	74 7c		 je	 SHORT $L24713

; 765  : 		//IuWFNg
; 766  : 		if(loop_flag == false){

  0207d	38 9e fc 01 00
	00		 cmp	 BYTE PTR [esi+508], bl
  02083	75 29		 jne	 SHORT $L24707

; 767  : 			SetEvent(new mml_general(nsd_EndOfTrack,_T("End of Track")));

  02085	6a 3c		 push	 60			; 0000003cH
  02087	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0208c	59		 pop	 ecx
  0208d	89 45 08	 mov	 DWORD PTR $T105236[ebp], eax
  02090	3b c3		 cmp	 eax, ebx
  02092	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  02095	74 0e		 je	 SHORT $L105237
  02097	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BK@OCDBGHAP@?$AAE?$AAn?$AAd?$AA?5?$AAo?$AAf?$AA?5?$AAT?$AAr?$AAa?$AAc?$AAk?$AA?$AA@
  0209c	53		 push	 ebx
  0209d	50		 push	 eax
  0209e	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  020a3	eb 02		 jmp	 SHORT $L105238
$L105237:
  020a5	33 c0		 xor	 eax, eax
$L105238:
  020a7	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  020ab	50		 push	 eax

; 768  : 		} else {

  020ac	eb 44		 jmp	 SHORT $L105249
$L24707:

; 769  : 			EchoVolRet();	//^GR[A

  020ae	e8 00 00 00 00	 call	 ?EchoVolRet@MusicTrack@@QAEXXZ ; MusicTrack::EchoVolRet

; 770  : 			_event = new mml_Address(nsd_Jump, _T("End of Track with LOOP"));

  020b3	6a 44		 push	 68			; 00000044H
  020b5	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  020ba	59		 pop	 ecx
  020bb	89 45 08	 mov	 DWORD PTR $T105240[ebp], eax
  020be	33 c0		 xor	 eax, eax
  020c0	40		 inc	 eax
  020c1	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
  020c4	39 5d 08	 cmp	 DWORD PTR $T105240[ebp], ebx
  020c7	74 10		 je	 SHORT $L105242
  020c9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CO@IIMELFGG@?$AAE?$AAn?$AAd?$AA?5?$AAo?$AAf?$AA?5?$AAT?$AAr?$AAa?$AAc?$AAk?$AA?5?$AAw?$AAi?$AAt?$AAh?$AA?5?$AAL?$AAO@
  020ce	50		 push	 eax
  020cf	ff 75 08	 push	 DWORD PTR $T105240[ebp]
  020d2	e8 00 00 00 00	 call	 ??0mml_Address@@QAE@EQBG@Z ; mml_Address::mml_Address
  020d7	8b d8		 mov	 ebx, eax
$L105242:
  020d9	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 771  : 			_event->set_Address(offset_loop - offset_now - 1);

  020dd	8b 8e 00 02 00
	00		 mov	 ecx, DWORD PTR [esi+512]
  020e3	2b 8e 9c 00 00
	00		 sub	 ecx, DWORD PTR [esi+156]
  020e9	8b c3		 mov	 eax, ebx
  020eb	49		 dec	 ecx
  020ec	e8 00 00 00 00	 call	 ?set_Address@mml_Address@@QAEXI@Z ; mml_Address::set_Address

; 772  : 			SetEvent(_event);

  020f1	53		 push	 ebx
$L105249:
  020f2	8b c6		 mov	 eax, esi
  020f4	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent
$L24713:

; 773  : 		}
; 774  : 	}
; 775  : 	iSize = offset_now;

  020f9	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]

; 776  : 
; 777  : 	return(iSize);
; 778  : }

  020ff	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  02102	89 46 30	 mov	 DWORD PTR [esi+48], eax
  02105	5e		 pop	 esi
  02106	5b		 pop	 ebx
  02107	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0210e	c9		 leave
  0210f	c2 04 00	 ret	 4
$L105248:
$L105243:
  00843	ff 75 08	 push	 DWORD PTR $T105236[ebp]
  00846	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0084b	59		 pop	 ecx
  0084c	c3		 ret	 0
$L105244:
  0084d	ff 75 08	 push	 DWORD PTR $T105240[ebp]
  00850	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00855	59		 pop	 ecx
  00856	c3		 ret	 0
__ehhandler$?SetEnd@MusicTrack@@QAEIPAVMMLfile@@@Z:
  00857	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T105246
  0085c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetEnd@MusicTrack@@QAEIPAVMMLfile@@@Z ENDP		; MusicTrack::SetEnd
PUBLIC	?SetVolumeDec@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetVolumeDec
$T105875 DD	0ffffffffH
	DD	FLAT:$L105869
$T105871 DD	019930520H
	DD	01H
	DD	FLAT:$T105875
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T105866 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetVolumeDec@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetVolumeDec
; _this$ = edx
; _MML$ = ecx

; 3599 : {

  02112	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetVolumeDec@MusicTrack@@QAEXPAVMMLfile@@@Z
  02117	e8 00 00 00 00	 call	 __EH_prolog
  0211c	51		 push	 ecx
  0211d	56		 push	 esi
  0211e	57		 push	 edi
  0211f	8b f9		 mov	 edi, ecx
  02121	8b f2		 mov	 esi, edx

; 3600 : 	unsigned	char	cData = MML->GetChar();

  02123	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 3601 : 				int		iValue;
; 3602 : 
; 3603 : 	if((cData >= '0') && (cData <= '9')){

  02128	3c 30		 cmp	 al, 48			; 00000030H
  0212a	72 16		 jb	 SHORT $L26262
  0212c	3c 39		 cmp	 al, 57			; 00000039H
  0212e	77 12		 ja	 SHORT $L26262

; 3604 : 		MML->Back();

  02130	8b c7		 mov	 eax, edi
  02132	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back

; 3605 : 		iValue = MML->GetInt();

  02137	8b c7		 mov	 eax, edi
  02139	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  0213e	8b f8		 mov	 edi, eax

; 3606 : 	} else {

  02140	eb 0a		 jmp	 SHORT $L26263
$L26262:

; 3607 : 		MML->Back();

  02142	8b c7		 mov	 eax, edi
  02144	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back

; 3608 : 		iValue = 1;

  02149	33 ff		 xor	 edi, edi
  0214b	47		 inc	 edi
$L26263:

; 3609 : 	}
; 3610 : 
; 3611 : 	EchoVolRet();

  0214c	e8 00 00 00 00	 call	 ?EchoVolRet@MusicTrack@@QAEXXZ ; MusicTrack::EchoVolRet

; 3612 : 
; 3613 : 	while(iValue > 0){

  02151	85 ff		 test	 edi, edi
  02153	7e 36		 jle	 SHORT $L26266
$L26265:

; 3614 : 		SetEvent(new mml_general(nsd_Volume_Down, _T("Volume down")));

  02155	6a 3c		 push	 60			; 0000003cH
  02157	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0215c	59		 pop	 ecx
  0215d	89 45 f0	 mov	 DWORD PTR $T105866[ebp], eax
  02160	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  02164	85 c0		 test	 eax, eax
  02166	74 0f		 je	 SHORT $L105867
  02168	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BI@MGACCNCM@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAd?$AAo?$AAw?$AAn?$AA?$AA@
  0216d	6a 20		 push	 32			; 00000020H
  0216f	50		 push	 eax
  02170	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  02175	eb 02		 jmp	 SHORT $L105868
$L105867:
  02177	33 c0		 xor	 eax, eax
$L105868:
  02179	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0217d	50		 push	 eax
  0217e	8b c6		 mov	 eax, esi
  02180	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 3615 : 		nsd.volume--;

  02185	ff 4e 64	 dec	 DWORD PTR [esi+100]
  02188	4f		 dec	 edi
  02189	75 ca		 jne	 SHORT $L26265
$L26266:

; 3616 : 		iValue--;
; 3617 : 	}
; 3618 : 	if(nsd.volume<0){

  0218b	83 7e 64 00	 cmp	 DWORD PTR [esi+100], 0
  0218f	7d 04		 jge	 SHORT $L26272

; 3619 : 		nsd.volume = 0;

  02191	83 66 64 00	 and	 DWORD PTR [esi+100], 0
$L26272:

; 3620 : 	}
; 3621 : 	if(opt_volume != -1){

  02195	8d 86 bc 00 00
	00		 lea	 eax, DWORD PTR [esi+188]
  0219b	83 38 ff	 cmp	 DWORD PTR [eax], -1
  0219e	74 05		 je	 SHORT $L26273

; 3622 : 		opt_volume = nsd.volume;

  021a0	8b 4e 64	 mov	 ecx, DWORD PTR [esi+100]
  021a3	89 08		 mov	 DWORD PTR [eax], ecx
$L26273:

; 3623 : 	}
; 3624 : }

  021a5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  021a8	5f		 pop	 edi
  021a9	5e		 pop	 esi
  021aa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  021b1	c9		 leave
  021b2	c3		 ret	 0
$L105869:
  00987	ff 75 f0	 push	 DWORD PTR $T105866[ebp]
  0098a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0098f	59		 pop	 ecx
  00990	c3		 ret	 0
__ehhandler$?SetVolumeDec@MusicTrack@@QAEXPAVMMLfile@@@Z:
  00991	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T105871
  00996	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetVolumeDec@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP	; MusicTrack::SetVolumeDec
PUBLIC	?SetVolumeInc@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetVolumeInc
$T105887 DD	0ffffffffH
	DD	FLAT:$L105881
$T105883 DD	019930520H
	DD	01H
	DD	FLAT:$T105887
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T105878 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetVolumeInc@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetVolumeInc
; _this$ = edx
; _MML$ = ecx

; 3570 : {

  021b3	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetVolumeInc@MusicTrack@@QAEXPAVMMLfile@@@Z
  021b8	e8 00 00 00 00	 call	 __EH_prolog
  021bd	51		 push	 ecx
  021be	56		 push	 esi
  021bf	57		 push	 edi
  021c0	8b f9		 mov	 edi, ecx
  021c2	8b f2		 mov	 esi, edx

; 3571 : 	unsigned	char	cData = MML->GetChar();

  021c4	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 3572 : 				int		iValue;
; 3573 : 
; 3574 : 	if((cData >= '0') && (cData <= '9')){

  021c9	3c 30		 cmp	 al, 48			; 00000030H
  021cb	72 16		 jb	 SHORT $L26244
  021cd	3c 39		 cmp	 al, 57			; 00000039H
  021cf	77 12		 ja	 SHORT $L26244

; 3575 : 		MML->Back();

  021d1	8b c7		 mov	 eax, edi
  021d3	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back

; 3576 : 		iValue = MML->GetInt();

  021d8	8b c7		 mov	 eax, edi
  021da	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  021df	8b f8		 mov	 edi, eax

; 3577 : 	} else {

  021e1	eb 0a		 jmp	 SHORT $L26245
$L26244:

; 3578 : 		MML->Back();

  021e3	8b c7		 mov	 eax, edi
  021e5	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back

; 3579 : 		iValue = 1;

  021ea	33 ff		 xor	 edi, edi
  021ec	47		 inc	 edi
$L26245:

; 3580 : 	}
; 3581 : 
; 3582 : 	EchoVolRet();

  021ed	e8 00 00 00 00	 call	 ?EchoVolRet@MusicTrack@@QAEXXZ ; MusicTrack::EchoVolRet

; 3583 : 
; 3584 : 	while(iValue > 0){

  021f2	85 ff		 test	 edi, edi
  021f4	7e 36		 jle	 SHORT $L26248
$L26247:

; 3585 : 		SetEvent(new mml_general(nsd_Volume_Up, _T("Volume up")));

  021f6	6a 3c		 push	 60			; 0000003cH
  021f8	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  021fd	59		 pop	 ecx
  021fe	89 45 f0	 mov	 DWORD PTR $T105878[ebp], eax
  02201	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  02205	85 c0		 test	 eax, eax
  02207	74 0f		 je	 SHORT $L105879
  02209	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@ILJOBKB@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAu?$AAp?$AA?$AA@
  0220e	6a 21		 push	 33			; 00000021H
  02210	50		 push	 eax
  02211	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  02216	eb 02		 jmp	 SHORT $L105880
$L105879:
  02218	33 c0		 xor	 eax, eax
$L105880:
  0221a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0221e	50		 push	 eax
  0221f	8b c6		 mov	 eax, esi
  02221	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 3586 : 		nsd.volume++;

  02226	ff 46 64	 inc	 DWORD PTR [esi+100]
  02229	4f		 dec	 edi
  0222a	75 ca		 jne	 SHORT $L26247
$L26248:

; 3587 : 		iValue--;
; 3588 : 	}
; 3589 : 	if(nsd.volume>15){

  0222c	6a 0f		 push	 15			; 0000000fH
  0222e	58		 pop	 eax
  0222f	39 46 64	 cmp	 DWORD PTR [esi+100], eax
  02232	7e 03		 jle	 SHORT $L26254

; 3590 : 		nsd.volume = 15;

  02234	89 46 64	 mov	 DWORD PTR [esi+100], eax
$L26254:

; 3591 : 	}
; 3592 : 	if(opt_volume != -1){

  02237	8d 86 bc 00 00
	00		 lea	 eax, DWORD PTR [esi+188]
  0223d	83 38 ff	 cmp	 DWORD PTR [eax], -1
  02240	74 05		 je	 SHORT $L26255

; 3593 : 		opt_volume = nsd.volume;

  02242	8b 4e 64	 mov	 ecx, DWORD PTR [esi+100]
  02245	89 08		 mov	 DWORD PTR [eax], ecx
$L26255:

; 3594 : 	}
; 3595 : }

  02247	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0224a	5f		 pop	 edi
  0224b	5e		 pop	 esi
  0224c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  02253	c9		 leave
  02254	c3		 ret	 0
$L105881:
  0099b	ff 75 f0	 push	 DWORD PTR $T105878[ebp]
  0099e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  009a3	59		 pop	 ecx
  009a4	c3		 ret	 0
__ehhandler$?SetVolumeInc@MusicTrack@@QAEXPAVMMLfile@@@Z:
  009a5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T105883
  009aa	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetVolumeInc@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP	; MusicTrack::SetVolumeInc
PUBLIC	?SetVolume@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetVolume
$T105898 DD	0ffffffffH
	DD	FLAT:$L105893
$T105895 DD	019930520H
	DD	01H
	DD	FLAT:$T105898
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T105890 = 8						; size = 4
_MML$ = 8						; size = 4
?SetVolume@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetVolume
; _this$ = esi

; 3553 : {

  02255	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetVolume@MusicTrack@@QAEXPAVMMLfile@@@Z
  0225a	e8 00 00 00 00	 call	 __EH_prolog

; 3554 : 	int	i = MML->GetInt();

  0225f	8b 45 08	 mov	 eax, DWORD PTR _MML$[ebp]
  02262	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 3555 : 
; 3556 : 	if( (i <= 15) && (i >= 0) ){

  02267	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0226a	7f 62		 jg	 SHORT $L26230
  0226c	85 c0		 test	 eax, eax
  0226e	7c 5e		 jl	 SHORT $L26230

; 3557 : 		if(opt_volume != i){

  02270	8d 8e bc 00 00
	00		 lea	 ecx, DWORD PTR [esi+188]
  02276	39 01		 cmp	 DWORD PTR [ecx], eax
  02278	74 46		 je	 SHORT $L26228

; 3558 : 			nsd.volume		= (char)i;

  0227a	0f be c0	 movsx	 eax, al

; 3559 : 			opt_volume		= nsd.volume;
; 3560 : 			echo_vol_ret	= false;
; 3561 : 			SetEvent(new mml_general(nsd_Volume + nsd.volume, _T("Volume")));

  0227d	6a 3c		 push	 60			; 0000003cH
  0227f	89 46 64	 mov	 DWORD PTR [esi+100], eax
  02282	89 01		 mov	 DWORD PTR [ecx], eax
  02284	c6 86 d9 00 00
	00 00		 mov	 BYTE PTR [esi+217], 0
  0228b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  02290	59		 pop	 ecx
  02291	89 45 08	 mov	 DWORD PTR $T105890[ebp], eax
  02294	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  02298	85 c0		 test	 eax, eax
  0229a	74 16		 je	 SHORT $L105891
  0229c	33 c9		 xor	 ecx, ecx
  0229e	8a 4e 64	 mov	 cl, BYTE PTR [esi+100]
  022a1	80 c1 60	 add	 cl, 96			; 00000060H
  022a4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1O@DMLCJFNF@?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@
  022a9	51		 push	 ecx
  022aa	50		 push	 eax
  022ab	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  022b0	eb 02		 jmp	 SHORT $L105892
$L105891:
  022b2	33 c0		 xor	 eax, eax
$L105892:
  022b4	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  022b8	50		 push	 eax
  022b9	8b c6		 mov	 eax, esi
  022bb	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent
$L26228:

; 3565 : 	}
; 3566 : }

  022c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  022c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  022ca	c9		 leave
  022cb	c2 04 00	 ret	 4
$L26230:

; 3562 : 		}
; 3563 : 	} else {
; 3564 : 		MML->Err(_T("0`15wB"));

  022ce	8b 45 08	 mov	 eax, DWORD PTR _MML$[ebp]
  022d1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CK@OMCJIBOF@?$JH?s?$JB?O0o?$AA0?$PP?$FO?$AA1?$AA50n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O0?$GA0U0D0?$AC@
  022d6	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L105899:
$L105897:
  022db	cc		 int	 3
$L105893:
  009af	ff 75 08	 push	 DWORD PTR $T105890[ebp]
  009b2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  009b7	59		 pop	 ecx
  009b8	c3		 ret	 0
__ehhandler$?SetVolume@MusicTrack@@QAEXPAVMMLfile@@@Z:
  009b9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T105895
  009be	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetVolume@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP		; MusicTrack::SetVolume
PUBLIC	?SetOctave@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetOctave
$T105910 DD	0ffffffffH
	DD	FLAT:$L105905
$T105907 DD	019930520H
	DD	01H
	DD	FLAT:$T105910
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T105902 = 8						; size = 4
_MML$ = 8						; size = 4
?SetOctave@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetOctave
; _this$ = esi

; 3489 : {

  022dc	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetOctave@MusicTrack@@QAEXPAVMMLfile@@@Z
  022e1	e8 00 00 00 00	 call	 __EH_prolog

; 3490 : 	nsd.octave = (char)(MML->GetInt() - 1);

  022e6	8b 45 08	 mov	 eax, DWORD PTR _MML$[ebp]
  022e9	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  022ee	fe c8		 dec	 al
  022f0	0f be c0	 movsx	 eax, al

; 3491 : 
; 3492 : 	if( (nsd.octave <= 7) && (nsd.octave >=0) ){

  022f3	83 f8 07	 cmp	 eax, 7
  022f6	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  022f9	7f 5a		 jg	 SHORT $L26179
  022fb	85 c0		 test	 eax, eax
  022fd	7c 56		 jl	 SHORT $L26179

; 3493 : 		if(opt_octave != nsd.octave){

  022ff	39 86 c0 00 00
	00		 cmp	 DWORD PTR [esi+192], eax
  02305	74 40		 je	 SHORT $L26177

; 3494 : 			SetEvent(new mml_general(nsd_Octave + (unsigned char)nsd.octave, _T("Octave")));

  02307	6a 3c		 push	 60			; 0000003cH
  02309	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0230e	59		 pop	 ecx
  0230f	89 45 08	 mov	 DWORD PTR $T105902[ebp], eax
  02312	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  02316	85 c0		 test	 eax, eax
  02318	74 16		 je	 SHORT $L105903
  0231a	33 c9		 xor	 ecx, ecx
  0231c	8a 4e 4c	 mov	 cl, BYTE PTR [esi+76]
  0231f	80 c1 38	 add	 cl, 56			; 00000038H
  02322	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1O@FEMFBHON@?$AAO?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?$AA@
  02327	51		 push	 ecx
  02328	50		 push	 eax
  02329	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  0232e	eb 02		 jmp	 SHORT $L105904
$L105903:
  02330	33 c0		 xor	 eax, eax
$L105904:
  02332	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  02336	50		 push	 eax
  02337	8b c6		 mov	 eax, esi
  02339	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 3495 : 			opt_octave = nsd.octave;

  0233e	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  02341	89 86 c0 00 00
	00		 mov	 DWORD PTR [esi+192], eax
$L26177:

; 3499 : 	}
; 3500 : }

  02347	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0234a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  02351	c9		 leave
  02352	c2 04 00	 ret	 4
$L26179:

; 3496 : 		}
; 3497 : 	} else {
; 3498 : 		MML->Err(_T("IN^[u1`8wB"));

  02355	8b 45 08	 mov	 eax, DWORD PTR _MML$[ebp]
  02358	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CO@KKLECMEI@0?$KK0?$KP0?$LP0?$PM0?V0o?$AA1?$PP?$FO?$AA80n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O0?$GA0U@
  0235d	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L105911:
$L105909:
  02362	cc		 int	 3
$L105905:
  009c3	ff 75 08	 push	 DWORD PTR $T105902[ebp]
  009c6	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  009cb	59		 pop	 ecx
  009cc	c3		 ret	 0
__ehhandler$?SetOctave@MusicTrack@@QAEXPAVMMLfile@@@Z:
  009cd	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T105907
  009d2	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetOctave@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP		; MusicTrack::SetOctave
PUBLIC	?SetKeyShift_Relative@MusicTrack@@QAEXPAVMMLfile@@@Z ; MusicTrack::SetKeyShift_Relative
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_MML$ = 8						; size = 4
?SetKeyShift_Relative@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR ; MusicTrack::SetKeyShift_Relative
; _this$ = eax

; 3441 : {

  02363	56		 push	 esi

; 3442 : 	iKeyShift += MML->GetInt();

  02364	8b f0		 mov	 esi, eax
  02366	8b 44 24 08	 mov	 eax, DWORD PTR _MML$[esp]
  0236a	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  02370	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  02375	01 06		 add	 DWORD PTR [esi], eax
  02377	8b 36		 mov	 esi, DWORD PTR [esi]

; 3443 : 	if( (iKeyShift < -128) || (iKeyShift > 127) ){

  02379	83 fe 80	 cmp	 esi, -128		; ffffff80H
  0237c	7c 05		 jl	 SHORT $L26150
  0237e	83 fe 7f	 cmp	 esi, 127		; 0000007fH
  02381	7e 0e		 jle	 SHORT $L26148
$L26150:

; 3444 : 		MML->Err(_T("L[Vtg-127`128B"));

  02383	8b 44 24 08	 mov	 eax, DWORD PTR _MML$[esp]
  02387	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DC@IEPABAMO@0?$KN0?$PM0?$LH0?U0?H0n?$HL?DV?r0L?$AA?9?$AA1?$AA2?$AA7?$PP?$FO?$AA1?$AA2?$AA80?$JC?$IN?$IF0H@
  0238c	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L105914:
$L26148:
  02391	5e		 pop	 esi

; 3445 : 	}
; 3446 : 
; 3447 : }

  02392	c2 04 00	 ret	 4
$L105913:
?SetKeyShift_Relative@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP ; MusicTrack::SetKeyShift_Relative
_TEXT	ENDS
PUBLIC	?SetKeyShift@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetKeyShift
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_this$ = 8						; size = 4
_MML$ = 12						; size = 4
?SetKeyShift@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetKeyShift

; 3426 : 	iKeyShift = MML->GetInt();

  02395	8b 44 24 08	 mov	 eax, DWORD PTR _MML$[esp-4]
  02399	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 3427 : 	if( (iKeyShift < -128) || (iKeyShift > 127) ){

  0239e	83 f8 80	 cmp	 eax, -128		; ffffff80H
  023a1	8b 4c 24 04	 mov	 ecx, DWORD PTR _this$[esp-4]
  023a5	89 81 d4 00 00
	00		 mov	 DWORD PTR [ecx+212], eax
  023ab	7c 05		 jl	 SHORT $L26143
  023ad	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  023b0	7e 0e		 jle	 SHORT $L26141
$L26143:

; 3428 : 		MML->Err(_T("L[Vtg-127`128wB"));

  023b2	8b 44 24 08	 mov	 eax, DWORD PTR _MML$[esp-4]
  023b6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DI@EBCJNIGK@0?$KN0?$PM0?$LH0?U0?H0o?$AA?9?$AA1?$AA2?$AA7?$PP?$FO?$AA1?$AA2?$AA80n?$HL?DV?r0gc?$AH?$FL?$JK@
  023bb	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L105917:
$L26141:

; 3429 : 	}
; 3430 : }

  023c0	c2 08 00	 ret	 8
$L105916:
?SetKeyShift@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP	; MusicTrack::SetKeyShift
_TEXT	ENDS
PUBLIC	?SetProtament@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetProtament
$T105931 DD	0ffffffffH
	DD	FLAT:$L105923
$T105925 DD	019930520H
	DD	01H
	DD	FLAT:$T105931
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
__Decay$ = -20						; size = 4
__Rate$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T105920 = 8						; size = 4
_this$ = 8						; size = 4
?SetProtament@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetProtament
; _MML$ = ecx

; 3366 : {

  023c3	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetProtament@MusicTrack@@QAEXPAVMMLfile@@@Z
  023c8	e8 00 00 00 00	 call	 __EH_prolog
  023cd	51		 push	 ecx
  023ce	51		 push	 ecx
  023cf	53		 push	 ebx
  023d0	56		 push	 esi
  023d1	57		 push	 edi
  023d2	8b f9		 mov	 edi, ecx

; 3367 : 	unsigned	char	cData;
; 3368 : 
; 3369 : 				int		_Decay;
; 3370 : 				int		_Rate;
; 3371 : 				int		_Depth;
; 3372 : 				int		_Target;
; 3373 : 
; 3374 : 	_Decay = MML->GetInt();

  023d4	8b c7		 mov	 eax, edi
  023d6	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  023db	8b f0		 mov	 esi, eax

; 3375 : 	if( (_Decay < 0) || (_Decay > 255) ){

  023dd	85 f6		 test	 esi, esi
  023df	0f 8c e8 00 00
	00		 jl	 $L26114
  023e5	81 fe ff 00 00
	00		 cmp	 esi, 255		; 000000ffH
  023eb	0f 8f dc 00 00
	00		 jg	 $L26114

; 3377 : 	}
; 3378 : 	_Decay++;
; 3379 : 
; 3380 : 	cData = MML->GetChar();

  023f1	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 3381 : 	if(cData != ','){

  023f6	3c 2c		 cmp	 al, 44			; 0000002cH

; 3382 : 		MML->Err(_T("P R}hp[^BSwB"));

  023f8	8b c7		 mov	 eax, edi
  023fa	74 0a		 je	 SHORT $L26116
$L105930:
  023fc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DO@OLCBIOJB@?$AAP?$AA?50?$LD0?$NO0?s0?I0n0?Q0?i0?a0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC?$PP?$BE@
  02401	e9 ce 00 00 00	 jmp	 $L105929
$L26116:

; 3383 : 	}
; 3384 : 
; 3385 : 	_Rate = MML->GetInt();

  02406	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 3386 : 	if( (_Rate < 1) || (_Rate > 256) ){

  0240b	83 f8 01	 cmp	 eax, 1
  0240e	89 45 f0	 mov	 DWORD PTR __Rate$[ebp], eax
  02411	0f 8c af 00 00
	00		 jl	 $L26119
  02417	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0241c	0f 8f a4 00 00
	00		 jg	 $L26119

; 3388 : 	}
; 3389 : 
; 3390 : 	cData = MML->GetChar();

  02422	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 3391 : 	if(cData != ','){

  02427	3c 2c		 cmp	 al, 44			; 0000002cH

; 3392 : 		MML->Err(_T("P R}hp[^BSwB"));

  02429	8b c7		 mov	 eax, edi
  0242b	75 cf		 jne	 SHORT $L105930

; 3393 : 	}
; 3394 : 
; 3395 : 	_Depth = MML->GetInt();

  0242d	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  02432	8b d8		 mov	 ebx, eax

; 3396 : 	if( (_Depth < -128) || (_Depth > 127) ){

  02434	83 fb 80	 cmp	 ebx, -128		; ffffff80H
  02437	0f 8c 82 00 00
	00		 jl	 $L26123
  0243d	83 fb 7f	 cmp	 ebx, 127		; 0000007fH
  02440	7f 7d		 jg	 SHORT $L26123

; 3398 : 	}
; 3399 : 	_Decay++;

  02442	46		 inc	 esi
  02443	46		 inc	 esi
  02444	89 75 ec	 mov	 DWORD PTR __Decay$[ebp], esi

; 3400 : 
; 3401 : 	cData = MML->GetChar();

  02447	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 3402 : 	if(cData != ','){

  0244c	3c 2c		 cmp	 al, 44			; 0000002cH

; 3403 : 		MML->Err(_T("P R}hp[^BSwB"));

  0244e	8b c7		 mov	 eax, edi
  02450	75 aa		 jne	 SHORT $L105930

; 3404 : 	}
; 3405 : 
; 3406 : 	_Target = MML->GetInt();

  02452	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  02457	8b f0		 mov	 esi, eax

; 3407 : 	if( (_Target < -128) || (_Target > 127) ){

  02459	83 fe 80	 cmp	 esi, -128		; ffffff80H
  0245c	7c 5a		 jl	 SHORT $L26127
  0245e	83 fe 7f	 cmp	 esi, 127		; 0000007fH
  02461	7f 55		 jg	 SHORT $L26127

; 3409 : 	}
; 3410 : 
; 3411 : 	if(jump_flag == false){

  02463	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  02466	80 bf a1 00 00
	00 00		 cmp	 BYTE PTR [edi+161], 0
  0246d	75 38		 jne	 SHORT $L26107

; 3412 :         SetEvent(new mml_general(nsd_Portamento, (unsigned char)_Decay, (unsigned char)_Rate, (unsigned char)_Depth, (unsigned char)_Target, _T("Portamento")));

  0246f	6a 3c		 push	 60			; 0000003cH
  02471	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  02476	59		 pop	 ecx
  02477	89 45 08	 mov	 DWORD PTR $T105920[ebp], eax
  0247a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0247e	85 c0		 test	 eax, eax
  02480	74 17		 je	 SHORT $L105921
  02482	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BG@GGJHBHG@?$AAP?$AAo?$AAr?$AAt?$AAa?$AAm?$AAe?$AAn?$AAt?$AAo?$AA?$AA@
  02487	56		 push	 esi
  02488	53		 push	 ebx
  02489	ff 75 f0	 push	 DWORD PTR __Rate$[ebp]
  0248c	ff 75 ec	 push	 DWORD PTR __Decay$[ebp]
  0248f	6a 17		 push	 23			; 00000017H
  02491	50		 push	 eax
  02492	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EDDDDQBG@Z ; mml_general::mml_general
  02497	eb 02		 jmp	 SHORT $L105922
$L105921:
  02499	33 c0		 xor	 eax, eax
$L105922:
  0249b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0249f	50		 push	 eax
  024a0	8b c7		 mov	 eax, edi
  024a2	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent
$L26107:

; 3413 : 	}
; 3414 : }

  024a7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  024aa	5f		 pop	 edi
  024ab	5e		 pop	 esi
  024ac	5b		 pop	 ebx
  024ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  024b4	c9		 leave
  024b5	c2 04 00	 ret	 4
$L26127:

; 3408 : 		MML->Err(_T("|^g4p[^-128`127wB"));

  024b8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1EK@FHHEJADM@0?$NN0?k0?$LP0?a0?s0?H0n?$HL?0?$AA40?Q0?i0?a0?$PM0?$LP0o?$AA?9?$AA1?$AA2?$AA8?$PP?$FO@
  024bd	eb 13		 jmp	 SHORT $L105928
$L26123:

; 3397 : 		MML->Err(_T("|^g3p[^-128`127wB"));

  024bf	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1EK@HIFALIIE@0?$NN0?k0?$LP0?a0?s0?H0n?$HL?0?$AA30?Q0?i0?a0?$PM0?$LP0o?$AA?9?$AA1?$AA2?$AA8?$PP?$FO@
  024c4	eb 0c		 jmp	 SHORT $L105928
$L26119:

; 3387 : 		MML->Err(_T("|^g2p[^1`256wB"));

  024c6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1EE@IIGGDGHG@0?$NN0?k0?$LP0?a0?s0?H0n?$HL?0?$AA20?Q0?i0?a0?$PM0?$LP0o?$AA1?$PP?$FO?$AA2?$AA5?$AA6@
  024cb	eb 05		 jmp	 SHORT $L105928
$L26114:

; 3376 : 		MML->Err(_T("|^g1p[^0`255wB"));

  024cd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1EE@PLBKOKJL@0?$NN0?k0?$LP0?a0?s0?H0n?$HL?0?$AA10?Q0?i0?a0?$PM0?$LP0o?$AA0?$PP?$FO?$AA2?$AA5?$AA5@
$L105928:
  024d2	8b c7		 mov	 eax, edi
$L105929:
  024d4	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L105932:
$L105927:
  024d9	cc		 int	 3
$L105923:
  009d7	ff 75 08	 push	 DWORD PTR $T105920[ebp]
  009da	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  009df	59		 pop	 ecx
  009e0	c3		 ret	 0
__ehhandler$?SetProtament@MusicTrack@@QAEXPAVMMLfile@@@Z:
  009e1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T105925
  009e6	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetProtament@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP	; MusicTrack::SetProtament
PUBLIC	?SetEchoBuffer@MusicTrack@@QAEXPAVMMLfile@@H@Z	; MusicTrack::SetEchoBuffer
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_iEchoNote$ = -8					; size = 4
_cData$25818 = -1					; size = 1
?SetEchoBuffer@MusicTrack@@QAEXPAVMMLfile@@H@Z PROC NEAR ; MusicTrack::SetEchoBuffer
; _this$ = ebx
; _MML$ = ecx
; _note$ = eax

; 2769 : {

  024da	55		 push	 ebp
  024db	8b ec		 mov	 ebp, esp
  024dd	51		 push	 ecx
  024de	51		 push	 ecx
  024df	56		 push	 esi
  024e0	57		 push	 edi
  024e1	8b f9		 mov	 edi, ecx
  024e3	8b f0		 mov	 esi, eax

; 2770 : 	int		iEchoNote;
; 2771 : 
; 2772 : 	if(note == -1){

  024e5	83 c9 ff	 or	 ecx, -1
  024e8	3b f1		 cmp	 esi, ecx

; 2773 : 		//x
; 2774 : 		iEchoNote = -1;
; 2775 : 
; 2776 : 	} else {

  024ea	74 53		 je	 SHORT $L25822

; 2777 : 		//m[g
; 2778 : 		unsigned	char	cData;
; 2779 : 					int		iOctave;
; 2780 : 
; 2781 : 		iEchoNote = calc_note(MML, note);

  024ec	53		 push	 ebx
  024ed	8b c7		 mov	 eax, edi
  024ef	e8 00 00 00 00	 call	 ?calc_note@MusicTrack@@QAEDPAVMMLfile@@H@Z ; MusicTrack::calc_note
  024f4	0f be c0	 movsx	 eax, al
  024f7	89 45 f8	 mov	 DWORD PTR _iEchoNote$[ebp], eax

; 2782 : 
; 2783 : 		cData = MML->GetChar();

  024fa	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar
  024ff	88 45 ff	 mov	 BYTE PTR _cData$25818[ebp], al

; 2784 : 		MML->Back();

  02502	8b c7		 mov	 eax, edi
  02504	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back

; 2785 : 
; 2786 : 		if((cData >= '0') && (cData <= '9')){

  02509	80 7d ff 30	 cmp	 BYTE PTR _cData$25818[ebp], 48 ; 00000030H
  0250d	72 10		 jb	 SHORT $L25820
  0250f	80 7d ff 39	 cmp	 BYTE PTR _cData$25818[ebp], 57 ; 00000039H
  02513	77 0a		 ja	 SHORT $L25820

; 2787 : 			iOctave = MML->GetInt() - 1;

  02515	8b c7		 mov	 eax, edi
  02517	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  0251c	48		 dec	 eax

; 2788 : 		} else {

  0251d	eb 03		 jmp	 SHORT $L25821
$L25820:

; 2789 : 			iOctave = nsd.octave;

  0251f	8b 43 4c	 mov	 eax, DWORD PTR [ebx+76]
$L25821:

; 2790 : 		}
; 2791 : 		iEchoNote += iKeyShift;
; 2792 : 		iEchoNote += iOctave*12;

  02522	8b 8b d4 00 00
	00		 mov	 ecx, DWORD PTR [ebx+212]
  02528	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0252b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0252e	01 45 f8	 add	 DWORD PTR _iEchoNote$[ebp], eax

; 2793 : 		if((iEchoNote<0) || (iEchoNote>255)){

  02531	78 22		 js	 SHORT $L25823
  02533	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _iEchoNote$[ebp], 255 ; 000000ffH
  0253a	7f 19		 jg	 SHORT $L25823
  0253c	8a 4d f8	 mov	 cl, BYTE PTR _iEchoNote$[ebp]
$L25822:

; 2795 : 		}
; 2796 : 	}
; 2797 : 
; 2798 : 	pt_oldNote++;

  0253f	8d 83 e2 01 00
	00		 lea	 eax, DWORD PTR [ebx+482]
  02545	fe 00		 inc	 BYTE PTR [eax]

; 2799 : 	oldNote[pt_oldNote]	= (char)iEchoNote;

  02547	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0254a	5f		 pop	 edi
  0254b	88 8c 18 e2 00
	00 00		 mov	 BYTE PTR [eax+ebx+226], cl
  02552	5e		 pop	 esi

; 2800 : }

  02553	c9		 leave
  02554	c3		 ret	 0
$L25823:

; 2794 : 			MML->Err(_T("m[gio[0`255B"));

  02555	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DK@PHOKHOEC@?$JH?sz?$AL0n?$HL?DV?r0L0?N0?$PM0?H0?J0?s0?P0?$PM?$AA0?$PP?$FO?$AA2?$AA5?$AA50n?$HL?D@
  0255a	8b c7		 mov	 eax, edi
  0255c	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L105935:
$L105934:
  02561	cc		 int	 3
?SetEchoBuffer@MusicTrack@@QAEXPAVMMLfile@@H@Z ENDP	; MusicTrack::SetEchoBuffer
_TEXT	ENDS
PUBLIC	?SetMMinor@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetMMinor
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_cData$ = -1						; size = 1
?SetMMinor@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetMMinor
; _this$ = ebx
; _MML$ = eax

; 2122 : {

  02562	55		 push	 ebp
  02563	8b ec		 mov	 ebp, esp
  02565	51		 push	 ecx
  02566	56		 push	 esi
  02567	57		 push	 edi
  02568	8b f8		 mov	 edi, eax

; 2123 : 	char	cData		= MML->GetChar();

  0256a	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar
  0256f	88 45 ff	 mov	 BYTE PTR _cData$[ebp], al

; 2124 : 			nowScale	= 20;

  02572	8d b3 d1 00 00
	00		 lea	 esi, DWORD PTR [ebx+209]

; 2125 : 
; 2126 : 	MML->Back();

  02578	8b c7		 mov	 eax, edi
  0257a	c6 06 14	 mov	 BYTE PTR [esi], 20	; 00000014H
  0257d	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back

; 2127 : 
; 2128 : 	if(cData=='('){

  02582	80 7d ff 28	 cmp	 BYTE PTR _cData$[ebp], 40 ; 00000028H
  02586	75 09		 jne	 SHORT $L25433

; 2129 : 		nowScale	+= (char)(MML->GetNum());

  02588	8b c7		 mov	 eax, edi
  0258a	e8 00 00 00 00	 call	 ?GetNum@MMLfile@@QAEHXZ	; MMLfile::GetNum
  0258f	00 06		 add	 BYTE PTR [esi], al
$L25433:

; 2130 : 	}
; 2131 : 
; 2132 : 	SetKey(nowKey, nowScale);

  02591	0f be 83 d0 00
	00 00		 movsx	 eax, BYTE PTR [ebx+208]
  02598	0f be 0e	 movsx	 ecx, BYTE PTR [esi]
  0259b	50		 push	 eax
  0259c	8b fb		 mov	 edi, ebx
  0259e	e8 00 00 00 00	 call	 ?SetKey@MusicTrack@@QAEXHH@Z ; MusicTrack::SetKey
  025a3	5f		 pop	 edi
  025a4	5e		 pop	 esi

; 2133 : }

  025a5	c9		 leave
  025a6	c3		 ret	 0
?SetMMinor@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP		; MusicTrack::SetMMinor
_TEXT	ENDS
PUBLIC	?SetHMinor@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetHMinor
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_cData$ = -1						; size = 1
?SetHMinor@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetHMinor
; _this$ = ebx
; _MML$ = eax

; 2107 : {

  025a7	55		 push	 ebp
  025a8	8b ec		 mov	 ebp, esp
  025aa	51		 push	 ecx
  025ab	56		 push	 esi
  025ac	57		 push	 edi
  025ad	8b f8		 mov	 edi, eax

; 2108 : 	char	cData		= MML->GetChar();

  025af	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar
  025b4	88 45 ff	 mov	 BYTE PTR _cData$[ebp], al

; 2109 : 			nowScale	= 10;

  025b7	8d b3 d1 00 00
	00		 lea	 esi, DWORD PTR [ebx+209]

; 2110 : 
; 2111 : 	MML->Back();

  025bd	8b c7		 mov	 eax, edi
  025bf	c6 06 0a	 mov	 BYTE PTR [esi], 10	; 0000000aH
  025c2	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back

; 2112 : 
; 2113 : 	if(cData=='('){

  025c7	80 7d ff 28	 cmp	 BYTE PTR _cData$[ebp], 40 ; 00000028H
  025cb	75 09		 jne	 SHORT $L25426

; 2114 : 		nowScale	+= (char)(MML->GetNum());

  025cd	8b c7		 mov	 eax, edi
  025cf	e8 00 00 00 00	 call	 ?GetNum@MMLfile@@QAEHXZ	; MMLfile::GetNum
  025d4	00 06		 add	 BYTE PTR [esi], al
$L25426:

; 2115 : 	}
; 2116 : 
; 2117 : 	SetKey(nowKey, nowScale);

  025d6	0f be 83 d0 00
	00 00		 movsx	 eax, BYTE PTR [ebx+208]
  025dd	0f be 0e	 movsx	 ecx, BYTE PTR [esi]
  025e0	50		 push	 eax
  025e1	8b fb		 mov	 edi, ebx
  025e3	e8 00 00 00 00	 call	 ?SetKey@MusicTrack@@QAEXHH@Z ; MusicTrack::SetKey
  025e8	5f		 pop	 edi
  025e9	5e		 pop	 esi

; 2118 : }

  025ea	c9		 leave
  025eb	c3		 ret	 0
?SetHMinor@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP		; MusicTrack::SetHMinor
_TEXT	ENDS
PUBLIC	?SetScale@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetScale
; Function compile flags: /Ogsy
_TEXT	SEGMENT
?SetScale@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetScale
; _this$ = ecx
; _MML$ = eax

; 2088 : {

  025ec	57		 push	 edi
  025ed	8b f9		 mov	 edi, ecx

; 2089 : 	nowScale	= (char)MML->GetNum();

  025ef	e8 00 00 00 00	 call	 ?GetNum@MMLfile@@QAEHXZ	; MMLfile::GetNum
  025f4	88 87 d1 00 00
	00		 mov	 BYTE PTR [edi+209], al

; 2090 : 	SetKey(nowKey, nowScale);

  025fa	0f be c8	 movsx	 ecx, al
  025fd	0f be 87 d0 00
	00 00		 movsx	 eax, BYTE PTR [edi+208]
  02604	50		 push	 eax
  02605	e8 00 00 00 00	 call	 ?SetKey@MusicTrack@@QAEXHH@Z ; MusicTrack::SetKey
  0260a	5f		 pop	 edi

; 2091 : }

  0260b	c3		 ret	 0
?SetScale@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP		; MusicTrack::SetScale
_TEXT	ENDS
PUBLIC	?SetReleaseVolume@MusicTrack@@QAEXPAVMMLfile@@@Z ; MusicTrack::SetReleaseVolume
$T105949 DD	0ffffffffH
	DD	FLAT:$L105944
$T105946 DD	019930520H
	DD	01H
	DD	FLAT:$T105949
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
$T105941 = 12						; size = 4
_MML$ = 12						; size = 4
?SetReleaseVolume@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR ; MusicTrack::SetReleaseVolume

; 1897 : {

  0260c	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetReleaseVolume@MusicTrack@@QAEXPAVMMLfile@@@Z
  02611	e8 00 00 00 00	 call	 __EH_prolog

; 1898 : 	int	i = MML->GetInt();

  02616	8b 45 0c	 mov	 eax, DWORD PTR _MML$[ebp]
  02619	53		 push	 ebx
  0261a	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  0261f	8b d8		 mov	 ebx, eax

; 1899 : 
; 1900 : 	if( (i <= 15) && (i >= 0) ){

  02621	83 fb 0f	 cmp	 ebx, 15			; 0000000fH
  02624	7f 46		 jg	 SHORT $L25370
  02626	85 db		 test	 ebx, ebx
  02628	7c 42		 jl	 SHORT $L25370

; 1901 : 		SetEvent(new mml_general(nsd_Release_Volume + (unsigned char)i, _T("Release Volume")));

  0262a	6a 3c		 push	 60			; 0000003cH
  0262c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  02631	59		 pop	 ecx
  02632	89 45 0c	 mov	 DWORD PTR $T105941[ebp], eax
  02635	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  02639	85 c0		 test	 eax, eax
  0263b	74 11		 je	 SHORT $L105942
  0263d	80 c3 70	 add	 bl, 112			; 00000070H
  02640	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BO@IEEELBMO@?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?5?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@
  02645	53		 push	 ebx
  02646	50		 push	 eax
  02647	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  0264c	eb 02		 jmp	 SHORT $L105943
$L105942:
  0264e	33 c0		 xor	 eax, eax
$L105943:
  02650	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  02654	50		 push	 eax
  02655	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  02658	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 1904 : 	}
; 1905 : }

  0265d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  02660	5b		 pop	 ebx
  02661	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  02668	c9		 leave
  02669	c2 08 00	 ret	 8
$L25370:

; 1902 : 	} else {
; 1903 : 		MML->Err(_T("0`15wB"));

  0266c	8b 45 0c	 mov	 eax, DWORD PTR _MML$[ebp]
  0266f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CK@OMCJIBOF@?$JH?s?$JB?O0o?$AA0?$PP?$FO?$AA1?$AA50n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O0?$GA0U0D0?$AC@
  02674	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L105950:
$L105948:
  02679	cc		 int	 3
$L105944:
  009eb	ff 75 0c	 push	 DWORD PTR $T105941[ebp]
  009ee	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  009f3	59		 pop	 ecx
  009f4	c3		 ret	 0
__ehhandler$?SetReleaseVolume@MusicTrack@@QAEXPAVMMLfile@@@Z:
  009f5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T105946
  009fa	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetReleaseVolume@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP	; MusicTrack::SetReleaseVolume
PUBLIC	?SetReleaseVoice@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetReleaseVoice
$T105961 DD	0ffffffffH
	DD	FLAT:$L105956
$T105958 DD	019930520H
	DD	01H
	DD	FLAT:$T105961
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
$T105953 = 12						; size = 4
_MML$ = 12						; size = 4
?SetReleaseVoice@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR ; MusicTrack::SetReleaseVoice

; 1878 : {

  0267a	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetReleaseVoice@MusicTrack@@QAEXPAVMMLfile@@@Z
  0267f	e8 00 00 00 00	 call	 __EH_prolog

; 1879 : 	int	i = MML->GetInt();

  02684	8b 45 0c	 mov	 eax, DWORD PTR _MML$[ebp]
  02687	53		 push	 ebx
  02688	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  0268d	8b d8		 mov	 ebx, eax

; 1880 : 
; 1881 : 	if( (i <= 7) && (i >= 0) ){

  0268f	83 fb 07	 cmp	 ebx, 7
  02692	7f 46		 jg	 SHORT $L25356
  02694	85 db		 test	 ebx, ebx
  02696	7c 42		 jl	 SHORT $L25356

; 1882 : 		SetEvent(new mml_general(nsd_Release_Voice + (unsigned char)i, _T("Release Voice")));

  02698	6a 3c		 push	 60			; 0000003cH
  0269a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0269f	59		 pop	 ecx
  026a0	89 45 0c	 mov	 DWORD PTR $T105953[ebp], eax
  026a3	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  026a7	85 c0		 test	 eax, eax
  026a9	74 11		 je	 SHORT $L105954
  026ab	80 c3 30	 add	 bl, 48			; 00000030H
  026ae	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BM@LPHMCIPB@?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AA?5?$AAV?$AAo?$AAi?$AAc?$AAe?$AA?$AA@
  026b3	53		 push	 ebx
  026b4	50		 push	 eax
  026b5	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  026ba	eb 02		 jmp	 SHORT $L105955
$L105954:
  026bc	33 c0		 xor	 eax, eax
$L105955:
  026be	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  026c2	50		 push	 eax
  026c3	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  026c6	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 1885 : 	}
; 1886 : }

  026cb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  026ce	5b		 pop	 ebx
  026cf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  026d6	c9		 leave
  026d7	c2 08 00	 ret	 8
$L25356:

; 1883 : 	} else {
; 1884 : 		MML->Err(_T("[XF0`7wB"));

  026da	8b 45 0c	 mov	 eax, DWORD PTR _MML$[ebp]
  026dd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DA@NPNLAEDI@0?j0?j0?$PM0?$LJ?$JH?s?$ICr0o?$AA0?$PP?$FO?$AA70n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O0?$GA@
  026e2	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L105962:
$L105960:
  026e7	cc		 int	 3
$L105956:
  009ff	ff 75 0c	 push	 DWORD PTR $T105953[ebp]
  00a02	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00a07	59		 pop	 ecx
  00a08	c3		 ret	 0
__ehhandler$?SetReleaseVoice@MusicTrack@@QAEXPAVMMLfile@@@Z:
  00a09	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T105958
  00a0e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetReleaseVoice@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP	; MusicTrack::SetReleaseVoice
PUBLIC	?SetReleaseMode@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetReleaseMode
$T105984 DD	0ffffffffH
	DD	FLAT:$L105976
	DD	0ffffffffH
	DD	FLAT:$L105977
	DD	0ffffffffH
	DD	FLAT:$L105978
$T105980 DD	019930520H
	DD	03H
	DD	FLAT:$T105984
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
$T105973 = 12						; size = 4
$T105969 = 12						; size = 4
$T105965 = 12						; size = 4
_MML$ = 12						; size = 4
?SetReleaseMode@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR ; MusicTrack::SetReleaseMode

; 1848 : {

  026e8	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetReleaseMode@MusicTrack@@QAEXPAVMMLfile@@@Z
  026ed	e8 00 00 00 00	 call	 __EH_prolog

; 1849 : 	mml_general*	_event;
; 1850 : 				int	i = MML->GetInt();

  026f2	8b 45 0c	 mov	 eax, DWORD PTR _MML$[ebp]
  026f5	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 1851 : 
; 1852 : 	switch(i){

  026fa	83 e8 00	 sub	 eax, 0
  026fd	74 57		 je	 SHORT $L25331
  026ff	48		 dec	 eax
  02700	74 2f		 je	 SHORT $L25337
  02702	48		 dec	 eax
  02703	74 0d		 je	 SHORT $L25343

; 1861 : 			break;
; 1862 : 		default:
; 1863 : 			MML->Err(_T("[X[h0`2wB"));

  02705	8b 45 0c	 mov	 eax, DWORD PTR _MML$[ebp]
  02708	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DC@NMCJFJGP@0?j0?j0?$PM0?$LJ0?b0?$PM0?I0o?$AA0?$PP?$FO?$AA20n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O@
  0270d	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L105985:
$L25343:

; 1858 : 			break;
; 1859 : 		case(2):
; 1860 : 			_event = new mml_general(nsd_GateMode_2,  _T("GateMode 2"));

  02712	6a 3c		 push	 60			; 0000003cH
  02714	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  02719	59		 pop	 ecx
  0271a	89 45 0c	 mov	 DWORD PTR $T105973[ebp], eax
  0271d	85 c0		 test	 eax, eax
  0271f	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  02726	74 4a		 je	 SHORT $L105966
  02728	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BG@ICPGMAAG@?$AAG?$AAa?$AAt?$AAe?$AAM?$AAo?$AAd?$AAe?$AA?5?$AA2?$AA?$AA@
  0272d	6a 0f		 push	 15			; 0000000fH
  0272f	eb 1d		 jmp	 SHORT $L105983
$L25337:

; 1855 : 			break;
; 1856 : 		case(1):
; 1857 : 			_event = new mml_general(nsd_GateMode_1,  _T("GateMode 1"));

  02731	6a 3c		 push	 60			; 0000003cH
  02733	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  02738	59		 pop	 ecx
  02739	89 45 0c	 mov	 DWORD PTR $T105969[ebp], eax
  0273c	85 c0		 test	 eax, eax
  0273e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  02745	74 2b		 je	 SHORT $L105966
  02747	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BG@JAEDGPOI@?$AAG?$AAa?$AAt?$AAe?$AAM?$AAo?$AAd?$AAe?$AA?5?$AA1?$AA?$AA@
  0274c	6a 0e		 push	 14			; 0000000eH
$L105983:
  0274e	50		 push	 eax
  0274f	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  02754	eb 1e		 jmp	 SHORT $L105967
$L25331:

; 1853 : 		case(0):
; 1854 : 			_event = new mml_general(nsd_GateMode_0,  _T("GateMode 0"));

  02756	6a 3c		 push	 60			; 0000003cH
  02758	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0275d	59		 pop	 ecx
  0275e	89 45 0c	 mov	 DWORD PTR $T105965[ebp], eax
  02761	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  02765	85 c0		 test	 eax, eax
  02767	74 09		 je	 SHORT $L105966
  02769	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BG@CIPPAIIN@?$AAG?$AAa?$AAt?$AAe?$AAM?$AAo?$AAd?$AAe?$AA?5?$AA0?$AA?$AA@
  0276e	6a 0d		 push	 13			; 0000000dH
  02770	eb dc		 jmp	 SHORT $L105983
$L105966:
  02772	33 c0		 xor	 eax, eax
$L105967:
  02774	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 1864 : 			break;
; 1865 : 	}
; 1866 : 	SetEvent(_event);

  02778	50		 push	 eax
  02779	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0277c	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 1867 : }

  02781	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  02784	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0278b	c9		 leave
  0278c	c2 08 00	 ret	 8
$L105982:
$L105978:
  00a13	ff 75 0c	 push	 DWORD PTR $T105973[ebp]
  00a16	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00a1b	59		 pop	 ecx
  00a1c	c3		 ret	 0
$L105977:
  00a1d	ff 75 0c	 push	 DWORD PTR $T105969[ebp]
  00a20	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00a25	59		 pop	 ecx
  00a26	c3		 ret	 0
$L105976:
  00a27	ff 75 0c	 push	 DWORD PTR $T105965[ebp]
  00a2a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00a2f	59		 pop	 ecx
  00a30	c3		 ret	 0
__ehhandler$?SetReleaseMode@MusicTrack@@QAEXPAVMMLfile@@@Z:
  00a31	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T105980
  00a36	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetReleaseMode@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP	; MusicTrack::SetReleaseMode
PUBLIC	?SetGatetime@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetGatetime
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_MML$ = 8						; size = 4
?SetGatetime@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetGatetime
; _this$ = eax

; 1805 : {

  0278f	56		 push	 esi
  02790	8b f0		 mov	 esi, eax

; 1806 : 	gatetime_q = MML->GetInt();

  02792	8b 44 24 08	 mov	 eax, DWORD PTR _MML$[esp]
  02796	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 1807 : 	if(gatetime_q > 255){

  0279b	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  027a0	89 86 ac 00 00
	00		 mov	 DWORD PTR [esi+172], eax
  027a6	7e 0e		 jle	 SHORT $L25310

; 1808 : 		MML->Err(_T("Q[g^Cq0`255wB"));

  027a8	8b 44 24 08	 mov	 eax, DWORD PTR _MML$[esp]
  027ac	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DE@DMILNHDF@0?$LC0?$PM0?H0?$LP0?$KE0?$OA?$AAq0o?$AA0?$PP?$FO?$AA2?$AA5?$AA50n?$HL?DV?r0gc?$AH?$FL?$JK0W@
  027b1	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L105988:
$L25310:

; 1809 : 	} else {
; 1810 : 		gatetime_Q = QMax;

  027b6	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  027bc	89 8e b0 00 00
	00		 mov	 DWORD PTR [esi+176], ecx

; 1811 : 		Set_q(gatetime_q);

  027c2	8b c8		 mov	 ecx, eax
  027c4	e8 00 00 00 00	 call	 ?Set_q@MusicTrack@@QAEXH@Z ; MusicTrack::Set_q
  027c9	5e		 pop	 esi

; 1812 : 	}
; 1813 : 
; 1814 : }

  027ca	c2 04 00	 ret	 4
$L105987:
?SetGatetime@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP	; MusicTrack::SetGatetime
_TEXT	ENDS
PUBLIC	?SetGatetime_Q@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetGatetime_Q
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_MML$ = 8						; size = 4
?SetGatetime_Q@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetGatetime_Q
; _this$ = eax

; 1782 : {

  027cd	56		 push	 esi
  027ce	8b f0		 mov	 esi, eax

; 1783 : 	int	i = MML->GetInt();

  027d0	8b 44 24 08	 mov	 eax, DWORD PTR _MML$[esp]
  027d4	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 1784 : 	if((i<1) || (i>QMax)){

  027d9	83 f8 01	 cmp	 eax, 1
  027dc	7c 24		 jl	 SHORT $L25302
  027de	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  027e4	3b c1		 cmp	 eax, ecx
  027e6	7f 1a		 jg	 SHORT $L25302

; 1785 : 		MML->Err(_T("Q[g^CQ1`#QMaxwB"));
; 1786 : 	} else {
; 1787 : 		gatetime_Q = i;

  027e8	89 86 b0 00 00
	00		 mov	 DWORD PTR [esi+176], eax

; 1788 : 		if(gatetime_Q == QMax){

  027ee	75 0e		 jne	 SHORT $L25299

; 1789 : 			gatetime_q = 0;

  027f0	83 a6 ac 00 00
	00 00		 and	 DWORD PTR [esi+172], 0

; 1790 : 			Set_q(gatetime_q);

  027f7	33 c9		 xor	 ecx, ecx
  027f9	e8 00 00 00 00	 call	 ?Set_q@MusicTrack@@QAEXH@Z ; MusicTrack::Set_q
$L25299:
  027fe	5e		 pop	 esi

; 1791 : 		}
; 1792 : 	}
; 1793 : 
; 1794 : }

  027ff	c2 04 00	 ret	 4
$L25302:
  02802	8b 44 24 08	 mov	 eax, DWORD PTR _MML$[esp]
  02806	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DI@HCGIJCFJ@0?$LC0?$PM0?H0?$LP0?$KE0?$OA?$AAQ0o?$AA1?$PP?$FO?$AA?$CD?$AAQ?$AAM?$AAa?$AAx0n?$HL?DV?r0gc?$AH@
  0280b	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L105991:
$L105990:
  02810	cc		 int	 3
?SetGatetime_Q@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP	; MusicTrack::SetGatetime_Q
_TEXT	ENDS
PUBLIC	?SetJump@MusicTrack@@QAEXPAVMMLfile@@@Z		; MusicTrack::SetJump
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_MML$ = 8						; size = 4
?SetJump@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetJump
; _this$ = esi

; 1721 : 	int		_value = MML->GetInt();

  02811	8b 44 24 04	 mov	 eax, DWORD PTR _MML$[esp-4]
  02815	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 1722 : 
; 1723 : 	switch(_value){

  0281a	83 e8 00	 sub	 eax, 0
  0281d	74 1a		 je	 SHORT $L25262
  0281f	48		 dec	 eax
  02820	74 0e		 je	 SHORT $L25263

; 1730 : 		default:
; 1731 : 			MML->Err(_T("JR}h0`1wB"));

  02822	8b 44 24 04	 mov	 eax, DWORD PTR _MML$[esp-4]
  02826	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CO@PCFIGAHG@?$AAJ0?$LD0?$NO0?s0?I0o?$AA0?$PP?$FO?$AA10n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O0?$GA0U@
  0282b	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L105994:
$L25263:

; 1726 : 			break;
; 1727 : 		case(1):
; 1728 : 			jump_flag = true;

  02830	c6 86 a1 00 00
	00 01		 mov	 BYTE PTR [esi+161], 1

; 1729 : 			break;

  02837	eb 07		 jmp	 SHORT $L25259
$L25262:

; 1724 : 		case(0):
; 1725 : 			jump_flag = false;

  02839	c6 86 a1 00 00
	00 00		 mov	 BYTE PTR [esi+161], 0
$L25259:

; 1732 : 	}
; 1733 : 
; 1734 : }

  02840	c2 04 00	 ret	 4
$L105993:
?SetJump@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP		; MusicTrack::SetJump
_TEXT	ENDS
PUBLIC	?SetN163_Set@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetN163_Set
; Function compile flags: /Ogsy
_TEXT	SEGMENT
?SetN163_Set@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetN163_Set
; _this$ = ecx
; _MML$ = eax

; 1684 : {

  02843	53		 push	 ebx
  02844	56		 push	 esi
  02845	8b d8		 mov	 ebx, eax
  02847	8b f1		 mov	 esi, ecx

; 1685 : 				int		i = MML->GetInt();

  02849	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 1686 : 	unsigned	char	cData;
; 1687 : 
; 1688 : 	if((i<0) || (i>252)){

  0284e	85 c0		 test	 eax, eax
  02850	7c 6a		 jl	 SHORT $L25243
  02852	3d fc 00 00 00	 cmp	 eax, 252		; 000000fcH
  02857	7f 63		 jg	 SHORT $L25243

; 1690 : 	}
; 1691 : 	if((i % 4) != 0){

  02859	6a 04		 push	 4
  0285b	99		 cdq
  0285c	59		 pop	 ecx
  0285d	f7 f9		 idiv	 ecx
  0285f	85 d2		 test	 edx, edx
  02861	74 07		 je	 SHORT $L25244

; 1692 : 		MML->Err(_T("n16xg`Jn_4{wB"));

  02863	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DE@ODMGCHFJ@?$AAn?$AA1?$AA6?$AAx0nl?b_b?$JF?$ILY?Kp?$LJ0o?$AA40nP?$ANep0gc?$AH?$FL?$JK0W0f@
  02868	eb 57		 jmp	 SHORT $L105998
$L25244:
  0286a	57		 push	 edi

; 1693 : 	}
; 1694 : 	SetVoice(i/4);

  0286b	8b f8		 mov	 edi, eax
  0286d	e8 00 00 00 00	 call	 ?SetVoice@MusicTrack@@QAEXI@Z ; MusicTrack::SetVoice

; 1695 : 
; 1696 : 	cData = MML->GetChar();

  02872	8b fb		 mov	 edi, ebx
  02874	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 1697 : 	if(cData == ','){

  02879	3c 2c		 cmp	 al, 44			; 0000002cH
  0287b	5f		 pop	 edi

; 1698 : 		i = MML->GetInt();

  0287c	8b c3		 mov	 eax, ebx
  0287e	75 35		 jne	 SHORT $L25245
  02880	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 1699 : 		if((i<4) || (i>256)){

  02885	83 f8 04	 cmp	 eax, 4
  02888	7c 24		 jl	 SHORT $L25247
  0288a	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0288f	7f 1d		 jg	 SHORT $L25247

; 1701 : 		}
; 1702 : 		if((i % 4) != 0){

  02891	6a 04		 push	 4
  02893	99		 cdq
  02894	59		 pop	 ecx
  02895	f7 f9		 idiv	 ecx
  02897	85 d2		 test	 edx, edx
  02899	74 07		 je	 SHORT $L25249

; 1703 : 			MML->Err(_T("n16xTv4{wB"));

  0289b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DE@MPDFLMLF@?$AAn?$AA1?$AA6?$AAx0n0?$LF0?s0?W0?k?$JFw0o?$AA40nP?$ANep0gc?$AH?$FL?$JK0W0f@
  028a0	eb 1f		 jmp	 SHORT $L105998
$L25249:

; 1704 : 		}
; 1705 : 		SetSweep((unsigned char)(64 - (i/4)));

  028a2	b3 40		 mov	 bl, 64			; 00000040H
  028a4	2a d8		 sub	 bl, al
  028a6	e8 00 00 00 00	 call	 ?SetSweep@MusicTrack@@QAEXE@Z ; MusicTrack::SetSweep
  028ab	5e		 pop	 esi
  028ac	5b		 pop	 ebx

; 1708 : 	}
; 1709 : }

  028ad	c3		 ret	 0
$L25247:

; 1700 : 			MML->Err(_T("n16xTv4`256wB"));

  028ae	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DM@DDNJDHDJ@?$AAn?$AA1?$AA6?$AAx0n0?$LF0?s0?W0?k?$JFw0o?$AA4?$PP?$FO?$AA2?$AA5?$AA60n?$HL?DV?r0g@
  028b3	eb 0c		 jmp	 SHORT $L105998
$L25245:
  028b5	5e		 pop	 esi
  028b6	5b		 pop	 ebx

; 1706 : 	} else {
; 1707 : 		MML->Back();

  028b7	e9 00 00 00 00	 jmp	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back
$L25243:

; 1689 : 		MML->Err(_T("n16xg`Jn_0`252wB"));

  028bc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DM@DHGNPNAI@?$AAn?$AA1?$AA6?$AAx0nl?b_b?$JF?$ILY?Kp?$LJ0o?$AA0?$PP?$FO?$AA2?$AA5?$AA20n?$HL?DV?r0g@
$L105998:
  028c1	8b c3		 mov	 eax, ebx
  028c3	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L105999:
$L105997:
  028c8	cc		 int	 3
?SetN163_Set@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP	; MusicTrack::SetN163_Set
_TEXT	ENDS
PUBLIC	?SetN163_Load@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetN163_Load
$T106016 DD	0ffffffffH
	DD	FLAT:$L106005
$T106012 DD	019930520H
	DD	01H
	DD	FLAT:$T106016
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T106002 = -16						; size = 4
__event$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetN163_Load@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetN163_Load
; _this$ = ebx
; _MML$ = ecx

; 1653 : {

  028c9	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetN163_Load@MusicTrack@@QAEXPAVMMLfile@@@Z
  028ce	e8 00 00 00 00	 call	 __EH_prolog
  028d3	51		 push	 ecx
  028d4	56		 push	 esi
  028d5	57		 push	 edi
  028d6	8b f9		 mov	 edi, ecx

; 1654 : 				int		i		= MML->GetInt();

  028d8	8b c7		 mov	 eax, edi
  028da	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  028df	8b f0		 mov	 esi, eax

; 1655 : 	unsigned	char	cData	= MML->GetChar();

  028e1	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 1656 : 	mml_Address*		_event;
; 1657 : 
; 1658 : 	if(cData != ','){

  028e6	3c 2c		 cmp	 al, 44			; 0000002cH
  028e8	74 0a		 je	 SHORT $L25225

; 1659 : 		MML->Err(_T("@N R}hp[^BQwB"));

  028ea	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1EA@CPIKLJAL@?$AA?$EA?$AAN?$AA?50?$LD0?$NO0?s0?I0n0?Q0?i0?a0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC@
  028ef	e9 86 00 00 00	 jmp	 $L106015
$L25225:

; 1660 : 	}
; 1661 : 
; 1662 : 	if((i<0) || (i>252)){

  028f4	85 f6		 test	 esi, esi
  028f6	7c 7d		 jl	 SHORT $L25227
  028f8	81 fe fc 00 00
	00		 cmp	 esi, 252		; 000000fcH
  028fe	7f 75		 jg	 SHORT $L25227

; 1664 : 	}
; 1665 : 	if((i % 4) != 0){

  02900	8b c6		 mov	 eax, esi
  02902	6a 04		 push	 4
  02904	99		 cdq
  02905	59		 pop	 ecx
  02906	f7 f9		 idiv	 ecx
  02908	85 d2		 test	 edx, edx
  0290a	8b f0		 mov	 esi, eax
  0290c	74 07		 je	 SHORT $L25229

; 1666 : 		MML->Err(_T("n16xg`Jn_4{wB"));

  0290e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DE@ODMGCHFJ@?$AAn?$AA1?$AA6?$AAx0nl?b_b?$JF?$ILY?Kp?$LJ0o?$AA40nP?$ANep0gc?$AH?$FL?$JK0W0f@
  02913	eb 65		 jmp	 SHORT $L106015
$L25229:

; 1667 : 	}
; 1668 : 
; 1669 : 	_event = new mml_Address(nsc_N163,(unsigned char)(i/4),_T("n163 wave table"));

  02915	6a 44		 push	 68			; 00000044H
  02917	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0291c	59		 pop	 ecx
  0291d	89 45 f0	 mov	 DWORD PTR $T106002[ebp], eax
  02920	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  02924	85 c0		 test	 eax, eax
  02926	74 12		 je	 SHORT $L106003
  02928	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CA@NKOKHIPN@?$AAn?$AA1?$AA6?$AA3?$AA?5?$AAw?$AAa?$AAv?$AAe?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$AA@
  0292d	56		 push	 esi
  0292e	6a 1e		 push	 30			; 0000001eH
  02930	50		 push	 eax
  02931	e8 00 00 00 00	 call	 ??0mml_Address@@QAE@EEQBG@Z ; mml_Address::mml_Address
  02936	8b f0		 mov	 esi, eax
  02938	eb 02		 jmp	 SHORT $L106004
$L106003:
  0293a	33 f6		 xor	 esi, esi
$L106004:
  0293c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 1670 : 	_event->set_id(MML->GetInt());

  02940	8b c7		 mov	 eax, edi
  02942	89 75 f0	 mov	 DWORD PTR __event$[ebp], esi
  02945	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  0294a	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 1671 : 	SetEvent(_event);

  0294d	56		 push	 esi
  0294e	8b c3		 mov	 eax, ebx
  02950	c6 46 40 01	 mov	 BYTE PTR [esi+64], 1
  02954	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 1672 : 	ptcWave.push_back(_event);

  02959	8d 83 a8 02 00
	00		 lea	 eax, DWORD PTR [ebx+680]
  0295f	8d 75 f0	 lea	 esi, DWORD PTR __event$[ebp]
  02962	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEXABQAVmml_Address@@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::push_back

; 1673 : }

  02967	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0296a	5f		 pop	 edi
  0296b	5e		 pop	 esi
  0296c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  02973	c9		 leave
  02974	c3		 ret	 0
$L25227:

; 1663 : 		MML->Err(_T("n16xg`Jn_0`252wB"));

  02975	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DM@DHGNPNAI@?$AAn?$AA1?$AA6?$AAx0nl?b_b?$JF?$ILY?Kp?$LJ0o?$AA0?$PP?$FO?$AA2?$AA5?$AA20n?$HL?DV?r0g@
$L106015:
  0297a	8b c7		 mov	 eax, edi
  0297c	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L106017:
$L106014:
  02981	cc		 int	 3
$L106005:
  00a3b	ff 75 f0	 push	 DWORD PTR $T106002[ebp]
  00a3e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00a43	59		 pop	 ecx
  00a44	c3		 ret	 0
__ehhandler$?SetN163_Load@MusicTrack@@QAEXPAVMMLfile@@@Z:
  00a45	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T106012
  00a4a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetN163_Load@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP	; MusicTrack::SetN163_Load
PUBLIC	?SetN163@MusicTrack@@QAEXPAVMMLfile@@@Z		; MusicTrack::SetN163
$T106033 DD	0ffffffffH
	DD	FLAT:$L106023
$T106030 DD	019930520H
	DD	01H
	DD	FLAT:$T106033
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T106020 = -16						; size = 4
__event$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetN163@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetN163
; _this$ = ebx
; _MML$ = ecx

; 1635 : {

  02982	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetN163@MusicTrack@@QAEXPAVMMLfile@@@Z
  02987	e8 00 00 00 00	 call	 __EH_prolog
  0298c	51		 push	 ecx
  0298d	56		 push	 esi
  0298e	57		 push	 edi

; 1636 : 	unsigned	char	cData;
; 1637 : 	mml_Address*		_event = new mml_Address(nsc_N163,(unsigned char)MML->GetInt(),_T("n163 wave table"));

  0298f	6a 44		 push	 68			; 00000044H
  02991	8b f9		 mov	 edi, ecx
  02993	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  02998	59		 pop	 ecx
  02999	89 45 f0	 mov	 DWORD PTR $T106020[ebp], eax
  0299c	33 f6		 xor	 esi, esi
  0299e	3b c6		 cmp	 eax, esi
  029a0	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  029a3	74 19		 je	 SHORT $L106022
  029a5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CA@NKOKHIPN@?$AAn?$AA1?$AA6?$AA3?$AA?5?$AAw?$AAa?$AAv?$AAe?$AA?5?$AAt?$AAa?$AAb?$AAl?$AAe?$AA?$AA@
  029aa	8b c7		 mov	 eax, edi
  029ac	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  029b1	50		 push	 eax
  029b2	6a 1e		 push	 30			; 0000001eH
  029b4	ff 75 f0	 push	 DWORD PTR $T106020[ebp]
  029b7	e8 00 00 00 00	 call	 ??0mml_Address@@QAE@EEQBG@Z ; mml_Address::mml_Address
  029bc	8b f0		 mov	 esi, eax
$L106022:
  029be	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  029c2	89 75 f0	 mov	 DWORD PTR __event$[ebp], esi

; 1638 : 
; 1639 : 	cData = MML->GetChar();

  029c5	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 1640 : 	if(cData != ','){

  029ca	3c 2c		 cmp	 al, 44			; 0000002cH

; 1641 : 		MML->Err(_T("@N R}hp[^BQwB"));

  029cc	8b c7		 mov	 eax, edi
  029ce	74 0a		 je	 SHORT $L25216
  029d0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1EA@CPIKLJAL@?$AA?$EA?$AAN?$AA?50?$LD0?$NO0?s0?I0n0?Q0?i0?a0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC@
  029d5	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L106034:
$L25216:

; 1642 : 	}
; 1643 : 
; 1644 : 	_event->set_id(MML->GetInt());

  029da	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  029df	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 1645 : 	SetEvent(_event);

  029e2	56		 push	 esi
  029e3	8b c3		 mov	 eax, ebx
  029e5	c6 46 40 01	 mov	 BYTE PTR [esi+64], 1
  029e9	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 1646 : 	ptcWave.push_back(_event);

  029ee	8d 83 a8 02 00
	00		 lea	 eax, DWORD PTR [ebx+680]
  029f4	8d 75 f0	 lea	 esi, DWORD PTR __event$[ebp]
  029f7	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEXABQAVmml_Address@@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::push_back

; 1647 : }

  029fc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  029ff	5f		 pop	 edi
  02a00	5e		 pop	 esi
  02a01	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  02a08	c9		 leave
  02a09	c3		 ret	 0
$L106032:
$L106023:
  00a4f	ff 75 f0	 push	 DWORD PTR $T106020[ebp]
  00a52	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00a57	59		 pop	 ecx
  00a58	c3		 ret	 0
__ehhandler$?SetN163@MusicTrack@@QAEXPAVMMLfile@@@Z:
  00a59	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T106030
  00a5e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetN163@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP		; MusicTrack::SetN163
PUBLIC	?SetVRC7@MusicTrack@@QAEXPAVMMLfile@@@Z		; MusicTrack::SetVRC7
$T106048 DD	0ffffffffH
	DD	FLAT:$L106040
$T106046 DD	019930520H
	DD	01H
	DD	FLAT:$T106048
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T106037 = -16						; size = 4
__event$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_MML$ = 8						; size = 4
?SetVRC7@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetVRC7
; _this$ = edi

; 1617 : {

  02a0a	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetVRC7@MusicTrack@@QAEXPAVMMLfile@@@Z
  02a0f	e8 00 00 00 00	 call	 __EH_prolog
  02a14	51		 push	 ecx
  02a15	56		 push	 esi

; 1618 : 	mml_Address*		_event = new mml_Address(nsc_VRC7, _T("VRC7 user instruments"));

  02a16	6a 44		 push	 68			; 00000044H
  02a18	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  02a1d	59		 pop	 ecx
  02a1e	89 45 f0	 mov	 DWORD PTR $T106037[ebp], eax
  02a21	33 f6		 xor	 esi, esi
  02a23	3b c6		 cmp	 eax, esi
  02a25	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  02a28	74 0f		 je	 SHORT $L106039
  02a2a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CM@FAPBPOGD@?$AAV?$AAR?$AAC?$AA7?$AA?5?$AAu?$AAs?$AAe?$AAr?$AA?5?$AAi?$AAn?$AAs?$AAt?$AAr?$AAu?$AAm?$AAe?$AAn?$AAt@
  02a2f	6a 1c		 push	 28			; 0000001cH
  02a31	50		 push	 eax
  02a32	e8 00 00 00 00	 call	 ??0mml_Address@@QAE@EQBG@Z ; mml_Address::mml_Address
  02a37	8b f0		 mov	 esi, eax
$L106039:
  02a39	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 1619 : 	unsigned	int		_no = MML->GetInt();

  02a3d	8b 45 08	 mov	 eax, DWORD PTR _MML$[ebp]
  02a40	89 75 f0	 mov	 DWORD PTR __event$[ebp], esi
  02a43	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 1620 : 
; 1621 : 	_event->set_id(_no);

  02a48	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 1622 : 	SetEvent(_event);

  02a4b	56		 push	 esi
  02a4c	8b c7		 mov	 eax, edi
  02a4e	c6 46 40 01	 mov	 BYTE PTR [esi+64], 1
  02a52	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 1623 : 	ptcOPLL.push_back(_event);

  02a57	8d 87 98 02 00
	00		 lea	 eax, DWORD PTR [edi+664]
  02a5d	8d 75 f0	 lea	 esi, DWORD PTR __event$[ebp]
  02a60	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEXABQAVmml_Address@@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::push_back

; 1624 : }

  02a65	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  02a68	5e		 pop	 esi
  02a69	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  02a70	c9		 leave
  02a71	c2 04 00	 ret	 4
$L106040:
  00a63	ff 75 f0	 push	 DWORD PTR $T106037[ebp]
  00a66	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00a6b	59		 pop	 ecx
  00a6c	c3		 ret	 0
__ehhandler$?SetVRC7@MusicTrack@@QAEXPAVMMLfile@@@Z:
  00a6d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T106046
  00a72	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetVRC7@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP		; MusicTrack::SetVRC7
PUBLIC	?SetFDSM@MusicTrack@@QAEXPAVMMLfile@@@Z		; MusicTrack::SetFDSM
$T106062 DD	0ffffffffH
	DD	FLAT:$L106054
$T106060 DD	019930520H
	DD	01H
	DD	FLAT:$T106062
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T106051 = -16						; size = 4
__event$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_MML$ = 8						; size = 4
?SetFDSM@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetFDSM
; _this$ = edi

; 1599 : {

  02a74	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetFDSM@MusicTrack@@QAEXPAVMMLfile@@@Z
  02a79	e8 00 00 00 00	 call	 __EH_prolog
  02a7e	51		 push	 ecx
  02a7f	56		 push	 esi

; 1600 : 	mml_Address*		_event = new mml_Address(nsd_FDS_Modlator, _T("FDS modulator wave table"));

  02a80	6a 44		 push	 68			; 00000044H
  02a82	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  02a87	59		 pop	 ecx
  02a88	89 45 f0	 mov	 DWORD PTR $T106051[ebp], eax
  02a8b	33 f6		 xor	 esi, esi
  02a8d	3b c6		 cmp	 eax, esi
  02a8f	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  02a92	74 0f		 je	 SHORT $L106053
  02a94	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DC@IBICFHPL@?$AAF?$AAD?$AAS?$AA?5?$AAm?$AAo?$AAd?$AAu?$AAl?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAw?$AAa?$AAv?$AAe?$AA?5?$AAt@
  02a99	6a 23		 push	 35			; 00000023H
  02a9b	50		 push	 eax
  02a9c	e8 00 00 00 00	 call	 ??0mml_Address@@QAE@EQBG@Z ; mml_Address::mml_Address
  02aa1	8b f0		 mov	 esi, eax
$L106053:
  02aa3	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 1601 : 	unsigned	int		_no = MML->GetInt();

  02aa7	8b 45 08	 mov	 eax, DWORD PTR _MML$[ebp]
  02aaa	89 75 f0	 mov	 DWORD PTR __event$[ebp], esi
  02aad	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 1602 : 
; 1603 : 	_event->set_id(_no);

  02ab2	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 1604 : 	SetEvent(_event);

  02ab5	56		 push	 esi
  02ab6	8b c7		 mov	 eax, edi
  02ab8	c6 46 40 01	 mov	 BYTE PTR [esi+64], 1
  02abc	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 1605 : 	ptcFDSM.push_back(_event);

  02ac1	8d 87 88 02 00
	00		 lea	 eax, DWORD PTR [edi+648]
  02ac7	8d 75 f0	 lea	 esi, DWORD PTR __event$[ebp]
  02aca	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEXABQAVmml_Address@@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::push_back

; 1606 : }

  02acf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  02ad2	5e		 pop	 esi
  02ad3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  02ada	c9		 leave
  02adb	c2 04 00	 ret	 4
$L106054:
  00a77	ff 75 f0	 push	 DWORD PTR $T106051[ebp]
  00a7a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00a7f	59		 pop	 ecx
  00a80	c3		 ret	 0
__ehhandler$?SetFDSM@MusicTrack@@QAEXPAVMMLfile@@@Z:
  00a81	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T106060
  00a86	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetFDSM@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP		; MusicTrack::SetFDSM
PUBLIC	?SetFDSC@MusicTrack@@QAEXPAVMMLfile@@@Z		; MusicTrack::SetFDSC
$T106076 DD	0ffffffffH
	DD	FLAT:$L106068
$T106074 DD	019930520H
	DD	01H
	DD	FLAT:$T106076
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T106065 = -16						; size = 4
__event$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_MML$ = 8						; size = 4
?SetFDSC@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetFDSC
; _this$ = edi

; 1581 : {

  02ade	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetFDSC@MusicTrack@@QAEXPAVMMLfile@@@Z
  02ae3	e8 00 00 00 00	 call	 __EH_prolog
  02ae8	51		 push	 ecx
  02ae9	56		 push	 esi

; 1582 : 	mml_Address*		_event = new mml_Address(nsd_FDS_Career, _T("FDS career wave table"));

  02aea	6a 44		 push	 68			; 00000044H
  02aec	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  02af1	59		 pop	 ecx
  02af2	89 45 f0	 mov	 DWORD PTR $T106065[ebp], eax
  02af5	33 f6		 xor	 esi, esi
  02af7	3b c6		 cmp	 eax, esi
  02af9	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  02afc	74 0f		 je	 SHORT $L106067
  02afe	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CM@GOJLGHKM@?$AAF?$AAD?$AAS?$AA?5?$AAc?$AAa?$AAr?$AAe?$AAe?$AAr?$AA?5?$AAw?$AAa?$AAv?$AAe?$AA?5?$AAt?$AAa?$AAb?$AAl@
  02b03	6a 22		 push	 34			; 00000022H
  02b05	50		 push	 eax
  02b06	e8 00 00 00 00	 call	 ??0mml_Address@@QAE@EQBG@Z ; mml_Address::mml_Address
  02b0b	8b f0		 mov	 esi, eax
$L106067:
  02b0d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 1583 : 	unsigned	int		_no = MML->GetInt();

  02b11	8b 45 08	 mov	 eax, DWORD PTR _MML$[ebp]
  02b14	89 75 f0	 mov	 DWORD PTR __event$[ebp], esi
  02b17	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 1584 : 
; 1585 : 	_event->set_id(_no);

  02b1c	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 1586 : 	SetEvent(_event);

  02b1f	56		 push	 esi
  02b20	8b c7		 mov	 eax, edi
  02b22	c6 46 40 01	 mov	 BYTE PTR [esi+64], 1
  02b26	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 1587 : 	ptcFDSC.push_back(_event);

  02b2b	8d 87 78 02 00
	00		 lea	 eax, DWORD PTR [edi+632]
  02b31	8d 75 f0	 lea	 esi, DWORD PTR __event$[ebp]
  02b34	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEXABQAVmml_Address@@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::push_back

; 1588 : }

  02b39	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  02b3c	5e		 pop	 esi
  02b3d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  02b44	c9		 leave
  02b45	c2 04 00	 ret	 4
$L106068:
  00a8b	ff 75 f0	 push	 DWORD PTR $T106065[ebp]
  00a8e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00a93	59		 pop	 ecx
  00a94	c3		 ret	 0
__ehhandler$?SetFDSC@MusicTrack@@QAEXPAVMMLfile@@@Z:
  00a95	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T106074
  00a9a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetFDSC@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP		; MusicTrack::SetFDSC
PUBLIC	?SetSweep@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetSweep
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_iSpeed$ = -4						; size = 4
?SetSweep@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetSweep
; _this$ = ecx
; _MML$ = eax

; 1536 : {

  02b48	55		 push	 ebp
  02b49	8b ec		 mov	 ebp, esp
  02b4b	51		 push	 ecx
  02b4c	53		 push	 ebx
  02b4d	56		 push	 esi
  02b4e	57		 push	 edi
  02b4f	8b f8		 mov	 edi, eax
  02b51	8b f1		 mov	 esi, ecx

; 1537 : 				int		iSpeed;
; 1538 : 				int		iDepth;
; 1539 : 	unsigned	char	cData;
; 1540 : 
; 1541 : 	iSpeed = MML->GetInt();

  02b53	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  02b58	8b d8		 mov	 ebx, eax
  02b5a	89 5d fc	 mov	 DWORD PTR _iSpeed$[ebp], ebx

; 1542 : 
; 1543 : 	cData = MML->GetChar();

  02b5d	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 1544 : 	if(cData != ','){

  02b62	3c 2c		 cmp	 al, 44			; 0000002cH
  02b64	74 24		 je	 SHORT $L25146

; 1545 : 		if( (iSpeed < 0) || (iSpeed > 255) ){

  02b66	85 db		 test	 ebx, ebx
  02b68	7c 19		 jl	 SHORT $L25148
  02b6a	81 fb ff 00 00
	00		 cmp	 ebx, 255		; 000000ffH
  02b70	7f 11		 jg	 SHORT $L25148

; 1547 : 		}
; 1548 : 		MML->Back();

  02b72	8b c7		 mov	 eax, edi
  02b74	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back
$L106079:

; 1549 : 		SetSweep((unsigned char)iSpeed);

  02b79	e8 00 00 00 00	 call	 ?SetSweep@MusicTrack@@QAEXE@Z ; MusicTrack::SetSweep
  02b7e	5f		 pop	 edi
  02b7f	5e		 pop	 esi
  02b80	5b		 pop	 ebx

; 1559 : 	}
; 1560 : }

  02b81	c9		 leave
  02b82	c3		 ret	 0
$L25148:

; 1546 : 			MML->Err(_T("sR}h0`255wB"));

  02b83	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DC@OMNANPHO@?$AAs0?$LD0?$NO0?s0?I0o?$AA0?$PP?$FO?$AA2?$AA5?$AA50n?$HL?DV?r0gc?$AH?$FL?$JK0W0f0O@
  02b88	eb 34		 jmp	 SHORT $L106080
$L25146:

; 1550 : 	} else {
; 1551 : 		if( (iSpeed < 0) || (iSpeed > 15) ){

  02b8a	85 db		 test	 ebx, ebx
  02b8c	7c 2b		 jl	 SHORT $L25153
  02b8e	83 fb 0f	 cmp	 ebx, 15			; 0000000fH
  02b91	7f 26		 jg	 SHORT $L25153

; 1553 : 		}
; 1554 : 		iDepth = MML->GetInt();

  02b93	8b c7		 mov	 eax, edi
  02b95	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 1555 : 		if( (iDepth < 0) || (iDepth > 15) ){

  02b9a	85 c0		 test	 eax, eax
  02b9c	7c 14		 jl	 SHORT $L25156
  02b9e	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  02ba1	7f 0f		 jg	 SHORT $L25156

; 1557 : 		}
; 1558 : 		SetSweep((unsigned char)(((iSpeed & 0x0F) << 4) | (iDepth & 0x0F)));

  02ba3	8a d8		 mov	 bl, al
  02ba5	8a 45 fc	 mov	 al, BYTE PTR _iSpeed$[ebp]
  02ba8	80 e3 0f	 and	 bl, 15			; 0000000fH
  02bab	c0 e0 04	 shl	 al, 4
  02bae	0a d8		 or	 bl, al

; 1559 : 	}
; 1560 : }

  02bb0	eb c7		 jmp	 SHORT $L106079
$L25156:

; 1556 : 			MML->Err(_T("sR}h2p[^0`15wB"));

  02bb2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1EA@BHDCEFM@?$AAs0?$LD0?$NO0?s0?I0n?$HL?0?$AA20?Q0?i0?a0?$PM0?$LP0o?$AA0?$PP?$FO?$AA1?$AA50n?$HL?D@
  02bb7	eb 05		 jmp	 SHORT $L106080
$L25153:

; 1552 : 			MML->Err(_T("sR}h1p[^0`15wB"));

  02bb9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1EA@FGFBAIAO@?$AAs0?$LD0?$NO0?s0?I0n?$HL?0?$AA10?Q0?i0?a0?$PM0?$LP0o?$AA0?$PP?$FO?$AA1?$AA50n?$HL?D@
$L106080:
  02bbe	8b c7		 mov	 eax, edi
  02bc0	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L106081:
$L106078:
  02bc5	cc		 int	 3
?SetSweep@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP		; MusicTrack::SetSweep
_TEXT	ENDS
PUBLIC	?CallPatch@MusicTrack@@QAEXPAVMMLfile@@D@Z	; MusicTrack::CallPatch
; Function compile flags: /Ogsy
_TEXT	SEGMENT
tv453 = -8						; size = 4
tv454 = -4						; size = 4
_this$ = 8						; size = 4
_MML$ = 12						; size = 4
$T106092 = 16						; size = 1
__note$ = 16						; size = 1
?CallPatch@MusicTrack@@QAEXPAVMMLfile@@D@Z PROC NEAR	; MusicTrack::CallPatch

; 1349 : {

  02bc6	55		 push	 ebp
  02bc7	8b ec		 mov	 ebp, esp
  02bc9	51		 push	 ecx
  02bca	51		 push	 ecx

; 1350 : 	if(f_Patch == true){

  02bcb	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  02bce	80 b8 e3 01 00
	00 01		 cmp	 BYTE PTR [eax+483], 1
  02bd5	0f 85 59 02 00
	00		 jne	 $L25048
  02bdb	53		 push	 ebx
  02bdc	56		 push	 esi
  02bdd	57		 push	 edi

; 1351 : 		//m[g
; 1352 : 		MML->ptcPatch[i_Patch]->setNote(_note);

  02bde	8b 7d 0c	 mov	 edi, DWORD PTR _MML$[ebp]
  02be1	8d b0 e4 01 00
	00		 lea	 esi, DWORD PTR [eax+484]
  02be7	83 c7 68	 add	 edi, 104		; 00000068H
  02bea	89 75 f8	 mov	 DWORD PTR tv453[ebp], esi
  02bed	89 7d fc	 mov	 DWORD PTR tv454[ebp], edi
  02bf0	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02bf5	8b c8		 mov	 ecx, eax
  02bf7	0f be 45 10	 movsx	 eax, BYTE PTR __note$[ebp]
  02bfb	8b 19		 mov	 ebx, DWORD PTR [ecx]
  02bfd	e8 00 00 00 00	 call	 ?setNote@Patch@@QAEXH@Z	; Patch::setNote

; 1353 : 
; 1354 : 		if(	MML->ptcPatch[i_Patch]->get_fSub() == true){

  02c02	8b de		 mov	 ebx, esi
  02c04	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02c09	8b 00		 mov	 eax, DWORD PTR [eax]
  02c0b	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02c0e	80 78 2f 01	 cmp	 BYTE PTR [eax+47], 1
  02c12	75 28		 jne	 SHORT $L106208

; 1355 : 			SetSubWithParch(MML->ptcPatch[i_Patch]->get_iSub(), MML->ptcPatch[i_Patch]->get_fSub_opt());

  02c14	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02c19	8b 00		 mov	 eax, DWORD PTR [eax]
  02c1b	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02c1e	8a 40 30	 mov	 al, BYTE PTR [eax+48]
  02c21	88 45 10	 mov	 BYTE PTR $T106092[ebp], al
  02c24	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02c29	8b 00		 mov	 eax, DWORD PTR [eax]
  02c2b	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02c2e	ff 75 10	 push	 DWORD PTR $T106092[ebp]
  02c31	8b 78 1c	 mov	 edi, DWORD PTR [eax+28]
  02c34	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  02c37	e8 00 00 00 00	 call	 ?SetSubWithParch@MusicTrack@@QAEXI_N@Z ; MusicTrack::SetSubWithParch
$L106208:

; 1356 : 		}
; 1357 : 
; 1358 : 		if(	MML->ptcPatch[i_Patch]->get_fGate_q() == true){

  02c3c	8b 7d fc	 mov	 edi, DWORD PTR tv454[ebp]
  02c3f	8b f3		 mov	 esi, ebx
  02c41	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02c46	8b 00		 mov	 eax, DWORD PTR [eax]
  02c48	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02c4b	80 78 31 01	 cmp	 BYTE PTR [eax+49], 1
  02c4f	75 15		 jne	 SHORT $L25033

; 1359 : 			Set_q(MML->ptcPatch[i_Patch]->get_iGate_q());

  02c51	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02c56	8b 00		 mov	 eax, DWORD PTR [eax]
  02c58	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02c5b	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  02c5e	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  02c61	e8 00 00 00 00	 call	 ?Set_q@MusicTrack@@QAEXH@Z ; MusicTrack::Set_q
$L25033:

; 1360 : 		}
; 1361 : 
; 1362 : 		if(	MML->ptcPatch[i_Patch]->get_fGate_u() == true){

  02c66	8b 7d fc	 mov	 edi, DWORD PTR tv454[ebp]
  02c69	8b f3		 mov	 esi, ebx
  02c6b	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02c70	8b 00		 mov	 eax, DWORD PTR [eax]
  02c72	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02c75	80 78 32 01	 cmp	 BYTE PTR [eax+50], 1
  02c79	75 15		 jne	 SHORT $L25034

; 1363 : 			Set_u(MML->ptcPatch[i_Patch]->get_iGate_u());

  02c7b	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02c80	8b 00		 mov	 eax, DWORD PTR [eax]
  02c82	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02c85	8b 70 24	 mov	 esi, DWORD PTR [eax+36]
  02c88	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  02c8b	e8 00 00 00 00	 call	 ?Set_u@MusicTrack@@QAEXH@Z ; MusicTrack::Set_u
$L25034:

; 1364 : 		}
; 1365 : 
; 1366 : 		if(	MML->ptcPatch[i_Patch]->get_fSweep() == true){

  02c90	8b 7d fc	 mov	 edi, DWORD PTR tv454[ebp]
  02c93	8b f3		 mov	 esi, ebx
  02c95	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02c9a	8b 00		 mov	 eax, DWORD PTR [eax]
  02c9c	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02c9f	80 78 2e 01	 cmp	 BYTE PTR [eax+46], 1
  02ca3	75 18		 jne	 SHORT $L25035

; 1367 : 			SetSweep(MML->ptcPatch[i_Patch]->get_iSweep());

  02ca5	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02caa	8b 00		 mov	 eax, DWORD PTR [eax]
  02cac	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02caf	8a 58 18	 mov	 bl, BYTE PTR [eax+24]
  02cb2	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  02cb5	e8 00 00 00 00	 call	 ?SetSweep@MusicTrack@@QAEXE@Z ; MusicTrack::SetSweep
  02cba	8b 5d f8	 mov	 ebx, DWORD PTR tv453[ebp]
$L25035:

; 1368 : 		}
; 1369 : 
; 1370 : 		if(	MML->ptcPatch[i_Patch]->get_fKey() == true){

  02cbd	8b 7d fc	 mov	 edi, DWORD PTR tv454[ebp]
  02cc0	8b f3		 mov	 esi, ebx
  02cc2	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02cc7	8b 00		 mov	 eax, DWORD PTR [eax]
  02cc9	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02ccc	80 78 2d 01	 cmp	 BYTE PTR [eax+45], 1
  02cd0	75 15		 jne	 SHORT $L25036

; 1371 : 			SetTranspose(MML->ptcPatch[i_Patch]->get_iKey());

  02cd2	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02cd7	8b 00		 mov	 eax, DWORD PTR [eax]
  02cd9	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02cdc	ff 70 14	 push	 DWORD PTR [eax+20]
  02cdf	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  02ce2	e8 00 00 00 00	 call	 ?SetTranspose@MusicTrack@@QAEXH@Z ; MusicTrack::SetTranspose
$L25036:

; 1372 : 		}
; 1373 : 
; 1374 : 		if(	MML->ptcPatch[i_Patch]->get_fVoi() == true){

  02ce7	8b 7d fc	 mov	 edi, DWORD PTR tv454[ebp]
  02cea	8b f3		 mov	 esi, ebx
  02cec	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02cf1	8b 00		 mov	 eax, DWORD PTR [eax]
  02cf3	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02cf6	80 78 28 01	 cmp	 BYTE PTR [eax+40], 1
  02cfa	75 14		 jne	 SHORT $L25037

; 1375 : 			SetVoice(MML->ptcPatch[i_Patch]->get_iVoi());

  02cfc	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02d01	8b 00		 mov	 eax, DWORD PTR [eax]
  02d03	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02d06	8b 38		 mov	 edi, DWORD PTR [eax]
  02d08	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  02d0b	e8 00 00 00 00	 call	 ?SetVoice@MusicTrack@@QAEXI@Z ; MusicTrack::SetVoice
$L25037:

; 1376 : 		}
; 1377 : 
; 1378 : 		if(	MML->ptcPatch[i_Patch]->get_fEvoi() == true){

  02d10	8b 7d fc	 mov	 edi, DWORD PTR tv454[ebp]
  02d13	8b f3		 mov	 esi, ebx
  02d15	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02d1a	8b 00		 mov	 eax, DWORD PTR [eax]
  02d1c	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02d1f	80 78 29 01	 cmp	 BYTE PTR [eax+41], 1
  02d23	75 2b		 jne	 SHORT $L106209

; 1379 : 			if(MML->ptcPatch[i_Patch]->get_sw_Evoi() == true){

  02d25	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02d2a	8b 00		 mov	 eax, DWORD PTR [eax]
  02d2c	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02d2f	80 78 33 01	 cmp	 BYTE PTR [eax+51], 1
  02d33	75 1b		 jne	 SHORT $L106209

; 1380 : 				SetEnvelop_Evoi(MML->ptcPatch[i_Patch]->get_iEvoi() + MML->offset_Ei);

  02d35	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02d3a	8b 00		 mov	 eax, DWORD PTR [eax]
  02d3c	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02d3f	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  02d42	8b 45 0c	 mov	 eax, DWORD PTR _MML$[ebp]
  02d45	03 78 74	 add	 edi, DWORD PTR [eax+116]
  02d48	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  02d4b	e8 00 00 00 00	 call	 ?SetEnvelop_Evoi@MusicTrack@@QAEXI@Z ; MusicTrack::SetEnvelop_Evoi
$L106209:

; 1381 : 			}
; 1382 : 		}
; 1383 : 
; 1384 : 		if(	MML->ptcPatch[i_Patch]->get_fEvol() == true){

  02d50	8b 7d fc	 mov	 edi, DWORD PTR tv454[ebp]
  02d53	8b f3		 mov	 esi, ebx
  02d55	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02d5a	8b 00		 mov	 eax, DWORD PTR [eax]
  02d5c	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02d5f	80 78 2a 01	 cmp	 BYTE PTR [eax+42], 1
  02d63	75 35		 jne	 SHORT $L25042

; 1385 : 			if(MML->ptcPatch[i_Patch]->get_sw_Evol() == true){

  02d65	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02d6a	8b 00		 mov	 eax, DWORD PTR [eax]
  02d6c	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02d6f	80 78 34 01	 cmp	 BYTE PTR [eax+52], 1
  02d73	75 1d		 jne	 SHORT $L25041

; 1386 : 				SetEnvelop_Evol(MML->ptcPatch[i_Patch]->get_iEvol() + MML->offset_Ev);

  02d75	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02d7a	8b 00		 mov	 eax, DWORD PTR [eax]
  02d7c	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02d7f	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  02d82	8b 45 0c	 mov	 eax, DWORD PTR _MML$[ebp]
  02d85	03 78 78	 add	 edi, DWORD PTR [eax+120]
  02d88	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  02d8b	e8 00 00 00 00	 call	 ?SetEnvelop_Evol@MusicTrack@@QAEXI@Z ; MusicTrack::SetEnvelop_Evol

; 1387 : 			} else {

  02d90	eb 08		 jmp	 SHORT $L25042
$L25041:

; 1388 : 				SetEnvelop_Evol();

  02d92	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  02d95	e8 00 00 00 00	 call	 ?SetEnvelop_Evol@MusicTrack@@QAEXXZ ; MusicTrack::SetEnvelop_Evol
$L25042:

; 1389 : 			}
; 1390 : 		}
; 1391 : 
; 1392 : 		if(	MML->ptcPatch[i_Patch]->get_fEm() == true){

  02d9a	8b 7d fc	 mov	 edi, DWORD PTR tv454[ebp]
  02d9d	8b f3		 mov	 esi, ebx
  02d9f	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02da4	8b 00		 mov	 eax, DWORD PTR [eax]
  02da6	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02da9	80 78 2b 01	 cmp	 BYTE PTR [eax+43], 1
  02dad	75 38		 jne	 SHORT $L25045

; 1393 : 			if(MML->ptcPatch[i_Patch]->get_sw_Em() == true){

  02daf	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02db4	8b 00		 mov	 eax, DWORD PTR [eax]
  02db6	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02db9	80 78 35 01	 cmp	 BYTE PTR [eax+53], 1
  02dbd	75 20		 jne	 SHORT $L25044

; 1394 : 				SetEnvelop_Em(MML->ptcPatch[i_Patch]->get_iEm() + MML->offset_Em);

  02dbf	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02dc4	8b 00		 mov	 eax, DWORD PTR [eax]
  02dc6	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02dc9	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  02dcc	8b 45 0c	 mov	 eax, DWORD PTR _MML$[ebp]
  02dcf	03 b8 80 00 00
	00		 add	 edi, DWORD PTR [eax+128]
  02dd5	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  02dd8	e8 00 00 00 00	 call	 ?SetEnvelop_Em@MusicTrack@@QAEXI@Z ; MusicTrack::SetEnvelop_Em

; 1395 : 			} else {

  02ddd	eb 08		 jmp	 SHORT $L25045
$L25044:

; 1396 : 				SetEnvelop_Em();

  02ddf	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  02de2	e8 00 00 00 00	 call	 ?SetEnvelop_Em@MusicTrack@@QAEXXZ ; MusicTrack::SetEnvelop_Em
$L25045:

; 1397 : 			}
; 1398 : 		}
; 1399 : 
; 1400 : 		if(	MML->ptcPatch[i_Patch]->get_fEn() == true){

  02de7	8b 7d fc	 mov	 edi, DWORD PTR tv454[ebp]
  02dea	8b f3		 mov	 esi, ebx
  02dec	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02df1	8b 00		 mov	 eax, DWORD PTR [eax]
  02df3	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02df6	80 78 2c 01	 cmp	 BYTE PTR [eax+44], 1
  02dfa	75 35		 jne	 SHORT $L106210

; 1401 : 			if(MML->ptcPatch[i_Patch]->get_sw_En() == true){

  02dfc	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02e01	8b 00		 mov	 eax, DWORD PTR [eax]
  02e03	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02e06	80 78 36 01	 cmp	 BYTE PTR [eax+54], 1
  02e0a	75 1d		 jne	 SHORT $L25047

; 1402 : 				SetEnvelop_En(MML->ptcPatch[i_Patch]->get_iEn() + MML->offset_En);

  02e0c	e8 00 00 00 00	 call	 ??A?$map@IPAVPatch@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVPatch@@@std@@@3@@std@@QAEAAPAVPatch@@ABI@Z ; std::map<unsigned int,Patch *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Patch *> > >::operator[]
  02e11	8b 00		 mov	 eax, DWORD PTR [eax]
  02e13	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02e16	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  02e19	8b 45 0c	 mov	 eax, DWORD PTR _MML$[ebp]
  02e1c	03 78 7c	 add	 edi, DWORD PTR [eax+124]
  02e1f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  02e22	e8 00 00 00 00	 call	 ?SetEnvelop_En@MusicTrack@@QAEXI@Z ; MusicTrack::SetEnvelop_En

; 1403 : 			} else {

  02e27	eb 08		 jmp	 SHORT $L106210
$L25047:

; 1404 : 				SetEnvelop_En();

  02e29	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  02e2c	e8 00 00 00 00	 call	 ?SetEnvelop_En@MusicTrack@@QAEXXZ ; MusicTrack::SetEnvelop_En
$L106210:
  02e31	5f		 pop	 edi
  02e32	5e		 pop	 esi
  02e33	5b		 pop	 ebx
$L25048:

; 1405 : 			}
; 1406 : 		}
; 1407 : 
; 1408 : 	}
; 1409 : }

  02e34	c9		 leave
  02e35	c2 0c 00	 ret	 12			; 0000000cH
?CallPatch@MusicTrack@@QAEXPAVMMLfile@@D@Z ENDP		; MusicTrack::CallPatch
_TEXT	ENDS
PUBLIC	?SetPatch@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetPatch
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_MML$ = 8						; size = 4
?SetPatch@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetPatch
; _this$ = esi

; 1325 : 	f_Patch = true;
; 1326 : 	i_Patch	= MML->GetInt();

  02e38	8b 44 24 04	 mov	 eax, DWORD PTR _MML$[esp-4]
  02e3c	c6 86 e3 01 00
	00 01		 mov	 BYTE PTR [esi+483], 1
  02e43	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 1327 : 
; 1328 : 	if(MML->ChkPatch(i_Patch) == false){

  02e48	50		 push	 eax
  02e49	ff 74 24 08	 push	 DWORD PTR _MML$[esp]
  02e4d	89 86 e4 01 00
	00		 mov	 DWORD PTR [esi+484], eax
  02e53	e8 00 00 00 00	 call	 ?ChkPatch@MMLfile@@QAE_NI@Z ; MMLfile::ChkPatch
  02e58	84 c0		 test	 al, al
  02e5a	75 0e		 jne	 SHORT $L25021

; 1329 : 		MML->Err(_T("pb`B"));

  02e5c	8b 44 24 04	 mov	 eax, DWORD PTR _MML$[esp-4]
  02e60	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BI@EHCLFFIH@?$FLXW?$CI0W0j0D0?Q0?C0?A0g0Y0?$AC?$AA?$AA@
  02e65	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L106215:
$L25021:

; 1330 : 	}
; 1331 : }

  02e6a	c2 04 00	 ret	 4
$L106214:
?SetPatch@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP		; MusicTrack::SetPatch
_TEXT	ENDS
PUBLIC	?SetSE@MusicTrack@@QAEXPAVMMLfile@@@Z		; MusicTrack::SetSE
$T106229 DD	0ffffffffH
	DD	FLAT:$L106221
$T106227 DD	019930520H
	DD	01H
	DD	FLAT:$T106229
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T106218 = 8						; size = 4
__event$24986 = 8					; size = 4
_MML$ = 8						; size = 4
?SetSE@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR		; MusicTrack::SetSE
; _this$ = ecx

; 1269 : {

  02e6d	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetSE@MusicTrack@@QAEXPAVMMLfile@@@Z
  02e72	e8 00 00 00 00	 call	 __EH_prolog

; 1270 : 	unsigned	int		_no = MML->GetInt();

  02e77	8b 45 08	 mov	 eax, DWORD PTR _MML$[ebp]
  02e7a	56		 push	 esi
  02e7b	57		 push	 edi
  02e7c	8b f1		 mov	 esi, ecx
  02e7e	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 1271 : 	if(jump_flag==false){

  02e83	80 be a1 00 00
	00 00		 cmp	 BYTE PTR [esi+161], 0
  02e8a	8b f8		 mov	 edi, eax
  02e8c	75 48		 jne	 SHORT $L24985

; 1272 : 		mml_Address*		_event = new mml_Address(nsd_Call_SE, _T("Call SE"));

  02e8e	6a 44		 push	 68			; 00000044H
  02e90	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  02e95	59		 pop	 ecx
  02e96	89 45 08	 mov	 DWORD PTR $T106218[ebp], eax
  02e99	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  02e9d	85 c0		 test	 eax, eax
  02e9f	74 0f		 je	 SHORT $L106219
  02ea1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BA@DMAFONIK@?$AAC?$AAa?$AAl?$AAl?$AA?5?$AAS?$AAE?$AA?$AA@
  02ea6	6a 06		 push	 6
  02ea8	50		 push	 eax
  02ea9	e8 00 00 00 00	 call	 ??0mml_Address@@QAE@EQBG@Z ; mml_Address::mml_Address
  02eae	eb 02		 jmp	 SHORT $L106220
$L106219:
  02eb0	33 c0		 xor	 eax, eax
$L106220:
  02eb2	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  02eb6	89 45 08	 mov	 DWORD PTR __event$24986[ebp], eax

; 1273 : 		_event->set_id(_no);

  02eb9	c6 40 40 01	 mov	 BYTE PTR [eax+64], 1
  02ebd	89 78 3c	 mov	 DWORD PTR [eax+60], edi

; 1274 : 		SetEvent(_event);

  02ec0	50		 push	 eax
  02ec1	8b c6		 mov	 eax, esi
  02ec3	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 1275 : 		ptcSE.push_back(_event);

  02ec8	8d 86 b8 02 00
	00		 lea	 eax, DWORD PTR [esi+696]
  02ece	8d 75 08	 lea	 esi, DWORD PTR __event$24986[ebp]
  02ed1	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEXABQAVmml_Address@@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::push_back
$L24985:

; 1276 : 	}
; 1277 : }

  02ed6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  02ed9	5f		 pop	 edi
  02eda	5e		 pop	 esi
  02edb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  02ee2	c9		 leave
  02ee3	c2 04 00	 ret	 4
$L106221:
  00a9f	ff 75 08	 push	 DWORD PTR $T106218[ebp]
  00aa2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00aa7	59		 pop	 ecx
  00aa8	c3		 ret	 0
__ehhandler$?SetSE@MusicTrack@@QAEXPAVMMLfile@@@Z:
  00aa9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T106227
  00aae	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetSE@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP		; MusicTrack::SetSE
PUBLIC	?SetRepeat_C_End@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetRepeat_C_End
$T106744 DD	0ffffffffH
	DD	FLAT:$L106250
	DD	00H
	DD	FLAT:$L106251
$T106730 DD	019930520H
	DD	02H
	DD	FLAT:$T106744
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_iRepeatCount$24908 = -56				; size = 4
_cData$24897 = -49					; size = 1
$T106241 = -48						; size = 4
$T106239 = -48						; size = 4
$T106238 = -48						; size = 4
$T106237 = -48						; size = 4
$T106236 = -48						; size = 4
$T106235 = -48						; size = 4
$T106234 = -48						; size = 4
_sOpCode$24910 = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_cOpCode$24909 = 8					; size = 1
_MML$ = 8						; size = 4
?SetRepeat_C_End@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR ; MusicTrack::SetRepeat_C_End
; _this$ = ecx

; 1121 : {

  02ee6	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetRepeat_C_End@MusicTrack@@QAEXPAVMMLfile@@@Z
  02eeb	e8 00 00 00 00	 call	 __EH_prolog
  02ef0	83 ec 2c	 sub	 esp, 44			; 0000002cH
  02ef3	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  02ef8	53		 push	 ebx
  02ef9	8b d9		 mov	 ebx, ecx
  02efb	56		 push	 esi

; 1122 : 	EchoVolRet();	//^GR[A

  02efc	8b f3		 mov	 esi, ebx
  02efe	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  02f01	e8 00 00 00 00	 call	 ?EchoVolRet@MusicTrack@@QAEXXZ ; MusicTrack::EchoVolRet

; 1123 : 
; 1124 : 	if((sp_repeat_c == 0) || ((*it_repeat_type) != 3)){

  02f06	83 bb 34 02 00
	00 00		 cmp	 DWORD PTR [ebx+564], 0
  02f0d	0f 84 ed 02 00
	00		 je	 $L24892
  02f13	8b 83 30 02 00
	00		 mov	 eax, DWORD PTR [ebx+560]
  02f19	83 38 03	 cmp	 DWORD PTR [eax], 3
  02f1c	0f 85 de 02 00
	00		 jne	 $L24892

; 1126 : 	} else {
; 1127 : 
; 1128 : 		list<MusicItem*>::iterator	pt_itMusic = ptcItem.end();

  02f22	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
  02f25	57		 push	 edi

; 1129 : 		unsigned	char	cData		= MML->GetChar();

  02f26	8b 7d 08	 mov	 edi, DWORD PTR _MML$[ebp]
  02f29	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar
  02f2e	88 45 cf	 mov	 BYTE PTR _cData$24897[ebp], al

; 1130 : 					int		repeat_cnt	= (*it_ct_repeat_c);

  02f31	8b 83 68 02 00
	00		 mov	 eax, DWORD PTR [ebx+616]
  02f37	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 1131 : 
; 1132 : 		MML->Back();

  02f3a	8b 45 08	 mov	 eax, DWORD PTR _MML$[ebp]
  02f3d	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back

; 1133 : 
; 1134 : 		if((cData < '0') || (cData > '9')){

  02f42	80 7d cf 30	 cmp	 BYTE PTR _cData$24897[ebp], 48 ; 00000030H
  02f46	72 7d		 jb	 SHORT $L24900
  02f48	80 7d cf 39	 cmp	 BYTE PTR _cData$24897[ebp], 57 ; 00000039H
  02f4c	77 77		 ja	 SHORT $L24900

; 1138 : 			}
; 1139 : 		} else {
; 1140 : 			//
; 1141 : 			if(repeat_cnt != -1){

  02f4e	83 ff ff	 cmp	 edi, -1

; 1142 : 				MML->Err(_T("s[gLqB"));

  02f51	8b 45 08	 mov	 eax, DWORD PTR _MML$[ebp]
  02f54	74 0a		 je	 SHORT $L24903
  02f56	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CI@IJNCMADK@0?j0?T0?$PM0?HV?$NOep0LN?$CBe?$LJ0k?$IK?$BI?$IP?p0U0?$IM0f0D0?$HO0Y0?$AC?$AA?$AA@
  02f5b	e9 a8 02 00 00	 jmp	 $L106743
$L24903:

; 1143 : 			}
; 1144 : 			repeat_cnt = MML->GetInt();

  02f60	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 1145 : 			if( (repeat_cnt > 255) || (repeat_cnt < 2) ){

  02f65	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  02f6a	7f 4f		 jg	 SHORT $L24905
  02f6c	83 f8 02	 cmp	 eax, 2
  02f6f	7c 4a		 jl	 SHORT $L24905

; 1147 : 			} else {
; 1148 : 				(*it_ct_repeat_c)	= repeat_cnt;

  02f71	8b 8b 68 02 00
	00		 mov	 ecx, DWORD PTR [ebx+616]
  02f77	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L106734:

; 1149 : 			}
; 1150 : 		}
; 1151 : 
; 1152 : 		pt_itMusic--;

  02f7a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 1153 : 		(*it_it_repeat_c_e) = pt_itMusic;

  02f7d	8b 8b 74 02 00
	00		 mov	 ecx, DWORD PTR [ebx+628]
  02f83	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1154 : 
; 1155 : 		//--------------------------
; 1156 : 		//s[gWJ
; 1157 : 		{
; 1158 : 			unsigned	int				iRepeatCount = (*it_ct_repeat_c) - 1;

  02f86	8b 83 68 02 00
	00		 mov	 eax, DWORD PTR [ebx+616]
  02f8c	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  02f8f	4e		 dec	 esi

; 1159 : 			unsigned	char			cOpCode;
; 1160 : 			string						sOpCode;

  02f90	6a 00		 push	 0
  02f92	8d 4d d4	 lea	 ecx, DWORD PTR _sOpCode$24910[ebp]
  02f95	89 75 c8	 mov	 DWORD PTR _iRepeatCount$24908[ebp], esi
  02f98	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _sOpCode$24910[ebp+24], 15 ; 0000000fH
  02f9f	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
  02fa4	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1161 : 
; 1162 : 			while(iRepeatCount>0){

  02fa8	85 f6		 test	 esi, esi
  02faa	0f 86 9e 01 00
	00		 jbe	 $L24913
$L24912:

; 1163 : 				pt_itMusic	=	(*it_it_repeat_c_s);

  02fb0	8b 83 6c 02 00
	00		 mov	 eax, DWORD PTR [ebx+620]

; 1164 : 				if(pt_itMusic != *it_it_repeat_c_e){

  02fb6	e9 77 01 00 00	 jmp	 $L106740
$L24905:

; 1146 : 				MML->Err(_T("s[g2`255wB"));

  02fbb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DC@JAEEIEKF@0?j0?T0?$PM0?HV?$NOep0o?$AA2?$PP?$FO?$AA2?$AA5?$AA50n?$HL?DV?r0gc?$AH?$FL?$JK0W0f@
  02fc0	e9 40 02 00 00	 jmp	 $L106742
$L24900:

; 1135 : 			//
; 1136 : 			if(repeat_cnt == -1){

  02fc5	83 ff ff	 cmp	 edi, -1
  02fc8	75 b0		 jne	 SHORT $L106734

; 1137 : 				MML->Err(_T("s[gLqB"));

  02fca	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CC@FCKGONLL@0?j0?T0?$PM0?HV?$NOep0n?$IK?$BI?$IP?p0L0B0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
  02fcf	e9 31 02 00 00	 jmp	 $L106742
$L24915:

; 1165 : 					do{
; 1166 : 						pt_itMusic++;

  02fd4	8b 3f		 mov	 edi, DWORD PTR [edi]

; 1167 : 						cOpCode		=	(*pt_itMusic)->getCode((unsigned int)0);

  02fd6	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  02fd9	33 c9		 xor	 ecx, ecx
  02fdb	e8 00 00 00 00	 call	 ?getCode@MusicItem@@QAEEI@Z ; MusicItem::getCode
  02fe0	88 45 08	 mov	 BYTE PTR _cOpCode$24909[ebp], al

; 1168 : 						sOpCode.clear();

  02fe3	8d 45 d4	 lea	 eax, DWORD PTR _sOpCode$24910[ebp]
  02fe6	e8 00 00 00 00	 call	 ?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear

; 1169 : 										(*pt_itMusic)->getCode(&sOpCode);

  02feb	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  02fee	8b 01		 mov	 eax, DWORD PTR [ecx]
  02ff0	8d 55 d4	 lea	 edx, DWORD PTR _sOpCode$24910[ebp]
  02ff3	52		 push	 edx
  02ff4	ff 10		 call	 DWORD PTR [eax]

; 1170 : 						switch(cOpCode){

  02ff6	0f b6 45 08	 movzx	 eax, BYTE PTR _cOpCode$24909[ebp]
  02ffa	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  02ffd	7f 7c		 jg	 SHORT $L106244
  02fff	74 5e		 je	 SHORT $L24929
  03001	83 f8 02	 cmp	 eax, 2
  03004	74 3d		 je	 SHORT $L24924
  03006	83 f8 06	 cmp	 eax, 6
  03009	74 1c		 je	 SHORT $L24926
  0300b	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0300e	7e 78		 jle	 SHORT $L24937
  03010	83 f8 13	 cmp	 eax, 19			; 00000013H
  03013	7f 73		 jg	 SHORT $L24937

; 1177 : 							case(nsd_Envelop_Voice):
; 1178 : 							case(nsd_Envelop_Volume):
; 1179 : 							case(nsd_Envelop_Frequency):
; 1180 : 							case(nsd_Envelop_Note):
; 1181 : 								CopyEnvEvent(cOpCode, &sOpCode, pt_itMusic);

  03015	57		 push	 edi
  03016	8d 45 d4	 lea	 eax, DWORD PTR _sOpCode$24910[ebp]
  03019	50		 push	 eax
  0301a	ff 75 08	 push	 DWORD PTR _cOpCode$24909[ebp]
  0301d	e8 00 00 00 00	 call	 ?CopyEnvEvent@MusicTrack@@QAEXEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@3@@Z ; MusicTrack::CopyEnvEvent

; 1182 : 								break;

  03022	e9 f2 00 00 00	 jmp	 $L24921
$L24926:

; 1174 : 							case(nsd_Call_SE):
; 1175 : 								ptcSE.push_back(CopyAddressEvent(cOpCode, &sOpCode, pt_itMusic));

  03027	57		 push	 edi
  03028	8d 45 d4	 lea	 eax, DWORD PTR _sOpCode$24910[ebp]
  0302b	50		 push	 eax
  0302c	ff 75 08	 push	 DWORD PTR _cOpCode$24909[ebp]
  0302f	53		 push	 ebx
  03030	e8 00 00 00 00	 call	 ?CopyAddressEvent@MusicTrack@@QAEPAVmml_Address@@EPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@4@@Z ; MusicTrack::CopyAddressEvent
  03035	89 45 d0	 mov	 DWORD PTR $T106235[ebp], eax
  03038	8d 83 b8 02 00
	00		 lea	 eax, DWORD PTR [ebx+696]

; 1176 : 								break;

  0303e	e9 ce 00 00 00	 jmp	 $L106741
$L24924:

; 1171 : 							case(nsd_Call):
; 1172 : 								ptcSub.push_back(CopyAddressEvent(cOpCode, &sOpCode, pt_itMusic));

  03043	57		 push	 edi
  03044	8d 45 d4	 lea	 eax, DWORD PTR _sOpCode$24910[ebp]
  03047	50		 push	 eax
  03048	ff 75 08	 push	 DWORD PTR _cOpCode$24909[ebp]
  0304b	53		 push	 ebx
  0304c	e8 00 00 00 00	 call	 ?CopyAddressEvent@MusicTrack@@QAEPAVmml_Address@@EPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@4@@Z ; MusicTrack::CopyAddressEvent
  03051	89 45 d0	 mov	 DWORD PTR $T106234[ebp], eax
  03054	8d 83 c8 02 00
	00		 lea	 eax, DWORD PTR [ebx+712]

; 1173 : 								break;

  0305a	e9 b2 00 00 00	 jmp	 $L106741
$L24929:

; 1183 : 							case(nsc_VRC7):
; 1184 : 								ptcOPLL.push_back(CopyAddressEvent(cOpCode, &sOpCode, pt_itMusic));

  0305f	57		 push	 edi
  03060	8d 45 d4	 lea	 eax, DWORD PTR _sOpCode$24910[ebp]
  03063	50		 push	 eax
  03064	ff 75 08	 push	 DWORD PTR _cOpCode$24909[ebp]
  03067	53		 push	 ebx
  03068	e8 00 00 00 00	 call	 ?CopyAddressEvent@MusicTrack@@QAEPAVmml_Address@@EPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@4@@Z ; MusicTrack::CopyAddressEvent
  0306d	89 45 d0	 mov	 DWORD PTR $T106236[ebp], eax
  03070	8d 83 98 02 00
	00		 lea	 eax, DWORD PTR [ebx+664]

; 1185 : 								break;

  03076	e9 96 00 00 00	 jmp	 $L106741
$L106244:

; 1170 : 						switch(cOpCode){

  0307b	83 e8 1e	 sub	 eax, 30			; 0000001eH
  0307e	74 7a		 je	 SHORT $L24931
  03080	83 e8 04	 sub	 eax, 4
  03083	74 5c		 je	 SHORT $L24933
  03085	48		 dec	 eax
  03086	74 40		 je	 SHORT $L24935
$L24937:

; 1195 : 							default:
; 1196 : 								{
; 1197 : 									mml_general*	_event	=	new	mml_general(cOpCode);

  03088	6a 3c		 push	 60			; 0000003cH
  0308a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0308f	59		 pop	 ecx
  03090	89 45 d0	 mov	 DWORD PTR $T106241[ebp], eax
  03093	85 c0		 test	 eax, eax
  03095	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  03099	74 12		 je	 SHORT $L106242
  0309b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BA@GCDNCJOK@?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl?$AA?$AA@
  030a0	ff 75 08	 push	 DWORD PTR _cOpCode$24909[ebp]
  030a3	50		 push	 eax
  030a4	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  030a9	8b f0		 mov	 esi, eax
  030ab	eb 02		 jmp	 SHORT $L106243
$L106242:
  030ad	33 f6		 xor	 esi, esi
$L106243:

; 1198 : 									_event->setCode(&sOpCode);

  030af	8d 4d d4	 lea	 ecx, DWORD PTR _sOpCode$24910[ebp]
  030b2	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  030b6	8b 06		 mov	 eax, DWORD PTR [esi]
  030b8	51		 push	 ecx
  030b9	8b ce		 mov	 ecx, esi
  030bb	ff 50 04	 call	 DWORD PTR [eax+4]

; 1199 : 									SetEvent(_event);

  030be	56		 push	 esi
  030bf	8b c3		 mov	 eax, ebx
  030c1	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 1200 : 								}
; 1201 : 								break;

  030c6	eb 51		 jmp	 SHORT $L24921
$L24935:

; 1192 : 							case(nsd_FDS_Modlator):
; 1193 : 								ptcFDSM.push_back(CopyAddressEvent(cOpCode, &sOpCode, pt_itMusic));

  030c8	57		 push	 edi
  030c9	8d 45 d4	 lea	 eax, DWORD PTR _sOpCode$24910[ebp]
  030cc	50		 push	 eax
  030cd	ff 75 08	 push	 DWORD PTR _cOpCode$24909[ebp]
  030d0	53		 push	 ebx
  030d1	e8 00 00 00 00	 call	 ?CopyAddressEvent@MusicTrack@@QAEPAVmml_Address@@EPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@4@@Z ; MusicTrack::CopyAddressEvent
  030d6	89 45 d0	 mov	 DWORD PTR $T106239[ebp], eax
  030d9	8d 83 88 02 00
	00		 lea	 eax, DWORD PTR [ebx+648]

; 1194 : 								break;

  030df	eb 30		 jmp	 SHORT $L106741
$L24933:

; 1188 : 								break;
; 1189 : 							case(nsd_FDS_Career):
; 1190 : 								ptcFDSC.push_back(CopyAddressEvent(cOpCode, &sOpCode, pt_itMusic));

  030e1	57		 push	 edi
  030e2	8d 45 d4	 lea	 eax, DWORD PTR _sOpCode$24910[ebp]
  030e5	50		 push	 eax
  030e6	ff 75 08	 push	 DWORD PTR _cOpCode$24909[ebp]
  030e9	53		 push	 ebx
  030ea	e8 00 00 00 00	 call	 ?CopyAddressEvent@MusicTrack@@QAEPAVmml_Address@@EPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@4@@Z ; MusicTrack::CopyAddressEvent
  030ef	89 45 d0	 mov	 DWORD PTR $T106238[ebp], eax
  030f2	8d 83 78 02 00
	00		 lea	 eax, DWORD PTR [ebx+632]

; 1191 : 								break;

  030f8	eb 17		 jmp	 SHORT $L106741
$L24931:

; 1186 : 							case(nsc_N163):
; 1187 : 								ptcWave.push_back(CopyAddressEvent(cOpCode, &sOpCode, pt_itMusic));

  030fa	57		 push	 edi
  030fb	8d 45 d4	 lea	 eax, DWORD PTR _sOpCode$24910[ebp]
  030fe	50		 push	 eax
  030ff	ff 75 08	 push	 DWORD PTR _cOpCode$24909[ebp]
  03102	53		 push	 ebx
  03103	e8 00 00 00 00	 call	 ?CopyAddressEvent@MusicTrack@@QAEPAVmml_Address@@EPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@4@@Z ; MusicTrack::CopyAddressEvent
  03108	89 45 d0	 mov	 DWORD PTR $T106237[ebp], eax
  0310b	8d 83 a8 02 00
	00		 lea	 eax, DWORD PTR [ebx+680]
$L106741:
  03111	8d 75 d0	 lea	 esi, DWORD PTR $T106237[ebp]
  03114	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVmml_Address@@V?$allocator@PAVmml_Address@@@std@@@std@@QAEXABQAVmml_Address@@@Z ; std::vector<mml_Address *,std::allocator<mml_Address *> >::push_back
$L24921:

; 1202 : 						}
; 1203 : 
; 1204 : 						if((iRepeatCount == 1) && (pt_itMusic == *it_it_repeat_c_b)){

  03119	8b 75 c8	 mov	 esi, DWORD PTR _iRepeatCount$24908[ebp]
  0311c	83 fe 01	 cmp	 esi, 1
  0311f	75 14		 jne	 SHORT $L24916
  03121	8b 83 70 02 00
	00		 mov	 eax, DWORD PTR [ebx+624]
  03127	3b 78 08	 cmp	 edi, DWORD PTR [eax+8]
  0312a	75 09		 jne	 SHORT $L24916

; 1205 : 							pt_itMusic = *it_it_repeat_c_e;

  0312c	8b 83 74 02 00
	00		 mov	 eax, DWORD PTR [ebx+628]
$L106740:
  03132	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
$L24916:

; 1206 : 						}
; 1207 : 					} while(pt_itMusic != *it_it_repeat_c_e);

  03135	8b 83 74 02 00
	00		 mov	 eax, DWORD PTR [ebx+628]
  0313b	3b 78 08	 cmp	 edi, DWORD PTR [eax+8]
  0313e	0f 85 90 fe ff
	ff		 jne	 $L24915

; 1208 : 				}
; 1209 : 				iRepeatCount--;

  03144	4e		 dec	 esi
  03145	89 75 c8	 mov	 DWORD PTR _iRepeatCount$24908[ebp], esi
  03148	0f 85 62 fe ff
	ff		 jne	 $L24912
$L24913:

; 1210 : 			}
; 1211 : 
; 1212 : 		}

  0314e	6a 00		 push	 0
  03150	6a 01		 push	 1
  03152	8d 4d d4	 lea	 ecx, DWORD PTR _sOpCode$24910[ebp]
  03155	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1213 : 
; 1214 : 		//--------------------------
; 1215 : 		//Ce[^
; 1216 : 		it_ct_repeat_c--;

  0315a	8b 83 68 02 00
	00		 mov	 eax, DWORD PTR [ebx+616]
  03160	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  03163	89 83 68 02 00
	00		 mov	 DWORD PTR [ebx+616], eax

; 1217 : 		it_it_repeat_c_s--;

  03169	8d 83 6c 02 00
	00		 lea	 eax, DWORD PTR [ebx+620]
  0316f	8b 08		 mov	 ecx, DWORD PTR [eax]
  03171	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  03174	89 08		 mov	 DWORD PTR [eax], ecx

; 1218 : 		it_it_repeat_c_b--;

  03176	8d 83 70 02 00
	00		 lea	 eax, DWORD PTR [ebx+624]
  0317c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0317e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  03181	89 08		 mov	 DWORD PTR [eax], ecx

; 1219 : 		it_it_repeat_c_e--;

  03183	8b 83 74 02 00
	00		 mov	 eax, DWORD PTR [ebx+628]
  03189	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0318c	89 83 74 02 00
	00		 mov	 DWORD PTR [ebx+628], eax

; 1220 : 
; 1221 : 		//X^bNj
; 1222 : 		st_ct_repeat_c.pop_back();

  03192	8d 83 38 02 00
	00		 lea	 eax, DWORD PTR [ebx+568]
  03198	e8 00 00 00 00	 call	 ?pop_back@?$list@IV?$allocator@I@std@@@std@@QAEXXZ ; std::list<unsigned int,std::allocator<unsigned int> >::pop_back

; 1223 : 		st_it_repeat_c_s.pop_back();

  0319d	8d 83 44 02 00
	00		 lea	 eax, DWORD PTR [ebx+580]
  031a3	e8 00 00 00 00	 call	 ?pop_back@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXXZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::pop_back

; 1224 : 		st_it_repeat_c_b.pop_back();

  031a8	8d 83 50 02 00
	00		 lea	 eax, DWORD PTR [ebx+592]
  031ae	e8 00 00 00 00	 call	 ?pop_back@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXXZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::pop_back

; 1225 : 		st_it_repeat_c_e.pop_back();

  031b3	8d 83 5c 02 00
	00		 lea	 eax, DWORD PTR [ebx+604]
  031b9	e8 00 00 00 00	 call	 ?pop_back@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXXZ ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::pop_back

; 1226 : 		sp_repeat_c--;

  031be	ff 8b 34 02 00
	00		 dec	 DWORD PTR [ebx+564]

; 1227 : 
; 1228 : 		Reset_opt();

  031c4	8b c3		 mov	 eax, ebx
  031c6	e8 00 00 00 00	 call	 ?Reset_opt@MusicTrack@@QAEXXZ ; MusicTrack::Reset_opt

; 1229 : 
; 1230 : 		//s[g^CvA
; 1231 : 		it_repeat_type--;

  031cb	83 83 30 02 00
	00 fc		 add	 DWORD PTR [ebx+560], -4	; fffffffcH

; 1232 : 		repeat_type.pop_back();

  031d2	81 c3 20 02 00
	00		 add	 ebx, 544		; 00000220H
  031d8	8b c3		 mov	 eax, ebx
  031da	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  031df	85 c0		 test	 eax, eax
  031e1	5f		 pop	 edi
  031e2	74 04		 je	 SHORT $L24890
  031e4	83 43 08 fc	 add	 DWORD PTR [ebx+8], -4	; fffffffcH
$L24890:

; 1233 : 
; 1234 : 	}
; 1235 : 
; 1236 : }

  031e8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  031eb	5e		 pop	 esi
  031ec	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  031f3	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  031f6	5b		 pop	 ebx
  031f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  031fc	c9		 leave
  031fd	c2 04 00	 ret	 4
$L24892:

; 1125 : 		MML->Err(_T("s[g(C)Jn [: R}hB"));

  03200	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DE@PIDIKAJB@0?j0?T0?$PM0?H?$AA?$CI?$AAC?$AA?$CJ0n?$JF?$ILY?K?$AA?5?$AA?$FL?$AA?3?$AA?50?$LD0?$NO0?s0?I0L0B@
$L106742:
  03205	8b 45 08	 mov	 eax, DWORD PTR _MML$[ebp]
$L106743:
  03208	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L106745:
$L106738:
  0320d	cc		 int	 3
$L106250:
  00ab3	8d 4d d4	 lea	 ecx, DWORD PTR _sOpCode$24910[ebp]
  00ab6	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L106251:
  00abb	ff 75 d0	 push	 DWORD PTR $T106241[ebp]
  00abe	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00ac3	59		 pop	 ecx
  00ac4	c3		 ret	 0
__ehhandler$?SetRepeat_C_End@MusicTrack@@QAEXPAVMMLfile@@@Z:
  00ac5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T106730
  00aca	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetRepeat_C_End@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP	; MusicTrack::SetRepeat_C_End
PUBLIC	?SetRepeat_A_End@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetRepeat_A_End
$T106826 DD	0ffffffffH
	DD	FLAT:$L106752
$T106821 DD	019930520H
	DD	01H
	DD	FLAT:$T106826
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T106748 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetRepeat_A_End@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR ; MusicTrack::SetRepeat_A_End
; _this$ = edx
; _MML$ = ecx

; 1063 : {

  0320e	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetRepeat_A_End@MusicTrack@@QAEXPAVMMLfile@@@Z
  03213	e8 00 00 00 00	 call	 __EH_prolog
  03218	51		 push	 ecx
  03219	56		 push	 esi
  0321a	57		 push	 edi
  0321b	8b f2		 mov	 esi, edx
  0321d	8b f9		 mov	 edi, ecx

; 1064 : 	EchoVolRet();	//^GR[A

  0321f	e8 00 00 00 00	 call	 ?EchoVolRet@MusicTrack@@QAEXXZ ; MusicTrack::EchoVolRet

; 1065 : 
; 1066 : 	if((offset_repeat_a_s == 0) || ((*it_repeat_type) != 1)){

  03224	83 be 0c 02 00
	00 00		 cmp	 DWORD PTR [esi+524], 0
  0322b	0f 84 1e 01 00
	00		 je	 $L24866
  03231	8b 86 30 02 00
	00		 mov	 eax, DWORD PTR [esi+560]
  03237	83 38 01	 cmp	 DWORD PTR [eax], 1
  0323a	0f 85 0f 01 00
	00		 jne	 $L24866
  03240	53		 push	 ebx

; 1068 : 
; 1069 : 	} else {
; 1070 : 		
; 1071 : 		mml_Address*		_event;
; 1072 : 		unsigned	char	cData	= MML->GetChar();

  03241	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar
  03246	8a d8		 mov	 bl, al

; 1073 : 
; 1074 : 		MML->Back();

  03248	8b c7		 mov	 eax, edi
  0324a	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back

; 1075 : 
; 1076 : 		if((cData < '0') || (cData > '9')){

  0324f	80 fb 30	 cmp	 bl, 48			; 00000030H
  03252	72 3b		 jb	 SHORT $L24871
  03254	80 fb 39	 cmp	 bl, 57			; 00000039H
  03257	77 36		 ja	 SHORT $L24871

; 1080 : 			}
; 1081 : 		} else {
; 1082 : 			//
; 1083 : 			if(count_repeat_a != -1){

  03259	83 be 1c 02 00
	00 ff		 cmp	 DWORD PTR [esi+540], -1

; 1084 : 				MML->Err(_T("s[gLqB"));

  03260	8b c7		 mov	 eax, edi
  03262	74 0a		 je	 SHORT $L24875
  03264	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CI@IJNCMADK@0?j0?T0?$PM0?HV?$NOep0LN?$CBe?$LJ0k?$IK?$BI?$IP?p0U0?$IM0f0D0?$HO0Y0?$AC?$AA?$AA@
  03269	e9 e8 00 00 00	 jmp	 $L106825
$L24875:

; 1085 : 			}
; 1086 : 			count_repeat_a = MML->GetInt();

  0326e	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 1087 : 			if( (count_repeat_a > 255) || (count_repeat_a < 2) ){

  03273	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  03278	89 86 1c 02 00
	00		 mov	 DWORD PTR [esi+540], eax
  0327e	7f 05		 jg	 SHORT $L24878
  03280	83 f8 02	 cmp	 eax, 2
  03283	7d 1d		 jge	 SHORT $L24872
$L24878:

; 1088 : 				MML->Err(_T("s[g2`255wB"));

  03285	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DC@JAEEIEKF@0?j0?T0?$PM0?HV?$NOep0o?$AA2?$PP?$FO?$AA2?$AA5?$AA50n?$HL?DV?r0gc?$AH?$FL?$JK0W0f@
  0328a	e9 c5 00 00 00	 jmp	 $L106824
$L24871:

; 1077 : 			//
; 1078 : 			if(count_repeat_a == -1){

  0328f	83 be 1c 02 00
	00 ff		 cmp	 DWORD PTR [esi+540], -1
  03296	75 0a		 jne	 SHORT $L24872

; 1079 : 				MML->Err(_T("s[gLqB"));

  03298	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CC@FCKGONLL@0?j0?T0?$PM0?HV?$NOep0n?$IK?$BI?$IP?p0L0B0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
  0329d	e9 b2 00 00 00	 jmp	 $L106824
$L24872:

; 1089 : 			}
; 1090 : 		}
; 1091 : 
; 1092 : 		_old_repeat->set_count((unsigned char)count_repeat_a);

  032a2	8a 8e 1c 02 00
	00		 mov	 cl, BYTE PTR [esi+540]
  032a8	8b 86 08 02 00
	00		 mov	 eax, DWORD PTR [esi+520]
  032ae	e8 00 00 00 00	 call	 ?set_count@mml_repeat@@QAEXE@Z ; mml_repeat::set_count

; 1093 : 
; 1094 : 		_event = new mml_Address(nsd_Repeat_A_End, _T("Repeat(A) End"));

  032b3	6a 44		 push	 68			; 00000044H
  032b5	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  032ba	59		 pop	 ecx
  032bb	89 45 f0	 mov	 DWORD PTR $T106748[ebp], eax
  032be	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  032c2	85 c0		 test	 eax, eax
  032c4	5b		 pop	 ebx
  032c5	74 11		 je	 SHORT $L106749
  032c7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BM@DPEAGELP@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAA?$AA?$CJ?$AA?5?$AAE?$AAn?$AAd?$AA?$AA@
  032cc	6a 05		 push	 5
  032ce	50		 push	 eax
  032cf	e8 00 00 00 00	 call	 ??0mml_Address@@QAE@EQBG@Z ; mml_Address::mml_Address
  032d4	8b f8		 mov	 edi, eax
  032d6	eb 02		 jmp	 SHORT $L106750
$L106749:
  032d8	33 ff		 xor	 edi, edi
$L106750:
  032da	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 1095 : 		_event->set_Address(offset_repeat_a_s - offset_now - 1);

  032de	8b 8e 0c 02 00
	00		 mov	 ecx, DWORD PTR [esi+524]
  032e4	2b 8e 9c 00 00
	00		 sub	 ecx, DWORD PTR [esi+156]
  032ea	8b c7		 mov	 eax, edi
  032ec	49		 dec	 ecx
  032ed	e8 00 00 00 00	 call	 ?set_Address@mml_Address@@QAEXI@Z ; mml_Address::set_Address

; 1096 : 		SetEvent(_event);

  032f2	57		 push	 edi
  032f3	8b c6		 mov	 eax, esi
  032f5	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 1097 : 		//B
; 1098 : 		if(offset_repeat_a_b != 0){

  032fa	8b 86 10 02 00
	00		 mov	 eax, DWORD PTR [esi+528]
  03300	85 c0		 test	 eax, eax
  03302	74 13		 je	 SHORT $L24885

; 1099 : 			_old_repeatA_Branch->set_Address(offset_now - offset_repeat_a_b);

  03304	8b 8e 9c 00 00
	00		 mov	 ecx, DWORD PTR [esi+156]
  0330a	2b c8		 sub	 ecx, eax
  0330c	8b 86 04 02 00
	00		 mov	 eax, DWORD PTR [esi+516]
  03312	e8 00 00 00 00	 call	 ?set_Address@mml_Address@@QAEXI@Z ; mml_Address::set_Address
$L24885:

; 1100 : 		}
; 1101 : 		offset_repeat_a_s = 0;

  03317	83 a6 0c 02 00
	00 00		 and	 DWORD PTR [esi+524], 0

; 1102 : 
; 1103 : 		Reset_opt();

  0331e	8b c6		 mov	 eax, esi
  03320	e8 00 00 00 00	 call	 ?Reset_opt@MusicTrack@@QAEXXZ ; MusicTrack::Reset_opt

; 1104 : 
; 1105 : 		//s[g^CvA
; 1106 : 		it_repeat_type--;

  03325	83 86 30 02 00
	00 fc		 add	 DWORD PTR [esi+560], -4	; fffffffcH

; 1107 : 		repeat_type.pop_back();

  0332c	81 c6 20 02 00
	00		 add	 esi, 544		; 00000220H
  03332	8b c6		 mov	 eax, esi
  03334	e8 00 00 00 00	 call	 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
  03339	85 c0		 test	 eax, eax
  0333b	74 04		 je	 SHORT $L24864
  0333d	83 46 08 fc	 add	 DWORD PTR [esi+8], -4	; fffffffcH
$L24864:

; 1108 : 	}
; 1109 : 
; 1110 : }

  03341	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  03344	5f		 pop	 edi
  03345	5e		 pop	 esi
  03346	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0334d	c9		 leave
  0334e	c3		 ret	 0
$L24866:

; 1067 : 		MML->Err(_T("s[g(A)Jn [ R}hB"));

  0334f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DC@IPGNKEJP@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJ0n?$JF?$ILY?K?$AA?5?$AA?$FL?$AA?50?$LD0?$NO0?s0?I0L0B0?$IK@
$L106824:
  03354	8b c7		 mov	 eax, edi
$L106825:
  03356	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L106827:
$L106823:
  0335b	cc		 int	 3
$L106752:
  00acf	ff 75 f0	 push	 DWORD PTR $T106748[ebp]
  00ad2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00ad7	59		 pop	 ecx
  00ad8	c3		 ret	 0
__ehhandler$?SetRepeat_A_End@MusicTrack@@QAEXPAVMMLfile@@@Z:
  00ad9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T106821
  00ade	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetRepeat_A_End@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP	; MusicTrack::SetRepeat_A_End
PUBLIC	?SetRepeat_End@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetRepeat_End
; Function compile flags: /Ogsy
_TEXT	SEGMENT
?SetRepeat_End@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetRepeat_End
; _this$ = edx
; _MML$ = ecx

; 1039 : 
; 1040 : 	switch(*it_repeat_type){

  0335c	8b 82 30 02 00
	00		 mov	 eax, DWORD PTR [edx+560]
  03362	8b 00		 mov	 eax, DWORD PTR [eax]
  03364	48		 dec	 eax
  03365	74 19		 je	 SHORT $L24858
  03367	48		 dec	 eax
  03368	48		 dec	 eax
  03369	74 0c		 je	 SHORT $L24859

; 1046 : 			break;
; 1047 : 		default:
; 1048 : 			MML->Err(_T("s[gJnR}hB"));

  0336b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CE@PJCEBMDC@0?j0?T0?$PM0?H?$JF?$ILY?K0?$LD0?$NO0?s0?I0L0B0?$IK0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
  03370	8b c1		 mov	 eax, ecx
  03372	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L106839:
$L24859:

; 1043 : 			break;
; 1044 : 		case(3):
; 1045 : 			SetRepeat_C_End(MML);

  03377	51		 push	 ecx
  03378	8b ca		 mov	 ecx, edx
  0337a	e8 00 00 00 00	 call	 ?SetRepeat_C_End@MusicTrack@@QAEXPAVMMLfile@@@Z ; MusicTrack::SetRepeat_C_End

; 1049 : 			break;
; 1050 : 	}
; 1051 : 
; 1052 : }

  0337f	c3		 ret	 0
$L24858:

; 1041 : 		case(1):
; 1042 : 			SetRepeat_A_End(MML);

  03380	e9 00 00 00 00	 jmp	 ?SetRepeat_A_End@MusicTrack@@QAEXPAVMMLfile@@@Z ; MusicTrack::SetRepeat_A_End
$L106838:
?SetRepeat_End@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP	; MusicTrack::SetRepeat_End
_TEXT	ENDS
PUBLIC	?SetRepeat_C_Start@MusicTrack@@QAEXPAVMMLfile@@@Z ; MusicTrack::SetRepeat_C_Start
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T106842 = -8						; size = 4
_cData$ = -1						; size = 1
$T106851 = 8						; size = 4
_pt_itMusic$ = 8					; size = 4
_MML$ = 8						; size = 4
?SetRepeat_C_Start@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR ; MusicTrack::SetRepeat_C_Start
; _this$ = ebx

; 936  : {

  03385	55		 push	 ebp
  03386	8b ec		 mov	 ebp, esp
  03388	51		 push	 ecx
  03389	51		 push	 ecx
  0338a	56		 push	 esi

; 937  : 
; 938  : 	list<MusicItem*>::iterator	pt_itMusic	=	ptcItem.end();

  0338b	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
  0338e	57		 push	 edi

; 939  : 	unsigned	char	cData	= MML->GetChar();

  0338f	8b 7d 08	 mov	 edi, DWORD PTR _MML$[ebp]
  03392	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar
  03397	88 45 ff	 mov	 BYTE PTR _cData$[ebp], al

; 940  : 				int		repeat_cnt;
; 941  : 
; 942  : 	MML->Back();

  0339a	8b c7		 mov	 eax, edi
  0339c	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back

; 943  : 
; 944  : 	if((cData < '0') || (cData > '9')){

  033a1	80 7d ff 30	 cmp	 BYTE PTR _cData$[ebp], 48 ; 00000030H
  033a5	72 29		 jb	 SHORT $L24800
  033a7	80 7d ff 39	 cmp	 BYTE PTR _cData$[ebp], 57 ; 00000039H
  033ab	77 23		 ja	 SHORT $L24800

; 946  : 	} else {
; 947  : 		repeat_cnt = MML->GetInt();

  033ad	8b c7		 mov	 eax, edi
  033af	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  033b4	8b f8		 mov	 edi, eax

; 948  : 		if( (repeat_cnt > 255) || (repeat_cnt < 2) ){

  033b6	81 ff ff 00 00
	00		 cmp	 edi, 255		; 000000ffH
  033bc	7f 05		 jg	 SHORT $L24803
  033be	83 ff 02	 cmp	 edi, 2
  033c1	7d 10		 jge	 SHORT $L24802
$L24803:

; 949  : 			MML->Err(_T("s[g2`255wB"));

  033c3	8b 45 08	 mov	 eax, DWORD PTR _MML$[ebp]
  033c6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DC@JAEEIEKF@0?j0?T0?$PM0?HV?$NOep0o?$AA2?$PP?$FO?$AA2?$AA5?$AA50n?$HL?DV?r0gc?$AH?$FL?$JK0W0f@
  033cb	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L107202:
$L24800:

; 945  : 		repeat_cnt = -1;

  033d0	83 cf ff	 or	 edi, -1
$L24802:

; 950  : 		}
; 951  : 	}
; 952  : 
; 953  : 	//UKZbg
; 954  : 	Reset_opt();

  033d3	8b c3		 mov	 eax, ebx
  033d5	e8 00 00 00 00	 call	 ?Reset_opt@MusicTrack@@QAEXXZ ; MusicTrack::Reset_opt

; 955  : 
; 956  : 	//X^bN
; 957  : 	pt_itMusic--;

  033da	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  033dd	89 45 08	 mov	 DWORD PTR _pt_itMusic$[ebp], eax

; 958  : 	st_ct_repeat_c.push_back(repeat_cnt);

  033e0	8d 83 38 02 00
	00		 lea	 eax, DWORD PTR [ebx+568]
  033e6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  033e9	8d 55 f8	 lea	 edx, DWORD PTR $T106842[ebp]
  033ec	52		 push	 edx
  033ed	51		 push	 ecx
  033ee	50		 push	 eax
  033ef	89 7d f8	 mov	 DWORD PTR $T106842[ebp], edi
  033f2	e8 00 00 00 00	 call	 ?_Insert@?$list@IV?$allocator@I@std@@@std@@QAEXViterator@12@ABI@Z ; std::list<unsigned int,std::allocator<unsigned int> >::_Insert

; 959  : 	st_it_repeat_c_s.push_back(pt_itMusic);

  033f7	8d 83 44 02 00
	00		 lea	 eax, DWORD PTR [ebx+580]
  033fd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  03400	8d 55 08	 lea	 edx, DWORD PTR _pt_itMusic$[ebp]
  03403	52		 push	 edx
  03404	51		 push	 ecx
  03405	50		 push	 eax
  03406	e8 00 00 00 00	 call	 ?_Insert@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXViterator@12@ABV3?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Insert

; 960  : 	st_it_repeat_c_b.push_back(pt_itMusic);

  0340b	8d 83 50 02 00
	00		 lea	 eax, DWORD PTR [ebx+592]
  03411	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  03414	8d 55 08	 lea	 edx, DWORD PTR _pt_itMusic$[ebp]
  03417	52		 push	 edx
  03418	51		 push	 ecx
  03419	50		 push	 eax
  0341a	e8 00 00 00 00	 call	 ?_Insert@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXViterator@12@ABV3?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Insert

; 961  : 	st_it_repeat_c_e.push_back(pt_itMusic);

  0341f	8d 83 5c 02 00
	00		 lea	 eax, DWORD PTR [ebx+604]
  03425	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  03428	8d 55 08	 lea	 edx, DWORD PTR _pt_itMusic$[ebp]
  0342b	52		 push	 edx
  0342c	51		 push	 ecx
  0342d	50		 push	 eax
  0342e	e8 00 00 00 00	 call	 ?_Insert@?$list@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@V?$allocator@Viterator@?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@std@@@3@@std@@QAEXViterator@12@ABV3?$list@PAVMusicItem@@V?$allocator@PAVMusicItem@@@std@@@2@@Z ; std::list<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator,std::allocator<std::list<MusicItem *,std::allocator<MusicItem *> >::iterator> >::_Insert

; 962  : 	sp_repeat_c++;
; 963  : 
; 964  : 	//Ce[^
; 965  : 	it_ct_repeat_c		= st_ct_repeat_c.end();

  03433	8b 83 3c 02 00
	00		 mov	 eax, DWORD PTR [ebx+572]
  03439	ff 83 34 02 00
	00		 inc	 DWORD PTR [ebx+564]
  0343f	89 83 68 02 00
	00		 mov	 DWORD PTR [ebx+616], eax

; 966  : 	it_it_repeat_c_s	= st_it_repeat_c_s.end();

  03445	8b 83 48 02 00
	00		 mov	 eax, DWORD PTR [ebx+584]
  0344b	89 83 6c 02 00
	00		 mov	 DWORD PTR [ebx+620], eax

; 967  : 	it_it_repeat_c_b	= st_it_repeat_c_b.end();

  03451	8b 83 54 02 00
	00		 mov	 eax, DWORD PTR [ebx+596]
  03457	89 83 70 02 00
	00		 mov	 DWORD PTR [ebx+624], eax

; 968  : 	it_it_repeat_c_e	= st_it_repeat_c_e.end();

  0345d	8b 83 60 02 00
	00		 mov	 eax, DWORD PTR [ebx+608]
  03463	89 83 74 02 00
	00		 mov	 DWORD PTR [ebx+628], eax

; 969  : 
; 970  : 	it_ct_repeat_c--;

  03469	8b 83 68 02 00
	00		 mov	 eax, DWORD PTR [ebx+616]
  0346f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  03472	89 83 68 02 00
	00		 mov	 DWORD PTR [ebx+616], eax

; 971  : 	it_it_repeat_c_s--;

  03478	8b 83 6c 02 00
	00		 mov	 eax, DWORD PTR [ebx+620]
  0347e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  03481	89 83 6c 02 00
	00		 mov	 DWORD PTR [ebx+620], eax

; 972  : 	it_it_repeat_c_b--;

  03487	8b 83 70 02 00
	00		 mov	 eax, DWORD PTR [ebx+624]
  0348d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  03490	89 83 70 02 00
	00		 mov	 DWORD PTR [ebx+624], eax

; 973  : 	it_it_repeat_c_e--;

  03496	8b 83 74 02 00
	00		 mov	 eax, DWORD PTR [ebx+628]
  0349c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0349f	89 83 74 02 00
	00		 mov	 DWORD PTR [ebx+628], eax

; 974  : 
; 975  : 	//s[g^CvL
; 976  : 	repeat_type.push_back(3);

  034a5	8d 83 20 02 00
	00		 lea	 eax, DWORD PTR [ebx+544]
  034ab	8d 75 08	 lea	 esi, DWORD PTR $T106851[ebp]
  034ae	c7 45 08 03 00
	00 00		 mov	 DWORD PTR $T106851[ebp], 3
  034b5	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 977  : 	it_repeat_type	=	repeat_type.end();

  034ba	8b 8b 28 02 00
	00		 mov	 ecx, DWORD PTR [ebx+552]
  034c0	8d 83 30 02 00
	00		 lea	 eax, DWORD PTR [ebx+560]
  034c6	5f		 pop	 edi
  034c7	89 08		 mov	 DWORD PTR [eax], ecx

; 978  : 	it_repeat_type--;

  034c9	83 00 fc	 add	 DWORD PTR [eax], -4	; fffffffcH
  034cc	5e		 pop	 esi

; 979  : 		
; 980  : }

  034cd	c9		 leave
  034ce	c2 04 00	 ret	 4
$L107201:
?SetRepeat_C_Start@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP	; MusicTrack::SetRepeat_C_Start
_TEXT	ENDS
PUBLIC	?SetRepeat_A_Start@MusicTrack@@QAEXPAVMMLfile@@@Z ; MusicTrack::SetRepeat_A_Start
$T107243 DD	0ffffffffH
	DD	FLAT:$L107211
$T107239 DD	019930520H
	DD	01H
	DD	FLAT:$T107243
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T107208 = -20						; size = 4
$T107205 = -20						; size = 4
_cData$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
?SetRepeat_A_Start@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR ; MusicTrack::SetRepeat_A_Start
; _this$ = ebx
; _MML$ = ecx

; 895  : {

  034d1	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetRepeat_A_Start@MusicTrack@@QAEXPAVMMLfile@@@Z
  034d6	e8 00 00 00 00	 call	 __EH_prolog
  034db	51		 push	 ecx
  034dc	51		 push	 ecx
  034dd	56		 push	 esi
  034de	57		 push	 edi
  034df	8b f9		 mov	 edi, ecx

; 896  : 	unsigned	char	cData	= MML->GetChar();

  034e1	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar
  034e6	88 45 f3	 mov	 BYTE PTR _cData$[ebp], al

; 897  : 
; 898  : 	MML->Back();

  034e9	8b c7		 mov	 eax, edi
  034eb	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back

; 899  : 
; 900  : 	if((cData < '0') || (cData > '9')){

  034f0	80 7d f3 30	 cmp	 BYTE PTR _cData$[ebp], 48 ; 00000030H
  034f4	72 26		 jb	 SHORT $L24774
  034f6	80 7d f3 39	 cmp	 BYTE PTR _cData$[ebp], 57 ; 00000039H
  034fa	77 20		 ja	 SHORT $L24774

; 902  : 	} else {
; 903  : 		count_repeat_a = MML->GetInt();

  034fc	8b c7		 mov	 eax, edi
  034fe	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 904  : 		if( (count_repeat_a > 255) || (count_repeat_a < 2) ){

  03503	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  03508	89 83 1c 02 00
	00		 mov	 DWORD PTR [ebx+540], eax
  0350e	7f 05		 jg	 SHORT $L24777
  03510	83 f8 02	 cmp	 eax, 2
  03513	7d 0e		 jge	 SHORT $L24776
$L24777:

; 905  : 			MML->Err(_T("s[g2`255wB"));

  03515	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DC@JAEEIEKF@0?j0?T0?$PM0?HV?$NOep0o?$AA2?$PP?$FO?$AA2?$AA5?$AA50n?$HL?DV?r0gc?$AH?$FL?$JK0W0f@
  0351a	eb 16		 jmp	 SHORT $L107242
$L24774:

; 901  : 		count_repeat_a = -1;

  0351c	83 8b 1c 02 00
	00 ff		 or	 DWORD PTR [ebx+540], -1
$L24776:

; 906  : 		}
; 907  : 	}
; 908  : 
; 909  : 	if(offset_repeat_a_s != 0){

  03523	33 f6		 xor	 esi, esi
  03525	39 b3 0c 02 00
	00		 cmp	 DWORD PTR [ebx+524], esi
  0352b	74 0c		 je	 SHORT $L24779

; 910  : 		MML->Err(_T("s[g(A)lXgB"));

  0352d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CG@DHEAMNDG@0?j0?T0?$PM0?H?$AA?$CI?$AAA?$AA?$CJ0n0?M0?$LJ0?H0o0g0M0?$HO0?$FL0?$JD0?$AC?$AA?$AA@
$L107242:
  03532	8b c7		 mov	 eax, edi
  03534	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L107244:
$L24779:

; 911  : 	} else {
; 912  : 		_old_repeat = new mml_repeat();

  03539	6a 3c		 push	 60			; 0000003cH
  0353b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03540	59		 pop	 ecx
  03541	89 45 ec	 mov	 DWORD PTR $T107205[ebp], eax
  03544	3b c6		 cmp	 eax, esi
  03546	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  03549	74 0d		 je	 SHORT $L107206
  0354b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CA@HFCOJDFA@?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$CI?$AAA?$AA?$CJ?$AA?5?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@
  03550	50		 push	 eax
  03551	e8 00 00 00 00	 call	 ??0mml_repeat@@QAE@QBG@Z ; mml_repeat::mml_repeat
  03556	eb 02		 jmp	 SHORT $L107207
$L107206:
  03558	33 c0		 xor	 eax, eax
$L107207:
  0355a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0355e	89 83 08 02 00
	00		 mov	 DWORD PTR [ebx+520], eax

; 913  : 
; 914  : 		SetEvent(_old_repeat);

  03564	50		 push	 eax
  03565	8b c3		 mov	 eax, ebx
  03567	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 915  : 		offset_repeat_a_s = offset_now;	// ] R}hAR}hB

  0356c	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [ebx+156]
  03572	89 83 0c 02 00
	00		 mov	 DWORD PTR [ebx+524], eax

; 916  : 		offset_repeat_a_b = 0;
; 917  : 
; 918  : 		Reset_opt();

  03578	8b c3		 mov	 eax, ebx
  0357a	89 b3 10 02 00
	00		 mov	 DWORD PTR [ebx+528], esi
  03580	e8 00 00 00 00	 call	 ?Reset_opt@MusicTrack@@QAEXXZ ; MusicTrack::Reset_opt

; 919  : 	}
; 920  : 		
; 921  : 	//s[g^CvL
; 922  : 	repeat_type.push_back(1);

  03585	8d 83 20 02 00
	00		 lea	 eax, DWORD PTR [ebx+544]
  0358b	8d 75 ec	 lea	 esi, DWORD PTR $T107208[ebp]
  0358e	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR $T107208[ebp], 1
  03595	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 923  : 	it_repeat_type	=	repeat_type.end();

  0359a	8b 8b 28 02 00
	00		 mov	 ecx, DWORD PTR [ebx+552]
  035a0	8d 83 30 02 00
	00		 lea	 eax, DWORD PTR [ebx+560]
  035a6	89 08		 mov	 DWORD PTR [eax], ecx

; 924  : 	it_repeat_type--;
; 925  : }

  035a8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  035ab	83 00 fc	 add	 DWORD PTR [eax], -4	; fffffffcH
  035ae	5f		 pop	 edi
  035af	5e		 pop	 esi
  035b0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  035b7	c9		 leave
  035b8	c3		 ret	 0
$L107241:
$L107211:
  00ae3	ff 75 ec	 push	 DWORD PTR $T107205[ebp]
  00ae6	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00aeb	59		 pop	 ecx
  00aec	c3		 ret	 0
__ehhandler$?SetRepeat_A_Start@MusicTrack@@QAEXPAVMMLfile@@@Z:
  00aed	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T107239
  00af2	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetRepeat_A_Start@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP	; MusicTrack::SetRepeat_A_Start
PUBLIC	?SetRepeat_Start@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetRepeat_Start
; Function compile flags: /Ogsy
_TEXT	SEGMENT
?SetRepeat_Start@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR ; MusicTrack::SetRepeat_Start
; _this$ = eax
; _MML$ = ecx

; 878  : {

  035b9	53		 push	 ebx
  035ba	8b d8		 mov	 ebx, eax

; 879  : 	if(offset_repeat_a_s == 0){

  035bc	83 bb 0c 02 00
	00 00		 cmp	 DWORD PTR [ebx+524], 0
  035c3	75 07		 jne	 SHORT $L24766

; 880  : 		SetRepeat_A_Start(MML);

  035c5	e8 00 00 00 00	 call	 ?SetRepeat_A_Start@MusicTrack@@QAEXPAVMMLfile@@@Z ; MusicTrack::SetRepeat_A_Start
  035ca	5b		 pop	 ebx

; 883  : 	}
; 884  : }

  035cb	c3		 ret	 0
$L24766:

; 881  : 	} else {
; 882  : 		SetRepeat_C_Start(MML);

  035cc	51		 push	 ecx
  035cd	e8 00 00 00 00	 call	 ?SetRepeat_C_Start@MusicTrack@@QAEXPAVMMLfile@@@Z ; MusicTrack::SetRepeat_C_Start
  035d2	5b		 pop	 ebx

; 883  : 	}
; 884  : }

  035d3	c3		 ret	 0
?SetRepeat_Start@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP	; MusicTrack::SetRepeat_Start
PUBLIC	?GenerateEcho@MusicTrack@@QAEXPAVMMLfile@@HH_N@Z ; MusicTrack::GenerateEcho
$T109534 DD	0ffffffffH
	DD	FLAT:$L109520
	DD	0ffffffffH
	DD	FLAT:$L109521
	DD	0ffffffffH
	DD	FLAT:$L109522
	DD	0ffffffffH
	DD	FLAT:$L109523
$T109525 DD	019930520H
	DD	04H
	DD	FLAT:$T109534
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
tv274 = -24						; size = 4
tv357 = -20						; size = 4
_old_note$ = -16					; size = 1
__$EHRec$ = -12						; size = 12
$T109517 = 8						; size = 4
$T109513 = 8						; size = 4
$T109509 = 8						; size = 4
$T109505 = 8						; size = 4
_MML$ = 8						; size = 4
_Length$ = 12						; size = 4
_GateTime$ = 16						; size = 4
_Slur$ = 20						; size = 1
?GenerateEcho@MusicTrack@@QAEXPAVMMLfile@@HH_N@Z PROC NEAR ; MusicTrack::GenerateEcho
; _this$ = esi

; 2833 : {

  035d4	b8 00 00 00 00	 mov	 eax, __ehhandler$?GenerateEcho@MusicTrack@@QAEXPAVMMLfile@@HH_N@Z
  035d9	e8 00 00 00 00	 call	 __EH_prolog
  035de	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2834 : 	char	old_note = oldNote[(pt_oldNote - echo_value) & 0xFF];

  035e1	33 c0		 xor	 eax, eax
  035e3	8a 86 e2 01 00
	00		 mov	 al, BYTE PTR [esi+482]
  035e9	33 c9		 xor	 ecx, ecx
  035eb	8a 8e e1 00 00
	00		 mov	 cl, BYTE PTR [esi+225]
  035f1	53		 push	 ebx

; 2835 : //	char	now_note = oldNote[pt_oldNote];
; 2836 : 
; 2837 : 	char	now_octave = nsd.octave;
; 2838 : 	char	old_octave = (old_note / 12);

  035f2	6a 0c		 push	 12			; 0000000cH
  035f4	8a 5e 4c	 mov	 bl, BYTE PTR [esi+76]
  035f7	2b c1		 sub	 eax, ecx
  035f9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  035fe	8a 84 30 e2 00
	00 00		 mov	 al, BYTE PTR [eax+esi+226]
  03605	88 45 f0	 mov	 BYTE PTR _old_note$[ebp], al
  03608	0f be c0	 movsx	 eax, al
  0360b	59		 pop	 ecx
  0360c	99		 cdq
  0360d	f7 f9		 idiv	 ecx

; 2839 : 
; 2840 : //	int		i = 0;
; 2841 : 
; 2842 : 	CallPatch(MML, old_note);

  0360f	ff 75 f0	 push	 DWORD PTR _old_note$[ebp]
  03612	ff 75 08	 push	 DWORD PTR _MML$[ebp]
  03615	56		 push	 esi
  03616	89 55 e8	 mov	 DWORD PTR tv274[ebp], edx
  03619	89 45 ec	 mov	 DWORD PTR tv357[ebp], eax
  0361c	e8 00 00 00 00	 call	 ?CallPatch@MusicTrack@@QAEXPAVMMLfile@@D@Z ; MusicTrack::CallPatch

; 2843 : 
; 2844 : 	if(echo_slur == false){

  03621	80 be db 00 00
	00 00		 cmp	 BYTE PTR [esi+219], 0
  03628	75 43		 jne	 SHORT $L25843

; 2845 : 		//Echo volume
; 2846 : 		SetEvent(new mml_general(nsd_Volume + echo_volume, _T("Echo Volume")));

  0362a	6a 3c		 push	 60			; 0000003cH
  0362c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03631	59		 pop	 ecx
  03632	89 45 08	 mov	 DWORD PTR $T109505[ebp], eax
  03635	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  03639	85 c0		 test	 eax, eax
  0363b	74 19		 je	 SHORT $L109506
  0363d	33 c9		 xor	 ecx, ecx
  0363f	8a 8e e0 00 00
	00		 mov	 cl, BYTE PTR [esi+224]
  03645	80 c1 60	 add	 cl, 96			; 00000060H
  03648	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BI@EPMKAKFB@?$AAE?$AAc?$AAh?$AAo?$AA?5?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$AA@
  0364d	51		 push	 ecx
  0364e	50		 push	 eax
  0364f	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  03654	eb 02		 jmp	 SHORT $L109507
$L109506:
  03656	33 c0		 xor	 eax, eax
$L109507:
  03658	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0365c	50		 push	 eax
  0365d	8b c6		 mov	 eax, esi
  0365f	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 2847 : 		echo_vol_ret = true;

  03664	c6 86 d9 00 00
	00 01		 mov	 BYTE PTR [esi+217], 1

; 2848 : 	} else {

  0366b	eb 14		 jmp	 SHORT $L109530
$L25843:

; 2849 : 		//Om[gA
; 2850 : 		if(echo_already == false){

  0366d	80 be d8 00 00
	00 00		 cmp	 BYTE PTR [esi+216], 0
  03674	75 0b		 jne	 SHORT $L109530

; 2851 : 			_old_note->SetTai();

  03676	8b 86 c4 00 00
	00		 mov	 eax, DWORD PTR [esi+196]
  0367c	e8 00 00 00 00	 call	 ?SetTai@mml_note@@QAEXXZ ; mml_note::SetTai
$L109530:

; 2852 : 		}
; 2853 : 	}
; 2854 : 
; 2855 : 	//Echo note
; 2856 : 	if(old_octave < now_octave){

  03681	8a 45 ec	 mov	 al, BYTE PTR tv357[ebp]
  03684	3a c3		 cmp	 al, bl
  03686	7d 3d		 jge	 SHORT $L109533
  03688	2a d8		 sub	 bl, al
  0368a	0f b6 db	 movzx	 ebx, bl
$L25853:

; 2857 : 		while(old_octave < now_octave){
; 2858 : 			old_octave++;
; 2859 : 			SetEvent(new mml_general(nsd_Octave_Down_1, _T("One time octave down")));

  0368d	6a 3c		 push	 60			; 0000003cH
  0368f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03694	59		 pop	 ecx
  03695	89 45 08	 mov	 DWORD PTR $T109509[ebp], eax
  03698	85 c0		 test	 eax, eax
  0369a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  036a1	74 0f		 je	 SHORT $L109510
  036a3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CK@JCJILIHF@?$AAO?$AAn?$AAe?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?5?$AAo?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAd?$AAo?$AAw?$AAn@
  036a8	6a 2c		 push	 44			; 0000002cH
  036aa	50		 push	 eax
  036ab	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  036b0	eb 02		 jmp	 SHORT $L109511
$L109510:
  036b2	33 c0		 xor	 eax, eax
$L109511:
  036b4	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  036b8	50		 push	 eax
  036b9	8b c6		 mov	 eax, esi
  036bb	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent
  036c0	4b		 dec	 ebx
  036c1	75 ca		 jne	 SHORT $L25853

; 2860 : 		}
; 2861 : 	} else if(old_octave > now_octave){

  036c3	eb 3d		 jmp	 SHORT $L25864
$L109533:
  036c5	7e 3b		 jle	 SHORT $L25864
  036c7	2a c3		 sub	 al, bl
  036c9	0f b6 d8	 movzx	 ebx, al
$L25863:

; 2862 : 		while(old_octave > now_octave){
; 2863 : 			old_octave--;
; 2864 : 			SetEvent(new mml_general(nsd_Octave_Up_1, _T("One time octave up")));

  036cc	6a 3c		 push	 60			; 0000003cH
  036ce	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  036d3	59		 pop	 ecx
  036d4	89 45 08	 mov	 DWORD PTR $T109513[ebp], eax
  036d7	85 c0		 test	 eax, eax
  036d9	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  036e0	74 0f		 je	 SHORT $L109514
  036e2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CG@IKGHOBJA@?$AAO?$AAn?$AAe?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?5?$AAo?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAu?$AAp?$AA?$AA@
  036e7	6a 2d		 push	 45			; 0000002dH
  036e9	50		 push	 eax
  036ea	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  036ef	eb 02		 jmp	 SHORT $L109515
$L109514:
  036f1	33 c0		 xor	 eax, eax
$L109515:
  036f3	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  036f7	50		 push	 eax
  036f8	8b c6		 mov	 eax, esi
  036fa	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent
  036ff	4b		 dec	 ebx
  03700	75 ca		 jne	 SHORT $L25863
$L25864:

; 2865 : 		}
; 2866 : 	}
; 2867 : 
; 2868 : 	if(Length == opt_DefaultLength){

  03702	8b 45 0c	 mov	 eax, DWORD PTR _Length$[ebp]
  03705	3b 86 a4 00 00
	00		 cmp	 eax, DWORD PTR [esi+164]
  0370b	5b		 pop	 ebx
  0370c	75 04		 jne	 SHORT $L109531

; 2869 : 		Length = -1;

  0370e	83 4d 0c ff	 or	 DWORD PTR _Length$[ebp], -1
$L109531:

; 2870 : 	}
; 2871 : 	_old_note = new mml_note(old_note % 12, Length, GateTime, Slur, _T("Echo Note"));

  03712	6a 3c		 push	 60			; 0000003cH
  03714	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03719	59		 pop	 ecx
  0371a	89 45 08	 mov	 DWORD PTR $T109517[ebp], eax
  0371d	85 c0		 test	 eax, eax
  0371f	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  03726	74 19		 je	 SHORT $L109518
  03728	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@HOMMDOEE@?$AAE?$AAc?$AAh?$AAo?$AA?5?$AAN?$AAo?$AAt?$AAe?$AA?$AA@
  0372d	ff 75 14	 push	 DWORD PTR _Slur$[ebp]
  03730	ff 75 10	 push	 DWORD PTR _GateTime$[ebp]
  03733	ff 75 0c	 push	 DWORD PTR _Length$[ebp]
  03736	ff 75 e8	 push	 DWORD PTR tv274[ebp]
  03739	50		 push	 eax
  0373a	e8 00 00 00 00	 call	 ??0mml_note@@QAE@HHH_NQBG@Z ; mml_note::mml_note
  0373f	eb 02		 jmp	 SHORT $L109519
$L109518:
  03741	33 c0		 xor	 eax, eax
$L109519:
  03743	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  03747	89 86 c4 00 00
	00		 mov	 DWORD PTR [esi+196], eax

; 2872 : 	SetEvent(_old_note);

  0374d	50		 push	 eax
  0374e	8b c6		 mov	 eax, esi
  03750	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 2873 : 
; 2874 : //	EchoVolRet();
; 2875 : 
; 2876 : 	echo_already	= true;
; 2877 : 
; 2878 : }

  03755	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  03758	c6 86 d8 00 00
	00 01		 mov	 BYTE PTR [esi+216], 1
  0375f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  03766	c9		 leave
  03767	c2 10 00	 ret	 16			; 00000010H
$L109520:
  00c3c	ff 75 08	 push	 DWORD PTR $T109505[ebp]
  00c3f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00c44	59		 pop	 ecx
  00c45	c3		 ret	 0
$L109521:
  00c46	ff 75 08	 push	 DWORD PTR $T109509[ebp]
  00c49	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00c4e	59		 pop	 ecx
  00c4f	c3		 ret	 0
$L109522:
  00c50	ff 75 08	 push	 DWORD PTR $T109513[ebp]
  00c53	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00c58	59		 pop	 ecx
  00c59	c3		 ret	 0
$L109523:
  00c5a	ff 75 08	 push	 DWORD PTR $T109517[ebp]
  00c5d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00c62	59		 pop	 ecx
  00c63	c3		 ret	 0
__ehhandler$?GenerateEcho@MusicTrack@@QAEXPAVMMLfile@@HH_N@Z:
  00c64	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T109525
  00c69	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?GenerateEcho@MusicTrack@@QAEXPAVMMLfile@@HH_N@Z ENDP	; MusicTrack::GenerateEcho
PUBLIC	?SetNote@MusicTrack@@QAEXPAVMMLfile@@HHH_N@Z	; MusicTrack::SetNote
$T109571 DD	0ffffffffH
	DD	FLAT:$L109557
	DD	0ffffffffH
	DD	FLAT:$L109558
	DD	0ffffffffH
	DD	FLAT:$L109559
	DD	0ffffffffH
	DD	FLAT:$L109560
$T109562 DD	019930520H
	DD	04H
	DD	FLAT:$T109571
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T109546 = -24						; size = 4
$T109542 = -24						; size = 4
__note_no$ = -20					; size = 1
_Length_0$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
$T109554 = 8						; size = 4
_MML$ = 8						; size = 4
$T109550 = 12						; size = 4
_Length$ = 12						; size = 4
_GateTime$ = 16						; size = 4
_Slur$ = 20						; size = 1
?SetNote@MusicTrack@@QAEXPAVMMLfile@@HHH_N@Z PROC NEAR	; MusicTrack::SetNote
; _this$ = edx
; __key$ = ecx

; 2910 : {

  0376a	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetNote@MusicTrack@@QAEXPAVMMLfile@@HHH_N@Z
  0376f	e8 00 00 00 00	 call	 __EH_prolog
  03774	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2911 : 	int		Length_0	= Length;		//

  03777	8b 45 0c	 mov	 eax, DWORD PTR _Length$[ebp]

; 2912 : 	char	_note_no;
; 2913 : 
; 2914 : 	//
; 2915 : 	if(Length_0 == -1){

  0377a	83 f8 ff	 cmp	 eax, -1
  0377d	53		 push	 ebx
  0377e	56		 push	 esi
  0377f	8b d9		 mov	 ebx, ecx
  03781	8b f2		 mov	 esi, edx
  03783	89 45 f0	 mov	 DWORD PTR _Length_0$[ebp], eax
  03786	75 06		 jne	 SHORT $L25895

; 2916 : 		Length_0 = nsd.length;

  03788	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  0378b	89 45 f0	 mov	 DWORD PTR _Length_0$[ebp], eax
$L25895:

; 2917 : 	}
; 2918 : 
; 2919 : 	//NI^CY
; 2920 : 	if(gatetime_Q != QMax){

  0378e	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  03794	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  0379a	3b d1		 cmp	 edx, ecx
  0379c	74 12		 je	 SHORT $L25896

; 2921 : 		Set_q((Length_0 * (QMax - gatetime_Q)) / QMax);

  0379e	8b c1		 mov	 eax, ecx
  037a0	2b c2		 sub	 eax, edx
  037a2	0f af 45 f0	 imul	 eax, DWORD PTR _Length_0$[ebp]
  037a6	99		 cdq
  037a7	f7 f9		 idiv	 ecx
  037a9	8b c8		 mov	 ecx, eax
  037ab	e8 00 00 00 00	 call	 ?Set_q@MusicTrack@@QAEXH@Z ; MusicTrack::Set_q
$L25896:

; 2922 : 	}
; 2923 : 
; 2924 : 	//
; 2925 : 	_key	+= iKeyShift;
; 2926 : 	_note_no = ((char)_key + (nsd.octave + nsd.octave1)*12) & 0xFF;

  037b0	8a 46 4c	 mov	 al, BYTE PTR [esi+76]
  037b3	02 46 50	 add	 al, BYTE PTR [esi+80]
  037b6	03 9e d4 00 00
	00		 add	 ebx, DWORD PTR [esi+212]
  037bc	b1 0c		 mov	 cl, 12			; 0000000cH
  037be	f6 e9		 imul	 cl
  037c0	02 c3		 add	 al, bl

; 2927 : 
; 2928 : 	//^GR[obt@
; 2929 : 	pt_oldNote++;

  037c2	fe 86 e2 01 00
	00		 inc	 BYTE PTR [esi+482]

; 2930 : 	oldNote[pt_oldNote]	= _note_no;

  037c8	0f b6 8e e2 01
	00 00		 movzx	 ecx, BYTE PTR [esi+482]
  037cf	88 84 31 e2 00
	00 00		 mov	 BYTE PTR [ecx+esi+226], al

; 2931 : 	nsd.octave1			= 0;

  037d6	83 66 50 00	 and	 DWORD PTR [esi+80], 0

; 2932 : 
; 2933 : 	echo_already		= false;
; 2934 : 
; 2935 : 	//B
; 2936 : 	if(echo_flag == true){

  037da	80 be da 00 00
	00 01		 cmp	 BYTE PTR [esi+218], 1
  037e1	88 45 ec	 mov	 BYTE PTR __note_no$[ebp], al
  037e4	c6 86 d8 00 00
	00 00		 mov	 BYTE PTR [esi+216], 0
  037eb	75 05		 jne	 SHORT $L109563

; 2937 : 		EchoVolRet();

  037ed	e8 00 00 00 00	 call	 ?EchoVolRet@MusicTrack@@QAEXXZ ; MusicTrack::EchoVolRet
$L109563:

; 2938 : 	}
; 2939 : 
; 2940 : 	//wB
; 2941 : 	while(_key < 0){

  037f2	85 db		 test	 ebx, ebx
  037f4	57		 push	 edi
  037f5	7d 48		 jge	 SHORT $L109564
  037f7	83 c8 ff	 or	 eax, -1
  037fa	2b c3		 sub	 eax, ebx
  037fc	6a 0c		 push	 12			; 0000000cH
  037fe	33 d2		 xor	 edx, edx
  03800	59		 pop	 ecx
  03801	f7 f1		 div	 ecx
  03803	8b f8		 mov	 edi, eax
  03805	47		 inc	 edi
  03806	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  03809	8d 1c 83	 lea	 ebx, DWORD PTR [ebx+eax*4]
$L25900:

; 2942 : 		_key += 12;
; 2943 : 		SetEvent(new mml_general(nsd_Octave_Down_1, _T("One time octave down")));

  0380c	6a 3c		 push	 60			; 0000003cH
  0380e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03813	59		 pop	 ecx
  03814	89 45 e8	 mov	 DWORD PTR $T109542[ebp], eax
  03817	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0381b	85 c0		 test	 eax, eax
  0381d	74 0f		 je	 SHORT $L109543
  0381f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CK@JCJILIHF@?$AAO?$AAn?$AAe?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?5?$AAo?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAd?$AAo?$AAw?$AAn@
  03824	6a 2c		 push	 44			; 0000002cH
  03826	50		 push	 eax
  03827	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  0382c	eb 02		 jmp	 SHORT $L109544
$L109543:
  0382e	33 c0		 xor	 eax, eax
$L109544:
  03830	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  03834	50		 push	 eax
  03835	8b c6		 mov	 eax, esi
  03837	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent
  0383c	4f		 dec	 edi
  0383d	75 cd		 jne	 SHORT $L25900
$L109564:

; 2944 : 	}
; 2945 : 
; 2946 : 	while(_key >= 12){

  0383f	83 fb 0c	 cmp	 ebx, 12			; 0000000cH
  03842	7c 46		 jl	 SHORT $L109567
  03844	6a 0c		 push	 12			; 0000000cH
  03846	8b c3		 mov	 eax, ebx
  03848	33 d2		 xor	 edx, edx
  0384a	59		 pop	 ecx
  0384b	f7 f1		 div	 ecx
  0384d	8b f8		 mov	 edi, eax
  0384f	6b c0 f4	 imul	 eax, -12		; fffffff4H
  03852	03 d8		 add	 ebx, eax
$L25907:

; 2947 : 		_key -= 12;
; 2948 : 		SetEvent(new mml_general(nsd_Octave_Up_1, _T("One time octave up")));

  03854	6a 3c		 push	 60			; 0000003cH
  03856	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0385b	59		 pop	 ecx
  0385c	89 45 e8	 mov	 DWORD PTR $T109546[ebp], eax
  0385f	85 c0		 test	 eax, eax
  03861	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  03868	74 0f		 je	 SHORT $L109547
  0386a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CG@IKGHOBJA@?$AAO?$AAn?$AAe?$AA?5?$AAt?$AAi?$AAm?$AAe?$AA?5?$AAo?$AAc?$AAt?$AAa?$AAv?$AAe?$AA?5?$AAu?$AAp?$AA?$AA@
  0386f	6a 2d		 push	 45			; 0000002dH
  03871	50		 push	 eax
  03872	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  03877	eb 02		 jmp	 SHORT $L109548
$L109547:
  03879	33 c0		 xor	 eax, eax
$L109548:
  0387b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0387f	50		 push	 eax
  03880	8b c6		 mov	 eax, esi
  03882	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent
  03887	4f		 dec	 edi
  03888	75 ca		 jne	 SHORT $L25907
$L109567:

; 2949 : 	}
; 2950 : 
; 2951 : 	CallPatch(MML, _note_no);

  0388a	ff 75 ec	 push	 DWORD PTR __note_no$[ebp]
  0388d	ff 75 08	 push	 DWORD PTR _MML$[ebp]
  03890	56		 push	 esi
  03891	e8 00 00 00 00	 call	 ?CallPatch@MusicTrack@@QAEXPAVMMLfile@@D@Z ; MusicTrack::CallPatch

; 2952 : 
; 2953 : 	if((echo_flag == true) && (oldNote[(pt_oldNote - echo_value) & 0xFF] != -1) && (echo_length != -1) && (Length_0 > echo_length) && (Slur == false)){

  03896	80 be da 00 00
	00 01		 cmp	 BYTE PTR [esi+218], 1
  0389d	5f		 pop	 edi
  0389e	0f 85 9f 00 00
	00		 jne	 $L109568
  038a4	33 c9		 xor	 ecx, ecx
  038a6	8a 8e e2 01 00
	00		 mov	 cl, BYTE PTR [esi+482]
  038ac	33 c0		 xor	 eax, eax
  038ae	8a 86 e1 00 00
	00		 mov	 al, BYTE PTR [esi+225]
  038b4	2b c8		 sub	 ecx, eax
  038b6	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  038bc	80 bc 31 e2 00
	00 00 ff	 cmp	 BYTE PTR [ecx+esi+226], -1
  038c4	74 7d		 je	 SHORT $L109568
  038c6	8b 86 dc 00 00
	00		 mov	 eax, DWORD PTR [esi+220]
  038cc	83 f8 ff	 cmp	 eax, -1
  038cf	74 72		 je	 SHORT $L109568
  038d1	39 45 f0	 cmp	 DWORD PTR _Length_0$[ebp], eax
  038d4	7e 6d		 jle	 SHORT $L109568
  038d6	80 7d 14 00	 cmp	 BYTE PTR _Slur$[ebp], 0
  038da	75 67		 jne	 SHORT $L109568

; 2954 : 		//^GR[ 
; 2955 : 
; 2956 : 		Length_0 -= echo_length;

  038dc	29 45 f0	 sub	 DWORD PTR _Length_0$[ebp], eax

; 2957 : 		if(Length_0 == opt_DefaultLength){

  038df	8b 45 f0	 mov	 eax, DWORD PTR _Length_0$[ebp]
  038e2	3b 86 a4 00 00
	00		 cmp	 eax, DWORD PTR [esi+164]
  038e8	75 04		 jne	 SHORT $L25914

; 2958 : 			Length_0 = -1;

  038ea	83 4d f0 ff	 or	 DWORD PTR _Length_0$[ebp], -1
$L25914:

; 2959 : 		}
; 2960 : 
; 2961 : 		_old_note = new mml_note(_key, Length_0, GateTime, Slur, _T("Note"));

  038ee	6a 3c		 push	 60			; 0000003cH
  038f0	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  038f5	59		 pop	 ecx
  038f6	89 45 0c	 mov	 DWORD PTR $T109550[ebp], eax
  038f9	85 c0		 test	 eax, eax
  038fb	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  03902	74 16		 je	 SHORT $L109551
  03904	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_19JIGFKGL@?$AAN?$AAo?$AAt?$AAe?$AA?$AA@
  03909	6a 00		 push	 0
  0390b	ff 75 10	 push	 DWORD PTR _GateTime$[ebp]
  0390e	ff 75 f0	 push	 DWORD PTR _Length_0$[ebp]
  03911	53		 push	 ebx
  03912	50		 push	 eax
  03913	e8 00 00 00 00	 call	 ??0mml_note@@QAE@HHH_NQBG@Z ; mml_note::mml_note
  03918	eb 02		 jmp	 SHORT $L109552
$L109551:
  0391a	33 c0		 xor	 eax, eax
$L109552:
  0391c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  03920	89 86 c4 00 00
	00		 mov	 DWORD PTR [esi+196], eax

; 2962 : 
; 2963 : 		//CxgIuWFNg
; 2964 : 		SetEvent(_old_note);

  03926	50		 push	 eax
  03927	8b c6		 mov	 eax, esi
  03929	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 2965 : 
; 2966 : 		GenerateEcho(MML,echo_length,GateTime,Slur);

  0392e	6a 00		 push	 0
  03930	ff 75 10	 push	 DWORD PTR _GateTime$[ebp]
  03933	ff b6 dc 00 00
	00		 push	 DWORD PTR [esi+220]
  03939	ff 75 08	 push	 DWORD PTR _MML$[ebp]
  0393c	e8 00 00 00 00	 call	 ?GenerateEcho@MusicTrack@@QAEXPAVMMLfile@@HH_N@Z ; MusicTrack::GenerateEcho

; 2967 : 	} else {

  03941	eb 50		 jmp	 SHORT $L25920
$L109568:

; 2968 : 		if(Length == opt_DefaultLength){

  03943	8b 45 0c	 mov	 eax, DWORD PTR _Length$[ebp]
  03946	3b 86 a4 00 00
	00		 cmp	 eax, DWORD PTR [esi+164]
  0394c	75 04		 jne	 SHORT $L109569

; 2969 : 			Length = -1;

  0394e	83 4d 0c ff	 or	 DWORD PTR _Length$[ebp], -1
$L109569:

; 2970 : 		}
; 2971 : 		//^GR[ 
; 2972 : 		_old_note = new mml_note(_key, Length, GateTime, Slur, _T("Note"));

  03952	6a 3c		 push	 60			; 0000003cH
  03954	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03959	59		 pop	 ecx
  0395a	89 45 08	 mov	 DWORD PTR $T109554[ebp], eax
  0395d	85 c0		 test	 eax, eax
  0395f	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  03966	74 17		 je	 SHORT $L109555
  03968	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_19JIGFKGL@?$AAN?$AAo?$AAt?$AAe?$AA?$AA@
  0396d	ff 75 14	 push	 DWORD PTR _Slur$[ebp]
  03970	ff 75 10	 push	 DWORD PTR _GateTime$[ebp]
  03973	ff 75 0c	 push	 DWORD PTR _Length$[ebp]
  03976	53		 push	 ebx
  03977	50		 push	 eax
  03978	e8 00 00 00 00	 call	 ??0mml_note@@QAE@HHH_NQBG@Z ; mml_note::mml_note
  0397d	eb 02		 jmp	 SHORT $L109556
$L109555:
  0397f	33 c0		 xor	 eax, eax
$L109556:
  03981	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  03985	89 86 c4 00 00
	00		 mov	 DWORD PTR [esi+196], eax

; 2973 : 
; 2974 : 		//CxgIuWFNg
; 2975 : 		SetEvent(_old_note);

  0398b	50		 push	 eax
  0398c	8b c6		 mov	 eax, esi
  0398e	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent
$L25920:

; 2976 : 
; 2977 : 	}
; 2978 : }

  03993	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  03996	5e		 pop	 esi
  03997	5b		 pop	 ebx
  03998	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0399f	c9		 leave
  039a0	c2 10 00	 ret	 16			; 00000010H
$L109557:
  00c6e	ff 75 e8	 push	 DWORD PTR $T109542[ebp]
  00c71	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00c76	59		 pop	 ecx
  00c77	c3		 ret	 0
$L109558:
  00c78	ff 75 e8	 push	 DWORD PTR $T109546[ebp]
  00c7b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00c80	59		 pop	 ecx
  00c81	c3		 ret	 0
$L109559:
  00c82	ff 75 0c	 push	 DWORD PTR $T109550[ebp]
  00c85	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00c8a	59		 pop	 ecx
  00c8b	c3		 ret	 0
$L109560:
  00c8c	ff 75 08	 push	 DWORD PTR $T109554[ebp]
  00c8f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00c94	59		 pop	 ecx
  00c95	c3		 ret	 0
__ehhandler$?SetNote@MusicTrack@@QAEXPAVMMLfile@@HHH_N@Z:
  00c96	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T109562
  00c9b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetNote@MusicTrack@@QAEXPAVMMLfile@@HHH_N@Z ENDP	; MusicTrack::SetNote
PUBLIC	?SetEcho@MusicTrack@@QAEXPAVMMLfile@@@Z		; MusicTrack::SetEcho
; Function compile flags: /Ogsy
_TEXT	SEGMENT
?SetEcho@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetEcho
; _this$ = ecx
; _MML$ = eax

; 2719 : {

  039a3	53		 push	 ebx
  039a4	56		 push	 esi
  039a5	57		 push	 edi
  039a6	8b f1		 mov	 esi, ecx
  039a8	8b f8		 mov	 edi, eax

; 2720 : 	unsigned	char	cData;
; 2721 : 				int		_value;
; 2722 : 				int		_volume;
; 2723 : 
; 2724 : 	//B
; 2725 : 	EchoVolRet();

  039aa	e8 00 00 00 00	 call	 ?EchoVolRet@MusicTrack@@QAEXXZ ; MusicTrack::EchoVolRet

; 2726 : 
; 2727 : 	_value = MML->GetInt();

  039af	8b c7		 mov	 eax, edi
  039b1	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt
  039b6	8b d8		 mov	 ebx, eax

; 2728 : 	if((_value<0) || (_value>255)){

  039b8	85 db		 test	 ebx, ebx
  039ba	0f 8c 83 00 00
	00		 jl	 $L25797
  039c0	81 fb ff 00 00
	00		 cmp	 ebx, 255		; 000000ffH
  039c6	7f 7b		 jg	 SHORT $L25797

; 2730 : 	}
; 2731 : 
; 2732 : 	cData = MML->GetChar();

  039c8	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 2733 : 	if(cData != ','){

  039cd	3c 2c		 cmp	 al, 44			; 0000002cH

; 2734 : 		MML->Err(_T("EC R}hp[^BQwB"));

  039cf	8b c7		 mov	 eax, edi
  039d1	74 07		 je	 SHORT $L25799
  039d3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1EA@ECJHFDDN@?$AAE?$AAC?$AA?50?$LD0?$NO0?s0?I0n0?Q0?i0?a0?$PM0?$LP0L?$IN?$LD0?$IK0?$HO0?$FL0?$JD0?$AC@
  039d8	eb 70		 jmp	 SHORT $L109575
$L25799:

; 2735 : 	}
; 2736 : 
; 2737 : 	_volume = MML->GetInt();

  039da	e8 00 00 00 00	 call	 ?GetInt@MMLfile@@QAEHXZ	; MMLfile::GetInt

; 2738 : 	if((_volume<-1) || (_volume>15)){

  039df	83 f8 ff	 cmp	 eax, -1
  039e2	7c 58		 jl	 SHORT $L25802
  039e4	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  039e7	7f 53		 jg	 SHORT $L25802

; 2740 : 	}
; 2741 : 
; 2742 : 	echo_flag = true;
; 2743 : 	echo_value	= (unsigned char)_value;
; 2744 : 	if(_volume == -1){

  039e9	83 f8 ff	 cmp	 eax, -1
  039ec	c6 86 da 00 00
	00 01		 mov	 BYTE PTR [esi+218], 1
  039f3	88 9e e1 00 00
	00		 mov	 BYTE PTR [esi+225], bl
  039f9	75 09		 jne	 SHORT $L25805

; 2745 : 		echo_slur = true;

  039fb	c6 86 db 00 00
	00 01		 mov	 BYTE PTR [esi+219], 1

; 2746 : 	} else {

  03a02	eb 0d		 jmp	 SHORT $L25806
$L25805:

; 2747 : 		echo_slur = false;

  03a04	c6 86 db 00 00
	00 00		 mov	 BYTE PTR [esi+219], 0

; 2748 : 		echo_volume	= (unsigned char)_volume;

  03a0b	88 86 e0 00 00
	00		 mov	 BYTE PTR [esi+224], al
$L25806:

; 2749 : 	}
; 2750 : 
; 2751 : 	cData = MML->GetChar();

  03a11	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 2752 : 	if(cData != ','){

  03a16	3c 2c		 cmp	 al, 44			; 0000002cH

; 2753 : 		MML->Back();

  03a18	8b c7		 mov	 eax, edi
  03a1a	74 10		 je	 SHORT $L25808
  03a1c	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back

; 2754 : 		echo_length = -1;

  03a21	83 8e dc 00 00
	00 ff		 or	 DWORD PTR [esi+220], -1
$L25792:
  03a28	5f		 pop	 edi
  03a29	5e		 pop	 esi
  03a2a	5b		 pop	 ebx

; 2755 : 	} else {
; 2756 : 		echo_length	= MML->GetLength(nsd.length);
; 2757 : 	}
; 2758 : }

  03a2b	c3		 ret	 0
$L25808:
  03a2c	ff 76 40	 push	 DWORD PTR [esi+64]
  03a2f	e8 00 00 00 00	 call	 ?GetLength@MMLfile@@QAEHH@Z ; MMLfile::GetLength
  03a34	89 86 dc 00 00
	00		 mov	 DWORD PTR [esi+220], eax
  03a3a	eb ec		 jmp	 SHORT $L25792
$L25802:

; 2739 : 		MML->Err(_T("ECR}hQp[^-1`15wB"));

  03a3c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1EE@OOLANPID@?$AAE?$AAC0?$LD0?$NO0?s0?I0n?$HL?0?$PP?$BC0?Q0?i0?a0?$PM0?$LP0o?$AA?9?$AA1?$PP?$FO?$AA1?$AA5@
  03a41	eb 05		 jmp	 SHORT $L109574
$L25797:

; 2729 : 		MML->Err(_T("ECR}hPp[^0`255wB"));

  03a43	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1EE@FMLCMNNO@?$AAE?$AAC0?$LD0?$NO0?s0?I0n?$HL?0?$PP?$BB0?Q0?i0?a0?$PM0?$LP0o?$AA0?$PP?$FO?$AA2?$AA5?$AA5@
$L109574:
  03a48	8b c7		 mov	 eax, edi
$L109575:
  03a4a	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L109576:
$L109573:
  03a4f	cc		 int	 3
?SetEcho@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP		; MusicTrack::SetEcho
_TEXT	ENDS
PUBLIC	?calc_gate@MusicTrack@@QAEHPAVMMLfile@@@Z	; MusicTrack::calc_gate
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_this$ = 8						; size = 4
?calc_gate@MusicTrack@@QAEHPAVMMLfile@@@Z PROC NEAR	; MusicTrack::calc_gate
; _MML$ = eax

; 2652 : {

  03a50	57		 push	 edi
  03a51	8b f8		 mov	 edi, eax

; 2653 : 	unsigned	char	cData = MML->GetChar();

  03a53	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 2654 : 				int		GateTime;
; 2655 : 
; 2656 : 	//Q[g^C
; 2657 : 	if(cData == ','){

  03a58	3c 2c		 cmp	 al, 44			; 0000002cH
  03a5a	75 24		 jne	 SHORT $L25773

; 2658 : 		cData = MML->GetChar();

  03a5c	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 2659 : 		if(cData == '0'){

  03a61	3c 30		 cmp	 al, 48			; 00000030H
  03a63	75 04		 jne	 SHORT $L25774

; 2660 : 			GateTime = 0;

  03a65	33 c0		 xor	 eax, eax

; 2661 : 		} else {

  03a67	eb 21		 jmp	 SHORT $L25776
$L25774:

; 2662 : 			MML->Back();

  03a69	8b c7		 mov	 eax, edi
  03a6b	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back

; 2663 : 			GateTime = MML->GetLength(nsd.length);

  03a70	8b 44 24 08	 mov	 eax, DWORD PTR _this$[esp]
  03a74	ff 70 40	 push	 DWORD PTR [eax+64]
  03a77	8b c7		 mov	 eax, edi
  03a79	e8 00 00 00 00	 call	 ?GetLength@MMLfile@@QAEHH@Z ; MMLfile::GetLength

; 2664 : 		}
; 2665 : 	} else {

  03a7e	eb 0a		 jmp	 SHORT $L25776
$L25773:

; 2666 : 		MML->Back();

  03a80	8b c7		 mov	 eax, edi
  03a82	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back

; 2667 : 		GateTime = -1;

  03a87	83 c8 ff	 or	 eax, -1
$L25776:
  03a8a	5f		 pop	 edi

; 2668 : 	}
; 2669 : 	return(GateTime);
; 2670 : }

  03a8b	c2 04 00	 ret	 4
?calc_gate@MusicTrack@@QAEHPAVMMLfile@@@Z ENDP		; MusicTrack::calc_gate
_TEXT	ENDS
PUBLIC	?calc_length@MusicTrack@@QAEHPAVMMLfile@@@Z	; MusicTrack::calc_length
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_this$ = 8						; size = 4
?calc_length@MusicTrack@@QAEHPAVMMLfile@@@Z PROC NEAR	; MusicTrack::calc_length
; _MML$ = eax

; 2630 : {

  03a8e	53		 push	 ebx
  03a8f	57		 push	 edi
  03a90	8b f8		 mov	 edi, eax

; 2631 : 	unsigned	char	cData = MML->GetChar();

  03a92	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar
  03a97	8a d8		 mov	 bl, al

; 2632 : 				int		Length;
; 2633 : 
; 2634 : 	MML->Back();

  03a99	8b c7		 mov	 eax, edi
  03a9b	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back

; 2635 : 	if(((cData >= '0') && (cData <= '9')) || (cData == '%') || (cData == '.') || (cData == '~') || ((MML->iTieMode == 1) && (cData == '^'))){

  03aa0	80 fb 30	 cmp	 bl, 48			; 00000030H
  03aa3	72 05		 jb	 SHORT $L25765
  03aa5	80 fb 39	 cmp	 bl, 57			; 00000039H
  03aa8	76 22		 jbe	 SHORT $L25764
$L25765:
  03aaa	80 fb 25	 cmp	 bl, 37			; 00000025H
  03aad	74 1d		 je	 SHORT $L25764
  03aaf	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  03ab2	74 18		 je	 SHORT $L25764
  03ab4	80 fb 7e	 cmp	 bl, 126			; 0000007eH
  03ab7	74 13		 je	 SHORT $L25764
  03ab9	83 bf 8c 00 00
	00 01		 cmp	 DWORD PTR [edi+140], 1
  03ac0	75 05		 jne	 SHORT $L25763
  03ac2	80 fb 5e	 cmp	 bl, 94			; 0000005eH
  03ac5	74 05		 je	 SHORT $L25764
$L25763:

; 2637 : 	} else {
; 2638 : 		Length = -1;

  03ac7	83 c8 ff	 or	 eax, -1
  03aca	eb 0e		 jmp	 SHORT $L25766
$L25764:

; 2636 : 		Length = MML->GetLength(nsd.length);

  03acc	8b 44 24 0c	 mov	 eax, DWORD PTR _this$[esp+4]
  03ad0	ff 70 40	 push	 DWORD PTR [eax+64]
  03ad3	8b c7		 mov	 eax, edi
  03ad5	e8 00 00 00 00	 call	 ?GetLength@MMLfile@@QAEHH@Z ; MMLfile::GetLength
$L25766:
  03ada	5f		 pop	 edi
  03adb	5b		 pop	 ebx

; 2639 : 	}
; 2640 : 	return(Length);
; 2641 : }

  03adc	c2 04 00	 ret	 4
?calc_length@MusicTrack@@QAEHPAVMMLfile@@@Z ENDP	; MusicTrack::calc_length
_TEXT	ENDS
PUBLIC	?SetLength@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetLength
	ORG $+4
$T109671 DD	0ffffffffH
	DD	FLAT:$L109650
	DD	0ffffffffH
	DD	FLAT:$L109651
	DD	0ffffffffH
	DD	FLAT:$L109652
	DD	0ffffffffH
	DD	FLAT:$L109653
	DD	0ffffffffH
	DD	FLAT:$L109654
	DD	0ffffffffH
	DD	FLAT:$L109655
	DD	0ffffffffH
	DD	FLAT:$L109656
	DD	0ffffffffH
	DD	FLAT:$L109657
	DD	0ffffffffH
	DD	FLAT:$L109658
	DD	0ffffffffH
	DD	FLAT:$L109659
	DD	0ffffffffH
	DD	FLAT:$L109660
	DD	0ffffffffH
	DD	FLAT:$L109661
	DD	0ffffffffH
	DD	FLAT:$L109662
	DD	0ffffffffH
	DD	FLAT:$L109663
	DD	0ffffffffH
	DD	FLAT:$L109664
	DD	0ffffffffH
	DD	FLAT:$L109665
	DD	0ffffffffH
	DD	FLAT:$L109666
$T109668 DD	019930520H
	DD	011H
	DD	FLAT:$T109671
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T109645 = 8						; size = 4
$T109641 = 8						; size = 4
$T109637 = 8						; size = 4
$T109633 = 8						; size = 4
$T109629 = 8						; size = 4
$T109625 = 8						; size = 4
$T109621 = 8						; size = 4
$T109617 = 8						; size = 4
$T109613 = 8						; size = 4
$T109609 = 8						; size = 4
$T109605 = 8						; size = 4
$T109601 = 8						; size = 4
$T109597 = 8						; size = 4
$T109593 = 8						; size = 4
$T109589 = 8						; size = 4
$T109585 = 8						; size = 4
$T109581 = 8						; size = 4
_MML$ = 8						; size = 4
?SetLength@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetLength
; _this$ = ebx

; 2520 : {

  03adf	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetLength@MusicTrack@@QAEXPAVMMLfile@@@Z
  03ae4	e8 00 00 00 00	 call	 __EH_prolog

; 2521 : 	nsd.length			= MML->GetLength(nsd.length);

  03ae9	ff 73 40	 push	 DWORD PTR [ebx+64]
  03aec	8b 45 08	 mov	 eax, DWORD PTR _MML$[ebp]
  03aef	e8 00 00 00 00	 call	 ?GetLength@MMLfile@@QAEHH@Z ; MMLfile::GetLength

; 2522 : 	opt_DefaultLength	= nsd.length;
; 2523 : 	mml_general*	_event;
; 2524 : 
; 2525 : 	switch(nsd.length){

  03af4	83 f8 18	 cmp	 eax, 24			; 00000018H
  03af7	89 43 40	 mov	 DWORD PTR [ebx+64], eax
  03afa	89 83 a4 00 00
	00		 mov	 DWORD PTR [ebx+164], eax
  03b00	0f 8f ee 01 00
	00		 jg	 $L109648
  03b06	0f 84 c2 01 00
	00		 je	 $L25663
  03b0c	83 f8 08	 cmp	 eax, 8
  03b0f	0f 8f 06 01 00
	00		 jg	 $L109649
  03b15	0f 84 da 00 00
	00		 je	 $L25693
  03b1b	48		 dec	 eax
  03b1c	0f 84 ad 00 00
	00		 je	 $L25723
  03b22	48		 dec	 eax
  03b23	0f 84 80 00 00
	00		 je	 $L25717
  03b29	48		 dec	 eax
  03b2a	74 57		 je	 SHORT $L25711
  03b2c	48		 dec	 eax
  03b2d	74 2e		 je	 SHORT $L25705
  03b2f	48		 dec	 eax
  03b30	48		 dec	 eax
  03b31	0f 85 de 01 00
	00		 jne	 $L25729

; 2558 : 			break;
; 2559 : 		case(6):
; 2560 : 			_event = new mml_general(nsd_Length_6,  _T("Length 6"));

  03b37	6a 3c		 push	 60			; 0000003cH
  03b39	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03b3e	59		 pop	 ecx
  03b3f	89 45 08	 mov	 DWORD PTR $T109625[ebp], eax
  03b42	85 c0		 test	 eax, eax
  03b44	c7 45 fc 0b 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  03b4b	0f 84 98 02 00
	00		 je	 $L109598
  03b51	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BC@EIEEAKMA@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA6?$AA?$AA@
  03b56	6a 4b		 push	 75			; 0000004bH
  03b58	e9 65 02 00 00	 jmp	 $L109670
$L25705:

; 2561 : 			break;
; 2562 : 		case(4):
; 2563 : 			_event = new mml_general(nsd_Length_4,  _T("Length 4"));

  03b5d	6a 3c		 push	 60			; 0000003cH
  03b5f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03b64	59		 pop	 ecx
  03b65	89 45 08	 mov	 DWORD PTR $T109629[ebp], eax
  03b68	85 c0		 test	 eax, eax
  03b6a	c7 45 fc 0c 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  03b71	0f 84 72 02 00
	00		 je	 $L109598
  03b77	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BC@OCENMCEL@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA4?$AA?$AA@
  03b7c	6a 4c		 push	 76			; 0000004cH
  03b7e	e9 3f 02 00 00	 jmp	 $L109670
$L25711:

; 2564 : 			break;
; 2565 : 		case(3):
; 2566 : 			_event = new mml_general(nsd_Length_3,  _T("Length 3"));

  03b83	6a 3c		 push	 60			; 0000003cH
  03b85	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03b8a	59		 pop	 ecx
  03b8b	89 45 08	 mov	 DWORD PTR $T109633[ebp], eax
  03b8e	85 c0		 test	 eax, eax
  03b90	c7 45 fc 0d 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  03b97	0f 84 4c 02 00
	00		 je	 $L109598
  03b9d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BC@HPJKPKPC@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA3?$AA?$AA@
  03ba2	6a 4d		 push	 77			; 0000004dH
  03ba4	e9 19 02 00 00	 jmp	 $L109670
$L25717:

; 2567 : 			break;
; 2568 : 		case(2):
; 2569 : 			_event = new mml_general(nsd_Length_2,  _T("Length 2"));

  03ba9	6a 3c		 push	 60			; 0000003cH
  03bab	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03bb0	59		 pop	 ecx
  03bb1	89 45 08	 mov	 DWORD PTR $T109637[ebp], eax
  03bb4	85 c0		 test	 eax, eax
  03bb6	c7 45 fc 0e 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  03bbd	0f 84 26 02 00
	00		 je	 $L109598
  03bc3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BC@MHCGJNJH@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA2?$AA?$AA@
  03bc8	6a 4e		 push	 78			; 0000004eH
  03bca	e9 f3 01 00 00	 jmp	 $L109670
$L25723:

; 2570 : 			break;
; 2571 : 		case(1):
; 2572 : 			_event = new mml_general(nsd_Length_1,  _T("Length 1"));

  03bcf	6a 3c		 push	 60			; 0000003cH
  03bd1	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03bd6	59		 pop	 ecx
  03bd7	89 45 08	 mov	 DWORD PTR $T109641[ebp], eax
  03bda	85 c0		 test	 eax, eax
  03bdc	c7 45 fc 0f 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  03be3	0f 84 00 02 00
	00		 je	 $L109598
  03be9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BC@NFJDDCHJ@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA1?$AA?$AA@
  03bee	6a 4f		 push	 79			; 0000004fH
  03bf0	e9 cd 01 00 00	 jmp	 $L109670
$L25693:

; 2555 : 			break;
; 2556 : 		case(8):
; 2557 : 			_event = new mml_general(nsd_Length_8,  _T("Length 8"));

  03bf5	6a 3c		 push	 60			; 0000003cH
  03bf7	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03bfc	59		 pop	 ecx
  03bfd	89 45 08	 mov	 DWORD PTR $T109621[ebp], eax
  03c00	85 c0		 test	 eax, eax
  03c02	c7 45 fc 0a 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  03c09	0f 84 da 01 00
	00		 je	 $L109598
  03c0f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BC@KIJLHNPD@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA8?$AA?$AA@
  03c14	6a 4a		 push	 74			; 0000004aH
  03c16	e9 a7 01 00 00	 jmp	 $L109670
$L109649:

; 2522 : 	opt_DefaultLength	= nsd.length;
; 2523 : 	mml_general*	_event;
; 2524 : 
; 2525 : 	switch(nsd.length){

  03c1b	83 e8 09	 sub	 eax, 9
  03c1e	0f 84 84 00 00
	00		 je	 $L25687
  03c24	83 e8 03	 sub	 eax, 3
  03c27	74 59		 je	 SHORT $L25681
  03c29	83 e8 04	 sub	 eax, 4
  03c2c	74 2e		 je	 SHORT $L25675
  03c2e	48		 dec	 eax
  03c2f	48		 dec	 eax
  03c30	0f 85 df 00 00
	00		 jne	 $L25729

; 2543 : 			break;
; 2544 : 		case(18):
; 2545 : 			_event = new mml_general(nsd_Length_18, _T("Length 18"));

  03c36	6a 3c		 push	 60			; 0000003cH
  03c38	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03c3d	59		 pop	 ecx
  03c3e	89 45 08	 mov	 DWORD PTR $T109605[ebp], eax
  03c41	85 c0		 test	 eax, eax
  03c43	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 6
  03c4a	0f 84 99 01 00
	00		 je	 $L109598
  03c50	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@DLFJGOC@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA1?$AA8?$AA?$AA@
  03c55	6a 46		 push	 70			; 00000046H
  03c57	e9 66 01 00 00	 jmp	 $L109670
$L25675:

; 2546 : 			break;
; 2547 : 		case(16):
; 2548 : 			_event = new mml_general(nsd_Length_16, _T("Length 16"));

  03c5c	6a 3c		 push	 60			; 0000003cH
  03c5e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03c63	59		 pop	 ecx
  03c64	89 45 08	 mov	 DWORD PTR $T109609[ebp], eax
  03c67	85 c0		 test	 eax, eax
  03c69	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 7
  03c70	0f 84 73 01 00
	00		 je	 $L109598
  03c76	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@ODGKOBNB@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA1?$AA6?$AA?$AA@
  03c7b	6a 47		 push	 71			; 00000047H
  03c7d	e9 40 01 00 00	 jmp	 $L109670
$L25681:

; 2549 : 			break;
; 2550 : 		case(12):
; 2551 : 			_event = new mml_general(nsd_Length_12, _T("Length 12"));

  03c82	6a 3c		 push	 60			; 0000003cH
  03c84	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03c89	59		 pop	 ecx
  03c8a	89 45 08	 mov	 DWORD PTR $T109613[ebp], eax
  03c8d	85 c0		 test	 eax, eax
  03c8f	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 8
  03c96	0f 84 4d 01 00
	00		 je	 $L109598
  03c9c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@GMAIHGIG@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA1?$AA2?$AA?$AA@
  03ca1	6a 48		 push	 72			; 00000048H
  03ca3	e9 1a 01 00 00	 jmp	 $L109670
$L25687:

; 2552 : 			break;
; 2553 : 		case(9):
; 2554 : 			_event = new mml_general(nsd_Length_9,  _T("Length 9"));

  03ca8	6a 3c		 push	 60			; 0000003cH
  03caa	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03caf	59		 pop	 ecx
  03cb0	89 45 08	 mov	 DWORD PTR $T109617[ebp], eax
  03cb3	85 c0		 test	 eax, eax
  03cb5	c7 45 fc 09 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 9
  03cbc	0f 84 27 01 00
	00		 je	 $L109598
  03cc2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BC@BACHBKJG@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA9?$AA?$AA@
  03cc7	6a 49		 push	 73			; 00000049H
  03cc9	e9 f4 00 00 00	 jmp	 $L109670
$L25663:

; 2540 : 			break;
; 2541 : 		case(24):
; 2542 : 			_event = new mml_general(nsd_Length_24, _T("Length 24"));

  03cce	6a 3c		 push	 60			; 0000003cH
  03cd0	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03cd5	59		 pop	 ecx
  03cd6	89 45 08	 mov	 DWORD PTR $T109601[ebp], eax
  03cd9	85 c0		 test	 eax, eax
  03cdb	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
  03ce2	0f 84 01 01 00
	00		 je	 $L109598
  03ce8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@MPPHFLPE@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA2?$AA4?$AA?$AA@
  03ced	6a 45		 push	 69			; 00000045H
  03cef	e9 ce 00 00 00	 jmp	 $L109670
$L109648:

; 2522 : 	opt_DefaultLength	= nsd.length;
; 2523 : 	mml_general*	_event;
; 2524 : 
; 2525 : 	switch(nsd.length){

  03cf4	83 f8 20	 cmp	 eax, 32			; 00000020H
  03cf7	0f 84 cd 00 00
	00		 je	 $L25657
  03cfd	83 f8 24	 cmp	 eax, 36			; 00000024H
  03d00	0f 84 9f 00 00
	00		 je	 $L25651
  03d06	83 f8 30	 cmp	 eax, 48			; 00000030H
  03d09	74 7b		 je	 SHORT $L25645
  03d0b	83 f8 48	 cmp	 eax, 72			; 00000048H
  03d0e	74 57		 je	 SHORT $L25639
  03d10	83 f8 60	 cmp	 eax, 96			; 00000060H
  03d13	74 32		 je	 SHORT $L25633
$L25729:

; 2573 : 			break;
; 2574 : 		default:
; 2575 : 			_event = new mml_general(nsd_Length, (unsigned char)nsd.length, _T("Length"));

  03d15	6a 3c		 push	 60			; 0000003cH
  03d17	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03d1c	59		 pop	 ecx
  03d1d	89 45 08	 mov	 DWORD PTR $T109645[ebp], eax
  03d20	85 c0		 test	 eax, eax
  03d22	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 16 ; 00000010H
  03d29	0f 84 ba 00 00
	00		 je	 $L109598
  03d2f	33 c9		 xor	 ecx, ecx
  03d31	8a 4b 40	 mov	 cl, BYTE PTR [ebx+64]
  03d34	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1O@IONIPGKG@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$AA@
  03d39	51		 push	 ecx
  03d3a	6a 09		 push	 9
  03d3c	50		 push	 eax
  03d3d	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EDQBG@Z ; mml_general::mml_general
  03d42	e9 a4 00 00 00	 jmp	 $L109599
$L25633:

; 2526 : 		case(96):
; 2527 : 			_event = new mml_general(nsd_Length_96, _T("Length 96"));

  03d47	6a 3c		 push	 60			; 0000003cH
  03d49	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03d4e	59		 pop	 ecx
  03d4f	89 45 08	 mov	 DWORD PTR $T109581[ebp], eax
  03d52	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  03d56	85 c0		 test	 eax, eax
  03d58	0f 84 8b 00 00
	00		 je	 $L109598
  03d5e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@PDJGDLM@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA9?$AA6?$AA?$AA@
  03d63	6a 40		 push	 64			; 00000040H
  03d65	eb 5b		 jmp	 SHORT $L109670
$L25639:

; 2528 : 			break;
; 2529 : 		case(72):
; 2530 : 			_event = new mml_general(nsd_Length_72, _T("Length 72"));

  03d67	6a 3c		 push	 60			; 0000003cH
  03d69	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03d6e	59		 pop	 ecx
  03d6f	89 45 08	 mov	 DWORD PTR $T109585[ebp], eax
  03d72	85 c0		 test	 eax, eax
  03d74	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  03d7b	74 6c		 je	 SHORT $L109598
  03d7d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@LKFBJFJL@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA7?$AA2?$AA?$AA@
  03d82	6a 41		 push	 65			; 00000041H
  03d84	eb 3c		 jmp	 SHORT $L109670
$L25645:

; 2531 : 			break;
; 2532 : 		case(48):
; 2533 : 			_event = new mml_general(nsd_Length_48, _T("Length 48"));

  03d86	6a 3c		 push	 60			; 0000003cH
  03d88	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03d8d	59		 pop	 ecx
  03d8e	89 45 08	 mov	 DWORD PTR $T109589[ebp], eax
  03d91	85 c0		 test	 eax, eax
  03d93	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  03d9a	74 4d		 je	 SHORT $L109598
  03d9c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@FDHIAHFB@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA4?$AA8?$AA?$AA@
  03da1	6a 42		 push	 66			; 00000042H
  03da3	eb 1d		 jmp	 SHORT $L109670
$L25651:

; 2534 : 			break;
; 2535 : 		case(36):
; 2536 : 			_event = new mml_general(nsd_Length_36, _T("Length 36"));

  03da5	6a 3c		 push	 60			; 0000003cH
  03da7	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03dac	59		 pop	 ecx
  03dad	89 45 08	 mov	 DWORD PTR $T109593[ebp], eax
  03db0	85 c0		 test	 eax, eax
  03db2	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  03db9	74 2e		 je	 SHORT $L109598
  03dbb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@KOKCEANK@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA3?$AA6?$AA?$AA@
  03dc0	6a 43		 push	 67			; 00000043H
$L109670:
  03dc2	50		 push	 eax
  03dc3	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EQBG@Z ; mml_general::mml_general
  03dc8	eb 21		 jmp	 SHORT $L109599
$L25657:

; 2537 : 			break;
; 2538 : 		case(32):
; 2539 : 			_event = new mml_general(nsd_Length_32, _T("Length 32"));

  03dca	6a 3c		 push	 60			; 0000003cH
  03dcc	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  03dd1	59		 pop	 ecx
  03dd2	89 45 08	 mov	 DWORD PTR $T109597[ebp], eax
  03dd5	85 c0		 test	 eax, eax
  03dd7	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  03dde	74 09		 je	 SHORT $L109598
  03de0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@CBMANHIN@?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA3?$AA2?$AA?$AA@
  03de5	6a 44		 push	 68			; 00000044H
  03de7	eb d9		 jmp	 SHORT $L109670
$L109598:
  03de9	33 c0		 xor	 eax, eax
$L109599:
  03deb	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 2576 : 			break;
; 2577 : 	}
; 2578 : 	SetEvent(_event);

  03def	50		 push	 eax
  03df0	8b c3		 mov	 eax, ebx
  03df2	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 2579 : }

  03df7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  03dfa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  03e01	c9		 leave
  03e02	c2 04 00	 ret	 4
$L109661:
  00ca0	ff 75 08	 push	 DWORD PTR $T109625[ebp]
  00ca3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00ca8	59		 pop	 ecx
  00ca9	c3		 ret	 0
$L109662:
  00caa	ff 75 08	 push	 DWORD PTR $T109629[ebp]
  00cad	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00cb2	59		 pop	 ecx
  00cb3	c3		 ret	 0
$L109663:
  00cb4	ff 75 08	 push	 DWORD PTR $T109633[ebp]
  00cb7	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00cbc	59		 pop	 ecx
  00cbd	c3		 ret	 0
$L109664:
  00cbe	ff 75 08	 push	 DWORD PTR $T109637[ebp]
  00cc1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00cc6	59		 pop	 ecx
  00cc7	c3		 ret	 0
$L109665:
  00cc8	ff 75 08	 push	 DWORD PTR $T109641[ebp]
  00ccb	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00cd0	59		 pop	 ecx
  00cd1	c3		 ret	 0
$L109660:
  00cd2	ff 75 08	 push	 DWORD PTR $T109621[ebp]
  00cd5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00cda	59		 pop	 ecx
  00cdb	c3		 ret	 0
$L109656:
  00cdc	ff 75 08	 push	 DWORD PTR $T109605[ebp]
  00cdf	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00ce4	59		 pop	 ecx
  00ce5	c3		 ret	 0
$L109657:
  00ce6	ff 75 08	 push	 DWORD PTR $T109609[ebp]
  00ce9	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00cee	59		 pop	 ecx
  00cef	c3		 ret	 0
$L109658:
  00cf0	ff 75 08	 push	 DWORD PTR $T109613[ebp]
  00cf3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00cf8	59		 pop	 ecx
  00cf9	c3		 ret	 0
$L109659:
  00cfa	ff 75 08	 push	 DWORD PTR $T109617[ebp]
  00cfd	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00d02	59		 pop	 ecx
  00d03	c3		 ret	 0
$L109655:
  00d04	ff 75 08	 push	 DWORD PTR $T109601[ebp]
  00d07	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00d0c	59		 pop	 ecx
  00d0d	c3		 ret	 0
$L109666:
  00d0e	ff 75 08	 push	 DWORD PTR $T109645[ebp]
  00d11	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00d16	59		 pop	 ecx
  00d17	c3		 ret	 0
$L109650:
  00d18	ff 75 08	 push	 DWORD PTR $T109581[ebp]
  00d1b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00d20	59		 pop	 ecx
  00d21	c3		 ret	 0
$L109651:
  00d22	ff 75 08	 push	 DWORD PTR $T109585[ebp]
  00d25	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00d2a	59		 pop	 ecx
  00d2b	c3		 ret	 0
$L109652:
  00d2c	ff 75 08	 push	 DWORD PTR $T109589[ebp]
  00d2f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00d34	59		 pop	 ecx
  00d35	c3		 ret	 0
$L109653:
  00d36	ff 75 08	 push	 DWORD PTR $T109593[ebp]
  00d39	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00d3e	59		 pop	 ecx
  00d3f	c3		 ret	 0
$L109654:
  00d40	ff 75 08	 push	 DWORD PTR $T109597[ebp]
  00d43	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00d48	59		 pop	 ecx
  00d49	c3		 ret	 0
__ehhandler$?SetLength@MusicTrack@@QAEXPAVMMLfile@@@Z:
  00d4a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T109668
  00d4f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetLength@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP		; MusicTrack::SetLength
PUBLIC	?SetGatetime_u@MusicTrack@@QAEXPAVMMLfile@@@Z	; MusicTrack::SetGatetime_u
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_this$ = 8						; size = 4
?SetGatetime_u@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetGatetime_u
; _MML$ = eax

; 1825 : {

  03e05	56		 push	 esi
  03e06	57		 push	 edi
  03e07	8b f8		 mov	 edi, eax

; 1826 : 					int		i;
; 1827 : 	unsigned		char	cData;
; 1828 : 
; 1829 : 	cData = MML->GetChar();

  03e09	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 1830 : 	if(cData == '0'){

  03e0e	3c 30		 cmp	 al, 48			; 00000030H
  03e10	75 04		 jne	 SHORT $L25319

; 1831 : 		i = 0;

  03e12	33 c0		 xor	 eax, eax

; 1832 : 	} else {

  03e14	eb 10		 jmp	 SHORT $L25320
$L25319:

; 1833 : 		MML->Back();

  03e16	8b c7		 mov	 eax, edi
  03e18	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back

; 1834 : 		i = MML->GetLength(-1);

  03e1d	6a ff		 push	 -1
  03e1f	8b c7		 mov	 eax, edi
  03e21	e8 00 00 00 00	 call	 ?GetLength@MMLfile@@QAEHH@Z ; MMLfile::GetLength
$L25320:

; 1835 : 	}
; 1836 : 	Set_u(i);

  03e26	8b 7c 24 0c	 mov	 edi, DWORD PTR _this$[esp+4]
  03e2a	8b f0		 mov	 esi, eax
  03e2c	e8 00 00 00 00	 call	 ?Set_u@MusicTrack@@QAEXH@Z ; MusicTrack::Set_u
  03e31	5f		 pop	 edi
  03e32	5e		 pop	 esi

; 1837 : }

  03e33	c2 04 00	 ret	 4
?SetGatetime_u@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP	; MusicTrack::SetGatetime_u
PUBLIC	?SetProtament@MusicTrack@@QAEXPAVMMLfile@@E@Z	; MusicTrack::SetProtament
$T109931 DD	0ffffffffH
	DD	FLAT:$L109907
$T109909 DD	019930520H
	DD	01H
	DD	FLAT:$T109931
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
$T109904 = -40						; size = 4
_iNote$ = -40						; size = 4
__key$ = -36						; size = 4
_Slur$ = -32						; size = 1
_GateTime$ = -28					; size = 4
_Length$ = -24						; size = 4
_o_rel2$ = -20						; size = 4
_o_rel$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_MML$ = 8						; size = 4
tv399 = 12						; size = 4
_pol_rate$ = 12						; size = 4
_iTempo$ = 12						; size = 1
?SetProtament@MusicTrack@@QAEXPAVMMLfile@@E@Z PROC NEAR	; MusicTrack::SetProtament
; _this$ = ebx

; 3138 : {

  03e36	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetProtament@MusicTrack@@QAEXPAVMMLfile@@E@Z
  03e3b	e8 00 00 00 00	 call	 __EH_prolog
  03e40	83 ec 1c	 sub	 esp, 28			; 0000001cH
  03e43	56		 push	 esi
  03e44	57		 push	 edi

; 3139 : 	unsigned	char	cData;
; 3140 : 
; 3141 : 				int		o_rel	= 0;
; 3142 : 				int		o_rel2	= 0;
; 3143 : 
; 3144 : 				int		iNote_2;	//m[gio[
; 3145 : 				int		note_2;		//code
; 3146 : 				int		_key_2;		//
; 3147 : 				int		Length_2;	//
; 3148 : 				int		GateTime_2;	//Q[g^C
; 3149 : 				bool	Slur_2;		//X[
; 3150 : 
; 3151 : 				int		iNote;		//m[gio[
; 3152 : 				int		note;		//code
; 3153 : 				int		_key;		//
; 3154 : 				int		Length;		//
; 3155 : 				int		GateTime;	//Q[g^C
; 3156 : 				bool	Slur;		//X[
; 3157 : 
; 3158 : 	//------
; 3159 : 	//|^g
; 3160 : 	cData = MML->GetChar();

  03e45	8b 7d 08	 mov	 edi, DWORD PTR _MML$[ebp]
  03e48	33 f6		 xor	 esi, esi
  03e4a	89 75 f0	 mov	 DWORD PTR _o_rel$[ebp], esi
  03e4d	89 75 ec	 mov	 DWORD PTR _o_rel2$[ebp], esi
  03e50	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 3161 : 	switch(cData){

  03e55	0f b6 c0	 movzx	 eax, al
  03e58	83 e8 61	 sub	 eax, 97			; 00000061H
  03e5b	74 31		 je	 SHORT $L26030
  03e5d	48		 dec	 eax
  03e5e	74 2a		 je	 SHORT $L26031
  03e60	48		 dec	 eax
  03e61	74 2e		 je	 SHORT $L26022
  03e63	48		 dec	 eax
  03e64	74 1f		 je	 SHORT $L26026
  03e66	48		 dec	 eax
  03e67	74 18		 je	 SHORT $L26027
  03e69	48		 dec	 eax
  03e6a	74 11		 je	 SHORT $L26028
  03e6c	48		 dec	 eax
  03e6d	74 0a		 je	 SHORT $L26029
$L109930:

; 3183 : 		default:
; 3184 : 			MML->Err(_T("a,b,c`gLqB"));

  03e6f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CK@DKBDHLKE@?$AAa?$AA?0?$AAb?$AA?0?$AAc?$PP?$FO?$AAg0n?$JH?sT?$AN0?$JC?$IK?$BI?$IP?p0W0f0O0?$GA0U0D0?$AC@
  03e74	e9 5b 01 00 00	 jmp	 $L109928
$L26029:

; 3174 : 		case('g'):
; 3175 : 			note	= 4;

  03e79	6a 04		 push	 4

; 3176 : 			break;

  03e7b	eb 13		 jmp	 SHORT $L109923
$L26028:

; 3171 : 		case('f'):
; 3172 : 			note	= 3;

  03e7d	6a 03		 push	 3

; 3173 : 			break;

  03e7f	eb 0f		 jmp	 SHORT $L109923
$L26027:

; 3168 : 		case('e'):
; 3169 : 			note	= 2;

  03e81	6a 02		 push	 2

; 3170 : 			break;

  03e83	eb 0b		 jmp	 SHORT $L109923
$L26026:

; 3162 : 		case('c'):
; 3163 : 			note	= 0;
; 3164 : 			break;
; 3165 : 		case('d'):
; 3166 : 			note	= 1;

  03e85	33 f6		 xor	 esi, esi
  03e87	46		 inc	 esi

; 3167 : 			break;

  03e88	eb 07		 jmp	 SHORT $L26022
$L26031:

; 3179 : 			break;
; 3180 : 		case('b'):
; 3181 : 			note	= 6;

  03e8a	6a 06		 push	 6

; 3182 : 			break;

  03e8c	eb 02		 jmp	 SHORT $L109923
$L26030:

; 3177 : 		case('a'):
; 3178 : 			note	= 5;

  03e8e	6a 05		 push	 5
$L109923:
  03e90	5e		 pop	 esi
$L26022:

; 3185 : 			break;
; 3186 : 	}
; 3187 : 
; 3188 : 	_key		= calc_note(MML, note);

  03e91	8b 7d 08	 mov	 edi, DWORD PTR _MML$[ebp]
  03e94	53		 push	 ebx
  03e95	8b c7		 mov	 eax, edi
  03e97	e8 00 00 00 00	 call	 ?calc_note@MusicTrack@@QAEDPAVMMLfile@@H@Z ; MusicTrack::calc_note
  03e9c	0f be c0	 movsx	 eax, al
  03e9f	89 45 dc	 mov	 DWORD PTR __key$[ebp], eax

; 3189 : 	Length		= calc_length(MML);

  03ea2	53		 push	 ebx
  03ea3	8b c7		 mov	 eax, edi
  03ea5	e8 00 00 00 00	 call	 ?calc_length@MusicTrack@@QAEHPAVMMLfile@@@Z ; MusicTrack::calc_length
  03eaa	89 45 e8	 mov	 DWORD PTR _Length$[ebp], eax

; 3190 : 	GateTime	= calc_gate(MML);

  03ead	53		 push	 ebx
  03eae	8b c7		 mov	 eax, edi
  03eb0	e8 00 00 00 00	 call	 ?calc_gate@MusicTrack@@QAEHPAVMMLfile@@@Z ; MusicTrack::calc_gate
  03eb5	89 45 e4	 mov	 DWORD PTR _GateTime$[ebp], eax

; 3191 : 	Slur		= calc_slur(MML);

  03eb8	8b c7		 mov	 eax, edi
  03eba	e8 00 00 00 00	 call	 ?calc_slur@MusicTrack@@QAE_NPAVMMLfile@@@Z ; MusicTrack::calc_slur

; 3192 : 
; 3193 : 	//m[gio[
; 3194 : 	iNote=		((char)_key + (nsd.octave + nsd.octave1)*12) & 0xFF;

  03ebf	8b 4d dc	 mov	 ecx, DWORD PTR __key$[ebp]
  03ec2	88 45 e0	 mov	 BYTE PTR _Slur$[ebp], al
  03ec5	8b 43 4c	 mov	 eax, DWORD PTR [ebx+76]
  03ec8	03 43 50	 add	 eax, DWORD PTR [ebx+80]
  03ecb	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  03ece	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  03ed1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  03ed6	89 45 d8	 mov	 DWORD PTR _iNote$[ebp], eax
$L109924:

; 3195 : 
; 3196 : 	//------
; 3197 : 	//IN^[u
; 3198 : 	cData = MML->GetChar();

  03ed9	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 3199 : 	while((cData == '>') || (cData == '<') || (cData == '`') || (cData == '"')){

  03ede	3c 3e		 cmp	 al, 62			; 0000003eH
  03ee0	74 0c		 je	 SHORT $L26038
  03ee2	3c 3c		 cmp	 al, 60			; 0000003cH
  03ee4	74 08		 je	 SHORT $L26038
  03ee6	3c 60		 cmp	 al, 96			; 00000060H
  03ee8	74 04		 je	 SHORT $L26038
  03eea	3c 22		 cmp	 al, 34			; 00000022H
  03eec	75 2d		 jne	 SHORT $L26037
$L26038:

; 3200 : 		switch(cData){

  03eee	0f b6 c0	 movzx	 eax, al
  03ef1	83 e8 22	 sub	 eax, 34			; 00000022H
  03ef4	74 1d		 je	 SHORT $L26046
  03ef6	83 e8 1a	 sub	 eax, 26			; 0000001aH
  03ef9	74 13		 je	 SHORT $L26043
  03efb	48		 dec	 eax
  03efc	48		 dec	 eax
  03efd	74 0a		 je	 SHORT $L26044
  03eff	83 e8 22	 sub	 eax, 34			; 00000022H
  03f02	75 12		 jne	 SHORT $L26040

; 3207 : 			case('`'):
; 3208 : 				o_rel2++;

  03f04	ff 45 ec	 inc	 DWORD PTR _o_rel2$[ebp]

; 3209 : 				break;

  03f07	eb 0d		 jmp	 SHORT $L26040
$L26044:

; 3204 : 			case('>'):
; 3205 : 				o_rel++;

  03f09	ff 45 f0	 inc	 DWORD PTR _o_rel$[ebp]

; 3206 : 				break;

  03f0c	eb 08		 jmp	 SHORT $L26040
$L26043:

; 3201 : 			case('<'):
; 3202 : 				o_rel--;

  03f0e	ff 4d f0	 dec	 DWORD PTR _o_rel$[ebp]

; 3203 : 				break;

  03f11	eb 03		 jmp	 SHORT $L26040
$L26046:

; 3210 : 			case('"'):
; 3211 : 				o_rel2--;

  03f13	ff 4d ec	 dec	 DWORD PTR _o_rel2$[ebp]
$L26040:

; 3212 : 				break;
; 3213 : 			default:
; 3214 : 				break;
; 3215 : 		}
; 3216 : 		cData = MML->GetChar();	//

  03f16	8b 7d 08	 mov	 edi, DWORD PTR _MML$[ebp]

; 3217 : 	}

  03f19	eb be		 jmp	 SHORT $L109924
$L26037:

; 3218 : 	//LA|C^B
; 3219 : 	MML->Back();

  03f1b	8b 7d 08	 mov	 edi, DWORD PTR _MML$[ebp]
  03f1e	8b c7		 mov	 eax, edi
  03f20	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back

; 3220 : 
; 3221 : 	//------
; 3222 : 	//|^g
; 3223 : 	cData = MML->GetChar();

  03f25	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 3224 : 	switch(cData){

  03f2a	0f b6 c0	 movzx	 eax, al
  03f2d	83 e8 61	 sub	 eax, 97			; 00000061H
  03f30	74 2f		 je	 SHORT $L26057
  03f32	48		 dec	 eax
  03f33	74 28		 je	 SHORT $L26058
  03f35	48		 dec	 eax
  03f36	74 21		 je	 SHORT $L26052
  03f38	48		 dec	 eax
  03f39	74 19		 je	 SHORT $L26053
  03f3b	48		 dec	 eax
  03f3c	74 12		 je	 SHORT $L26054
  03f3e	48		 dec	 eax
  03f3f	74 0b		 je	 SHORT $L26055
  03f41	48		 dec	 eax

; 3246 : 		default:
; 3247 : 			MML->Err(_T("a,b,c`gLqB"));

  03f42	0f 85 27 ff ff
	ff		 jne	 $L109930

; 3237 : 		case('g'):
; 3238 : 			note_2	= 4;

  03f48	6a 04		 push	 4

; 3239 : 			break;

  03f4a	eb 17		 jmp	 SHORT $L109925
$L26055:

; 3234 : 		case('f'):
; 3235 : 			note_2	= 3;

  03f4c	6a 03		 push	 3

; 3236 : 			break;

  03f4e	eb 13		 jmp	 SHORT $L109925
$L26054:

; 3231 : 		case('e'):
; 3232 : 			note_2	= 2;

  03f50	6a 02		 push	 2

; 3233 : 			break;

  03f52	eb 0f		 jmp	 SHORT $L109925
$L26053:

; 3228 : 		case('d'):
; 3229 : 			note_2	= 1;

  03f54	33 f6		 xor	 esi, esi
  03f56	46		 inc	 esi

; 3230 : 			break;

  03f57	eb 0b		 jmp	 SHORT $L26049
$L26052:

; 3225 : 		case('c'):
; 3226 : 			note_2	= 0;

  03f59	33 f6		 xor	 esi, esi

; 3227 : 			break;

  03f5b	eb 07		 jmp	 SHORT $L26049
$L26058:

; 3242 : 			break;
; 3243 : 		case('b'):
; 3244 : 			note_2	= 6;

  03f5d	6a 06		 push	 6

; 3245 : 			break;

  03f5f	eb 02		 jmp	 SHORT $L109925
$L26057:

; 3240 : 		case('a'):
; 3241 : 			note_2	= 5;

  03f61	6a 05		 push	 5
$L109925:
  03f63	5e		 pop	 esi
$L26049:

; 3248 : 			break;
; 3249 : 	}
; 3250 : 
; 3251 : 	_key_2		= calc_note(MML, note_2);

  03f64	8b 7d 08	 mov	 edi, DWORD PTR _MML$[ebp]
  03f67	53		 push	 ebx
  03f68	8b c7		 mov	 eax, edi
  03f6a	e8 00 00 00 00	 call	 ?calc_note@MusicTrack@@QAEDPAVMMLfile@@H@Z ; MusicTrack::calc_note
  03f6f	0f be c8	 movsx	 ecx, al

; 3252 : 	iNote_2		= ((char)_key_2 + (nsd.octave + nsd.octave1 + o_rel + o_rel2)*12) & 0xFF;

  03f72	8b 43 4c	 mov	 eax, DWORD PTR [ebx+76]
  03f75	03 43 50	 add	 eax, DWORD PTR [ebx+80]
  03f78	03 45 ec	 add	 eax, DWORD PTR _o_rel2$[ebp]
  03f7b	03 45 f0	 add	 eax, DWORD PTR _o_rel$[ebp]
  03f7e	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  03f81	8d 34 81	 lea	 esi, DWORD PTR [ecx+eax*4]
  03f84	81 e6 ff 00 00
	00		 and	 esi, 255		; 000000ffH

; 3253 : 
; 3254 : 	//------
; 3255 : 	//|^gI
; 3256 : 	cData = MML->GetChar();

  03f8a	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 3257 : 	if(cData != '}'){

  03f8f	3c 7d		 cmp	 al, 125			; 0000007dH
  03f91	74 09		 je	 SHORT $L26061

; 3258 : 		MML->Err(_T("|^gR}hA}B"));

  03f93	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1CM@GGEMPKPF@0?$NN0?k0?$LP0?a0?s0?H0?$LD0?$NO0?s0?I0o0?$AB?$AA?$HN0g?$JF?$IJ0X0fN?$AL0U0D@
  03f98	8b c7		 mov	 eax, edi
  03f9a	eb 3a		 jmp	 SHORT $L109929
$L26061:

; 3259 : 	}
; 3260 : 
; 3261 : 	Length_2	= calc_length(MML);

  03f9c	8b 7d 08	 mov	 edi, DWORD PTR _MML$[ebp]
  03f9f	53		 push	 ebx
  03fa0	8b c7		 mov	 eax, edi
  03fa2	e8 00 00 00 00	 call	 ?calc_length@MusicTrack@@QAEHPAVMMLfile@@@Z ; MusicTrack::calc_length

; 3262 : 	if(Length_2 != -1){

  03fa7	83 f8 ff	 cmp	 eax, -1
  03faa	74 10		 je	 SHORT $L109916

; 3263 : 		if(Length != -1){

  03fac	83 7d e8 ff	 cmp	 DWORD PTR _Length$[ebp], -1
  03fb0	74 07		 je	 SHORT $L26064

; 3264 : 			MML->Err(_T("|^gR}hA2LqB"));

  03fb2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DK@BBKDBEBK@0?$NN0?k0?$LP0?a0?s0?H0?$LD0?$NO0?s0?I0g0?$AB?$JH?s?$JFw0L?$AA2?$HL?$IHb?$EA0k?$IK?$BI@
  03fb7	eb 1b		 jmp	 SHORT $L109928
$L26064:

; 3265 : 		} else {
; 3266 : 			Length = Length_2;

  03fb9	89 45 e8	 mov	 DWORD PTR _Length$[ebp], eax
$L109916:

; 3267 : 		}
; 3268 : 	}
; 3269 : 
; 3270 : 	GateTime_2	= calc_gate(MML);

  03fbc	53		 push	 ebx
  03fbd	8b c7		 mov	 eax, edi
  03fbf	e8 00 00 00 00	 call	 ?calc_gate@MusicTrack@@QAEHPAVMMLfile@@@Z ; MusicTrack::calc_gate

; 3271 : 	if(GateTime_2 != -1){

  03fc4	83 f8 ff	 cmp	 eax, -1
  03fc7	74 15		 je	 SHORT $L109917

; 3272 : 		if(GateTime != -1){

  03fc9	83 7d e4 ff	 cmp	 DWORD PTR _GateTime$[ebp], -1
  03fcd	74 0c		 je	 SHORT $L26068

; 3273 : 			MML->Err(_T("|^gR}hAQ[g^C2LqB"));

  03fcf	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1EC@HFJPNNCI@0?$NN0?k0?$LP0?a0?s0?H0?$LD0?$NO0?s0?I0g0?$AB0?$LC0?$PM0?H0?$LP0?$KE0?$OA0L?$AA2@
$L109928:
  03fd4	8b c7		 mov	 eax, edi
$L109929:
  03fd6	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L109932:
$L26068:

; 3274 : 		} else {
; 3275 : 			GateTime = GateTime_2;

  03fdb	89 45 e4	 mov	 DWORD PTR _GateTime$[ebp], eax
$L109917:

; 3276 : 		}
; 3277 : 	}
; 3278 : 
; 3279 : 	Slur_2		= calc_slur(MML);

  03fde	8b c7		 mov	 eax, edi
  03fe0	e8 00 00 00 00	 call	 ?calc_slur@MusicTrack@@QAE_NPAVMMLfile@@@Z ; MusicTrack::calc_slur

; 3280 : 	if(Slur_2 == true){

  03fe5	3c 01		 cmp	 al, 1
  03fe7	75 03		 jne	 SHORT $L26071

; 3281 : 		Slur = true;

  03fe9	88 45 e0	 mov	 BYTE PTR _Slur$[ebp], al
$L26071:

; 3282 : 	}
; 3283 : 
; 3284 : 	//------
; 3285 : 	//|^gvZ
; 3286 : 	int		Length_0	= Length;		//

  03fec	8b 45 e8	 mov	 eax, DWORD PTR _Length$[ebp]

; 3287 : 
; 3288 : 	int	pol_length;
; 3289 : 	int pol_target;
; 3290 : 	int	pol_rate;
; 3291 : 	int	pol_depth;
; 3292 : 
; 3293 : 	//
; 3294 : 	if(Length_0 == -1){

  03fef	83 cf ff	 or	 edi, -1
  03ff2	3b c7		 cmp	 eax, edi
  03ff4	75 03		 jne	 SHORT $L26077

; 3295 : 		Length_0 = nsd.length;

  03ff6	8b 43 40	 mov	 eax, DWORD PTR [ebx+64]
$L26077:

; 3296 : 	}
; 3297 : 
; 3298 : 	pol_length	= (Length_0 * 150) / (iTempo);

  03ff9	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _iTempo$[ebp]
  03ffd	69 c0 96 00 00
	00		 imul	 eax, 150		; 00000096H
  04003	99		 cdq
  04004	f7 f9		 idiv	 ecx

; 3299 : 	pol_target	= iNote_2 - iNote;

  04006	2b 75 d8	 sub	 esi, DWORD PTR _iNote$[ebp]
  04009	8b c8		 mov	 ecx, eax

; 3300 : 
; 3301 : 	if(abs(pol_target) * 16 >= pol_length){

  0400b	8b c6		 mov	 eax, esi
  0400d	99		 cdq
  0400e	33 c2		 xor	 eax, edx
  04010	2b c2		 sub	 eax, edx
  04012	c1 e0 04	 shl	 eax, 4
  04015	3b c1		 cmp	 eax, ecx
  04017	7c 1b		 jl	 SHORT $L26078

; 3302 : 		pol_rate	= 1;
; 3303 : 		pol_depth	= (pol_target * 16) / pol_length;

  04019	8b c6		 mov	 eax, esi
  0401b	c1 e0 04	 shl	 eax, 4
  0401e	99		 cdq
  0401f	f7 f9		 idiv	 ecx

; 3304 : 	//	if((pol_depth * pol_length) != (pol_target * 16)){
; 3305 : 			if(pol_target>=0){

  04021	85 f6		 test	 esi, esi
  04023	c7 45 0c 01 00
	00 00		 mov	 DWORD PTR _pol_rate$[ebp], 1
  0402a	8b f8		 mov	 edi, eax
  0402c	7c 03		 jl	 SHORT $L26079

; 3306 : 				pol_depth++;

  0402e	47		 inc	 edi

; 3307 : 			} else {

  0402f	eb 2b		 jmp	 SHORT $L26083
$L26079:

; 3308 : 				pol_depth--;

  04031	4f		 dec	 edi

; 3309 : 			}
; 3310 : 	//	}
; 3311 : 	} else {

  04032	eb 28		 jmp	 SHORT $L26083
$L26078:

; 3312 : 		if(pol_target < 0){

  04034	85 f6		 test	 esi, esi
  04036	7d 14		 jge	 SHORT $L26082

; 3313 : 			pol_rate	= pol_length / (-pol_target * 16);

  04038	8b c6		 mov	 eax, esi
  0403a	f7 d8		 neg	 eax
  0403c	c1 e0 04	 shl	 eax, 4
  0403f	89 45 0c	 mov	 DWORD PTR tv399[ebp], eax
  04042	8b c1		 mov	 eax, ecx
  04044	8b 4d 0c	 mov	 ecx, DWORD PTR tv399[ebp]
  04047	99		 cdq
  04048	f7 f9		 idiv	 ecx

; 3314 : 			pol_depth	= -1;
; 3315 : 		} else {

  0404a	eb 0d		 jmp	 SHORT $L109926
$L26082:

; 3316 : 			pol_rate	= pol_length / (+pol_target * 16);

  0404c	8b c1		 mov	 eax, ecx
  0404e	8b fe		 mov	 edi, esi
  04050	c1 e7 04	 shl	 edi, 4
  04053	99		 cdq
  04054	f7 ff		 idiv	 edi

; 3317 : 			pol_depth	= 1;

  04056	33 ff		 xor	 edi, edi
  04058	47		 inc	 edi
$L109926:

; 3316 : 			pol_rate	= pol_length / (+pol_target * 16);

  04059	89 45 0c	 mov	 DWORD PTR _pol_rate$[ebp], eax
$L26083:

; 3318 : 		}
; 3319 : 	}
; 3320 : 
; 3321 : //	printf("length :%d\n", pol_length);
; 3322 : //	printf("Rate   :%d\n", pol_rate);
; 3323 : //	printf("Depth  :%d\n", pol_depth);
; 3324 : //	printf("Target :%d\n", pol_target);
; 3325 : 
; 3326 : 	//------
; 3327 : 	//IuWFNg
; 3328 : 	if(jump_flag == false){

  0405c	80 bb a1 00 00
	00 00		 cmp	 BYTE PTR [ebx+161], 0
  04063	75 4d		 jne	 SHORT $L109918

; 3329 : 
; 3330 : 		//|^g
; 3331 : 		SetEvent(new mml_general(nsd_Portamento, (unsigned char)1, (unsigned char)pol_rate, (unsigned char)pol_depth, (unsigned char)pol_target, _T("Portamento")));

  04065	6a 3c		 push	 60			; 0000003cH
  04067	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0406c	59		 pop	 ecx
  0406d	89 45 d8	 mov	 DWORD PTR $T109904[ebp], eax
  04070	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  04074	85 c0		 test	 eax, eax
  04076	74 16		 je	 SHORT $L109905
  04078	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BG@GGJHBHG@?$AAP?$AAo?$AAr?$AAt?$AAa?$AAm?$AAe?$AAn?$AAt?$AAo?$AA?$AA@
  0407d	56		 push	 esi
  0407e	57		 push	 edi
  0407f	ff 75 0c	 push	 DWORD PTR _pol_rate$[ebp]
  04082	6a 01		 push	 1
  04084	6a 17		 push	 23			; 00000017H
  04086	50		 push	 eax
  04087	e8 00 00 00 00	 call	 ??0mml_general@@QAE@EDDDDQBG@Z ; mml_general::mml_general
  0408c	eb 02		 jmp	 SHORT $L109906
$L109905:
  0408e	33 c0		 xor	 eax, eax
$L109906:
  04090	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  04094	50		 push	 eax
  04095	8b c3		 mov	 eax, ebx
  04097	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent

; 3332 : 
; 3333 : 		//|^g
; 3334 : 		SetNote(MML, _key, Length, GateTime, Slur);

  0409c	ff 75 e0	 push	 DWORD PTR _Slur$[ebp]
  0409f	8b 4d dc	 mov	 ecx, DWORD PTR __key$[ebp]
  040a2	ff 75 e4	 push	 DWORD PTR _GateTime$[ebp]
  040a5	8b d3		 mov	 edx, ebx
  040a7	ff 75 e8	 push	 DWORD PTR _Length$[ebp]
  040aa	ff 75 08	 push	 DWORD PTR _MML$[ebp]
  040ad	e8 00 00 00 00	 call	 ?SetNote@MusicTrack@@QAEXPAVMMLfile@@HHH_N@Z ; MusicTrack::SetNote
$L109918:

; 3335 : 	}
; 3336 : 
; 3337 : 	//IN^[uR}ho
; 3338 : 	while( o_rel > 0){

  040b2	8b 45 f0	 mov	 eax, DWORD PTR _o_rel$[ebp]
  040b5	85 c0		 test	 eax, eax
  040b7	7e 28		 jle	 SHORT $L109927
  040b9	83 65 f0 00	 and	 DWORD PTR _o_rel$[ebp], 0
  040bd	8b f8		 mov	 edi, eax
$L26095:

; 3339 : 		if(MML->octave_reverse == true){

  040bf	8b 45 08	 mov	 eax, DWORD PTR _MML$[ebp]
  040c2	80 b8 94 00 00
	00 01		 cmp	 BYTE PTR [eax+148], 1

; 3340 : 			SetOctaveDec();

  040c9	8b f3		 mov	 esi, ebx
  040cb	75 07		 jne	 SHORT $L26097
  040cd	e8 00 00 00 00	 call	 ?SetOctaveDec@MusicTrack@@QAEXXZ ; MusicTrack::SetOctaveDec

; 3341 : 		} else {

  040d2	eb 05		 jmp	 SHORT $L26098
$L26097:

; 3342 : 			SetOctaveInc();

  040d4	e8 00 00 00 00	 call	 ?SetOctaveInc@MusicTrack@@QAEXXZ ; MusicTrack::SetOctaveInc
$L26098:

; 3335 : 	}
; 3336 : 
; 3337 : 	//IN^[uR}ho
; 3338 : 	while( o_rel > 0){

  040d9	4f		 dec	 edi
  040da	75 e3		 jne	 SHORT $L26095
  040dc	8b 45 f0	 mov	 eax, DWORD PTR _o_rel$[ebp]

; 3343 : 		}
; 3344 : 		o_rel--;
; 3345 : 	}
; 3346 : 	while( o_rel < 0){

  040df	85 c0		 test	 eax, eax
$L109927:
  040e1	7d 21		 jge	 SHORT $L26101
  040e3	f7 d8		 neg	 eax
  040e5	8b f8		 mov	 edi, eax
$L26100:

; 3347 : 		if(MML->octave_reverse == true){

  040e7	8b 45 08	 mov	 eax, DWORD PTR _MML$[ebp]
  040ea	80 b8 94 00 00
	00 01		 cmp	 BYTE PTR [eax+148], 1

; 3348 : 			SetOctaveInc();

  040f1	8b f3		 mov	 esi, ebx
  040f3	75 07		 jne	 SHORT $L26102
  040f5	e8 00 00 00 00	 call	 ?SetOctaveInc@MusicTrack@@QAEXXZ ; MusicTrack::SetOctaveInc

; 3349 : 		} else {

  040fa	eb 05		 jmp	 SHORT $L26103
$L26102:

; 3350 : 			SetOctaveDec();

  040fc	e8 00 00 00 00	 call	 ?SetOctaveDec@MusicTrack@@QAEXXZ ; MusicTrack::SetOctaveDec
$L26103:

; 3343 : 		}
; 3344 : 		o_rel--;
; 3345 : 	}
; 3346 : 	while( o_rel < 0){

  04101	4f		 dec	 edi
  04102	75 e3		 jne	 SHORT $L26100
$L26101:

; 3351 : 		}
; 3352 : 		o_rel++;
; 3353 : 	}
; 3354 : 
; 3355 : }

  04104	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  04107	5f		 pop	 edi
  04108	5e		 pop	 esi
  04109	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  04110	c9		 leave
  04111	c2 08 00	 ret	 8
$L109922:
$L109907:
  00d7d	ff 75 d8	 push	 DWORD PTR $T109904[ebp]
  00d80	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00d85	59		 pop	 ecx
  00d86	c3		 ret	 0
__ehhandler$?SetProtament@MusicTrack@@QAEXPAVMMLfile@@E@Z:
  00d87	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T109909
  00d8c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetProtament@MusicTrack@@QAEXPAVMMLfile@@E@Z ENDP	; MusicTrack::SetProtament
PUBLIC	?SetRest@MusicTrack@@QAEXPAVMMLfile@@H@Z	; MusicTrack::SetRest
$T109946 DD	0ffffffffH
	DD	FLAT:$L109938
$T109940 DD	019930520H
	DD	01H
	DD	FLAT:$T109946
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_GateTime$ = -20					; size = 4
_old_note$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
$T109935 = 8						; size = 4
_MML$ = 8						; size = 4
_Slur$ = 12						; size = 1
_mode$ = 12						; size = 4
?SetRest@MusicTrack@@QAEXPAVMMLfile@@H@Z PROC NEAR	; MusicTrack::SetRest
; _this$ = ecx

; 3012 : {

  04114	b8 00 00 00 00	 mov	 eax, __ehhandler$?SetRest@MusicTrack@@QAEXPAVMMLfile@@H@Z
  04119	e8 00 00 00 00	 call	 __EH_prolog
  0411e	51		 push	 ecx
  0411f	51		 push	 ecx
  04120	53		 push	 ebx
  04121	56		 push	 esi
  04122	8b f1		 mov	 esi, ecx

; 3013 : 					char	old_note = oldNote[(pt_oldNote - echo_value) & 0xFF];

  04124	33 c0		 xor	 eax, eax
  04126	8a 86 e2 01 00
	00		 mov	 al, BYTE PTR [esi+482]
  0412c	33 c9		 xor	 ecx, ecx
  0412e	8a 8e e1 00 00
	00		 mov	 cl, BYTE PTR [esi+225]
  04134	57		 push	 edi

; 3014 : 	
; 3015 : 	unsigned		char	cData;
; 3016 : 	unsigned		char	_code = 0x0F;
; 3017 : 					int		Length = -1;
; 3018 : 					int		GateTime = -1;
; 3019 : 					bool	Slur = false;
; 3020 : 
; 3021 : 
; 3022 : 	//x[h
; 3023 : 	cData = MML->GetChar();

  04135	8b 7d 08	 mov	 edi, DWORD PTR _MML$[ebp]
  04138	2b c1		 sub	 eax, ecx
  0413a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0413f	8a 84 30 e2 00
	00 00		 mov	 al, BYTE PTR [eax+esi+226]
  04146	88 45 f3	 mov	 BYTE PTR _old_note$[ebp], al
  04149	e8 00 00 00 00	 call	 ?GetChar@MMLfile@@QAEDXZ ; MMLfile::GetChar

; 3024 : 	switch(cData){

  0414e	0f b6 c0	 movzx	 eax, al
  04151	83 e8 23	 sub	 eax, 35			; 00000023H
  04154	74 6f		 je	 SHORT $L25952
  04156	83 e8 07	 sub	 eax, 7
  04159	74 33		 je	 SHORT $L25964
  0415b	48		 dec	 eax
  0415c	74 67		 je	 SHORT $L25952
  0415e	48		 dec	 eax
  0415f	48		 dec	 eax
  04160	74 5f		 je	 SHORT $L25979
  04162	83 e8 10	 sub	 eax, 16			; 00000010H
  04165	74 2b		 je	 SHORT $L25963

; 3031 : 			break;
; 3032 : 		case('='):
; 3033 : 			_code = 0x0F;	//mode 2
; 3034 : 			break;
; 3035 : 		case('*'):
; 3036 : 			_code = 0x0C;	//mode 3
; 3037 : 			break;
; 3038 : 		default:
; 3039 : 			MML->Back();

  04167	8b c7		 mov	 eax, edi
  04169	e8 00 00 00 00	 call	 ?Back@MMLfile@@QAEXXZ	; MMLfile::Back

; 3040 : 			if(mode & 0x80){

  0416e	f6 45 0c 80	 test	 BYTE PTR _mode$[ebp], -128 ; ffffff80H
  04172	74 22		 je	 SHORT $L25956

; 3041 : 				switch(mode){

  04174	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  04177	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  0417c	74 43		 je	 SHORT $L25979
  0417e	48		 dec	 eax
  0417f	74 44		 je	 SHORT $L25952
  04181	48		 dec	 eax
  04182	74 0e		 je	 SHORT $L25963
  04184	48		 dec	 eax
  04185	74 07		 je	 SHORT $L25964

; 3054 : 					default:
; 3055 : 						MML->Err(_T("MusicTrack::SetRest()A#waitR}hmodelmlB"));

  04187	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1GG@HBOGPEMM@?$AAM?$AAu?$AAs?$AAi?$AAc?$AAT?$AAr?$AAa?$AAc?$AAk?$AA?3?$AA?3?$AAS?$AAe?$AAt?$AAR?$AAe?$AAs?$AAt?$AA?$CI@
  0418c	eb 2c		 jmp	 SHORT $L109945
$L25964:

; 3050 : 						break;
; 3051 : 					case(0x83):
; 3052 : 						_code = 0x0C;

  0418e	b3 0c		 mov	 bl, 12			; 0000000cH

; 3053 : 						break;

  04190	eb 35		 jmp	 SHORT $L25948
$L25963:

; 3048 : 					case(0x82):
; 3049 : 						_code = 0x0F;

  04192	b3 0f		 mov	 bl, 15			; 0000000fH

; 3042 : 					case(0x80):
; 3043 : 						_code = 0x0D;
; 3044 : 						break;
; 3045 : 					case(0x81):
; 3046 : 						_code = 0x0E;
; 3047 : 						break;

  04194	eb 31		 jmp	 SHORT $L25948
$L25956:

; 3056 : 						break;
; 3057 : 				}
; 3058 : 			} else {
; 3059 : 				switch(KeySignature[7]){

  04196	8a 86 cf 00 00
	00		 mov	 al, BYTE PTR [esi+207]
  0419c	3c ff		 cmp	 al, -1
  0419e	74 21		 je	 SHORT $L25979
  041a0	3c 01		 cmp	 al, 1
  041a2	74 21		 je	 SHORT $L25952

; 3066 : 					default:
; 3067 : 						switch(mode){

  041a4	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  041a7	83 e8 00	 sub	 eax, 0
  041aa	74 15		 je	 SHORT $L25979
  041ac	48		 dec	 eax
  041ad	74 16		 je	 SHORT $L25952
  041af	48		 dec	 eax
  041b0	74 e0		 je	 SHORT $L25963
  041b2	48		 dec	 eax
  041b3	74 d9		 je	 SHORT $L25964

; 3070 : 								break;
; 3071 : 							case(1):
; 3072 : 								_code = 0x0E;
; 3073 : 								break;
; 3074 : 							case(2):
; 3075 : 								_code = 0x0F;
; 3076 : 								break;
; 3077 : 							case(3):
; 3078 : 								_code = 0x0C;
; 3079 : 								break;
; 3080 : 							default:
; 3081 : 								MML->Err(_T("MusicTrack::SetRest()A#restR}hmodelmlB"));

  041b5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1GG@IPLHPKBL@?$AAM?$AAu?$AAs?$AAi?$AAc?$AAT?$AAr?$AAa?$AAc?$AAk?$AA?3?$AA?3?$AAS?$AAe?$AAt?$AAR?$AAe?$AAs?$AAt?$AA?$CI@
$L109945:
  041ba	8b c7		 mov	 eax, edi
  041bc	e8 00 00 00 00	 call	 ?Err@MMLfile@@QAEXQBG@Z	; MMLfile::Err
$L109947:
$L25979:

; 3068 : 							case(0):
; 3069 : 								_code = 0x0D;

  041c1	b3 0d		 mov	 bl, 13			; 0000000dH

; 3060 : 					case(-1):
; 3061 : 						_code = 0x0D;
; 3062 : 						break;
; 3063 : 					case(+1):
; 3064 : 						_code = 0x0E;
; 3065 : 						break;

  041c3	eb 02		 jmp	 SHORT $L25948
$L25952:

; 3025 : 		case('-'):
; 3026 : 			_code = 0x0D;	//mode 0
; 3027 : 			break;
; 3028 : 		case('#'):
; 3029 : 		case('+'):
; 3030 : 			_code = 0x0E;	//mode 1

  041c5	b3 0e		 mov	 bl, 14			; 0000000eH
$L25948:

; 3082 : 								break;
; 3083 : 						}
; 3084 : 						break;
; 3085 : 				}
; 3086 : 			}
; 3087 : 			break;
; 3088 : 	}
; 3089 : 
; 3090 : 	Length		= calc_length(MML);		//

  041c7	8b 45 08	 mov	 eax, DWORD PTR _MML$[ebp]
  041ca	56		 push	 esi
  041cb	e8 00 00 00 00	 call	 ?calc_length@MusicTrack@@QAEHPAVMMLfile@@@Z ; MusicTrack::calc_length
  041d0	8b f8		 mov	 edi, eax

; 3091 : 	GateTime	= calc_gate(MML);		//Q[g^C or ^C

  041d2	8b 45 08	 mov	 eax, DWORD PTR _MML$[ebp]
  041d5	56		 push	 esi
  041d6	e8 00 00 00 00	 call	 ?calc_gate@MusicTrack@@QAEHPAVMMLfile@@@Z ; MusicTrack::calc_gate
  041db	89 45 ec	 mov	 DWORD PTR _GateTime$[ebp], eax

; 3092 : 	Slur		= calc_slur(MML);		//^CEX[

  041de	8b 45 08	 mov	 eax, DWORD PTR _MML$[ebp]
  041e1	e8 00 00 00 00	 call	 ?calc_slur@MusicTrack@@QAE_NPAVMMLfile@@@Z ; MusicTrack::calc_slur

; 3093 : 
; 3094 : 	if(jump_flag==false){

  041e6	80 be a1 00 00
	00 00		 cmp	 BYTE PTR [esi+161], 0
  041ed	88 45 0c	 mov	 BYTE PTR _Slur$[ebp], al
  041f0	0f 85 99 00 00
	00		 jne	 $L25995

; 3095 : 		//NI^CY
; 3096 : 		if(gatetime_Q != QMax){

  041f6	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  041fc	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  04202	3b d1		 cmp	 edx, ecx
  04204	74 11		 je	 SHORT $L25986

; 3097 : 			Set_q((Length * (QMax - gatetime_Q)) / QMax);

  04206	8b c1		 mov	 eax, ecx
  04208	2b c2		 sub	 eax, edx
  0420a	0f af c7	 imul	 eax, edi
  0420d	99		 cdq
  0420e	f7 f9		 idiv	 ecx
  04210	8b c8		 mov	 ecx, eax
  04212	e8 00 00 00 00	 call	 ?Set_q@MusicTrack@@QAEXH@Z ; MusicTrack::Set_q
$L25986:

; 3098 : 		}
; 3099 : 
; 3100 : 		if((echo_flag == false) || (_code != 0x0F) || (old_note == -1) || (echo_length != -1)){

  04217	80 be da 00 00
	00 00		 cmp	 BYTE PTR [esi+218], 0
  0421e	74 25		 je	 SHORT $L109941
  04220	80 fb 0f	 cmp	 bl, 15			; 0000000fH
  04223	75 20		 jne	 SHORT $L109941
  04225	80 7d f3 ff	 cmp	 BYTE PTR _old_note$[ebp], -1
  04229	74 1a		 je	 SHORT $L109941
  0422b	83 be dc 00 00
	00 ff		 cmp	 DWORD PTR [esi+220], -1
  04232	75 11		 jne	 SHORT $L109941

; 3106 : 		} else {
; 3107 : 			GenerateEcho(MML,Length,GateTime,Slur);

  04234	ff 75 0c	 push	 DWORD PTR _Slur$[ebp]
  04237	ff 75 ec	 push	 DWORD PTR _GateTime$[ebp]
  0423a	57		 push	 edi
  0423b	ff 75 08	 push	 DWORD PTR _MML$[ebp]
  0423e	e8 00 00 00 00	 call	 ?GenerateEcho@MusicTrack@@QAEXPAVMMLfile@@HH_N@Z ; MusicTrack::GenerateEcho
  04243	eb 4a		 jmp	 SHORT $L25995
$L109941:

; 3101 : 			if(Length == opt_DefaultLength){

  04245	3b be a4 00 00
	00		 cmp	 edi, DWORD PTR [esi+164]
  0424b	75 03		 jne	 SHORT $L25989

; 3102 : 				Length = -1;

  0424d	83 cf ff	 or	 edi, -1
$L25989:

; 3103 : 			}
; 3104 : 			_old_note = new mml_note(_code, Length, GateTime, Slur, _T("Rest"));

  04250	6a 3c		 push	 60			; 0000003cH
  04252	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  04257	59		 pop	 ecx
  04258	89 45 08	 mov	 DWORD PTR $T109935[ebp], eax
  0425b	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0425f	85 c0		 test	 eax, eax
  04261	74 18		 je	 SHORT $L109936
  04263	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_19FAHECHIH@?$AAR?$AAe?$AAs?$AAt?$AA?$AA@
  04268	ff 75 0c	 push	 DWORD PTR _Slur$[ebp]
  0426b	0f b6 cb	 movzx	 ecx, bl
  0426e	ff 75 ec	 push	 DWORD PTR _GateTime$[ebp]
  04271	57		 push	 edi
  04272	51		 push	 ecx
  04273	50		 push	 eax
  04274	e8 00 00 00 00	 call	 ??0mml_note@@QAE@HHH_NQBG@Z ; mml_note::mml_note
  04279	eb 02		 jmp	 SHORT $L109937
$L109936:
  0427b	33 c0		 xor	 eax, eax
$L109937:
  0427d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  04281	89 86 c4 00 00
	00		 mov	 DWORD PTR [esi+196], eax

; 3105 : 			SetEvent(_old_note);

  04287	50		 push	 eax
  04288	8b c6		 mov	 eax, esi
  0428a	e8 00 00 00 00	 call	 ?SetEvent@MusicTrack@@QAEXPAVMusicItem@@@Z ; MusicTrack::SetEvent
$L25995:

; 3108 : 		}
; 3109 : 	}
; 3110 : }

  0428f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  04292	5f		 pop	 edi
  04293	5e		 pop	 esi
  04294	5b		 pop	 ebx
  04295	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0429c	c9		 leave
  0429d	c2 08 00	 ret	 8
$L109943:
$L109938:
  00d91	ff 75 08	 push	 DWORD PTR $T109935[ebp]
  00d94	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00d99	59		 pop	 ecx
  00d9a	c3		 ret	 0
__ehhandler$?SetRest@MusicTrack@@QAEXPAVMMLfile@@H@Z:
  00d9b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T109940
  00da0	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
?SetRest@MusicTrack@@QAEXPAVMMLfile@@H@Z ENDP		; MusicTrack::SetRest
PUBLIC	?SetNote@MusicTrack@@QAEXPAVMMLfile@@H@Z	; MusicTrack::SetNote
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_Length$ = -12						; size = 4
_GateTime$ = -8						; size = 4
_Slur$ = -4						; size = 1
?SetNote@MusicTrack@@QAEXPAVMMLfile@@H@Z PROC NEAR	; MusicTrack::SetNote
; _this$ = edi
; _MML$ = ebx
; _note$ = eax

; 2990 : {

  042a0	55		 push	 ebp
  042a1	8b ec		 mov	 ebp, esp
  042a3	83 ec 0c	 sub	 esp, 12			; 0000000cH
  042a6	56		 push	 esi

; 2991 : 	int		_key		= calc_note(MML, note);

  042a7	8b f0		 mov	 esi, eax
  042a9	57		 push	 edi
  042aa	8b c3		 mov	 eax, ebx
  042ac	e8 00 00 00 00	 call	 ?calc_note@MusicTrack@@QAEDPAVMMLfile@@H@Z ; MusicTrack::calc_note
  042b1	0f be f0	 movsx	 esi, al

; 2992 : 	int		Length		= calc_length(MML);

  042b4	57		 push	 edi
  042b5	8b c3		 mov	 eax, ebx
  042b7	e8 00 00 00 00	 call	 ?calc_length@MusicTrack@@QAEHPAVMMLfile@@@Z ; MusicTrack::calc_length
  042bc	89 45 f4	 mov	 DWORD PTR _Length$[ebp], eax

; 2993 : 	int		GateTime	= calc_gate(MML);

  042bf	57		 push	 edi
  042c0	8b c3		 mov	 eax, ebx
  042c2	e8 00 00 00 00	 call	 ?calc_gate@MusicTrack@@QAEHPAVMMLfile@@@Z ; MusicTrack::calc_gate
  042c7	89 45 f8	 mov	 DWORD PTR _GateTime$[ebp], eax

; 2994 : 	bool	Slur		= calc_slur(MML);

  042ca	8b c3		 mov	 eax, ebx
  042cc	e8 00 00 00 00	 call	 ?calc_slur@MusicTrack@@QAE_NPAVMMLfile@@@Z ; MusicTrack::calc_slur

; 2995 : 
; 2996 : 	if(jump_flag==false){

  042d1	80 bf a1 00 00
	00 00		 cmp	 BYTE PTR [edi+161], 0
  042d8	88 45 fc	 mov	 BYTE PTR _Slur$[ebp], al
  042db	75 13		 jne	 SHORT $L25935

; 2997 : 		SetNote(MML, _key, Length, GateTime, Slur);

  042dd	ff 75 fc	 push	 DWORD PTR _Slur$[ebp]
  042e0	8b ce		 mov	 ecx, esi
  042e2	ff 75 f8	 push	 DWORD PTR _GateTime$[ebp]
  042e5	8b d7		 mov	 edx, edi
  042e7	ff 75 f4	 push	 DWORD PTR _Length$[ebp]
  042ea	53		 push	 ebx
  042eb	e8 00 00 00 00	 call	 ?SetNote@MusicTrack@@QAEXPAVMMLfile@@HHH_N@Z ; MusicTrack::SetNote
$L25935:
  042f0	5e		 pop	 esi

; 2998 : 	}
; 2999 : 
; 3000 : }

  042f1	c9		 leave
  042f2	c3		 ret	 0
?SetNote@MusicTrack@@QAEXPAVMMLfile@@H@Z ENDP		; MusicTrack::SetNote
_TEXT	ENDS
PUBLIC	?SetTai@MusicTrack@@QAEXPAVMMLfile@@@Z		; MusicTrack::SetTai
; Function compile flags: /Ogsy
_TEXT	SEGMENT
_MML$ = 8						; size = 4
?SetTai@MusicTrack@@QAEXPAVMMLfile@@@Z PROC NEAR	; MusicTrack::SetTai
; _this$ = ecx

; 3122 : 	if(jump_flag==false){

  042f3	80 b9 a1 00 00
	00 00		 cmp	 BYTE PTR [ecx+161], 0
  042fa	75 0b		 jne	 SHORT $L26000

; 3123 : 		_old_note->SetTai();

  042fc	8b 81 c4 00 00
	00		 mov	 eax, DWORD PTR [ecx+196]
  04302	e8 00 00 00 00	 call	 ?SetTai@mml_note@@QAEXXZ ; mml_note::SetTai
$L26000:

; 3124 : 	}
; 3125 : 	SetRest(MML,2);

  04307	6a 02		 push	 2
  04309	ff 74 24 08	 push	 DWORD PTR _MML$[esp]
  0430d	e8 00 00 00 00	 call	 ?SetRest@MusicTrack@@QAEXPAVMMLfile@@H@Z ; MusicTrack::SetRest

; 3126 : }

  04312	c2 04 00	 ret	 4
?SetTai@MusicTrack@@QAEXPAVMMLfile@@@Z ENDP		; MusicTrack::SetTai
; Function compile flags: /Ogsy
; File c:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocnum
;	COMDAT _$E3
text$yc	SEGMENT
_$E3	PROC NEAR					; COMDAT

; 806  : 		{	// initialize from _Locinfo object

  00000	83 25 00 00 00
	00 00		 and	 DWORD PTR ?id@?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@2V0locale@2@A, 0 ; std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short,std::char_traits<unsigned short> > >::id
  00007	c3		 ret	 0
_$E3	ENDP
END
