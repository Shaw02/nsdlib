ca65 V2.13.3 - (C) Copyright 1998-2012 Ullrich von Bassewitz
Main file   : nsd_env.s
Current file: nsd_env.s

000000r 1               
000000r 1               	.setcpu		"6502"
000000r 1               
000000r 1               	.export		nsd_envelop
000000r 1               
000000r 1               	.import		_nsd_snd_voice
000000r 1               	.import		_nsd_snd_volume
000000r 1               	.import		_nsd_snd_frequency
000000r 1               	.import		_nsd_mul
000000r 1               	.import		nsd_work
000000r 1               	.importzp	nsd_work_zp
000000r 1               
000000r 1               	.include	"nes.inc"
000000r 2               ;
000000r 2               ; NES definitions. By Groepaz/Hitmem.
000000r 2               ;
000000r 2               
000000r 2               
000000r 2               ;; FIXME: optimize zeropage usage
000000r 2               
000000r 2               SCREEN_PTR	= $62           ;2
000000r 2               CRAM_PTR        = $64           ;2
000000r 2               CHARCOLOR	= $66
000000r 2               BGCOLOR		= $67
000000r 2               RVS		= $68
000000r 2               CURS_X		= $69
000000r 2               CURS_Y		= $6a
000000r 2               
000000r 2               tickcount       = $6b           ;2
000000r 2               
000000r 2               VBLANK_FLAG	= $70
000000r 2               
000000r 2               ringbuff        = $0200
000000r 2               ringwrite       = $71
000000r 2               ringread        = $72
000000r 2               ringcount       = $73
000000r 2               
000000r 2               ppuhi           = $74
000000r 2               ppulo           = $75
000000r 2               ppuval          = $76
000000r 2               
000000r 2               screenrows 	= (30-1)
000000r 2               charsperline    = 32
000000r 2               xsize           = charsperline
000000r 2               
000000r 2               ;; PPU defines
000000r 2               
000000r 2               PPU_CTRL1      	= $2000
000000r 2               PPU_CTRL2	= $2001
000000r 2               PPU_STATUS	= $2002
000000r 2               PPU_SPR_ADDR	= $2003
000000r 2               PPU_SPR_IO  	= $2004
000000r 2               PPU_VRAM_ADDR1	= $2005
000000r 2               PPU_VRAM_ADDR2	= $2006
000000r 2               PPU_VRAM_IO	= $2007
000000r 2               
000000r 2               ;; APU defines
000000r 2               
000000r 2               APU_PULSE1CTRL  = $4000         ; Pulse #1 Control Register (W)
000000r 2               APU_PULSE1RAMP  = $4001         ; Pulse #1 Ramp Control Register (W)
000000r 2               APU_PULSE1FTUNE = $4002         ; Pulse #1 Fine Tune (FT) Register (W)
000000r 2               APU_PULSE1CTUNE = $4003         ; Pulse #1 Coarse Tune (CT) Register (W)
000000r 2               APU_PULSE2CTRL  = $4004         ; Pulse #2 Control Register (W)
000000r 2               APU_PULSE2RAMP  = $4005         ; Pulse #2 Ramp Control Register (W)
000000r 2               APU_PULSE2FTUNE = $4006         ; Pulse #2 Fine Tune Register (W)
000000r 2               APU_PULSE2STUNE = $4007         ; Pulse #2 Coarse Tune Register (W)
000000r 2               APU_TRICTRL1    = $4008         ; Triangle Control Register #1 (W)
000000r 2               APU_TRICTRL2    = $4009         ; Triangle Control Register #2 (?)
000000r 2               APU_TRIFREQ1    = $400A         ; Triangle Frequency Register #1 (W)
000000r 2               APU_TRIFREQ2    = $400B         ; Triangle Frequency Register #2 (W)
000000r 2               APU_NOISECTRL   = $400C         ; Noise Control Register #1 (W)
000000r 2               ;;APU_ = $400D  ; Unused (???)
000000r 2               APU_NOISEFREQ1  = $400E         ; Noise Frequency Register #1 (W)
000000r 2               APU_NOISEFREQ2  = $400F         ; Noise Frequency Register #2 (W)
000000r 2               APU_MODCTRL     = $4010         ; Delta Modulation Control Register (W)
000000r 2               APU_MODDA       = $4011         ; Delta Modulation D/A Register (W)
000000r 2               APU_MODADDR     = $4012         ; Delta Modulation Address Register (W)
000000r 2               APU_MODLEN      = $4013         ; Delta Modulation Data Length Register (W)
000000r 2               APU_SPR_DMA    	= $4014         ; Sprite DMA Register (W)
000000r 2               APU_CHANCTRL   	= $4015         ; Sound/Vertical Clock Signal Register (R)
000000r 2               APU_PAD1       	= $4016         ; Joypad #1 (RW)
000000r 2               APU_PAD2	= $4017         ; Joypad #2/SOFTCLK (RW)
000000r 2               
000000r 2               
000000r 2               CH_HLINE    	= 11
000000r 2               CH_VLINE    	= 14
000000r 2               CH_ULCORNER 	= 176
000000r 2               CH_URCORNER 	= 174
000000r 2               CH_LLCORNER 	= 173
000000r 2               CH_LRCORNER 	= 189
000000r 2               CH_TTEE	    	= 178
000000r 2               CH_RTEE	    	= 179
000000r 2               CH_BTEE	    	= 177
000000r 2               CH_LTEE	    	= 171
000000r 2               CH_CROSS    	= 123
000000r 2               CH_CURS_UP     	= 145
000000r 2               CH_CURS_DOWN	= 17
000000r 2               CH_CURS_LEFT	= 157
000000r 2               CH_CURS_RIGHT	= 29
000000r 2               CH_PI		= 126
000000r 2               CH_DEL		= 20
000000r 2               CH_INS		= 148
000000r 2               CH_ENTER        = 10
000000r 2               CH_STOP         = 3
000000r 2               CH_ESC          = 27
000000r 2               
000000r 2               
000000r 1               	.include	"nsd.inc"
000000r 2               
000000r 2               ;---------------------------------------
000000r 2               ;General Define
000000r 2               .scope	nsd
000000r 2               	APU_Track	= 5		;
000000r 2               
000000r 2               	TR_FDS		= APU_Track * 2
000000r 2               	.ifdef	FDS
000000r 2               		FDS_Track	= 1		;
000000r 2               	.else
000000r 2               		FDS_Track	= 0		;
000000r 2               	.endif
000000r 2               
000000r 2               	TR_VRC6		= TR_FDS + FDS_Track * 2
000000r 2               	.ifdef	VRC6
000000r 2               		VRC6_Track	= 3		;
000000r 2               	.else
000000r 2               		VRC6_Track	= 0		;
000000r 2               	.endif
000000r 2               
000000r 2               	TR_VRC7		= TR_VRC6 + VRC6_Track * 2
000000r 2               	.ifdef	VRC7
000000r 2               		VRC7_Track	= 6		;
000000r 2               	.else
000000r 2               		VRC7_Track	= 0		;
000000r 2               	.endif
000000r 2               
000000r 2               	TR_MMC5		= TR_VRC7 + VRC7_Track * 2
000000r 2               	.ifdef	MMC5
000000r 2               		MMC5_Track	= 2		; (without DPCM)
000000r 2               	.else
000000r 2               		MMC5_Track	= 0		;
000000r 2               	.endif
000000r 2               
000000r 2               	TR_N163		= TR_MMC5 + MMC5_Track * 2
000000r 2               	.ifdef	N163
000000r 2               		N163_Track	= 8		;
000000r 2               	.else
000000r 2               		N163_Track	= 0		;
000000r 2               	.endif
000000r 2               
000000r 2               	TR_PSG		= TR_N163 + N163_Track * 2
000000r 2               	.ifdef	PSG
000000r 2               		PSG_Track	= 3		;
000000r 2               	.else
000000r 2               		PSG_Track	= 0		;
000000r 2               	.endif
000000r 2               
000000r 2               	BGM_Track	= APU_Track + FDS_Track + VRC6_Track + VRC7_Track + MMC5_Track + N163_Track + PSG_Track
000000r 2               	SE_Track	= 2		;
000000r 2               
000000r 2               	Track		= BGM_Track + SE_Track
000000r 2               
000000r 2               	TR_BGM1		= 0
000000r 2               	TR_BGM2		= 2
000000r 2               	TR_BGM3		= 4
000000r 2               	TR_BGM4		= 6
000000r 2               	TR_BGM5		= 8
000000r 2               	TR_SE1		= BGM_Track * 2 + 0
000000r 2               	TR_SE2		= BGM_Track * 2 + 2
000000r 2               
000000r 2               .endscope
000000r 2               
000000r 2               ;---------------------------------------
000000r 2               ;FDS define
000000r 2               
000000r 2               FDS_Wave_Table		= $4040		; to $407F
000000r 2               FDS_Volume		= $4080
000000r 2               FDS_FTUNE		= $4082
000000r 2               FDS_CTUNE		= $4083
000000r 2               FDS_Sweep_Envelope	= $4084
000000r 2               FDS_Sweep_Bias		= $4085
000000r 2               FDS_Mod_FTUNE		= $4086
000000r 2               FDS_Mod_CTUNE		= $4087
000000r 2               FDS_Mod_Append		= $4088
000000r 2               FDS_Write_Enable	= $4089
000000r 2               FDS_Envelope_Speed	= $408A
000000r 2               FDS_Volume_Gain		= $4090		;$4080's value
000000r 2               FDS_Sweep_Gain		= $4092		;$4084's value
000000r 2               
000000r 2               ;---------------------------------------
000000r 2               ;VRC6 define
000000r 2               
000000r 2               VRC6_Frequency		= $9003
000000r 2               VRC6_Pulse1_CTRL	= $9000
000000r 2               VRC6_Pulse1_FTUNE	= $9001
000000r 2               VRC6_Pulse1_CTUNE	= $9002
000000r 2               VRC6_Pulse2_CTRL	= $A000
000000r 2               VRC6_Pulse2_FTUNE	= $A001
000000r 2               VRC6_Pulse2_CTUNE	= $A002
000000r 2               VRC6_SAW_CTRL		= $B000
000000r 2               VRC6_SAW_FTUNE		= $B001
000000r 2               VRC6_SAW_CTUNE		= $B002
000000r 2               
000000r 2               ;---------------------------------------
000000r 2               ;VRC7 define
000000r 2               
000000r 2               VRC7_Resister		= $9010		;wait  6 clk
000000r 2               VRC7_Data		= $9030		;wait 42 clk
000000r 2               
000000r 2               VRC7_Patch0		= $00
000000r 2               VRC7_Patch1		= $01
000000r 2               VRC7_Patch2		= $02
000000r 2               VRC7_Patch3		= $03
000000r 2               VRC7_Patch4		= $04
000000r 2               VRC7_Patch5		= $05
000000r 2               VRC7_Patch6		= $06
000000r 2               VRC7_Patch7		= $07
000000r 2               
000000r 2               VRC7_Frequency		= $10
000000r 2               VRC7_Octave		= $20
000000r 2               VRC7_Volume		= $30
000000r 2               
000000r 2               ;---------------------------------------
000000r 2               ;MMC5 define
000000r 2               
000000r 2               MMC5_Pulse1_CTRL	= $5000         ; Pulse_ #1 Control Register (W)
000000r 2               MMC5_Pulse1_FTUNE	= $5002         ; Pulse_ #1 Fine Tune (FT) Register (W)
000000r 2               MMC5_Pulse1_CTUNE	= $5003         ; Pulse_ #1 Coarse Tune (CT) Register (W)
000000r 2               MMC5_Pulse2_CTRL	= $5004         ; Pulse_ #2 Control Register (W)
000000r 2               MMC5_Pulse2_FTUNE	= $5006         ; Pulse_ #2 Fine Tune Register (W)
000000r 2               MMC5_Pulse2_STUNE	= $5007         ; Pulse_ #2 Coarse Tune Register (W)
000000r 2               
000000r 2               ;---------------------------------------
000000r 2               ;N163 define
000000r 2               
000000r 2               N163_Resister		= $F800
000000r 2               N163_Data		= $4800
000000r 2               
000000r 2               N163_Frequency_Low	= $40
000000r 2               N163_Frequency_Middle	= $42
000000r 2               N163_Frequency_High	= $44
000000r 2               N163_Waveform		= $46
000000r 2               N163_Volume		= $47
000000r 2               N163_EnableChannel	= $7F
000000r 2               
000000r 2               ;---------------------------------------
000000r 2               ;PSG define
000000r 2               
000000r 2               PSG_Register		= $C000
000000r 2               PSG_Data		= $E000
000000r 2               
000000r 2               ;=======================================================================
000000r 2               ;	Working Struct define in Zero-page area
000000r 2               ;-----------------------------------------------------------------------
000000r 2               .Struct		NSD_Envelop
000000r 2               	V		.byte		;Volume & Voice (ch3:Tempo / ch5:Tempo_ctr)
000000r 2               	F		.byte		;Frequency & Note
000000r 2               .Endstruct
000000r 2               
000000r 2               .Struct		NSD_Length_Cnt
000000r 2               	counter		.byte		;now length of note
000000r 2               	gate		.byte		;length - u
000000r 2               .Endstruct
000000r 2               
000000r 2               .Struct		NSD_work_zp
000000r 2               	_ptr		.word					;00 General pointer value
000000r 2               	_tmp		.word					;02 General value
000000r 2               	flag		.byte					;04 flag
000000r 2               	channel		.byte					;05 channel (y resister)
000000r 2               	Sequence_ptr	.word			nsd::Track	;06 Address of playing sequence
000000r 2               	Length		.tag	NSD_Length_Cnt	nsd::Track	;16 Length Counter
000000r 2               	Envelop		.tag	NSD_Envelop	nsd::Track	;26 Envelop counter
000000r 2               .Endstruct
000000r 2               
000000r 2               ; 6 + ( 6 [Byte] * 28 [ch] ) = 174
000000r 2               
000000r 2               ;=======================================================================
000000r 2               ;	Working  Struct define in RAM area
000000r 2               ;-----------------------------------------------------------------------
000000r 2               
000000r 2               .Struct		NSD_Flag
000000r 2               	flag		.byte		;flag
000000r 2               	gatemode	.byte		;gate mode
000000r 2               .Endstruct
000000r 2               
000000r 2               .Struct		NSD_length
000000r 2               	length		.byte		;`l' command value
000000r 2               	tai		.byte		;flag of Tai & Slur
000000r 2               .Endstruct
000000r 2               
000000r 2               .Struct		NSD_gatetime
000000r 2               	q		.byte		;`q' command value
000000r 2               	u		.byte		;`u' command value
000000r 2               .Endstruct
000000r 2               
000000r 2               .Struct		NSD_note
000000r 2               	note		.byte		;`note' command value (bit 7 = `H' : rest)
000000r 2               	octave		.byte		;`o' command value
000000r 2               .Endstruct
000000r 2               
000000r 2               .Struct		NSD_Detune
000000r 2               	cent		.byte		;`D' command value
000000r 2               	fine		.byte		;`D%' command value
000000r 2               .Endstruct
000000r 2               
000000r 2               .Struct		NSD_Por_Lv
000000r 2               	target		.byte		;`P' target
000000r 2               	depth		.byte		;`P' add value
000000r 2               .Endstruct
000000r 2               
000000r 2               .Struct		NSD_Por_Co
000000r 2               	count		.byte		;rate control
000000r 2               	rate		.byte		;now depth
000000r 2               .Endstruct
000000r 2               
000000r 2               .Struct		NSD_Trans
000000r 2               	trans		.byte		;`_' command value
000000r 2               	onetime		.byte		;`'', `"' command value
000000r 2               .Endstruct
000000r 2               
000000r 2               .Struct		NSD_Repeat
000000r 2               	count1		.byte		;counter of repeat(A)
000000r 2               	count2		.byte		;counter of repeat(B)
000000r 2               .Endstruct
000000r 2               
000000r 2               .Struct		NSD_volume
000000r 2               	volume		.byte		;`v' & `vR' command value
000000r 2               	volume_env	.byte		;now envelop volume
000000r 2               .Endstruct
000000r 2               
000000r 2               .Struct		NSD_voice
000000r 2               	voice		.byte		;`@R' command value (upper 4bit)
000000r 2               	voice_set	.byte		;deveice setting value
000000r 2               .Endstruct
000000r 2               
000000r 2               .Struct		NSD_Env_V_Ptr
000000r 2               	Volume		.byte		;Volume
000000r 2               	Voice		.byte		;Voice
000000r 2               .Endstruct
000000r 2               
000000r 2               .Struct		NSD_Env_F_Ptr
000000r 2               	Frequency	.byte		;Freeuqncy
000000r 2               	Note		.byte		;Note
000000r 2               .Endstruct
000000r 2               
000000r 2               .Struct		NSD_Env_F_Now
000000r 2               	Frequency	.byte		;now envelop Freeuqncy
000000r 2               	Note		.byte		;now envelop Note
000000r 2               .Endstruct
000000r 2               
000000r 2               .Struct		NSD_work
000000r 2               	Flag		.tag	NSD_Flag	nsd::Track	;flag
000000r 2               	Length		.tag	NSD_length	nsd::Track	;note length [tick]
000000r 2               	Gatetime	.tag	NSD_gatetime	nsd::Track	;gate time [tick]
000000r 2               	Note		.tag	NSD_note	nsd::Track	;octave and note command
000000r 2               	Detune		.tag	NSD_Detune	nsd::Track	;detune
000000r 2               	Por_Lv		.tag	NSD_Por_Lv	nsd::Track	;Portamento
000000r 2               	Por_Co		.tag	NSD_Por_Co	nsd::Track	;Portamento
000000r 2               	Por_now		.word			nsd::Track	;Portamento
000000r 2               	Trans		.tag	NSD_Trans	nsd::Track	;Repeat and Transpose
000000r 2               	Repeat		.tag	NSD_Repeat	nsd::Track	;Repeat and Transpose
000000r 2               	Volume		.tag	NSD_volume	nsd::Track	;volume
000000r 2               	Voice		.tag	NSD_voice	nsd::Track	;voice
000000r 2               	Env_F_Now	.tag	NSD_Env_F_Now	nsd::Track	;Now value of envelop
000000r 2               	Env_V_Ptr	.tag	NSD_Env_V_Ptr	nsd::Track	;Address of envelop
000000r 2               	Env_F_Ptr	.tag	NSD_Env_F_Ptr	nsd::Track	;Address of envelop
000000r 2               	Envelop_Volume	.word			nsd::Track	;Pointer of envelop
000000r 2               	Envelop_Voice	.word			nsd::Track	;Pointer of envelop
000000r 2               	Envelop_Freq	.word			nsd::Track	;Pointer of envelop
000000r 2               	Envelop_Note	.word			nsd::Track	;Pointer of envelop
000000r 2               	Frequency	.word			nsd::Track	;Setting frequency
000000r 2               	Frequency_Set	.word			nsd::Track	;Setting frequency for Device
000000r 2               	SubRoutine	.word			nsd::Track	;Pointer of sub-routine return address
000000r 2               	Repeat2		.word			nsd::Track	;Pointer of repeat2 goto point
000000r 2               .Endstruct
000000r 2               
000000r 2               ;=======================================================================
000000r 2               ;	Defines for work structures
000000r 2               ;-----------------------------------------------------------------------
000000r 2               
000000r 2               .scope	nsd_flag
000000r 2               	BGM	= $01
000000r 2               	SE	= $02
000000r 2               .endscope
000000r 2               
000000r 2               ;Zero Page Works
000000r 2               .define	__ptr		nsd_work_zp + NSD_work_zp::_ptr
000000r 2               .define	__tmp		nsd_work_zp + NSD_work_zp::_tmp
000000r 2               .define	__flag		nsd_work_zp + NSD_work_zp::flag
000000r 2               .define	__channel	nsd_work_zp + NSD_work_zp::channel
000000r 2               .define	__Sequence_ptr	nsd_work_zp + NSD_work_zp::Sequence_ptr
000000r 2               .define	__Length_ctr	nsd_work_zp + NSD_work_zp::Length + NSD_Length_Cnt::counter
000000r 2               .define	__Gate		nsd_work_zp + NSD_work_zp::Length + NSD_Length_Cnt::gate
000000r 2               .define	__Envelop_V	nsd_work_zp + NSD_work_zp::Envelop + NSD_Envelop::V	;upper 4bit Voice / lower 4bit:Volume
000000r 2               .define	__Envelop_F	nsd_work_zp + NSD_work_zp::Envelop + NSD_Envelop::F	;upper 4bit:Note  / lower 4bit:Frequency
000000r 2               .define	__Tempo		nsd_work_zp + NSD_work_zp::Envelop + NSD_Envelop::V + nsd::TR_BGM3
000000r 2               .define	__Tempo_ctr	nsd_work_zp + NSD_work_zp::Envelop + NSD_Envelop::V + nsd::TR_BGM5
000000r 2               
000000r 2               .scope	nsd_chflag
000000r 2               	SE1	= $40
000000r 2               	SE2	= $80
000000r 2               	KeyOff	= $03		;00	Key Off	: Vol = 0
000000r 2               				;01	Key Off	: Release command
000000r 2               				;10	Key Off	:  envelop
000000r 2               				;11	Note On	: (envelop)
000000r 2               .endscope
000000r 2               
000000r 2               ;RAM Works
000000r 2               .define	__chflag	nsd_work + NSD_work::Flag + NSD_Flag::flag
000000r 2               .define	__gatemode	nsd_work + NSD_work::Flag + NSD_Flag::gatemode
000000r 2               .define	__tai		nsd_work + NSD_work::Length + NSD_length::tai
000000r 2               .define	__length	nsd_work + NSD_work::Length + NSD_length::length
000000r 2               .define	__gate_q	nsd_work + NSD_work::Gatetime + NSD_gatetime::q
000000r 2               .define	__gate_u	nsd_work + NSD_work::Gatetime + NSD_gatetime::u
000000r 2               .define __note		nsd_work + NSD_work::Note + NSD_note::note
000000r 2               .define	__octave	nsd_work + NSD_work::Note + NSD_note::octave
000000r 2               .define	__detune_cent	nsd_work + NSD_work::Detune + NSD_Detune::cent
000000r 2               .define	__detune_fine	nsd_work + NSD_work::Detune + NSD_Detune::fine
000000r 2               .define	__por_target	nsd_work + NSD_work::Por_Lv + NSD_Por_Lv::target
000000r 2               .define	__por_depth	nsd_work + NSD_work::Por_Lv + NSD_Por_Lv::depth
000000r 2               .define	__por_ctr	nsd_work + NSD_work::Por_Co + NSD_Por_Co::count
000000r 2               .define	__por_rate	nsd_work + NSD_work::Por_Co + NSD_Por_Co::rate
000000r 2               .define __por_now	nsd_work + NSD_work::Por_now
000000r 2               .define	__trans		nsd_work + NSD_work::Trans + NSD_Trans::trans
000000r 2               .define	__trans_one	nsd_work + NSD_work::Trans + NSD_Trans::onetime
000000r 2               .define	__repeat_ctr	nsd_work + NSD_work::Repeat + NSD_Repeat::count1
000000r 2               .define	__repeat_ctr2	nsd_work + NSD_work::Repeat + NSD_Repeat::count2
000000r 2               .define	__volume	nsd_work + NSD_work::Volume + NSD_volume::volume
000000r 2               .define	__voice		nsd_work + NSD_work::Voice + NSD_voice::voice
000000r 2               .define	__voice_set	nsd_work + NSD_work::Voice + NSD_voice::voice_set
000000r 2               .define	__frequency	nsd_work + NSD_work::Frequency
000000r 2               .define	__frequency_set	nsd_work + NSD_work::Frequency_Set
000000r 2               .define	__subroutine	nsd_work + NSD_work::SubRoutine
000000r 2               .define	__repeat2	nsd_work + NSD_work::Repeat2
000000r 2               .define	__env_volume	nsd_work + NSD_work::Envelop_Volume
000000r 2               .define	__env_voice	nsd_work + NSD_work::Envelop_Voice
000000r 2               .define	__env_frequency	nsd_work + NSD_work::Envelop_Freq
000000r 2               .define	__env_note	nsd_work + NSD_work::Envelop_Note
000000r 2               .define	__env_vol_ptr	nsd_work + NSD_work::Env_V_Ptr + NSD_Env_V_Ptr::Volume
000000r 2               .define	__env_voi_ptr	nsd_work + NSD_work::Env_V_Ptr + NSD_Env_V_Ptr::Voice
000000r 2               .define	__env_freq_ptr	nsd_work + NSD_work::Env_F_Ptr + NSD_Env_F_Ptr::Frequency
000000r 2               .define	__env_note_ptr	nsd_work + NSD_work::Env_F_Ptr + NSD_Env_F_Ptr::Note
000000r 2               ;	voiceに関しては、その後の演算は無いので、更新されない場合はエンベロープ処理を終了する。
000000r 2               .define	__env_vol_now	nsd_work + NSD_work::Volume + NSD_volume::volume_env
000000r 2               .define	__env_freq_now	nsd_work + NSD_work::Env_F_Now + NSD_Env_F_Now::Frequency
000000r 2               .define	__env_note_now	nsd_work + NSD_work::Env_F_Now + NSD_Env_F_Now::Note
000000r 2               
000000r 2               .define	__sweep_ch1	nsd_work + NSD_work::Volume + NSD_volume::volume_env + nsd::TR_BGM3
000000r 2               .define	__sweep_ch2	nsd_work + NSD_work::Volume + NSD_volume::volume_env + nsd::TR_BGM5
000000r 2               
000000r 2               .define	__dpcm_info	nsd_work + NSD_work::Env_V_Ptr + nsd::TR_BGM5
000000r 2               
000000r 2               
000000r 2               ;=======================================================================
000000r 2               ;		Struct of DPCM					*
000000r 2               ;-----------------------------------------------------------------------
000000r 2               .Struct		nsd_dpcm
000000r 2               	Control		.byte		;I/O 0x4010
000000r 2               	DA		.byte		;I/O 0x4011
000000r 2               	Address		.byte		;I/O 0x4012
000000r 2               	Size		.byte		;I/O 0x4013
000000r 2               .Endstruct
000000r 2               
000000r 2               
000000r 2               
000000r 2               ;=======================================================================
000000r 2               ;	Macros
000000r 2               ;-----------------------------------------------------------------------
000000r 2               
000000r 2               .MACPACK generic
000000r 2               
000000r 2               .macro  ldax    arg
000000r 2               	.if (.match (.left (1, {arg}), #))
000000r 2               		; immediate mode
000000r 2               		lda     #<(.right (.tcount ({arg})-1, {arg}))
000000r 2               		ldx     #>(.right (.tcount ({arg})-1, {arg}))
000000r 2               	.else
000000r 2               		; assume absolute or zero page
000000r 2               		lda     arg
000000r 2               		ldx     1+(arg)
000000r 2               	.endif
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  addw    Arg
000000r 2               	clc
000000r 2               	.if (.match (.left (1, {arg}), #))
000000r 2               		; immediate mode
000000r 2               		adc     #<(.right (.tcount ({arg})-1, {arg}))
000000r 2               		adc     #>(.right (.tcount ({arg})-1, {arg}))
000000r 2               	.else
000000r 2               		; assume absolute or zero page
000000r 2               		adc     arg
000000r 2               		adc     1+(arg)
000000r 2               	.endif
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  subw    Arg
000000r 2               	sec
000000r 2               	.if (.match (.left (1, {arg}), #))
000000r 2               		; immediate mode
000000r 2               		sbc     #<(.right (.tcount ({arg})-1, {arg}))
000000r 2               		sbc     #>(.right (.tcount ({arg})-1, {arg}))
000000r 2               	.else
000000r 2               		; assume absolute or zero page
000000r 2               		sbc     arg
000000r 2               		sbc     1+(arg)
000000r 2               	.endif
000000r 2               .endmacro
000000r 2               
000000r 2               .macro	shl	arg, c
000000r 2               	.repeat	c
000000r 2               		asl	arg
000000r 2               	.endrepeat
000000r 2               .endmacro
000000r 2               
000000r 2               .macro	shr	arg, c
000000r 2               	.repeat	c
000000r 2               		lsr	arg
000000r 2               	.endrepeat
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 1               
000000r 1               .code
000000r 1               
000000r 1               ;=======================================================================
000000r 1               ;	void	nsd_envelop_proc(void);
000000r 1               ;-----------------------------------------------------------------------
000000r 1               ;<<Contents>>
000000r 1               ;	Process of envelop
000000r 1               ;<<Input>>
000000r 1               ;	__ptr	Pointer of envelop pattern
000000r 1               ;	y	Address
000000r 1               ;<<Output>>
000000r 1               ;	a	Next Address
000000r 1               ;	__ptr	Value
000000r 1               ;=======================================================================
000000r 1               .macro	ENV	Address, Pointer, Now, Counter, n
000000r 1               
000000r 1               	lda	Counter,x
000000r 1               	.if	(n = 0)
000000r 1               		and	#$0F			;
000000r 1               		beq	@Done			;
000000r 1               		lda	Counter,x		;
000000r 1               		sub	#$01			;
000000r 1               	.else
000000r 1               		and	#$F0			;
000000r 1               		beq	@Done			;if(counter != 0){
000000r 1               		lda	Counter,x		;
000000r 1               		sub	#$10			;  counter--
000000r 1               	.endif
000000r 1               	sta	Counter,x		;
000000r 1               	jmp	@Decay			;} else {
000000r 1               
000000r 1               @Done:	lda	Address,x
000000r 1               	sta	__ptr			;  __ptr = (table address of envelop)
000000r 1               	ldy	Pointer,x		;  y     = (_envelop pointer)
000000r 1               @Loop:	lda	(__ptr),y		;  do{
000000r 1               	bpl	@Value			;  a = __ptr[y]
000000r 1               	cmp	#$C0			;    if( a >= 0x80 ){
000000r 1               	bcc	@SetDecay		;      if( a >= 0xc0){
000000r 1               	and	#$3F			;        y = a & 0x3F;  //continue
000000r 1               	tay				;      } else {
000000r 1               	jmp	@Loop			;        (decay counter) = a<<4 | (decay counter);
000000r 1               
000000r 1               @SetDecay:				;        break;
000000r 1               	.if	(n = 4)
000000r 1               		shl	a, n		;      }
000000r 1               	.else
000000r 1               		and	#$0F
000000r 1               	.endif
000000r 1               	ora	Counter,x		;    } else {
000000r 1               	sta	Counter,x		;      (now value) = a;
000000r 1               	jmp	@SetY			;      break;
000000r 1               					;    }
000000r 1               @Value:	sta	Now,x			;  } while(1);
000000r 1               @SetY:	iny				;  (_envelop pointer) = y + 1;
000000r 1               	tya				;}
000000r 1               	sta	Pointer,x		;a = (now value)
000000r 1               @Decay:	lda	Now,x			;
000000r 1               @Set:
000000r 1               
000000r 1               .endmacro
000000r 1               ;=======================================================================
000000r 1               ;	void	nsd_envelop(void);
000000r 1               ;-----------------------------------------------------------------------
000000r 1               ;<<Contents>>
000000r 1               ;	Envelop & LFO main routine
000000r 1               ;<<Input>>
000000r 1               ;	x	Channel * 2
000000r 1               ;<<Output>>
000000r 1               ;	nothing
000000r 1               ;<<Note>>
000000r 1               ;	DPCM track do not call this routine.
000000r 1               ;=======================================================================
000000r 1               .proc	nsd_envelop
000000r 1               
000000r 1  86 rr        	stx	__channel
000002r 1               
000002r 1               	;=======================================
000002r 1               	;Frequency (note)
000002r 1               Frequency:
000002r 1  BD rr rr     	lda	__chflag,x
000005r 1  29 03        	and	#nsd_chflag::KeyOff
000007r 1  D0 05        	bne	@L
000009r 1  A9 00        	lda	#0			; if (rest with vol=0){
00000Br 1  4C rr rr     	jmp	_nsd_snd_volume		;	volume = 0
00000Er 1               @L:					; } else {
00000Er 1               
00000Er 1               	;-------------------------------
00000Er 1               	;Envelop of Note
00000Er 1  BD rr rr     	lda	__env_note + 1,x
000011r 1  85 rr        	sta	__ptr + 1
000013r 1  F0 49        	beq	@NOENV				;envelop is disable?
000015r 1  B5 rr 29 F0  	ENV	__env_note, __env_note_ptr, __env_note_now, __Envelop_F, 4
000019r 1  F0 0A B5 rr  
00001Dr 1  38 E9 10 95  
000021r 1  rr 4C rr rr  
000025r 1  BD rr rr 85  
000029r 1  rr BC rr rr  
00002Dr 1  B1 rr 10 15  
000031r 1  C9 C0 90 06  
000035r 1  29 3F A8 4C  
000039r 1  rr rr 0A 0A  
00003Dr 1  0A 0A 15 rr  
000041r 1  95 rr 4C rr  
000045r 1  rr 9D rr rr  
000049r 1  C8 98 9D rr  
00004Dr 1  rr BD rr rr  
000051r 1  C9 40        	cmp	#$40
000053r 1  90 02        	bcc	@Sigh
000055r 1  09 80        	ora	#$80
000057r 1  18 7D rr rr  @Sigh:	add	__note,x
00005Br 1  4C rr rr     	jmp	@Note_Exit
00005Er 1               @NOENV:
00005Er 1  BD rr rr     	lda	__note,x
000061r 1               @Note_Exit:
000061r 1               
000061r 1               	;-------------------------------
000061r 1               	; __tmp = (__note,x + __trans,x) << 4;
000061r 1  18 7D rr rr  	add	__trans,x
000065r 1  85 rr        	sta	__tmp + 1
000067r 1  0A 0A 0A 0A  	shl	a, 4
00006Br 1  85 rr        	sta	__tmp
00006Dr 1  A5 rr        	lda	__tmp + 1
00006Fr 1  4A 4A 4A 4A  	shr	a, 4
000073r 1  85 rr        	sta	__tmp + 1
000075r 1               
000075r 1               	;-------------------------------
000075r 1               	;Por
000075r 1  BD rr rr     	lda	__por_target,x
000078r 1  F0 7C        	beq	F_Env
00007Ar 1               
00007Ar 1  BD rr rr     	lda	__por_depth,x
00007Dr 1  F0 68        	beq	Por_S
00007Fr 1               
00007Fr 1  DE rr rr     	dec	__por_ctr,x		;MMLコンパイラではdecayを +1 する事。
000082r 1  D0 63        	bne	Por_S
000084r 1               
000084r 1  BD rr rr     	lda	__por_rate,x
000087r 1  9D rr rr     	sta	__por_ctr,x
00008Ar 1               
00008Ar 1  A0 00        	ldy	#$00
00008Cr 1  BD rr rr     	lda	__por_depth,x
00008Fr 1  10 02        	bpl	@PL
000091r 1  A0 FF        	ldy	#$FF
000093r 1  18 7D rr rr  @PL:	add	__por_now + 0,x
000097r 1  9D rr rr     	sta	__por_now + 0,x
00009Ar 1  98           	tya
00009Br 1  7D rr rr     	adc	__por_now + 1,x
00009Er 1  9D rr rr     	sta	__por_now + 1,x		;__por_now += __por_depth
0000A1r 1               
0000A1r 1  0A 0A 0A 0A  	shl	a, 4
0000A5r 1  85 rr        	sta	__ptr
0000A7r 1  BD rr rr     	lda	__por_now + 0,x
0000AAr 1  4A 4A 4A 4A  	shr	a, 4
0000AEr 1  05 rr        	ora	__ptr			;a = __por_now >> 4;
0000B0r 1               
0000B0r 1  C0 00        	cpy	#$00
0000B2r 1  F0 07        	beq	Por_PL
0000B4r 1  DD rr rr     Por_MI:	cmp	__por_target,x		;if (a - __por_target < 0) then
0000B7r 1  90 09        	bcc	Por_O
0000B9r 1  B0 2C        	bcs	Por_S
0000BBr 1  DD rr rr     Por_PL:	cmp	__por_target,x		;if (a - __por_target > 0) then
0000BEr 1  B0 02        	bcs	Por_O
0000C0r 1  90 25        	bcc	Por_S
0000C2r 1               
0000C2r 1  BD rr rr     Por_O:	lda	__por_target,x
0000C5r 1  9D rr rr     	sta	__por_now + 1,x
0000C8r 1  0A 0A 0A 0A  	shl	a, 4
0000CCr 1  9D rr rr     	sta	__por_now,x
0000CFr 1  BD rr rr     	lda	__por_now + 1,x
0000D2r 1  4A 4A 4A 4A  	shr	a, 4
0000D6r 1  C0 00        	cpy	#00
0000D8r 1  F0 02        	beq	@L
0000DAr 1  09 F0        	ora	#$F0			;算術シフト的なもの
0000DCr 1  9D rr rr     @L:	sta	__por_now + 1,x
0000DFr 1  A9 00        	lda	#$0
0000E1r 1  9D rr rr     	sta	__por_rate,x
0000E4r 1  9D rr rr     	sta	__por_depth,x
0000E7r 1  BD rr rr     Por_S:	lda	__por_now,x
0000EAr 1  18 65 rr     	add	__tmp
0000EDr 1  85 rr        	sta	__tmp
0000EFr 1  BD rr rr     	lda	__por_now + 1,x
0000F2r 1  65 rr        	adc	__tmp + 1
0000F4r 1  85 rr        	sta	__tmp + 1
0000F6r 1               Por_E:
0000F6r 1               
0000F6r 1               	;-------------------------------
0000F6r 1               	;Envelop of Frequency
0000F6r 1  BD rr rr     F_Env:	lda	__env_frequency + 1,x
0000F9r 1  85 rr        	sta	__ptr + 1
0000FBr 1  F0 54        	beq	@Freq_Exit
0000FDr 1  B5 rr 29 0F  	ENV	__env_frequency, __env_freq_ptr, __env_freq_now, __Envelop_F, 0
000101r 1  F0 0A B5 rr  
000105r 1  38 E9 01 95  
000109r 1  rr 4C rr rr  
00010Dr 1  BD rr rr 85  
000111r 1  rr BC rr rr  
000115r 1  B1 rr 10 13  
000119r 1  C9 C0 90 06  
00011Dr 1  29 3F A8 4C  
000121r 1  rr rr 29 0F  
000125r 1  15 rr 95 rr  
000129r 1  4C rr rr 9D  
00012Dr 1  rr rr C8 98  
000131r 1  9D rr rr BD  
000135r 1  rr rr        
000137r 1  C9 40        	cmp	#$40
000139r 1  90 0B        	bcc	@Sigh
00013Br 1  09 80        	ora	#$80
00013Dr 1  18 65 rr     	add	__tmp
000140r 1  85 rr        	sta	__tmp
000142r 1  A9 FF        	lda	#$FF
000144r 1  D0 07        	bne	@SetH
000146r 1  18 65 rr     @Sigh:	add	__tmp
000149r 1  85 rr        	sta	__tmp
00014Br 1  A9 00        	lda	#$0
00014Dr 1  65 rr        @SetH:	adc	__tmp+1
00014Fr 1  85 rr        	sta	__tmp+1
000151r 1               @Freq_Exit:
000151r 1               
000151r 1               	;-------------------------------
000151r 1               	;Detune of cent unit
000151r 1               Detune:
000151r 1  A0 00        	ldy	#$00
000153r 1  BD rr rr     	lda	__detune_cent,x
000156r 1  10 02        	bpl	@L
000158r 1  A0 FF        	ldy	#$FF			; ay = __detune_cent (sign expand)
00015Ar 1  18 65 rr     @L:	add	__tmp
00015Dr 1  85 rr        	sta	__tmp
00015Fr 1  98           	tya
000160r 1  65 rr        	adc	__tmp + 1
000162r 1  85 rr        	sta	__tmp + 1		;__tmp += (signed int)__detune_cent
000164r 1               
000164r 1               	;-----------------------
000164r 1               	;Setting device (APU)
000164r 1  A5 rr        	lda	__tmp
000166r 1  A6 rr        	ldx	__tmp + 1
000168r 1  20 rr rr     	jsr	_nsd_snd_frequency	;nsd_snd_frequency(ax);
00016Br 1               
00016Br 1               
00016Br 1               
00016Br 1               	;=======================================
00016Br 1               	;Voice & Volume
00016Br 1  A6 rr        	ldx	__channel	;要る？
00016Dr 1  E0 04        	cpx	#nsd::TR_BGM3
00016Fr 1  D0 01        	bne	Voice
000171r 1  60           exit:	rts
000172r 1               
000172r 1               	;-------------------------------
000172r 1               	;Envelop of Voice
000172r 1               Voice:
000172r 1  BD rr rr     	lda	__chflag,x
000175r 1  BD rr rr     	lda	__chflag,x
000178r 1  29 02        	and	#$02
00017Ar 1  D0 0A        	bne	@L
00017Cr 1               
00017Cr 1  BD rr rr     	lda	__voice,x
00017Fr 1  4A 4A 4A 4A  	shr	a, 4			; a = release voice
000183r 1  4C rr rr     	jmp	Set_Voice
000186r 1               
000186r 1  BD rr rr     @L:	lda	__env_voice + 1,x
000189r 1  D0 06        	bne	@Envelop
00018Br 1  BD rr rr     	lda	__env_voice,x
00018Er 1  4C rr rr     	jmp	Set_Voice
000191r 1               
000191r 1               @Envelop:
000191r 1  85 rr        	sta	__ptr + 1
000193r 1  B5 rr        	lda	__Envelop_V,x
000195r 1  29 F0        	and	#$F0			;
000197r 1  F0 0A        	beq	@Done			;if(counter != 0){
000199r 1  B5 rr        	lda	__Envelop_V,x		;
00019Br 1  38 E9 10     	sub	#$10			;  counter--
00019Er 1  95 rr        	sta	__Envelop_V,x		;
0001A0r 1  4C rr rr     	jmp	Voice_Exit		;} else {
0001A3r 1               
0001A3r 1  BD rr rr     @Done:	lda	__env_voice,x
0001A6r 1  85 rr        	sta	__ptr			;  __ptr = (table address of envelop)
0001A8r 1  BC rr rr     	ldy	__env_voi_ptr,x		;  y     = (_envelop pointer)
0001ABr 1  B1 rr        @Loop:	lda	(__ptr),y		;  do{
0001ADr 1  10 1A        	bpl	@Value			;  a = __ptr[y]
0001AFr 1  C9 C0        	cmp	#$C0			;    if( a >= 0x80 ){
0001B1r 1  90 06        	bcc	@SetDecay		;      if( a >= 0xc0){
0001B3r 1  29 3F        	and	#$3F			;        y = a & 0x3F;  //continue
0001B5r 1  A8           	tay				;      } else {
0001B6r 1  4C rr rr     	jmp	@Loop			;        (decay counter) = a<<4 | (decay counter);
0001B9r 1               
0001B9r 1               @SetDecay:				;
0001B9r 1  0A 0A 0A 0A  	shl	a, 4			;
0001BDr 1  15 rr        	ora	__Envelop_V,x		;
0001BFr 1  95 rr        	sta	__Envelop_V,x		;
0001C1r 1  C8           	iny				;
0001C2r 1  98           	tya				;
0001C3r 1  9D rr rr     	sta	__env_voi_ptr,x		;
0001C6r 1  4C rr rr     	jmp	Voice_Exit
0001C9r 1               
0001C9r 1               @Value:
0001C9r 1  48           	pha
0001CAr 1  C8           	iny
0001CBr 1  98           	tya
0001CCr 1  9D rr rr     	sta	__env_voi_ptr,x
0001CFr 1  68           	pla
0001D0r 1               	;-----------------------
0001D0r 1               	;Setting device (APU)
0001D0r 1               Set_Voice:
0001D0r 1  20 rr rr     	jsr	_nsd_snd_voice		;nsd_snd_voice(a);
0001D3r 1               Voice_Exit:
0001D3r 1               
0001D3r 1               	;-------------------------------
0001D3r 1               	;Envelop of Volume
0001D3r 1               Volume:
0001D3r 1  BD rr rr     	lda	__chflag,x
0001D6r 1  29 03        	and	#$03
0001D8r 1  C9 03        	cmp	#$03
0001DAr 1  F0 11        	beq	@L3	;mode = 3 だったら、エンベロープへ
0001DCr 1  C9 01        	cmp	#$01
0001DEr 1  F0 05        	beq	@L1		;mode = 1 で、リリース音量
0001E0r 1               
0001E0r 1  BD rr rr     @L2:	lda	__env_volume + 1,x
0001E3r 1  D0 17        	bne	@Envelop	;mode = 2 且つ、ポインタ有りで、エンベロープへ。
0001E5r 1  BD rr rr     @L1:	lda	__volume,x
0001E8r 1  29 F0        	and	#$F0
0001EAr 1  4C rr rr     	jmp	Set_Volume
0001EDr 1               
0001EDr 1  BD rr rr     @L3:	lda	__env_volume + 1,x
0001F0r 1  D0 0A        	bne	@Envelop
0001F2r 1  BD rr rr     	lda	__volume,x
0001F5r 1  0A 0A 0A 0A  	shl	a, 4
0001F9r 1  4C rr rr     	jmp	Set_Volume
0001FCr 1               
0001FCr 1               @Envelop:
0001FCr 1  85 rr        	sta	__ptr + 1
0001FEr 1  B5 rr 29 0F  	ENV	__env_volume, __env_vol_ptr, __env_vol_now, __Envelop_V, 0
000202r 1  F0 0A B5 rr  
000206r 1  38 E9 01 95  
00020Ar 1  rr 4C rr rr  
00020Er 1  BD rr rr 85  
000212r 1  rr BC rr rr  
000216r 1  B1 rr 10 13  
00021Ar 1  C9 C0 90 06  
00021Er 1  29 3F A8 4C  
000222r 1  rr rr 29 0F  
000226r 1  15 rr 95 rr  
00022Ar 1  4C rr rr 9D  
00022Er 1  rr rr C8 98  
000232r 1  9D rr rr BD  
000236r 1  rr rr        
000238r 1               
000238r 1  85 rr        	sta	__tmp
00023Ar 1  BD rr rr     	lda	__volume,x
00023Dr 1  A6 rr        	ldx	__tmp
00023Fr 1  20 rr rr     	jsr	_nsd_mul
000242r 1  A6 rr        	ldx	__channel
000244r 1               
000244r 1               	;-----------------------
000244r 1               	;Setting device (APU)
000244r 1               Set_Volume:
000244r 1  4C rr rr     	jmp	_nsd_snd_volume		;nsd_snd_volume(a);
000247r 1               
000247r 1               .endproc
000247r 1               
000247r 1               
